<?xml version="1.0"?>
<doc>
    <assembly>
        <name>JetBrains.Platform.Interop.WinApi</name>
    </assembly>
    <members>
        <member name="F:JetBrains.Interop.WinApi.Constants.StringCompareFlags.SORT_DIGITSASNUMBERS">
            <since>Windows NT 6.1</since>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Constants.EXTENDED_NAME_FORMAT">
            <summary>
             Examples for the following formats assume a fictitous company
             which hooks into the global X.500 and DNS name spaces as follows.
             Enterprise root domain in DNS is
                  widget.com
             Enterprise root domain in X.500 (RFC 1779 format) is
                  O=Widget, C=US
             There exists the child domain
                  engineering.widget.com
             equivalent to
                  OU=Engineering, O=Widget, C=US
             There exists a container within the Engineering domain
                  OU=Software, OU=Engineering, O=Widget, C=US
             There exists the user
                  CN=John Doe, OU=Software, OU=Engineering, O=Widget, C=US
             And this user's downlevel (pre-ADS) user name is
                  Engineering\JohnDoe
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.EXTENDED_NAME_FORMAT.NameUnknown">
            <summary>  unknown name type </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.EXTENDED_NAME_FORMAT.NameFullyQualifiedDN">
            <summary>  CN=John Doe, OU=Software, OU=Engineering, O=Widget, C=US </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.EXTENDED_NAME_FORMAT.NameSamCompatible">
            <summary>  Engineering\JohnDoe </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.EXTENDED_NAME_FORMAT.NameDisplay">
            <summary>  Probably "John Doe" but could be something else.  I.e. The </summary>
            <summary>  display name is not necessarily the defining RDN. </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.EXTENDED_NAME_FORMAT.NameUniqueId">
            <summary>  String-ized GUID as returned by IIDFromString(). </summary>
            <summary>  eg: {4fa050f0-f561-11cf-bdd9-00aa003a77b6} </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.EXTENDED_NAME_FORMAT.NameCanonical">
            <summary>  engineering.widget.com/software/John Doe </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.EXTENDED_NAME_FORMAT.NameUserPrincipal">
            <summary>  someone@example.com </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.EXTENDED_NAME_FORMAT.NameCanonicalEx">
            <summary>  Same as NameCanonical except that rightmost '/' is </summary>
            <summary>  replaced with '\n' - even in domain-only case. </summary>
            <summary>  eg: engineering.widget.com/software\nJohn Doe </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.EXTENDED_NAME_FORMAT.NameServicePrincipal">
            <summary>  www/srv.engineering.com/engineering.com </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.EXTENDED_NAME_FORMAT.NameDnsDomain">
            <summary>  DNS domain name + SAM username </summary>
            <summary>  eg: engineering.widget.com\JohnDoe </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.Locale.LOCALE_NAME_MAX_LENGTH">
            <summary>
            8 characters for language <br />
            8 characters for region <br />
            64 characters for suffix (script) <br />
            2 characters for '-' separators <br />
            2 characters for prefix like "i-" or "x-" <br />
            1 null termination
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.Locale.LOCALE_INVARIANT">
            <summary>
            Windows XP: The locale used for operating system-level functions that require consistent and locale-independent results. For example, the invariant locale is used when an application compares character strings using the CompareString function and expects a consistent result regardless of the user locale. The settings of the invariant locale are similar to those for English (United States) but should not be used to display formatted data. Typically, an application does not use LOCALE_INVARIANT because it expects the results of an action to depend on the rules governing each individual locale. The value of LOCALE_INVARIANT IS 0x007f.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.Locale.LOCALE_NAME_INVARIANT">
            <summary>
            Name of an invariant locale that provides stable locale and calendar data.
            </summary>
            <since>Windows NT 6.0</since>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.Locale.LOCALE_NAME_SYSTEM_DEFAULT">
            <summary>
            Name of the current operating system locale.
            </summary>
            <since>Windows NT 6.0</since>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.Locale.LOCALE_NAME_USER_DEFAULT">
            <summary>
            Name of the current user locale, matching the preference set in the regional and language options portion of Control Panel. This locale can be different from the locale for the current user interface language.
            </summary>
            <since>Windows NT 6.0</since>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.LocaleDependentMappingFlags.LCMAP_TITLECASE">
            <since>win7</since>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.RestartManagerConstants.CCH_RM_MAX_APP_NAME">
            <summary>
            CCH_RM_MAX_APP_NAME - maximum character count of application friendly name.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.RestartManagerConstants.CCH_RM_MAX_SVC_NAME">
            <summary>
            CCH_RM_MAX_SVC_NAME - maximum character count of service short name.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.RestartManagerConstants.RM_SESSION_KEY_LEN">
            <summary>
            RM_SESSION_KEY_LEN - size in bytes of binary session key.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.RestartManagerConstants.CCH_RM_SESSION_KEY">
            <summary>
            CCH_RM_SESSION_KEY - character count of text-encoded session key.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.RestartManagerConstants.RM_INVALID_PROCESS">
            <summary>
            Uninitialized value for Process ID.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.RestartManagerConstants.RM_INVALID_TS_SESSION">
            <summary>
            Uninitialized value for TS Session ID.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Constants.RM_APP_STATUS">
            <summary>
            Describes the current status of an application that is acted upon by the Restart Manager.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.RM_APP_STATUS.RmStatusUnknown">
            <summary>
            Application in unknown state or state not important.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.RM_APP_STATUS.RmStatusRunning">
            <summary>
            Application is currently running.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.RM_APP_STATUS.RmStatusStopped">
            <summary>
            Application stopped by Restart Manager.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.RM_APP_STATUS.RmStatusStoppedOther">
            <summary>
            Application detected stopped by outside action.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.RM_APP_STATUS.RmStatusRestarted">
            <summary>
            Application restarted by Restart Manager.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.RM_APP_STATUS.RmStatusErrorOnStop">
            <summary>
            An error occurred when stopping this application.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.RM_APP_STATUS.RmStatusErrorOnRestart">
            <summary>
            An error occurred when restarting this application.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.RM_APP_STATUS.RmStatusShutdownMasked">
            <summary>
            Shutdown action masked by filer.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.RM_APP_STATUS.RmStatusRestartMasked">
            <summary>
            Restart action masked by filter.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Constants.RM_APP_TYPE">
            <summary>
            Specifies the type of application that is described by the <see cref="T:JetBrains.Interop.WinApi.RM_PROCESS_INFO"/> structure.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.RM_APP_TYPE.RmUnknownApp">
            <summary>
            The application cannot be classified as any other type. An application of this type can only be shut down by a forced shutdown.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.RM_APP_TYPE.RmMainWindow">
            <summary>
            A Windows application run as a stand-alone process that displays a top-level window.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.RM_APP_TYPE.RmOtherWindow">
            <summary>
            A Windows application that does not run as a stand-alone process and does not display a top-level window.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.RM_APP_TYPE.RmService">
            <summary>
            The application is a Windows service.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.RM_APP_TYPE.RmExplorer">
            <summary>
            The application is Windows Explorer.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.RM_APP_TYPE.RmConsole">
            <summary>
            The application is a stand-alone console application.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.RM_APP_TYPE.RmCritical">
            <summary>
            A system restart is required to complete the installation because a process cannot be shut down. The process cannot be shut down because of the following reasons. The process may be a critical process. The current user may not have permission to shut down the process. The process may belong to the primary installer that started the Restart Manager.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Constants.RM_REBOOT_REASON">
            <summary>
            Describes the reasons a restart of the system is needed.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.RM_REBOOT_REASON.RmRebootReasonNone">
            <summary>
            Reboot not required.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.RM_REBOOT_REASON.RmRebootReasonPermissionDenied">
            <summary>
            Current user does not have permission to shut down one or more detected processes.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.RM_REBOOT_REASON.RmRebootReasonSessionMismatch">
            <summary>
            One or more processes are running in another TS session.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.RM_REBOOT_REASON.RmRebootReasonCriticalProcess">
            <summary>
            A critical process has been detected.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.RM_REBOOT_REASON.RmRebootReasonCriticalService">
            <summary>
            A critical service has been detected.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.RM_REBOOT_REASON.RmRebootReasonDetectedSelf">
            <summary>
            The current process has been detected.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.RstrtmgrDll">
            <summary>
             Rstrtmgr.dll (Restart Manager) functions.
             Must be 64bit-safe.
            </summary>
            <remarks>
             IMPORTANT! Rules for authoring the class (v1.1):
             (1) All the function declarations MUST be 64-bit aware.
             (2) When copypasting from older declarations, you MUST check against the MSDN help or header declaration,
                and you MUST ensure that each parameter has a proper size.
             (3) Call the Wide version of the functions (UCS-2-LE) unless there's a strong reason for calling the ANSI version
                (such a reason MUST be indicated in XmlDoc). <c>CharSet = CharSet.Unicode</c>.
             (4) ExactSpelling MUST be TRUE. Add the "…W" suffix wherever needed.
             (5) SetLastError SHOULD be considered individually for each function. Setting it to <c>True</c> allows to report the errors,
                but slows down the execution of critical members.
             (6) These properties MUST be explicitly set on DllImport attributes of EACH import:
                CharSet, PreserveSig, SetLastError, ExactSpelling.
             (7) CLR names MUST be used for types instead of C# ones, eg "Int32" not "int" and "Int64" not "long".
                This greately improves the understanding of the parameter sizes.
             (8) Sign of the types MUST be favored, eg "DWORD" is "UInt32" not "Int32".
             (9) Unsafe pointer types should be used for explicit and implicit pointers rather than IntPtr.
                This way we outline the unsafety of the native calls, and also make it more clear for the 64bit transition.
                Eg "HANDLE" is "void*". If the rule forces you to mark some assembly as unsafe, it's an indication a managed utility
                incapsulating the call and the handle should be provided in one of the already-unsafe assemblies.
             (A) Same rules must apply to members of the structures.
             (B) All of the structures MUST have the [StructLayout(LayoutKind.Sequential)], [NoReorder] attributes, as appropriate.
            </remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.RstrtmgrDll.RmEndSession(System.UInt32)">
            <summary>
            Ends the Restart Manager session. This function should be called by the primary installer that has previously started the session by calling the RmStartSession function. The RmEndSession function can be called by a secondary installer that is joined to the session once no more resources need to be registered by the secondary installer.
            </summary>
            <param name="dwSessionHandle">A handle to an existing Restart Manager session.</param>
            <returns>This is the most recent error received. The function can return one of the system error codes that are defined in Winerror.h.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.RstrtmgrDll.RmGetList(System.UInt32,System.UInt32*,System.UInt32*,JetBrains.Interop.WinApi.RM_PROCESS_INFO*,System.UInt32*)">
            <summary>
            Gets a list of all applications and services that are currently using resources that have been registered with the Restart Manager session.
            </summary>
            <param name="dwSessionHandle">A handle to an existing Restart Manager session.</param>
            <param name="pnProcInfoNeeded">A pointer to an array size necessary to receive RM_PROCESS_INFO structures required to return information for all affected applications and services.</param>
            <param name="pnProcInfo">A pointer to the total number of RM_PROCESS_INFO structures in an array and number of structures filled.</param>
            <param name="rgAffectedApps">An array of RM_PROCESS_INFO structures that list the applications and services using resources that have been registered with the session.</param>
            <param name="lpdwRebootReasons">Pointer to location that receives a value of the RM_REBOOT_REASON enumeration that describes the reason a system restart is needed.</param>
            <returns>This is the most recent error received. The function can return one of the system error codes that are defined in Winerror.h.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.RstrtmgrDll.RmRegisterResources(System.UInt32,System.UInt32,System.Char**,System.UInt32,JetBrains.Interop.WinApi.RM_UNIQUE_PROCESS*,System.UInt32,System.Char**)">
            <summary>
            Registers resources to a Restart Manager session. The Restart Manager uses the list of resources registered with the session to determine which applications and services must be shut down and restarted. Resources can be identified by filenames, service short names, or <see cref="T:JetBrains.Interop.WinApi.RM_UNIQUE_PROCESS"/> structures that describe running applications. The RmRegisterResources function can be used by a primary or secondary installer.
            </summary>
            <param name="dwSessionHandle">A handle to an existing Restart Manager session.</param>
            <param name="nFiles">The number of files being registered.</param>
            <param name="rgsFilenames">An array of null-terminated strings of full filename paths. This parameter can be NULL if nFiles is 0.</param>
            <param name="nApplications">The number of processes being registered.</param>
            <param name="rgApplications">An array of <see cref="T:JetBrains.Interop.WinApi.RM_UNIQUE_PROCESS"/> structures. This parameter can be NULL if nApplications is 0.</param>
            <param name="nServices">The number of services to be registered.</param>
            <param name="rgsServiceNames">An array of null-terminated strings of service short names. This parameter can be NULL if nServices is 0.</param>
            <returns>This is the most recent error received. The function can return one of the system error codes that are defined in Winerror.h. </returns>
            <remarks>Each call to the RmRegisterResources function performs relatively expensive write operations. Do not call this function once per file, instead group related files together into components and register these together.</remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.RstrtmgrDll.RmStartSession(System.UInt32*,System.UInt32,System.Char*)">
            <summary>
            Starts a new Restart Manager session. A maximum of 64 Restart Manager sessions per user session can be open on the system at the same time. When this function starts a session, it returns a session handle and session key that can be used in subsequent calls to the Restart Manager API.
            </summary>
            <param name="pSessionHandle">A pointer to the handle of a Restart Manager session. The session handle can be passed in subsequent calls to the Restart Manager API.</param>
            <param name="dwSessionFlags">Reserved. This parameter should be 0.</param>
            <param name="strSessionKey">A null-terminated string that contains the session key to the new session. The string must be allocated before calling the RmStartSession function. Must be at least CCH_RM_SESSION_KEY+1 unicode characters in length.</param>
            <returns>This is the most recent error received. The function can return one of the system error codes that are defined in Winerror.h.</returns>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Secur32Dll">
            <summary>
            Secur32.dll functions.
            Must be 64bit-safe.
            </summary>
            <remarks>
            IMPORTANT! Rules for authoring the class (v1.1):
            (1) All the function declarations MUST be 64-bit aware.
            (2) When copypasting from older declarations, you MUST check against the MSDN help or header declaration,
               and you MUST ensure that each parameter has a proper size.
            (3) Call the Wide version of the functions (UCS-2-LE) unless there's a strong reason for calling the ANSI version
               (such a reason MUST be indicated in XmlDoc). <c>CharSet = CharSet.Unicode</c>.
            (4) ExactSpelling MUST be TRUE. Add the "…W" suffix wherever needed.
            (5) SetLastError SHOULD be considered individually for each function. Setting it to <c>True</c> allows to report the errors,
               but slows down the execution of critical members.
            (6) These properties MUST be explicitly set on DllImport attributes of EACH import:
               CharSet, PreserveSig, SetLastError, ExactSpelling.
            (7) CLR names MUST be used for types instead of C# ones, eg "Int32" not "int" and "Int64" not "long".
               This greately improves the understanding of the parameter sizes.
            (8) Sign of the types MUST be favored, eg "DWORD" is "UInt32" not "Int32".
            (9) Unsafe pointer types should be used for explicit and implicit pointers rather than IntPtr.
               This way we outline the unsafety of the native calls, and also make it more clear for the 64bit transition.
               Eg "HANDLE" is "void*". If the rule forces you to mark some assembly as unsafe, it's an indication a managed utility
               incapsulating the call and the handle should be provided in one of the already-unsafe assemblies.
            (A) Same rules must apply to members of the structures.
            (B) All of the structures MUST have the [StructLayout(LayoutKind.Sequential)], [NoReorder] attributes, as appropriate.
            </remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Secur32Dll.GetUserNameExW(JetBrains.Interop.WinApi.Constants.EXTENDED_NAME_FORMAT,System.Char*,System.UInt32*)">
            <summary>
            Retrieves the name of the user or other security principal associated with the calling thread. You can specify the format of the returned name.
            If the thread is impersonating a client, GetUserNameEx returns the name of the client.
            </summary>
            <param name="NameFormat"></param>
            <param name="lpNameBuffer"></param>
            <param name="lpnSize"></param>
            <returns>If the function succeeds, the return value is a nonzero value.</returns>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Constants.CorH">
            <summary>
            Constants from file <c>Cor.h</c>.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Constants.CorSym">
            <summary>
            Constants from file <c>CorSym.h</c> and <c>CorSym.idl</c>.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.CorSymSearchPolicyAttributes">
            <summary>
            Specifies the policy to be used when doing a search for a symbol reader.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.CorSymSearchPolicyAttributes.AllowRegistryAccess">
            <summary>
            Queries the registry for symbol search paths.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.CorSymSearchPolicyAttributes.AllowSymbolServerAccess">
            <summary>
            Accesses a symbol server.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.CorSymSearchPolicyAttributes.AllowOriginalPathAccess">
            <summary>
            Searches the path specified in the Debug directory.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.CorSymSearchPolicyAttributes.AllowReferencePathAccess">
            <summary>
            Searches for the PDB in the place where the .exe file is.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Constants.FrameControlState">
            <summary>
            Values for <see cref="M:JetBrains.Interop.WinApi.User32Dll.DrawFrameControl(System.Void*,JetBrains.Interop.WinApi.RECT*,System.UInt32,System.UInt32)"/>.
            Incomplete.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.FrameControlState.DFCS_BUTTONPUSH">
            <summary>
            Push button
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Constants.FrameControlType">
            <summary>
            Values for <see cref="M:JetBrains.Interop.WinApi.User32Dll.DrawFrameControl(System.Void*,JetBrains.Interop.WinApi.RECT*,System.UInt32,System.UInt32)"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.FrameControlType.DFC_BUTTON">
            <summary>
            Standard button
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.FrameControlType.DFC_CAPTION">
            <summary>
            Title bar
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.FrameControlType.DFC_MENU">
            <summary>
            Menu bar
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.FrameControlType.DFC_POPUPMENU">
            <summary>
            Windows 98/Me, Windows 2000/XP: Popup menu item.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.FrameControlType.DFC_SCROLL">
            <summary>
            Scroll bar
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Constants.HookType">
            <summary>
            Windows hook types for <see cref="M:JetBrains.Interop.WinApi.User32Dll.SetWindowsHookExW(System.Int32,JetBrains.Interop.WinApi.Functions.HOOKPROC,System.Void*,System.UInt32)"/>.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Constants.ImagehlpH">
            <summary>
            Constants for <see cref="T:JetBrains.Interop.WinApi.ImagehlpDll"/> functions.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.ImagehlpH.CERT_SECTION_TYPE_ANY">
            <summary>
            Any Certificate type
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Constants.MemoryMappingAttributes">
            <summary>
            <see cref="M:JetBrains.Interop.WinApi.Kernel32Dll.CreateFileMappingW(System.Void*,JetBrains.Interop.WinApi.SECURITY_ATTRIBUTES*,System.UInt32,System.UInt32,System.UInt32,System.String)"/>'s <c>flProtect</c> attribute values.
            An application can specify one or more of the following attributes for the file mapping object by combining them with one of the preceding page protection values.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.MemoryMappingAttributes.SEC_FILE">
            <summary>
            (no info in MSDN on this)
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.MemoryMappingAttributes.SEC_IMAGE">
            <summary>
            Specifies that the file that the hFile parameter specifies is an executable image file.
            The SEC_IMAGE attribute must be combined with a page protection value such as PAGE_READONLY. However, this page protection value has no effect on views of the executable image file. Page protection for views of an executable image file is determined by the executable file itself.
            No other attributes are valid with SEC_IMAGE.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.MemoryMappingAttributes.SEC_PROTECTED_IMAGE">
            <summary>
            (no info in MSDN on this)
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.MemoryMappingAttributes.SEC_RESERVE">
            <summary>
            If the file mapping object is backed by the operating system paging file (the hfile parameter is INVALID_HANDLE_VALUE), specifies that when a view of the file is mapped into a process address space, the entire range of pages is reserved for later use by the process rather than committed.
            Reserved pages can be committed in subsequent calls to the VirtualAlloc function. After the pages are committed, they cannot be freed or decommitted with the VirtualFree function.
            This attribute has no effect for file mapping objects that are backed by executable image files or data files (the hfile parameter is a handle to a file).
            SEC_RESERVE cannot be combined with SEC_COMMIT.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.MemoryMappingAttributes.SEC_COMMIT">
            <summary>
            If the file mapping object is backed by the operating system paging file (the hfile parameter is INVALID_HANDLE_VALUE), specifies that when a view of the file is mapped into a process address space, the entire range of pages is committed rather than reserved. The system must have enough committable pages to hold the entire mapping. Otherwise, CreateFileMapping fails.
            This attribute has no effect for file mapping objects that are backed by executable image files or data files (the hfile parameter is a handle to a file).
            SEC_COMMIT cannot be combined with SEC_RESERVE.
            If no attribute is specified, SEC_COMMIT is assumed.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.MemoryMappingAttributes.SEC_NOCACHE">
            <summary>
            Sets all pages to be non-cachable.
            Applications should not use this attribute except when explicitly required for a device. Using the interlocked functions with memory that is mapped with SEC_NOCACHE can result in an EXCEPTION_ILLEGAL_INSTRUCTION exception.
            SEC_NOCACHE requires either the SEC_RESERVE or SEC_COMMIT attribute to be set.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.MemoryMappingAttributes.SEC_WRITECOMBINE">
            <summary>
            Sets all pages to be write-combined.
            Applications should not use this attribute except when explicitly required for a device. Using the interlocked functions with memory that is mapped with SEC_WRITECOMBINE can result in an EXCEPTION_ILLEGAL_INSTRUCTION exception.
            SEC_WRITECOMBINE requires either the SEC_RESERVE or SEC_COMMIT attribute to be set.
            Windows Server 2003 and Windows XP:  This flag is not supported until Windows Vista.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.MemoryMappingAttributes.SEC_LARGE_PAGES">
            <summary>
            Enables large pages to be used for file mapping objects that are backed by the operating system paging file (the hfile parameter is INVALID_HANDLE_VALUE). This attribute is not supported for file mapping objects that are backed by executable image files or data files (the hFile parameter is a handle to an executable image or data file).
            The maximum size of the file mapping object must be a multiple of the minimum size of a large page returned by the GetLargePageMinimum function. If it is not, CreateFileMapping fails. When mapping a view of a file mapping object created with SEC_LARGE_PAGES, the base address and view size must also be multiples of the minimum large page size.
            SEC_LARGE_PAGES requires the SeLockMemoryPrivilege privilege to be enabled in the caller's token.
            If SEC_LARGE_PAGES is specified, SEC_COMMIT must also be specified.
            Windows Server 2003:  This value is not supported until Windows Server 2003 with SP1.
            Windows XP:  This value is not supported.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.MemoryMappingAttributes.SEC_IMAGE_NO_EXECUTE">
            <summary>
            Specifies that the file that the hFile parameter specifies is an executable image file that will not be executed and the loaded image file will have no forced integrity checks run. Additionally, mapping a view of a file mapping object created with the SEC_IMAGE_NO_EXECUTE attribute will not invoke driver callbacks registered using the PsSetLoadImageNotifyRoutine kernel API.
            The SEC_IMAGE_NO_EXECUTE attribute must be combined with the PAGE_READONLY page protection value. No other attributes are valid with SEC_IMAGE_NO_EXECUTE.
            Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003, and Windows XP:  This value is not supported before Windows Server 2012 and Windows 8.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Constants.MetaHostH">
            <summary>
            Constants from file <c>metahost.h</c>.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Declarations.Constants.MsoConstants">
            <summary>
            Contants used by Component API Interfaces (IMsoComponent and IMsoComponentManager).
            </summary>
            <remarks>
            The constants are taken from: System.Windows.Forms.NativeMethods.MSOCM, Assembly: System.Windows.Forms, Version=4.0.0.0
            </remarks>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Declarations.Constants.MSOCRF">
            <summary>
            MSO component registration flags.
            </summary>
            <remarks>
            Used by OLECRINFO.grfcrf field passed to IOleComponentManager.FRegisterComponent method and its equivalent in the OLE-world IMsoComponentManager and MSOCRINFO structure.
            </remarks>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.MSOCRF.msocrfNeedIdleTime">
            <summary>
            Component needs idle time.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.MSOCRF.msocrfNeedPeriodicIdleTime">
            <summary>
            Component needs idle time every N milliseconds.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.MSOCRF.msocrfPreTranslateKeys">
            <summary>
            Component must process keyboard messages before translation.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.MSOCRF.msocrfPreTranslateAll">
            <summary>
            Component must process all messages before translation.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.MSOCRF.msocrfNeedSpecActiveNotifs">
            <summary>
            Component needs to be notified for special activation changes. 
            Currently, this will notify component if ExclusiveBorderSpace or ExclusiveActivation mode changes.
            Top-level components should reg this flag.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.MSOCRF.msocrfNeedAllActiveNotifs">
            <summary>
            Component needs to be notified for every change in activation state
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.MSOCRF.msocrfExclusiveBorderSpace">
            <summary>
            Component needs exclusive border space when active (normally only used by TopLevel Mac components).
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.MSOCRF.msocrfExclusiveActivation">
            <summary>
            Component becomes exclusively active when activated
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.MSOCRF.msocrfNeedAllMacEvents">
            <summary>
            Component needs all mac events
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.MSOCRF.msocrfMaster">
            <summary>
            Component is always active and gets first shot at evrything (Mac?)
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Declarations.Constants.OLECADVF">
            <summary>
            OLE component registration advise flags (see msocstate enumeration).
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Declarations.Constants.OLECRF">
            <summary>
            Component registration flags.  
            </summary>
            <remarks>Used by OLECRINFO.grfcrf field passed to IOleComponentManager.FRegisterComponent method and its equivalent in the OLE-world IMsoComponentManager and MSOCRINFO structure.
            </remarks>
            <seealso cref="!:Microsoft.VisualStudio.OLE.Interop._OLECRF"/>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Declarations.Constants.PRSPEC">
            <summary>
            Kinds for <see cref="T:JetBrains.Interop.WinApi.Declarations.Structures.PROPSPEC"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.PRSPEC.PRSPEC_LPWSTR">
            <summary>
            The <see cref="!:PROPSPEC.lpwstr"/> member is used and set to a string name.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.PRSPEC.PRSPEC_PROPID">
            <summary>
            The <see cref="!:PROPSPEC.propid"/> member is used and set to a property ID value.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Constants.RegionResult">
            <summary>
            The return value specifies the new clipping region's complexity; it can be one of the following values.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.RegionResult.ERROR">
            <summary>
            An error occurred.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.RegionResult.NULLREGION">
            <summary>
            Region is empty.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.RegionResult.SIMPLEREGION">
            <summary>
            Region is a single rectangle.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.RegionResult.COMPLEXREGION">
            <summary>
            Region is more than one rectangle.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.RegionResult.RGN_ERROR">
            <summary>
            An error occurred.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Declarations.Constants.ResourceTypes">
            <summary>
            The following are the predefined resource types.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.ResourceTypes.RT_ACCELERATOR">
            <summary>Accelerator table.</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.ResourceTypes.RT_ANICURSOR">
            <summary>Animated cursor.</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.ResourceTypes.RT_ANIICON">
            <summary>Animated icon.</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.ResourceTypes.RT_BITMAP">
            <summary>Bitmap resource.</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.ResourceTypes.RT_CURSOR">
            <summary>Hardware-dependent cursor resource.</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.ResourceTypes.RT_DIALOG">
            <summary>Dialog box.</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.ResourceTypes.RT_DLGINCLUDE">
            <summary>Allows a resource editing tool to associate a string with an .rc file. Typically, the string is the name of the header file that provides symbolic names. The resource compiler parses the string but otherwise ignores the value. For example, 1 DLGINCLUDE "MyFile.h"</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.ResourceTypes.RT_FONT">
            <summary>Font resource.</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.ResourceTypes.RT_FONTDIR">
            <summary>Font directory resource.</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.ResourceTypes.RT_GROUP_CURSOR">
            <summary>Hardware-independent cursor resource.</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.ResourceTypes.RT_GROUP_ICON">
            <summary>Hardware-independent icon resource.</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.ResourceTypes.RT_HTML">
            <summary>HTML resource.</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.ResourceTypes.RT_ICON">
            <summary>Hardware-dependent icon resource.</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.ResourceTypes.RT_MANIFEST">
            <summary>Side-by-Side Assembly Manifest.</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.ResourceTypes.RT_MENU">
            <summary>Menu resource.</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.ResourceTypes.RT_MESSAGETABLE">
            <summary>Message-table entry.</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.ResourceTypes.RT_PLUGPLAY">
            <summary>Plug and Play resource.</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.ResourceTypes.RT_RCDATA">
            <summary>Application-defined resource (raw data).</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.ResourceTypes.RT_STRING">
            <summary>String-table entry.</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.ResourceTypes.RT_VERSION">
            <summary>Version resource.</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.ResourceTypes.RT_VXD">
            <summary>VXD.</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.SPI.FE_FONTSMOOTHINGSTANDARD">
            <summary>
            constants for SPI_GETFONTSMOOTHINGTYPE and SPI_SETFONTSMOOTHINGTYPE:
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.SPI.FE_FONTSMOOTHINGCLEARTYPE">
            <summary>
            constants for SPI_GETFONTSMOOTHINGTYPE and SPI_SETFONTSMOOTHINGTYPE:
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Declarations.Constants.STATFLAG">
            <summary>
            The STATFLAG enumeration values indicate whether the method should try to return a name in the pwcsName member of the STATSTG structure. The values are used in the ILockBytes::Stat, IStorage::Stat, and IStream::Stat methods to save memory when the pwcsName member is not required.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.STATFLAG.STATFLAG_DEFAULT">
            <summary>
            Requests that the statistics include the pwcsName member of the STATSTG structure.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.STATFLAG.STATFLAG_NONAME">
            <summary>
            Requests that the statistics not include the pwcsName member of the STATSTG structure. If the name is omitted, there is no need for the ILockBytes::Stat, IStorage::Stat, and IStream::Stat methods methods to allocate and free memory for the string value of the name, therefore the method reduces time and resources used in an allocation and free operation.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.STATFLAG.STATFLAG_NOOPEN">
            <summary>
            Not implemented.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Declarations.Constants.STGC">
            <summary>
            The STGC enumeration constants specify the conditions for performing the commit operation in the IStorage::Commit and IStream::Commit methods.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Declarations.Constants.STGTY">
            <summary>
            The STGTY enumeration values are used in the type member of the STATSTG structure to indicate the type of the storage element. A storage element is a storage object, a stream object, or a byte-array object (LOCKBYTES).
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.STGTY.STGTY_STORAGE">
            <summary>
            Indicates that the storage element is a storage object.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.STGTY.STGTY_STREAM">
            <summary>
            Indicates that the storage element is a stream object.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.STGTY.STGTY_LOCKBYTES">
            <summary>
            Indicates that the storage element is a byte-array object.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.STGTY.STGTY_PROPERTY">
            <summary>
            Indicates that the storage element is a property storage object.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Declarations.Constants.STREAM_SEEK">
            <summary>
            The STREAM_SEEK enumeration values specify the origin from which to calculate the new seek-pointer location. They are used for the dworigin parameter in the IStream::Seek method. The new seek position is calculated using this value and the dlibMove parameter.
            </summary>
            <remarks>Binary compatible with the <see cref="T:System.IO.SeekOrigin"/> enum.</remarks>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.STREAM_SEEK.STREAM_SEEK_SET">
            <summary>
            The new seek pointer is an offset relative to the beginning of the stream. In this case, the dlibMove parameter is the new seek position relative to the beginning of the stream.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.STREAM_SEEK.STREAM_SEEK_CUR">
            <summary>
            The new seek pointer is an offset relative to the current seek pointer location. In this case, the dlibMove parameter is the signed displacement from the current seek position.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.STREAM_SEEK.STREAM_SEEK_END">
            <summary>
            The new seek pointer is an offset relative to the end of the stream. In this case, the dlibMove parameter is the new seek position relative to the end of the stream.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.TernaryRasterOperations.SRCCOPY">
            <summary>dest = source</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.TernaryRasterOperations.SRCPAINT">
            <summary>dest = source OR dest</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.TernaryRasterOperations.SRCAND">
            <summary>dest = source AND dest</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.TernaryRasterOperations.SRCINVERT">
            <summary>dest = source XOR dest</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.TernaryRasterOperations.SRCERASE">
            <summary>dest = source AND (NOT dest)</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.TernaryRasterOperations.NOTSRCCOPY">
            <summary>dest = (NOT source)</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.TernaryRasterOperations.NOTSRCERASE">
            <summary>dest = (NOT src) AND (NOT dest)</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.TernaryRasterOperations.MERGECOPY">
            <summary>dest = (source AND pattern)</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.TernaryRasterOperations.MERGEPAINT">
            <summary>dest = (NOT source) OR dest</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.TernaryRasterOperations.PATCOPY">
            <summary>dest = pattern</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.TernaryRasterOperations.PATPAINT">
            <summary>dest = DPSnoo</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.TernaryRasterOperations.PATINVERT">
            <summary>dest = pattern XOR dest</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.TernaryRasterOperations.DSTINVERT">
            <summary>dest = (NOT dest)</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.TernaryRasterOperations.BLACKNESS">
            <summary>dest = BLACK</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.TernaryRasterOperations.WHITENESS">
            <summary>dest = WHITE</summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Constants.WinTrustDataConstants">
            <summary>
            Constants around the <see cref="T:JetBrains.Interop.WinApi.WINTRUST_DATA"/> and its uses.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.WinTrustDataConstants.WINTRUST_ACTION_GENERIC_VERIFY_V2">
            <summary>
             WINTRUST_ACTION_GENERIC_VERIFY_V2 Guid  (Authenticode)
            ----------------------------------------------------------------------------
              Assigned to the pgActionID parameter of WinVerifyTrust to verify the
              authenticity of a file/object using the Microsoft Authenticode
              Policy Provider,
                      {00AAC56B-CD44-11d0-8CC2-00C04FC295EE}
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Constants.WmSizeFlags">
            <summary>
            Flags that go along with the WM_SIZE message in its wParam.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.WmSizeFlags.SIZE_RESTORED">
            <summary>
            The window has been resized, but neither the <see cref="F:JetBrains.Interop.WinApi.Constants.WmSizeFlags.SIZE_MINIMIZED"/> nor <see cref="F:JetBrains.Interop.WinApi.Constants.WmSizeFlags.SIZE_MAXIMIZED"/> value applies.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.WmSizeFlags.SIZE_MINIMIZED">
            <summary>
            The window has been minimized.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.WmSizeFlags.SIZE_MAXIMIZED">
            <summary>
            The window has been maximized.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.WmSizeFlags.SIZE_MAXSHOW">
            <summary>
            Message is sent to all pop-up windows when some other window has been restored to its former size.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Constants.WmSizeFlags.SIZE_MAXHIDE">
            <summary>
            Message is sent to all pop-up windows when some other window is maximized.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.DwmApiDll">
            <summary>
            Dwmapi.dll functions.
            Must be 64bit-safe.
            </summary>
            <remarks>
            IMPORTANT! Rules for authoring the class (v1.1):
            (1) All the function declarations MUST be 64-bit aware.
            (2) When copypasting from older declarations, you MUST check against the MSDN help or header declaration,
               and you MUST ensure that each parameter has a proper size.
            (3) Call the Wide version of the functions (UCS-2-LE) unless there's a strong reason for calling the ANSI version
               (such a reason MUST be indicated in XmlDoc). <c>CharSet = CharSet.Unicode</c>.
            (4) ExactSpelling MUST be TRUE. Add the "…W" suffix wherever needed.
            (5) SetLastError SHOULD be considered individually for each function. Setting it to <c>True</c> allows to report the errors,
               but slows down the execution of critical members.
            (6) These properties MUST be explicitly set on DllImport attributes of EACH import:
               CharSet, PreserveSig, SetLastError, ExactSpelling.
            (7) CLR names MUST be used for types instead of C# ones, eg "Int32" not "int" and "Int64" not "long".
               This greately improves the understanding of the parameter sizes.
            (8) Sign of the types MUST be favored, eg "DWORD" is "UInt32" not "Int32".
            (9) Unsafe pointer types should be used for explicit and implicit pointers rather than IntPtr.
               This way we outline the unsafety of the native calls, and also make it more clear for the 64bit transition.
               Eg "HANDLE" is "void*". If the rule forces you to mark some assembly as unsafe, it's an indication a managed utility
               incapsulating the call and the handle should be provided in one of the already-unsafe assemblies.
            (A) Same rules must apply to members of the structures.
            (B) All of the structures MUST have the [StructLayout(LayoutKind.Sequential)], [NoReorder] attributes, as appropriate.
            </remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.DwmApiDll.DwmDefWindowProc(System.Void*,System.UInt32,System.IntPtr,System.IntPtr,System.IntPtr*)">
            <summary>
            Default window procedure for Desktop Window Manager (DWM) hit testing within the non-client area.
            </summary>
            <param name="hwnd">Handle to the window procedure that received the message.</param>
            <param name="msg">Specifies the message.</param>
            <param name="wParam">Specifies additional message information. The content of this parameter depends on the value of the msg parameter. </param>
            <param name="lParam">Specifies additional message information. The content of this parameter depends on the value of the msg parameter. </param>
            <param name="plResult">Pointer to an LRESULT value that, when this method returns, receives the result of the hit test.</param>
            <returns>TRUE if DwmDefWindowProc handled the message; otherwise, FALSE. </returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.DwmApiDll.DwmExtendFrameIntoClientArea(System.Void*,JetBrains.Interop.WinApi.MARGINS*)">
            <summary>
            Extends the window frame behind the client area.
            If Desktop Window Manager (DWM) composition is toggled, this function must be called again. Handle the WM_DWMCOMPOSITIONCHANGED message for composition change notification.
            Negative margins are used to create the "sheet of glass" effect where the client area is rendered as a solid surface with no window border.
            </summary>
            <param name="hWnd">The handle to the window for which the frame is extended into the client area.</param>
            <param name="pMarInset"><see cref="T:JetBrains.Interop.WinApi.MARGINS"/> that describes the margins to use when extending the frame into the client area.</param>
            <returns>Returns S_OK if successful, or an error value otherwise.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.DwmApiDll.DwmIsCompositionEnabled(System.Int32*)">
            <summary>
            Obtains a value that indicates whether Desktop Window Manager (DWM) composition is enabled. Applications on machines running Windows 7 or earlier can listen for composition state changes by handling the WM_DWMCOMPOSITIONCHANGED notification.
            </summary>
            <param name="pfEnabled"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.DwmApiDll.Helpers.DwmIsCompositionEnabled">
            <summary>
            Obtains a value that indicates whether Desktop Window Manager (DWM) composition is enabled.
            Makes the call safely by checking the WinNT version first.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Functions.HOOKPROC">
            <summary>
            Hook delegate for the <see cref="M:JetBrains.Interop.WinApi.User32Dll.SetWindowsHookExW(System.Int32,JetBrains.Interop.WinApi.Functions.HOOKPROC,System.Void*,System.UInt32)"/> function.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.MARGINS">
            <summary>
            Manages DWM window glass.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.MARGINS.#ctor(System.Int32)">
            <summary>
            Sets all margins to the same value.
            </summary>
        </member>
        <member name="P:JetBrains.Interop.WinApi.MARGINS.WholeSurface">
            <summary>
            Sets the margins so that they cover the whole surface.
            </summary>
        </member>
        <member name="P:JetBrains.Interop.WinApi.MARGINS.Null">
            <summary>
            Sets the margins so that they cover none of the window inner surface.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.PAINTSTRUCT">
            <summary>
            The PAINTSTRUCT structure contains information for an application. This information can be used to paint the client area of a window owned by that application.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.RM_PROCESS_INFO">
            <summary>
            Describes an application that is to be registered with the Restart Manager.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.RM_PROCESS_INFO.Process">
            <summary>
            Contains an RM_UNIQUE_PROCESS structure that uniquely identifies the application by its PID and the time the process began.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.RM_PROCESS_INFO.strAppName">
            <summary>
            If the process is a service, this parameter returns the long name for the service. If the process is not a service, this parameter returns the user-friendly name for the application. If the process is a critical process, and the installer is run with elevated privileges, this parameter returns the name of the executable file of the critical process. If the process is a critical process, and the installer is run as a service, this parameter returns the long name of the critical process.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.RM_PROCESS_INFO.strServiceShortName">
            <summary>
            If the process is a service, this is the short name for the service. This member is not used if the process is not a service.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.RM_PROCESS_INFO.ApplicationType">
            <summary>
            Contains an RM_APP_TYPE enumeration value that specifies the type of application as RmUnknownApp, RmMainWindow, RmOtherWindow, RmService, RmExplorer or RmCritical.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.RM_PROCESS_INFO.AppStatus">
            <summary>
            Contains a bit mask that describes the current status of the application. See the RM_APP_STATUS enumeration.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.RM_PROCESS_INFO.TSSessionId">
            <summary>
            Contains the Terminal Services session ID of the process. If the terminal session of the process cannot be determined, the value of this member is set to RM_INVALID_SESSION (-1). This member is not used if the process is a service or a system critical process.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.RM_PROCESS_INFO.bRestartable">
            <summary>
            TRUE if the application can be restarted by the Restart Manager; otherwise, FALSE. This member is always TRUE if the process is a service. This member is always FALSE if the process is a critical system process.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.RM_UNIQUE_PROCESS">
            <summary>
            Uniquely identifies a process by its PID and the time the process began. An array of RM_UNIQUE_PROCESS structures can be passed to the RmRegisterResources function.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.RM_UNIQUE_PROCESS.dwProcessId">
            <summary>
            The product identifier (PID).
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.RM_UNIQUE_PROCESS.ProcessStartTime">
            <summary>
            The creation time of the process. The time is provided as a FILETIME structure that is returned by the lpCreationTime parameter of the GetProcessTimes function.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.WintrustDll">
            <summary>
            Microsoft Trust Verification APIs (WINTRUST.DLL) functions.
            Must be 64bit-safe.
            </summary>
            <remarks>
            IMPORTANT! Rules for authoring the class (v1.1):
            (1) All the function declarations MUST be 64-bit aware.
            (2) When copypasting from older declarations, you MUST check against the MSDN help or header declaration,
               and you MUST ensure that each parameter has a proper size.
            (3) Call the Wide version of the functions (UCS-2-LE) unless there's a strong reason for calling the ANSI version
               (such a reason MUST be indicated in XmlDoc). <c>CharSet = CharSet.Unicode</c>.
            (4) ExactSpelling MUST be TRUE. Add the "…W" suffix wherever needed.
            (5) SetLastError SHOULD be considered individually for each function. Setting it to <c>True</c> allows to report the errors,
               but slows down the execution of critical members.
            (6) These properties MUST be explicitly set on DllImport attributes of EACH import:
               CharSet, PreserveSig, SetLastError, ExactSpelling.
            (7) CLR names MUST be used for types instead of C# ones, eg "Int32" not "int" and "Int64" not "long".
               This greately improves the understanding of the parameter sizes.
            (8) Sign of the types MUST be favored, eg "DWORD" is "UInt32" not "Int32".
            (9) Unsafe pointer types should be used for explicit and implicit pointers rather than IntPtr.
               This way we outline the unsafety of the native calls, and also make it more clear for the 64bit transition.
               Eg "HANDLE" is "void*". If the rule forces you to mark some assembly as unsafe, it's an indication a managed utility
               incapsulating the call and the handle should be provided in one of the already-unsafe assemblies.
            (A) Same rules must apply to members of the structures.
            (B) All of the structures MUST have the [StructLayout(LayoutKind.Sequential)], [NoReorder] attributes, as appropriate.
            </remarks>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Interfaces.IClrMetaHost">
            <summary>
            Provides methods that return a specific version of the common language runtime (CLR) based on its version number, list all installed CLRs, list all runtimes that are loaded in a specified process, discover the CLR version used to compile an assembly, exit a process with a clean runtime shutdown, and query legacy API binding.
            </summary>
            <code>
            ICLRMetaHost* pMetaHost = NULL;
            HRESULT hr = CLRCreateInstance(CLSID_CLRMetaHost, IID_ICLRMetaHost, (LPVOID*) &amp; pMetaHost);
            </code>
            <remarks>.NET Framework Versions: 4.5, 4.</remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Interfaces.IClrMetaHost.GetRuntime(System.String,System.Guid,System.Object@)">
            <summary>
            Gets the ICLRRuntimeInfo interface that corresponds to a particular version of the common language runtime (CLR). This method supersedes the CorBindToRuntimeEx function used with the STARTUP_LOADER_SAFEMODE flag.
            </summary>
            HRESULT GetRuntime([in] LPCWSTR pwzVersion, [in, REFIID riid, [out, iid_is(riid), retval] LPVOID* ppRuntime);
        </member>
        <member name="M:JetBrains.Interop.WinApi.Interfaces.IClrMetaHost.GetVersionFromFile(System.String,System.Text.StringBuilder,System.UInt32@)">
            <summary>
            Gets an assembly's original .NET Framework compilation version (stored in the metadata), given its file path. This method supersedes the GetFileVersion function.
            </summary>
            HRESULT GetVersionFromFile([in] LPCWSTR pwzFilePath, [out, size_is(*pcchBuffer)] LPWSTR pwzBuffer, [in, out] DWORD* pcchBuffer);
        </member>
        <member name="M:JetBrains.Interop.WinApi.Interfaces.IClrMetaHost.EnumerateInstalledRuntimes(JetBrains.Interop.WinApi.Interfaces.IEnumUnknown@)">
            <summary>
            Returns an enumeration that contains a valid ICLRRuntimeInfo interface for each version of the common language runtime (CLR) that is installed on a computer.
            </summary>
            HRESULT EnumerateInstalledRuntimes([out, retval] IEnumUnknown** ppEnumerator);
        </member>
        <member name="M:JetBrains.Interop.WinApi.Interfaces.IClrMetaHost.EnumerateLoadedRuntimes(System.Void*,JetBrains.Interop.WinApi.Interfaces.IEnumUnknown@)">
            <summary>
            Returns an enumeration that includes a valid ICLRRuntimeInfo interface pointer for each version of the common language runtime (CLR) that is loaded in a given process. This method supersedes the GetVersionFromProcess function.
            </summary>
            HRESULT EnumerateLoadedRuntimes([in] HANDLE hndProcess, [out, retval] IEnumUnknown** ppEnumerator);
        </member>
        <member name="M:JetBrains.Interop.WinApi.Interfaces.IClrMetaHost.RequestRuntimeLoadedNotification(System.Void*)">
            <summary>
            Provides a callback function that is guaranteed to be called when a common language runtime (CLR) version is first loaded, but not yet started. This method supersedes the LockClrVersion function.
            </summary>
            HRESULT RequestRuntimeLoadedNotification([in] RuntimeLoadedCallbackFnPtr pCallbackFunction);
        </member>
        <member name="M:JetBrains.Interop.WinApi.Interfaces.IClrMetaHost.QueryLegacyV2RuntimeBinding(System.Guid,System.Object@)">
            <summary>
            Returns an interface that represents a runtime to which legacy activation policy has been bound, for example, by using the useLegacyV2RuntimeActivationPolicy attribute on the [startup] element configuration file entry, by direct use of the legacy activation APIs, or by calling the ICLRRuntimeInfo::BindAsLegacyV2Runtime method.
            </summary>
            HRESULT QueryLegacyV2RuntimeBinding([in] REFIID riid, [out, iid_is(riid), retval] LPVOID* ppUnk);
        </member>
        <member name="T:JetBrains.Interop.WinApi.Interfaces.IClrRuntimeInfo">
            <summary>
            Provides methods that return information about a specific common language runtime (CLR), including version, directory, and load status. 
            This interface also provides runtime-specific functionality without initializing the runtime. 
            It includes the runtime-relative LoadLibrary method, the runtime module-specific GetProcAddress method, and runtime-provided interfaces through the GetInterface method.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Interfaces.IClrRuntimeInfo.GetVersionString(System.Text.StringBuilder,System.UInt32@)">
            <summary>
            Gets common language runtime (CLR) version information associated with a given ICLRRuntimeInfo interface. This method supersedes GetRequestedRuntimeInfo and GetRequestedRuntimeVersion functions.
            </summary>
            <param name="buffer">
            <para>The .NET Framework compilation version in the format "vA.B[.X]". A, B, and X are decimal numbers that correspond to the major version, the minor version, and the build number. X is optional. If X is not present, there is no trailing period.</para>
            <para>This parameter must match the directory name for the .NET Framework version, as it appears under C:\Windows\Microsoft.NET\Framework.</para>
            <para>Example values are "v1.0.3705", "v1.1.4322", "v2.0.50727", and "v4.0.x", where x depends on the build number installed. Note that the "v" prefix is mandatory.</para>
            </param>
            <param name="bufferLength">Specifies the size of pwzBuffer to avoid buffer overruns. If pwzBuffer is null, pchBuffer returns the required size of pwzBuffer to allow preallocation.</param>
            <returns>HRESULT</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Interfaces.IClrRuntimeInfo.GetRuntimeDirectory(System.Text.StringBuilder,System.UInt32@)">
            <summary>
            Gets the installation directory of the common language runtime (CLR) associated with this interface. This method supersedes the GetCORSystemDirectory function provided in the .NET Framework versions 2.0, 3.0, and 3.5.
            </summary>
            <param name="buffer">Returns the CLR installation directory. The installation path is fully qualified; for example, "c:\windows\microsoft.net\framework\v1.0.3705\".</param>
            <param name="bufferLength">Specifies the size of pwzBuffer to avoid buffer overruns. If pwzBuffer is null, pchBuffer returns the required size of pwzBuffer.</param>
            <returns>HRESULT</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Interfaces.IClrRuntimeInfo.IsLoaded(System.Void*,System.Boolean@)">
            <summary>
            Indicates whether the common language runtime (CLR) associated with the ICLRRuntimeInfo interface is loaded into a process. A runtime can be loaded without also being started.
            </summary>
            <param name="processHandle">A handle to the process.</param>
            <param name="isLoaded">True if the CLR is loaded into the process; otherwise, false.</param>
            <returns>HRESULT</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Interfaces.IClrRuntimeInfo.LoadErrorString(System.Int32,System.Text.StringBuilder,System.UInt32@)">
            <summary>
            Translates an HRESULT value into an appropriate error message for the specified culture. This method supersedes the following functions: LoadStringRC, LoadStringRCEx.
            </summary>
            <param name="resourceId">The HRESULT to translate.</param>
            <param name="buffer">The message string associated with the given HRESULT.</param>
            <param name="bufferLength">The size of pwzbuffer to avoid buffer overruns. If pwzbuffer is null, pcchBuffer provides the expected size of pwzbuffer to allow preallocation.</param>
            <param name="iLocaleID">The culture identifier. To use the default culture, you must specify -1.</param>
            <returns>HRESULT</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Interfaces.IClrRuntimeInfo.LoadLibrary(System.String,System.Void*@)">
            <summary>
            Loads a .NET Framework library from the common language runtime (CLR) represented by an ICLRRuntimeInfo interface. This method supersedes the LoadLibraryShim function.
            </summary>
            <param name="dllName">The name of the assembly to be loaded.</param>
            <param name="hModule">A handle to the loaded assembly.</param>
            <returns>HRESULT</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Interfaces.IClrRuntimeInfo.GetProcAddress(System.String,System.Void*@)">
            <summary>
            Gets the address of a specified function that was exported from the common language runtime (CLR) associated with this interface. This method supersedes the GetRealProcAddress function.
            </summary>
            <param name="procName">The name of the exported function.</param>
            <param name="pProc">The address of the exported function.</param>
            <returns>HRESULT</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Interfaces.IClrRuntimeInfo.GetInterface(System.Guid,System.Guid,System.Object@)">
            <summary>
            Loads the CLR into the current process and returns runtime interface pointers, such as ICLRRuntimeHost, ICLRStrongName, ICorDebug, and IMetaDataDispenserEx. This method supersedes all the CorBindTo* functions in the .NET Framework 1.1 and 2.0 Hosting Global Static Functions section.
            </summary>
            <param name="clsid">The CLSID interface for the coclass.</param>
            <param name="iid">The IID of the requested rclsid interface.</param>
            <param name="ppUnk">A pointer to the queried interface.</param>
            <returns>HRESULT</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Interfaces.IClrRuntimeInfo.IsLoadable(System.Boolean@)">
            <summary>
            Indicates whether the runtime associated with this interface can be loaded into the current process, taking into account other runtimes that might already be loaded into the process.
            </summary>
            <param name="isLoaded">True if this runtime could be loaded into the current process; otherwise, false.</param>
            <returns>HRESULT</returns>
            <remarks>
            If another runtime is already loaded into the process and the runtime associated with this interface can be loaded for in-process side-by-side execution, pbLoadable returns true. If the two runtimes cannot run side-by-side in-process, pbLoadable returns false. For example, the common language runtime (CLR) version 4 can run side-by-side in the same process with CLR version 2.0 or CLR version 1.1. However, CLR version 1.1 and CLR version 2.0 cannot run side-by-side in-process.
            If no runtimes are loaded into the process, this method always returns true.
            </remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Interfaces.IClrRuntimeInfo.SetDefaultStartupFlags(System.UInt32,System.String)">
            <summary>
            Sets the startup flags and the host configuration file that will be used to start the runtime. This method supersedes the use of the startupFlags parameter in the CorBindToRuntimeEx and CorBindToRuntimeHost functions.
            </summary>
            <param name="dwStartupFlags">The host startup flags to set. Use the same flags as with the CorBindToRuntimeEx and CorBindToRuntimeHost functions.</param>
            <param name="pwzHostConfigFile">The directory path of the host configuration file to set.</param>
            <returns>HRESULT</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Interfaces.IClrRuntimeInfo.GetDefaultStartupFlags(System.UInt32@,System.Text.StringBuilder,System.UInt32@)">
            <summary>
            Gets the startup flags and host configuration file that will be used to start the runtime.
            </summary>
            <param name="dwStartupFlags"> A pointer to the host startup flags that are currently set.</param>
            <param name="pwzHostConfigFile">A pointer to the directory path of the current host configuration file.</param>
            <param name="pcchHostConfigFile">On input, the size of pwzHostConfigFile, to avoid buffer overruns. If pwzHostConfigFile is null, the method returns the required size of pwzHostConfigFile for pre-allocation.</param>
            <returns>HRESULT</returns>
            <remarks>
            This method returns the default flag values (STARTUP_CONCURRENT_GC and NULL), or the values provided by a previous call to the ICLRRuntimeInfo::SetDefaultStartupFlags method, or the values set by any of the CorBind* methods if they are bound to this runtime.
            </remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Interfaces.IClrRuntimeInfo.BindAsLegacyV2Runtime">
            <summary>
            Binds the current runtime for all legacy common language runtime (CLR) version 2 activation policy decisions.
            </summary>
            <returns>HRESULT</returns>
            <remarks>
            If the current runtime is already bound for all legacy CLR version 2 activation policy decisions (for example, by using the useLegacyV2RuntimeActivationPolicy attribute on the &lt;startup&gt; element in the configuration file), this method does not return an error result; instead, the result is S_OK, just as it would be if the method had successfully bound legacy activation policy.
            </remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Interfaces.IClrRuntimeInfo.IsStarted(System.Boolean@,System.UInt32@)">
            <summary>
            Indicates whether the runtime has been started (that is, whether the ICLRRuntimeHost::Start method has been called and has succeeded).
            </summary>
            <param name="isStarted">True if this runtime is started; otherwise, false.</param>
            <param name="dwStartupFlags">Returns the flags that were used to start the runtime.</param>
            <returns>HRESULT</returns>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Interfaces.IEnumUnknown">
            <summary>
            Enumerates objects with the IUnknown interface. It can be used to enumerate through the objects in a component containing multiple objects.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Interfaces.IEnumUnknown.Next(System.UInt32,System.Object[],System.UInt32@)">
            <summary>
            Retrieves the specified number of items in the enumeration sequence.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Interfaces.IEnumUnknown.Skip(System.UInt32)">
            <summary>
            Skips over the specified number of items in the enumeration sequence.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Interfaces.IEnumUnknown.Reset">
            <summary>
            Resets the enumeration sequence to the beginning.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Interfaces.IEnumUnknown.Clone(JetBrains.Interop.WinApi.Interfaces.IEnumUnknown@)">
            <summary>
            Creates a new enumerator that contains the same enumeration state as the current one.
            </summary>
            <remarks>This method makes it possible to record a point in the enumeration sequence in order to return to that point at a later time. The caller must release this new enumerator separately from the first enumerator.</remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.ProcessorArchitectureConventions.GetExeFileSuffix(JetBrains.Interop.WinApi.ProcessorArchitecture)">
            <summary>
            The standard file suffix for naming executables, like <c>Receptor32.exe</c> or <c>Receptor64.exe</c>.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.ProcessorArchitectureConventions.GetFolderName(JetBrains.Interop.WinApi.ProcessorArchitecture)">
            <summary>
            The standard folder name for storing files for certain CPU in a subfolder.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.ProcessorArchitectureConventions.ToStringNoPrefix(JetBrains.Interop.WinApi.ProcessorArchitecture)">
            <summary>
            Returns the distinctive part of the string representation, e.g. <c>"INTEL"</c> for <c>"PROCESSOR_ARCHITECTURE_INTEL"</c>.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Declarations.Interfaces.IEnumSTATPROPSETSTG">
            <summary>
            Enumerates an array of structures containing statistical data about the property sets managed by the current <see cref="T:JetBrains.Interop.WinApi.Declarations.Interfaces.IPropertySetStorage"/> instance. For more information, see IEnumSTATPROPSETSTG, IEnumSTATPROPSETSTG-Compound File Implementation, and STATPROPSETSTG.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Declarations.Interfaces.IPropertySetStorage">
            <summary>
            Creates, opens, deletes, and enumerates storage of property sets supporting the <see cref="T:JetBrains.Interop.WinApi.Declarations.Interfaces.IPropertyStorage"/> interface. For more information, see IPropertySetStorage.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Declarations.Interfaces.IPropertyStorage">
            <summary>
            Manages the persistent properties of a single property set. For more information, see IPropertyStorage and IPropertySetStorage.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Declarations.Interfaces.IEnumSTATSTG">
            <summary>
            Enumerates an array of structures containing statistical data about open storage, stream, or byte array objects. For more information, see IEnumSTATSTG and STATSTG.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Declarations.Interfaces.ILockBytes">
            <summary>
            The ILockBytes interface is implemented on a byte array object that is backed by some physical storage, such as a disk file, global memory, or a database. It is used by a COM compound file storage object to give its root storage access to the physical device, while isolating the root storage from the details of accessing the physical storage.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Interfaces.IMsoComponent">
            <summary>
            Provides components that need idle time, such as packages that manage modeless top-level windows, with access to the message loop and other facilities. 
            </summary>
            <remarks>
            Register the interface with the component manager that implements the IMsoComponentManager interface.
            The interface is also declared in internal class System.Windows.Forms.UnsafeNativeMethods (Assembly: System.Windows.Forms, Version=4.0.0.0)
            </remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Interfaces.IMsoComponent.FDebugMessage(System.IntPtr,System.UInt32,System.IntPtr,System.IntPtr)">
            <summary>
            This method is reserved for internal use and is not intended to be used in your code. This method always returns TRUE.
            </summary>
            <remarks>
            In Microsoft.VisualStudio.OLE.Interop.IOleComponent inerface this method is called FReserved1.
            </remarks>
            <prototype>
            BOOL FDebugMessage(HANDLE hinst, UINT message, WPARAM wParam, LPARAM lParam);
            </prototype>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Interfaces.IMsoComponent.FPreTranslateMessage(JetBrains.Interop.WinApi.MSG[])">
            <summary>
            Enables components to process a message before the message is translated and is dispatched. 
            </summary>
            <returns>TRUE to indicate that the message is consumed; otherwise, FALSE</returns>
            <remarks>
            Components can use the TranslateAccelerator function, use the IsDialogMessage function, modify the pMsg parameter, or take some other action.
            </remarks>
            <prototype>
            BOOL FPreTranslateMessage(MSG *pMsg);
            </prototype>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Interfaces.IMsoComponent.OnEnterState(System.UInt32,System.Int32)">
            <summary>
            Notifies a component when the application enters or exits the state specified by the uStateId parameter.
            </summary>
            <remarks>
            The component should take action depending on the value of the uStateId parameter (see msocstateXxx flags).
            
            If n calls are made with the fEnter parameter equal to TRUE, the component should consider the state to be in effect 
            until n calls are made with the fEnter parameter equal to FALSE.  
            
            It is possible for this method to be called with the fEnter parameter equal to FALSE more times than it was called with TRUE. 
            The counter should not be decremented for FALSE if it is already at 0.
            </remarks>
            <prototype>
            void OnEnterState(ULONG uStateID, BOOL fEnter);
            </prototype>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Interfaces.IMsoComponent.OnAppActivate(System.Int32,System.UInt32)">
            <summary>
            Notifies the component when the host application gains or loses activation.
            </summary>
            <prototype>
            void OnAppActivate(BOOL fActive, DWORD dwOtherThreadID);
            </prototype>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Interfaces.IMsoComponent.OnLoseActivation">
            <summary>
            Notifies the active component that it has lost its active status because the host or another component has become active.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Interfaces.IMsoComponent.OnActivationChange(System.Object,System.Int32,JetBrains.Interop.WinApi.MSOCRINFO*,System.Int32,JetBrains.Interop.WinApi.MSOCHOSTINFO*,System.UInt32)">
            <summary>
            Notifies the component when a new object is being activated.
            </summary>
            <param name="component">A pointer to the component being activated. Can be NULL.</param>
            <param name="fSameComponent">TRUE to indicate that the component parameter is the same component registration as the component that this method is being called on; otherwise, FALSE.</param>
            <param name="pcrinfo">A pointer to an MSOCRINFO structure that specifies the active component’s registration information. Can be NULL.</param>
            <param name="fHostIsActivating">TRUE to indicate that the host object is being activated; otherwise, FALSE. 
            If the fHostIsActivating parameter is TRUE and the component parameter is NULL, the host object is being activated. 
            If the fHostIsActivating parameter is FALSE and the component parameter is NULL, there is no current active object</param>
            <param name="pchostinfo">A pointer to an MSOCHOSTINFO structure that specifies the host component's information. Can be NULL.</param>
            <param name="dwReserved">Reserved for future use. Should be 0.</param>
            <prototype>
            void OnActivationChange(IMsoComponent *pic, BOOL fSameComponent, const MSOCRINFO *pcrinfo, BOOL fHostIsActivating, const MSOCHOSTINFO *pchostinfo, DWORD dwReserved);
            </prototype>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Interfaces.IMsoComponent.FDoIdle(System.UInt32)">
            <summary>
            Enables the component to do idle-time tasks.
            </summary>
            <param name="grfidlef">The type of idle-time tasks to perform. The type of tasks are specified by a combination of the values of the following flags:
            msoidlefPeriodic = 1      Specifies to perform periodic idle-time tasks.
            msoidlefNonPeriodic = 2   Specifies to perform any nonperiodic idle-time tasks.
            msoidlefPriority = 4      Specifies to perform high priority, nonperiodic idle-time tasks.
            msoidlefAll = 0xFFFFFFFF  Specifies to perform all idle-time tasks.</param>
            <returns>TRUE to indicate that more time is needed to perform the idle-time tasks; otherwise, FALSE.</returns>
            <remarks>
            The component may periodically call the IMsoComponentManager::FContinueIdle method. 
            If the FContinueIdle method returns FALSE, the component should terminate its idle-time processing and return.
            If a component reaches a point where it has no idle-time tasks and does not need IMsoComponent::FDoIdle method calls, 
            it should remove its idle task registration by calling the IMsoComponentManager::FUpdateComponentRegistration method.
            If this method is called while the component is performing a tracking operation, 
            the component should perform only idle-time tasks that are appropriate to perform during tracking.
            </remarks>
            <prototype>
            BOOL FDoIdle(DWORD grfidlef);
            </prototype>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Interfaces.IMsoComponent.FContinueMessageLoop(System.UInt32,System.Void*,JetBrains.Interop.WinApi.MSG[])">
            <summary>
            Indicates whether the message loop pushed by the component should continue.
            </summary>
            <param name="uReason">Specifies the reason the message loop is being pushed. For more information, see the Msoloop enumeration.</param>
            <param name="pvLoopData">The component's private data.</param>
            <param name="pMsgPeeked">A pointer to the next message in the queue. This parameter is NULL if there are no more messages in the queue.</param>
            <returns>TRUE to indicate that the message loop should continue; otherwise, FALSE.</returns>
            <remarks>
            This method is called after peeking the next message in the queue (by calling the PeekMessage function) but before the message is removed from the queue. 
            The peeked message is passed in the pMsgPeeked parameter. This method may be called again when the next message has already been removed from the queue, 
            in which case the pMsgPeeked parameter is NULL.
            If this method returns FALSE, the component manager terminates the loop without removing from the queue the message specified by the pMsgPeeked parameter.
            </remarks>
            <prototype>
            BOOL FContinueMessageLoop(ULONG uReason, void *pvLoopData, MSG *pMsgPeeked);
            </prototype>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Interfaces.IMsoComponent.FQueryTerminate(System.Int32)">
            <summary>
            Specifies whether the component can terminate.
            </summary>
            <param name="fPromptUser">TRUE to indicate that the component might need to prompt the user; otherwise, FALSE.</param>
            <returns>TRUE if the component can terminate; otherwise, FALSE.</returns>
            <remarks>
            This method is called by the component manager to determine whether the component is in a state in which it can terminate.
            
            If fPromptUser is TRUE, the component may query the user, as appropriate, to determine whether it should terminate. 
            If it cannot terminate, it should inform the user of why it cannot terminate. 
            If fPromptUser is FALSE, the component should make its decision without querying or informing the user.
            </remarks>
            <prototype>
            BOOL FQueryTerminate(BOOL fPromptUser);
            </prototype>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Interfaces.IMsoComponent.Terminate">
            <summary>
            Terminates the registration of the IMsoComponent interface.
            </summary>
            <remarks>
            The IMsoComponent interface should revoke its registration with the component manager, release references to the component manager, and then perform any necessary cleanup.
            </remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Interfaces.IMsoComponent.HwndGetWindow(System.UInt32,System.UInt32)">
            <summary>
            Retrieves a window that is associated with the component.
            </summary>
            <param name="dwWhich">The window for which to obtain the window handle (HWND). The possible values are:
            msocWindowFrameToplevel = 0 Specifies the top frame window. 
                                        Multiple-document interface (MDI) applications should return the MDI frame (not the MDI client) or the application frame window. 
                                        Single-document interface (SDI) applications should return the frame window that hosts the component. 
                                        This should be the topmost window that owns the component.
            msocWindowFrameOwner = 1    Specifies the window that owns the component. 
                                        The window may be the same as the top frame window, or may be an owned window of the top frame window.
            msocWindowComponent = 2     Specifies the main window of the component.
            msocWindowDlgOwner = 3      Specifies that the caller needs to display a dialog box to be owned by the component. 
                                        The component should return a window that is suitable for use as the dialog box's owner window.</param>
            <param name="dwReserved">Reserved for future use. Should be 0.</param>
            <returns>The handle to the window associated with the component. If this method fails or the window does not exist, NULL is returned.</returns>
            <prototype>
            HWND HwndGetWindow(DWORD dwWhich, DWORD dwReserved);
            </prototype>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Interfaces.IMsoComponentManager">
            <summary>
            Defines a component manager, which is an object that coordinates other components by using its message loop for message processing and allocation of idle time.
            </summary>
            <remarks>
            You can get an instance of this interface by calling the CoRegisterMessageFilter function to get a reference to the current message filter. 
            Ensure that you immediately call the CoRegisterMessageFilter function again to put the object back right away. 
            Then call the QueryInterface method on the returned message filter to get an IServiceProvider interface. 
            Finally, call the QueryService method on the IServiceProvider interface to get an IMsoComponentManager interface.
            
            The interface is also declared in internal class System.Windows.Forms.UnsafeNativeMethods (Assembly: System.Windows.Forms, Version=4.0.0.0)
            </remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Interfaces.IMsoComponentManager.QueryService(System.Guid@,System.Guid@,System.Object@)">
            <prototype>
            HRESULT QueryService(REFGUID guidService, REFIID iid, void** ppvObj);
            </prototype>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Interfaces.IMsoComponentManager.FDebugMessage(System.IntPtr,System.UInt32,System.IntPtr,System.IntPtr)">
            <prototype>
            BOOL FDebugMessage(ULONG dwReserved, ULONG message, DWORD_PTR wParam, DWORD_PTR lParam);
            </prototype>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Interfaces.IMsoComponentManager.FRegisterComponent(JetBrains.Interop.WinApi.Interfaces.IMsoComponent,JetBrains.Interop.WinApi.MSOCRINFO[],System.IntPtr@)">
            <prototype>
            BOOL FRegisterComponent(IMsoComponent *piComponent, const MSOCRINFO *pcrinfo, DWORD_PTR *pdwComponentID);
            </prototype>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Interfaces.IMsoComponentManager.FRevokeComponent(System.IntPtr)">
            <prototype>
            BOOL FRevokeComponent(DWORD_PTR dwComponentID);
            </prototype>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Interfaces.IMsoComponentManager.FUpdateComponentRegistration(System.IntPtr,JetBrains.Interop.WinApi.MSOCRINFO[])">
            <prototype>
            BOOL FUpdateComponentRegistration(DWORD_PTR dwComponentID, const MSOCRINFO *pcrinfo);
            </prototype>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Interfaces.IMsoComponentManager.FOnComponentActivate(System.IntPtr)">
            <prototype>
            BOOL FOnComponentActivate(DWORD_PTR dwComponentID);
            </prototype>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Interfaces.IMsoComponentManager.FSetTrackingComponent(System.IntPtr,System.Int32)">
            <prototype>
            BOOL FSetTrackingComponent(DWORD_PTR dwComponentID, ULONG grftrack);
            </prototype>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Interfaces.IMsoComponentManager.OnComponentEnterState(System.IntPtr,System.UInt32,System.UInt32,System.UInt32,System.Void**,System.UInt32)">
            <prototype>
            void OnComponentEnterState(DWORD_PTR dwComponentID, ULONG uStateID, ULONG uContext, ULONG cpicmExclude, IMsoComponentManager **rgpicmExclude, DWORD dwReserved);
            </prototype>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Interfaces.IMsoComponentManager.FOnComponentExitState(System.IntPtr,System.UInt32,System.UInt32,System.UInt32,System.Void**)">
            <prototype>
            BOOL FOnComponentExitState(DWORD_PTR dwComponentID, ULONG uStateID, ULONG uContext, ULONG cpicmExclude, IMsoComponentManager **rgpicmExclude);
            </prototype>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Interfaces.IMsoComponentManager.FInState(System.UInt32,System.IntPtr)">
            <prototype>
            BOOL FInState(ULONG uStateID, void* pvoid);
            </prototype>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Interfaces.IMsoComponentManager.FContinueIdle">
            <prototype>
            BOOL FContinueIdle();
            </prototype>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Interfaces.IMsoComponentManager.FPushMessageLoop(System.IntPtr,System.Int32,System.Void*)">
            <prototype>
            BOOL FPushMessageLoop(DWORD_PTR dwComponentID, ULONG uReason, void *pvLoopData);
            </prototype>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Interfaces.IMsoComponentManager.FCreateSubComponentManager(System.Object,System.Object,System.Guid@,System.IntPtr@)">
            <prototype>
            BOOL FCreateSubComponentManager(IUnknown *piunkOuter, IUnknown *piunkServProv, REFIID riid, void **ppvObj);
            </prototype>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Interfaces.IMsoComponentManager.FGetParentComponentManager(System.Object@)">
            <prototype>
            BOOL FGetParentComponentManager(IMsoComponentManager **ppicm);
            </prototype>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Interfaces.IMsoComponentManager.FGetActiveComponent(System.UInt32,System.Object[],JetBrains.Interop.WinApi.MSOCRINFO[],System.UInt32)">
            <prototype>
            BOOL FGetActiveComponent(DWORD dwgac, IMsoComponent **ppic, MSOCRINFO *pcrinfo, DWORD dwReserved);
            </prototype>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Declarations.Interfaces.IServiceProvider">
            <summary>
            <para>The IServiceProvider interface is a generic access mechanism to locate a GUID-identified service that is provided through a control or any other object that the service can communicate with. For example, an embedded object (such as an OLE control) typically communicates only with its associated client site object in the container through the IOleClientSite interface that is supplied by using IOleObject::SetClientSite. The embedded object must ask the client site for some other service that the container supports when that service might not be implemented in the client site.</para>
            <para>The client site must provide a means by which the control that is managed by the site can access the service when necessary. For example, the IOleInPlaceSite::GetWindowContext function can be used by an in-place object or control to access interface pointers for the document object that contains the site and the frame object that contains the document. Because these interface pointers exist on separate objects, the control cannot call the site's QueryInterface to obtain those pointers. Instead, use the IServiceProvider interface. </para>
            <para>The IServiceProvider interface has only one member, QueryService, through which a caller specifies the service ID (SID, a GUID), the IID of the interface to return, and the address of the caller's interface pointer variable. </para>
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Declarations.Interfaces.IServiceProvider.QueryService(System.Guid*,System.Guid*)">
            <summary>
            Acts as the factory method for any services exposed through an implementation of IServiceProvider.
            </summary>
            <param name="guidService">[in] The unique identifier of the service (an SID). </param>
            <param name="riid">[in] The unique identifier of the interface that the caller wants to receive for the service. </param>
            <returns>[out] The address of the caller-allocated variable to receive the interface pointer of the service on successful return from this function. The caller becomes responsible for calling Release through this interface pointer when the service is no longer required.</returns>
        </member>
        <member name="T:JetBrains.Interop.WinApi.ImagehlpDll">
            <summary>
            Windows NT Image Helper (IMAGEHLP.DLL) functions.
            Must be 64bit-safe.
            </summary>
            <remarks>
            IMPORTANT! Rules for authoring the class (v1.1):
            (1) All the function declarations MUST be 64-bit aware.
            (2) When copypasting from older declarations, you MUST check against the MSDN help or header declaration,
               and you MUST ensure that each parameter has a proper size.
            (3) Call the Wide version of the functions (UCS-2-LE) unless there's a strong reason for calling the ANSI version
               (such a reason MUST be indicated in XmlDoc). <c>CharSet = CharSet.Unicode</c>.
            (4) ExactSpelling MUST be TRUE. Add the "…W" suffix wherever needed.
            (5) SetLastError SHOULD be considered individually for each function. Setting it to <c>True</c> allows to report the errors,
               but slows down the execution of critical members.
            (6) These properties MUST be explicitly set on DllImport attributes of EACH import:
               CharSet, PreserveSig, SetLastError, ExactSpelling.
            (7) CLR names MUST be used for types instead of C# ones, eg "Int32" not "int" and "Int64" not "long".
               This greately improves the understanding of the parameter sizes.
            (8) Sign of the types MUST be favored, eg "DWORD" is "UInt32" not "Int32".
            (9) Unsafe pointer types should be used for explicit and implicit pointers rather than IntPtr.
               This way we outline the unsafety of the native calls, and also make it more clear for the 64bit transition.
               Eg "HANDLE" is "void*". If the rule forces you to mark some assembly as unsafe, it's an indication a managed utility
               incapsulating the call and the handle should be provided in one of the already-unsafe assemblies.
            (A) Same rules must apply to members of the structures.
            (B) All of the structures MUST have the [StructLayout(LayoutKind.Sequential)], [NoReorder] attributes, as appropriate.
            </remarks>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.PROPSPEC.ulKind">
            <seealso cref="T:JetBrains.Interop.WinApi.Declarations.Constants.PRSPEC"/>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Declarations.Structures.IntOrStringResourceId">
            <summary>
            A helper <c>MAKEINTRESOURCE</c>-friendly structure which, just like the WinAPI stuff, can hold either a string or an int to identify the resource.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Declarations.Structures.NativeResourceTypeAndName">
            <summary>
            A helper <c>MAKEINTRESOURCE</c>-friendly structure which, just like the WinAPI stuff, can hold either a string or an int to identify the resource.
            Holds two values, for the resource type and resource name/id.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Declarations.Structures.NativeResourceTypeAndName.WithMakeIntResource(JetBrains.Interop.WinApi.Declarations.Structures.NativeResourceTypeAndName.WithMakeIntResourceDelegate)">
            <summary>
            Does the <c>MAKEINTRESOURCE</c>-compliant pointer magic for the resource type and name.
            </summary>
            <param name="F"></param>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Declarations.Structures.NativeResourceTypeAndName.WithMakeIntResourceDelegate">
            <summary>
            A callback with <c>MAKEINTRESOURCE</c>-processed parameters.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.PROPVARIANT.pdata1">
            <summary>
            Data entry start. The data size is two pointers large, so there is the second one to keep space.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.MscoreeDll.CLRCreateInstance(System.Guid,System.Guid,System.Object@)">
            <summary>
            Provides one of three interfaces: ICLRMetaHost, ICLRMetaHostPolicy, or ICLRDebugging.
            </summary>
            <param name="clsid">One of three class identifiers: CLSID_CLRMetaHost, CLSID_CLRMetaHostPolicy, or CLSID_CLRDebugging.</param>
            <param name="riid">One of three interface identifiers (IIDs): IID_ICLRMetaHost, IID_ICLRMetaHostPolicy, or IID_ICLRDebugging.</param>
            <param name="pInterface">One of three interfaces: ICLRMetaHost, ICLRMetaHostPolicy, or ICLRDebugging.</param>
            <returns>HRESULT</returns>
            <remarks>.NET Framework Versions: 4.5, 4</remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.MscoreeDll.GetVersionFromProcess(System.Void*,System.Text.StringBuilder,System.UInt32,System.UInt32@)">
            <summary>
            Gets the version number of the common language runtime (CLR) that is associated with the specified process handle. This function has been deprecated in the .NET Framework version 4.
            </summary>
            <param name="hProcess">A handle to a process.</param>
            <param name="buffer">A buffer that contains the version number string upon successful completion of the method.</param>
            <param name="bufferSize">The length of the version buffer.</param>
            <param name="bufferLength">A pointer to the length of the version number string.</param>
            <returns>HRESULT</returns>
            <remarks>.NET Framework Versions: 4.5, 4, 3.5 SP1, 3.5, 3.0 SP1, 3.0, 2.0 SP1, 2.0</remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.MscoreeDll.GetFileVersion(System.String,System.Text.StringBuilder,System.UInt32,System.UInt32@)">
            <summary>
            Gets the common language runtime (CLR) version information of the specified file, using the specified buffer. This function has been deprecated in the .NET Framework 4.
            </summary>
            <param name="fileName">The path of the file to be examined.</param>
            <param name="buffer">The buffer allocated for the version information that is returned.</param>
            <param name="bufferSize">The size, in wide characters, of szBuffer.</param>
            <param name="bufferLength">The size, in bytes, of the returned szBuffer.</param>
            <returns>HRESULT</returns>
            <remarks>.NET Framework Versions: 4.5, 4, 3.5 SP1, 3.5, 3.0 SP1, 3.0, 2.0 SP1, 2.0, 1.1</remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.MscoreeDll.GetRequestedRuntimeVersion(System.String,System.Text.StringBuilder,System.UInt32,System.UInt32@)">
            <summary>
            Gets the version number of the common language runtime (CLR) requested by the specified application. If that version is not installed, gets the most recent version that is installed before the requested version. This function has been deprecated in the .NET Framework 4.
            </summary>
            <param name="filePath">The name of the application.</param>
            <param name="buffer">A buffer that contains the version number string upon successful completion.</param>
            <param name="bufferSize">The length of the version buffer.</param>
            <param name="bufferLength">A pointer to the length of the version number string.</param>
            <returns>HRESULT</returns>
            <remarks>.NET Framework Versions: 4.5, 4, 3.5 SP1, 3.5, 3.0 SP1, 3.0, 2.0 SP1, 2.0, 1.1</remarks>
        </member>
        <member name="T:JetBrains.Interop.WinApi.EVENT_RECORD">
            <summary>
            The EVENT_RECORD structure defines the layout of an event that ETW delivers.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.EVENT_TRACE">
            <summary>
            The EVENT_TRACE structure is used to deliver event information to an event trace consumer.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.EVENT_TRACE_LOGFILE">
            <summary>
            The EVENT_TRACE_LOGFILE structure specifies how the consumer wants to read events (from a log file or in real-time) and the callbacks that will receive the events.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.EventRecordCallback">
            <summary>
            Consumers implement this function to receive events from a session.
            </summary>
            <param name="eventRecord">Pointer to an EVENT_TRACE structure that contains the event information.</param>
            <remarks>
            <para>To specify the function that ETW calls to deliver the events, set the EventCallback member of the EVENT_TRACE_LOGFILE structure that you pass to the OpenTrace function.</para>
            <para>This callback receives all events that the session generates from the time you call the OpenTrace function to open the trace. Call the ProcessTrace function to begin receiving the events.</para>
            <para>The event data for the first event you always receive contains the TRACE_LOGFILE_HEADER information. All the other events you receive contain provider-specific event data. You use the Header.Guid and Header.Class.Type members of EVENT_TRACE to determine the type of event you received.</para>
            </remarks>
        </member>
        <member name="T:JetBrains.Interop.WinApi.EventTraceBufferCallback">
            <summary>
            Consumers implement this function to receive statistics about each buffer of events that ETW delivers to an event trace consumer. ETW calls this function after the events for each buffer are delivered.
            </summary>
            <param name="logfile">Pointer to an EVENT_TRACE_LOGFILE structure that contains information about the buffer.</param>
            <returns>To continue processing events, return TRUE. Otherwise, return FALSE. Returning FALSE will terminate the ProcessTrace function.</returns>
            <remarks>To specify the function that ETW calls to deliver the buffer statistics, set the BufferCallback member of the EVENT_TRACE_LOGFILE structure that you pass to the OpenTrace function.</remarks>
        </member>
        <member name="T:JetBrains.Interop.WinApi.EVENT_TRACE_PROPERTIES">
            <summary>
            The EVENT_TRACE_PROPERTIES structure contains information about an event tracing session. You use this structure when you define a session, change the properties of a session, or query for the properties of a session.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.EventTrace_LogFileMode">
            <summary>
            Logger Mode flags
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Declarations.Structures.STATSTG">
            <summary>
            Contains statistical information about an open storage, stream, or byte-array object.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.STATSTG.pwcsName">
            <summary>
            Represents a pointer to a null-terminated string containing the name of the object described by this structure.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.STATSTG.type">
            <summary>
            Indicates the type of storage object, which is one of the values from the STGTY enumeration.
            </summary>
            <seealso cref="T:JetBrains.Interop.WinApi.Declarations.Constants.STGTY"/>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.STATSTG.cbSize">
            <summary>
            Specifies the size, in bytes, of the stream or byte array.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.STATSTG.mtime">
            <summary>
            Indicates the last modification time for this storage, stream, or byte array.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.STATSTG.ctime">
            <summary>
            Indicates the creation time for this storage, stream, or byte array.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.STATSTG.atime">
            <summary>
            Specifies the last access time for this storage, stream, or byte array.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.STATSTG.grfMode">
            <summary>
            Indicates the access mode that was specified when the object was opened.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.STATSTG.grfLocksSupported">
            <summary>
            Indicates the types of region locking supported by the stream or byte array.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.STATSTG.clsid">
            <summary>
            Indicates the class identifier for the storage object.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.STATSTG.grfStateBits">
            <summary>
            Indicates the current state bits of the storage object (the value most recently set by the IStorage::SetStateBits method).
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.STATSTG.reserved">
            <summary>
            Reserved for future use.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.MSOCRINFO">
            <summary>
            Specifies registration information for a MSO component.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.MSOCRINFO.cbSize">
            <summary>
            The size, in bytes, of the MSOCRINFO structure.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.MSOCRINFO.uIdleTimeInterval">
            <summary>
            The interval time, in milliseconds, of when a periodic idle phase should occur. During the idle phase, the component needs to perform idle-time tasks. 
            This member applies only if the msocrfNeedPeriodicIdleTime bit flag is registered in the grfcrf member
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.MSOCRINFO.grfcrf">
            <summary>
            Bit flags composed from the Msocrf enumeration.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.MSOCRINFO.grfcadvf">
            <summary>
            Bit flags composed from the Msocadvf enumeration.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.ConnectDll">
            <summary>
            Connect.dll functions.
            Must be 64bit-safe.
            </summary>
            <remarks>
            IMPORTANT! Rules for authoring the class (v1.1):
            (1) All the function declarations MUST be 64-bit aware.
            (2) When copypasting from older declarations, you MUST check against the MSDN help or header declaration,
               and you MUST ensure that each parameter has a proper size.
            (3) Call the Wide version of the functions (UCS-2-LE) unless there's a strong reason for calling the ANSI version
               (such a reason MUST be indicated in XmlDoc). <c>CharSet = CharSet.Unicode</c>.
            (4) ExactSpelling MUST be TRUE. Add the "…W" suffix wherever needed.
            (5) SetLastError SHOULD be considered individually for each function. Setting it to <c>True</c> allows to report the errors,
               but slows down the execution of critical members.
            (6) These properties MUST be explicitly set on DllImport attributes of EACH import:
               CharSet, PreserveSig, SetLastError, ExactSpelling.
            (7) CLR names MUST be used for types instead of C# ones, eg "Int32" not "int" and "Int64" not "long".
               This greately improves the understanding of the parameter sizes.
            (8) Sign of the types MUST be favored, eg "DWORD" is "UInt32" not "Int32".
            (9) Unsafe pointer types should be used for explicit and implicit pointers rather than IntPtr.
               This way we outline the unsafety of the native calls, and also make it more clear for the 64bit transition.
               Eg "HANDLE" is "void*". If the rule forces you to mark some assembly as unsafe, it's an indication a managed utility
               incapsulating the call and the handle should be provided in one of the already-unsafe assemblies.
            (A) Same rules must apply to members of the structures.
            (B) All of the structures MUST have the [StructLayout(LayoutKind.Sequential)], [NoReorder] attributes, as appropriate.
            </remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.ConnectDll.Helpers.IsInternetConnected">
            <summary>
            The IsInternetConnected function determines whether the current user is connected to the Internet.
            </summary>
            <remarks>Cannot call the API <c>IsInternetConnected</c> function directly because it's only available starting with NT6.</remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Declarations.Interfaces.IStorage.Commit(System.UInt32)">
            <seealso cref="T:JetBrains.Interop.WinApi.Declarations.Constants.STGC"/>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Declarations.Constants.STGM">
            <summary>
              Storage instantiation modes
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.STGFMT.STGFMT_DOCUMENT">
            <summary>
              This is a legacy define to allow old component to builds
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Declarations.Constants.FileMapAccess">
            <summary>
              Access flags, e.g. for <see cref="M:JetBrains.Interop.WinApi.Kernel32Dll.MapViewOfFile(System.Void*,System.UInt32,System.UInt32,System.UInt32,System.UIntPtr)"/>.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Declarations.Constants.KEYEVENTF">
            <summary>
              For <see cref="M:JetBrains.Interop.WinApi.User32Dll.keybd_event(System.Byte,System.Byte,System.UInt32,System.UIntPtr)"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.KEYEVENTF.KEYEVENTF_EXTENDEDKEY">
            <summary>
              If specified, the scan code was preceded by a prefix byte having the value 0xE0 (224).
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.KEYEVENTF.KEYEVENTF_KEYUP">
            <summary>
              If specified, the key is being released. If not specified, the key is being depressed.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Declarations.Constants.SectionFlags">
            <summary>
              From <c>Winnt.h</c>.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.MsiDll.MsiCloseHandle(System.Void*)">
            <summary>
            The MsiCloseHandle function closes an open installation handle.
            </summary>
            <param name="hAny"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.MsiDll.MsiGetProductPropertyW(System.Void*,System.String,System.Char*,System.UInt32*)">
            <summary>
            The MsiGetProductProperty function retrieves product properties. These properties are in the product database.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.MsiDll.MsiOpenPackageExW(System.String,System.UInt32,System.Void**)">
            <summary>
            The MsiOpenPackageEx function opens a package to use with functions that access the product database. The MsiCloseHandle function must be called with the handle when the handle is no longer needed.
            </summary>
            <param name="szPackagePath"> </param>
            <param name="dwOptions">MSIOPENPACKAGEFLAGS_IGNOREMACHINESTATE = 1</param>
            <param name="hProduct"> </param>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Declarations.Constants.MOUSEEVENTF">
            <summary>
              For <see cref="M:JetBrains.Interop.WinApi.User32Dll.mouse_event(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UIntPtr)"/>.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.SYSTEMTIME">
            <summary>
            Specifies a date and time, using individual members for the month, day, year, weekday, hour, minute, second, and millisecond. The time is either in coordinated universal time (UTC) or local time, depending on the function that is being called.
            </summary>
            <remarks>Winbase.h (include Windows.h)</remarks>
        </member>
        <member name="T:JetBrains.Interop.WinApi.TIME_ZONE_INFORMATION">
            <summary>
            Specifies settings for a time zone.
            </summary>
            <remarks>Winbase.h (include Windows.h)</remarks>
        </member>
        <member name="T:JetBrains.Interop.WinApi.TRACE_GUID_PROPERTIES">
            <summary>
            The TRACE_GUID_PROPERTIES structure contains information about an event trace provider.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Declarations.Constants.BiCompression">
            <summary>
            <see cref="T:JetBrains.Interop.WinApi.Declarations.Structures.BITMAPINFOHEADER"/> compression values.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.BiCompression.BI_RGB">
            <summary>
            An uncompressed format. (<see cref="T:JetBrains.Interop.WinApi.Declarations.Structures.BITMAPINFOHEADER"/> version 5)
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.BiCompression.BI_RLE8">
            <summary>
            A run-length encoded (RLE) format for bitmaps with 8 bpp. The compression format is a 2-byte format consisting of a count byte followed by a byte containing a color index. For more information, see Bitmap Compression.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.BiCompression.BI_RLE4">
            <summary>
            An RLE format for bitmaps with 4 bpp. The compression format is a 2-byte format consisting of a count byte followed by two word-length color indexes. For more information, see Bitmap Compression.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.BiCompression.BI_BITFIELDS">
            <summary>
            Specifies that the bitmap is not compressed and that the color table consists of three DWORD color masks that specify the red, green, and blue components, respectively, of each pixel. This is valid when used with 16- and 32-bpp bitmaps. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.BiCompression.BI_JPEG">
            <summary>
            Windows 98/Me, Windows 2000/XP: Indicates that the image is a JPEG image. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.BiCompression.BI_PNG">
            <summary>
            Windows 98/Me, Windows 2000/XP: Indicates that the image is a PNG image. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.CreationDisposition.New">
            <summary>
            Creates a new file. The function fails if a specified file exists.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.CreationDisposition.CreateAlways">
            <summary>
            Creates a new file, always.
            If a file exists, the function overwrites the file, clears the existing attributes, combines the specified file attributes,
            and flags with FILE_ATTRIBUTE_ARCHIVE, but does not set the security descriptor that the SECURITY_ATTRIBUTES structure specifies.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.CreationDisposition.OpenExisting">
            <summary>
            Opens a file. The function fails if the file does not exist.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.CreationDisposition.OpenAlways">
            <summary>
            Opens a file, always.
            If a file does not exist, the function creates a file as if dwCreationDisposition is CREATE_NEW.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.CreationDisposition.TruncateExisting">
            <summary>
            Opens a file and truncates it so that its size is 0 (zero) bytes. The function fails if the file does not exist.
            The calling process must open the file with the GENERIC_WRITE access right.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.FileShareFlags.Read">
            <summary>
            Enables subsequent open operations on an object to request read access.
            Otherwise, other processes cannot open the object if they request read access.
            If this flag is not specified, but the object has been opened for read access, the function fails.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.FileShareFlags.Write">
            <summary>
            Enables subsequent open operations on an object to request write access.
            Otherwise, other processes cannot open the object if they request write access.
            If this flag is not specified, but the object has been opened for write access, the function fails.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.FileShareFlags.Delete">
            <summary>
            Enables subsequent open operations on an object to request delete access.
            Otherwise, other processes cannot open the object if they request delete access.
            If this flag is not specified, but the object has been opened for delete access, the function fails.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Declarations.Constants.HookCode">
            <summary>
            Hook codes for callback functions of <see cref="M:JetBrains.Interop.WinApi.User32Dll.SetWindowsHookExW(System.Int32,JetBrains.Interop.WinApi.Functions.HOOKPROC,System.Void*,System.UInt32)"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.HookCode.HC_ACTION">
            <summary>
            Mouse hook: The wParam and lParam parameters contain information about a mouse message.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.HookCode.HC_NOREMOVE">
            <summary>
            Mouse hook: The wParam and lParam parameters contain information about a mouse message, and the mouse message has not been removed from the message queue. (An application called the PeekMessage function, specifying the PM_NOREMOVE flag.)
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Declarations.Constants.MemoryAllocationTypes">
            <summary>
            The type of memory allocation. This parameter must contain one of the following values.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.MemoryAllocationTypes.MEM_COMMIT">
            <summary>
            Allocates physical storage in memory or in the paging file on disk for the specified reserved memory pages. The function initializes the memory to zero.
            To reserve and commit pages in one step, call VirtualAlloc with MEM_COMMIT | MEM_RESERVE.
            The function fails if you attempt to commit a page that has not been reserved. The resulting error code is ERROR_INVALID_ADDRESS.
            An attempt to commit a page that is already committed does not cause the function to fail. This means that you can commit pages without first determining the current commitment state of each page.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.MemoryAllocationTypes.MEM_RESERVE">
            <summary>
            Reserves a range of the process's virtual address space without allocating any actual physical storage in memory or in the paging file on disk.
            You can commit reserved pages in subsequent calls to the VirtualAlloc function. To reserve and commit pages in one step, call VirtualAlloc with MEM_COMMIT | MEM_RESERVE.
            Other memory allocation functions, such as malloc and LocalAlloc, cannot use a reserved range of memory until it is released.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.MemoryAllocationTypes.MEM_RESET">
            <summary>
            Indicates that data in the memory range specified by lpAddress and dwSize is no longer of interest. The pages should not be read from or written to the paging file. However, the memory block will be used again later, so it should not be decommitted. This value cannot be used with any other value.
            Using this value does not guarantee that the range operated on with MEM_RESET will contain zeroes. If you want the range to contain zeroes, decommit the memory and then recommit it.
            When you specify MEM_RESET, the VirtualAlloc function ignores the value of flProtect. However, you must still set flProtect to a valid protection value, such as PAGE_NOACCESS.
            VirtualAlloc returns an error if you use MEM_RESET and the range of memory is mapped to a file. A shared view is only acceptable if it is mapped to a paging file.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.MemoryAllocationTypes.MEM_FREE">
            <summary>
            Indicates free pages not accessible to the calling process and available to be allocated. For free pages, the information in the AllocationBase, AllocationProtect, Protect, and Type members is undefined.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.MemoryAllocationTypes.MEM_LARGE_PAGES">
            <summary>
            Allocates memory using large page support.
            The size and alignment must be a multiple of the large-page minimum. To obtain this value, use the GetLargePageMinimum function.
            Windows XP/2000:   This flag is not supported.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.MemoryAllocationTypes.MEM_PHYSICAL">
            <summary>
            Reserves an address range that can be used to map Address Windowing Extensions (AWE) pages. 
            This value must be used with MEM_RESERVE and no other values.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.MemoryAllocationTypes.MEM_TOP_DOWN">
            <summary>
            Allocates memory at the highest possible address.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.MemoryAllocationTypes.MEM_WRITE_WATCH">
            <summary>
            Causes the system to track pages that are written to in the allocated region. If you specify this value, you must also specify MEM_RESERVE.
            To retrieve the addresses of the pages that have been written to since the region was allocated or the write-tracking state was reset, call the GetWriteWatch function. To reset the write-tracking state, call GetWriteWatch or ResetWriteWatch. The write-tracking feature remains enabled for the memory region until the region is freed.
            Windows 2000:   This flag is not supported.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Declarations.Constants.MemoryPageTypes">
            <summary>
            The type of pages in the region. The following types are defined. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.MemoryPageTypes.MEM_IMAGE">
            <summary>
            Indicates that the memory pages within the region are mapped into the view of an image section.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.MemoryPageTypes.MEM_MAPPED">
            <summary>
            Indicates that the memory pages within the region are mapped into the view of a section.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.MemoryPageTypes.MEM_PRIVATE">
            <summary>
            Indicates that the memory pages within the region are private (that is, not shared by other processes).
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Declarations.Constants.MemoryProtectionConstants">
            <summary>
            The following are the memory-protection options; you must specify one of the following values when allocating or protecting a page in memory. Protection attributes cannot be assigned to a portion of a page; they can only be assigned to a whole page.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.MemoryProtectionConstants.PAGE_EXECUTE">
            <summary>
            Enables execute access to the committed region of pages. An attempt to read from or write to the committed region results in an access violation. 
            This flag is not supported by the CreateFileMapping function.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.MemoryProtectionConstants.PAGE_EXECUTE_READ">
            <summary>
            Enables execute or read-only access to the committed region of pages. An attempt to write to the committed region results in an access violation. 
            Windows Server 2003 and Windows XP/2000:  This attribute is not supported by the CreateFileMapping function until Windows XP with SP2 and Windows Server 2003 with SP1.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.MemoryProtectionConstants.PAGE_EXECUTE_READWRITE">
            <summary>
            Enables execute, read-only, or read/write access to the committed region of pages. 
            Windows Server 2003 and Windows XP/2000:  This attribute is not supported by the CreateFileMapping function until Windows XP with SP2 and Windows Server 2003 with SP1.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.MemoryProtectionConstants.PAGE_EXECUTE_WRITECOPY">
            <summary>
            Enables execute, read-only, or copy-on-write access to a mapped view of a file mapping object. An attempt to write to a committed copy-on-write page results in a private copy of the page being made for the process. The private page is marked as PAGE_EXECUTE_READWRITE, and the change is written to the new page. 
            This flag is not supported by the VirtualAlloc or VirtualAllocEx functions. 
            Windows Vista, Windows Server 2003, and Windows XP/2000:  This attribute is not supported by the CreateFileMapping function until Windows Vista with SP1 and Windows Server 2008.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.MemoryProtectionConstants.PAGE_NOACCESS">
            <summary>
            Disables all access to the committed region of pages. An attempt to read from, write to, or execute the committed region results in an access violation. 
            This flag is not supported by the CreateFileMapping function.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.MemoryProtectionConstants.PAGE_READONLY">
            <summary>
            Enables read-only access to the committed region of pages. An attempt to write to the committed region results in an access violation. If Data Execution Prevention is enabled, an attempt to execute code in the committed region results in an access violation.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.MemoryProtectionConstants.PAGE_READWRITE">
            <summary>
            Enables read-only or read/write access to the committed region of pages. If Data Execution Prevention is enabled, attempting to execute code in the committed region results in an access violation.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.MemoryProtectionConstants.PAGE_WRITECOPY">
            <summary>
            Enables read-only or copy-on-write access to a mapped view of a file mapping object. An attempt to write to a committed copy-on-write page results in a private copy of the page being made for the process. The private page is marked as PAGE_READWRITE, and the change is written to the new page. If Data Execution Prevention is enabled, attempting to execute code in the committed region results in an access violation.
            This flag is not supported by the VirtualAlloc or VirtualAllocEx functions.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.MemoryProtectionConstants.PAGE_GUARD">
            <summary>
            Pages in the region become guard pages. Any attempt to access a guard page causes the system to raise a STATUS_GUARD_PAGE_VIOLATION exception and turn off the guard page status. Guard pages thus act as a one-time access alarm. For more information, see Creating Guard Pages. 
            When an access attempt leads the system to turn off guard page status, the underlying page protection takes over.
            If a guard page exception occurs during a system service, the service typically returns a failure status indicator.
            This value cannot be used with PAGE_NOACCESS.
            This flag is not supported by the CreateFileMapping function.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.MemoryProtectionConstants.PAGE_NOCACHE">
            <summary>
            Sets all pages to be non-cachable. Applications should not use this attribute except when explicitly required for a device. Using the interlocked functions with memory that is mapped with SEC_NOCACHE can result in an EXCEPTION_ILLEGAL_INSTRUCTION exception.
            The PAGE_NOCACHE flag cannot be used with the PAGE_GUARD, PAGE_NOACCESS, or PAGE_WRITECOMBINE flags.
            The PAGE_NOCACHE flag can be used only when allocating private memory with the VirtualAlloc, VirtualAllocEx, or VirtualAllocExNuma functions. To enable non-cached memory access for shared memory, specify the SEC_NOCACHE flag when calling the CreateFileMapping function.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.MemoryProtectionConstants.PAGE_WRITECOMBINE">
            <summary>
            Sets all pages to be write-combined. 
            Applications should not use this attribute except when explicitly required for a device. Using the interlocked functions with memory that is mapped as write-combined can result in an EXCEPTION_ILLEGAL_INSTRUCTION exception.
            The PAGE_WRITECOMBINE flag cannot be specified with the PAGE_NOACCESS, PAGE_GUARD, and PAGE_NOCACHE flags. 
            The PAGE_WRITECOMBINE flag can be used only when allocating private memory with the VirtualAlloc, VirtualAllocEx, or VirtualAllocExNuma functions. To enable write-combined memory access for shared memory, specify the SEC_WRITECOMBINE flag when calling the CreateFileMapping function.
            Windows Server 2003 and Windows XP/2000:  This flag is not supported until Windows Server 2003 with SP1.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Declarations.Constants.PropSheetPageProcMsg">
            <summary>
            <see cref="T:JetBrains.Interop.WinApi.Functions.LPFNPSPCALLBACK"/> <c>msg</c> parameter.
            Action flag. This parameter can be one of the following values.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.PropSheetPageProcMsg.PSPCB_ADDREF">
            <summary>
            Version 5.80 or later. A page is being created. The return value is not used.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.PropSheetPageProcMsg.PSPCB_CREATE">
            <summary>
            A dialog box for a page is being created. Return nonzero to allow it to be created, or zero to prevent it.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.PropSheetPageProcMsg.PSPCB_RELEASE">
            <summary>
            A page is being destroyed. The return value is ignored.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Declarations.Constants.SHGetFileInfoFlags">
            <summary>
            Flags for the <see cref="M:JetBrains.Interop.WinApi.Shell32Dll.SHGetFileInfoW(System.String,System.UInt32,JetBrains.Interop.WinApi.SHFILEINFO*,System.UInt32,System.UInt32)"/> function.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.SHGetFileInfoFlags.SHGFI_ADDOVERLAYS">
            <summary>Version 5.0. Apply the appropriate overlays to the file's icon. The SHGFI_ICON flag must also be set.</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.SHGetFileInfoFlags.SHGFI_ATTR_SPECIFIED">
            <summary>Modify SHGFI_ATTRIBUTES to indicate that the dwAttributes member of the SHFILEINFO structure at psfi contains the specific attributes that are desired. These attributes are passed to IShellFolder::GetAttributesOf. If this flag is not specified, 0xFFFFFFFF is passed to IShellFolder::GetAttributesOf, requesting all attributes. This flag cannot be specified with the SHGFI_ICON flag.</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.SHGetFileInfoFlags.SHGFI_ATTRIBUTES">
            <summary>Retrieve the item attributes. The attributes are copied to the dwAttributes member of the structure specified in the psfi parameter. These are the same attributes that are obtained from IShellFolder::GetAttributesOf.</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.SHGetFileInfoFlags.SHGFI_DISPLAYNAME">
            <summary>Retrieve the display name for the file. The name is copied to the szDisplayName member of the structure specified in psfi. The returned display name uses the long file name, if there is one, rather than the 8.3 form of the file name.</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.SHGetFileInfoFlags.SHGFI_EXETYPE">
            <summary>Retrieve the type of the executable file if pszPath identifies an executable file. The information is packed into the return value. This flag cannot be specified with any other flags.</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.SHGetFileInfoFlags.SHGFI_ICON">
            <summary>Retrieve the handle to the icon that represents the file and the index of the icon within the system image list. The handle is copied to the hIcon member of the structure specified by psfi, and the index is copied to the iIcon member.</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.SHGetFileInfoFlags.SHGFI_ICONLOCATION">
            <summary>Retrieve the name of the file that contains the icon representing the file specified by pszPath, as returned by the IExtractIcon::GetIconLocation method of the file's icon handler. Also retrieve the icon index within that file. The name of the file containing the icon is copied to the szDisplayName member of the structure specified by psfi. The icon's index is copied to that structure's iIcon member.</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.SHGetFileInfoFlags.SHGFI_LARGEICON">
            <summary>Modify SHGFI_ICON, causing the function to retrieve the file's large icon. The SHGFI_ICON flag must also be set.</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.SHGetFileInfoFlags.SHGFI_LINKOVERLAY">
            <summary>Modify SHGFI_ICON, causing the function to add the link overlay to the file's icon. The SHGFI_ICON flag must also be set.</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.SHGetFileInfoFlags.SHGFI_OPENICON">
            <summary>Modify SHGFI_ICON, causing the function to retrieve the file's open icon. Also used to modify SHGFI_SYSICONINDEX, causing the function to return the handle to the system image list that contains the file's small open icon. A container object displays an open icon to indicate that the container is open. The SHGFI_ICON and/or SHGFI_SYSICONINDEX flag must also be set.</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.SHGetFileInfoFlags.SHGFI_OVERLAYINDEX">
            <summary>Version 5.0. Return the index of the overlay icon. The value of the overlay index is returned in the upper eight bits of the iIcon member of the structure specified by psfi. This flag requires that the SHGFI_ICON be set as well.</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.SHGetFileInfoFlags.SHGFI_PIDL">
            <summary>Indicate that pszPath is the address of an ITEMIDLIST structure rather than a path name.</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.SHGetFileInfoFlags.SHGFI_SELECTED">
            <summary>Modify SHGFI_ICON, causing the function to blend the file's icon with the system highlight color. The SHGFI_ICON flag must also be set.</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.SHGetFileInfoFlags.SHGFI_SHELLICONSIZE">
            <summary>Modify SHGFI_ICON, causing the function to retrieve a Shell-sized icon. If this flag is not specified the function sizes the icon according to the system metric values. The SHGFI_ICON flag must also be set.</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.SHGetFileInfoFlags.SHGFI_SMALLICON">
            <summary>Modify SHGFI_ICON, causing the function to retrieve the file's small icon. Also used to modify SHGFI_SYSICONINDEX, causing the function to return the handle to the system image list that contains small icon images. The SHGFI_ICON and/or SHGFI_SYSICONINDEX flag must also be set.</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.SHGetFileInfoFlags.SHGFI_SYSICONINDEX">
            <summary>Retrieve the index of a system image list icon. If successful, the index is copied to the iIcon member of psfi. The return value is a handle to the system image list. Only those images whose indices are successfully copied to iIcon are valid. Attempting to access other images in the system image list will result in undefined behavior.</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.SHGetFileInfoFlags.SHGFI_TYPENAME">
            <summary>Retrieve the string that describes the file's type. The string is copied to the szTypeName member of the structure specified in psfi.</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.SHGetFileInfoFlags.SHGFI_USEFILEATTRIBUTES">
            <summary>Indicates that the function should not attempt to access the file specified by pszPath. Rather, it should act as if the file specified by pszPath exists with the file attributes passed in dwFileAttributes. This flag cannot be combined with the SHGFI_ATTRIBUTES, SHGFI_EXETYPE, or SHGFI_PIDL flags.</summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Declarations.Constants.UxThemeClasses">
            <summary>
            Classes for <see cref="T:JetBrains.Interop.WinApi.UxThemeDll"/> functions like <see cref="M:JetBrains.Interop.WinApi.UxThemeDll.OpenThemeData(System.Void*,System.String)"/>.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Declarations.Constants.UxThemeParts">
            <summary>
            Parts for <see cref="T:JetBrains.Interop.WinApi.UxThemeDll"/> functions like <see cref="M:JetBrains.Interop.WinApi.UxThemeDll.DrawThemeBackground(System.Void*,System.Void*,System.Int32,System.Int32,JetBrains.Interop.WinApi.RECT*,JetBrains.Interop.WinApi.RECT*)"/>.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Functions.LPFNPSPCALLBACK">
            <summary>
            Function type for the <see cref="F:JetBrains.Interop.WinApi.Declarations.Structures.PROPSHEETPAGE.pfnCallback"/> field.
            </summary>
            <param name="hwnd"></param>
            <param name="nMsg">See <see cref="T:JetBrains.Interop.WinApi.Declarations.Constants.PropSheetPageProcMsg"/> members for values.</param>
            <param name="ppsp"></param>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Interop.WinApi.IpHlpApiDll">
            <summary>
            User32.dll functions.
            Must be 64bit-safe.
            </summary>
            <remarks>
            IMPORTANT! Rules for authoring the class (v1.1):
            (1) All the function declarations MUST be 64-bit aware.
            (2) When copypasting from older declarations, you MUST check against the MSDN help or header declaration, 
               and you MUST ensure that each parameter has a proper size.
            (3) Call the Wide version of the functions (UCS-2-LE) unless there's a strong reason for calling the ANSI version 
               (such a reason MUST be indicated in XmlDoc). <c>CharSet = CharSet.Unicode</c>.
            (4) ExactSpelling MUST be TRUE. Add the "…W" suffix wherever needed.
            (5) SetLastError SHOULD be considered individually for each function. Setting it to <c>True</c> allows to report the errors,
               but slows down the execution of critical members.
            (6) These properties MUST be explicitly set on DllImport attributes of EACH import: 
               CharSet, PreserveSig, SetLastError, ExactSpelling.
            (7) CLR names MUST be used for types instead of C# ones, eg "Int32" not "int" and "Int64" not "long".
               This greately improves the understanding of the parameter sizes.
            (8) Sign of the types MUST be favored, eg "DWORD" is "UInt32" not "Int32".
            (9) Unsafe pointer types should be used for explicit and implicit pointers rather than IntPtr. 
               This way we outline the unsafety of the native calls, and also make it more clear for the 64bit transition.
               Eg "HANDLE" is "void*". If the rule forces you to mark some assembly as unsafe, it's an indication a managed utility
               incapsulating the call and the handle should be provided in one of the already-unsafe assemblies.
            (A) Same rules must apply to members of the structures.
            (B) All of the structures MUST have the [StructLayout(LayoutKind.Sequential)], [NoReorder] attributes, as appropriate.
            </remarks>
        </member>
        <member name="T:JetBrains.Interop.WinApi.ShlwapiDll">
            <summary>
            Shlwapi.dll functions.
            Must be 64bit-safe.
            </summary>
            <remarks>
            IMPORTANT! Rules for authoring the class (v1.1):
            (1) All the function declarations MUST be 64-bit aware.
            (2) When copypasting from older declarations, you MUST check against the MSDN help or header declaration,
               and you MUST ensure that each parameter has a proper size.
            (3) Call the Wide version of the functions (UCS-2-LE) unless there's a strong reason for calling the ANSI version
               (such a reason MUST be indicated in XmlDoc). <c>CharSet = CharSet.Unicode</c>.
            (4) ExactSpelling MUST be TRUE. Add the "…W" suffix wherever needed.
            (5) SetLastError SHOULD be considered individually for each function. Setting it to <c>True</c> allows to report the errors,
               but slows down the execution of critical members.
            (6) These properties MUST be explicitly set on DllImport attributes of EACH import:
               CharSet, PreserveSig, SetLastError, ExactSpelling.
            (7) CLR names MUST be used for types instead of C# ones, eg "Int32" not "int" and "Int64" not "long".
               This greately improves the understanding of the parameter sizes.
            (8) Sign of the types MUST be favored, eg "DWORD" is "UInt32" not "Int32".
            (9) Unsafe pointer types should be used for explicit and implicit pointers rather than IntPtr.
               This way we outline the unsafety of the native calls, and also make it more clear for the 64bit transition.
               Eg "HANDLE" is "void*". If the rule forces you to mark some assembly as unsafe, it's an indication a managed utility
               incapsulating the call and the handle should be provided in one of the already-unsafe assemblies.
            (A) Same rules must apply to members of the structures.
            (B) All of the structures MUST have the [StructLayout(LayoutKind.Sequential)], [NoReorder] attributes, as appropriate.
            </remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.ShlwapiDll.StrFormatByteSize64A(System.Int64,System.Byte*,System.UInt32)">
            <summary>
            Converts a numeric value into a string that represents the number expressed as a size value in bytes, kilobytes, megabytes, or gigabytes, depending on the size.
            </summary>
            <param name="qdw">Numeric value to be converted.</param>
            <param name="pszBuf">Pointer to a buffer to hold the converted number. Note: this function is bound to call the ANSI version.</param>
            <param name="cchBuf">Size of the buffer, in characters. Note: in our case, in bytes.</param>
            <returns>Returns the address of the converted string, or <see cref="F:System.IntPtr.Zero"/> if the conversion fails.</returns>
            <remarks>
            The following table illustrates how this function converts a numeric value into a text string.
            Numeric value -&gt; Text string
            532 532 -&gt; bytes
            1340 -&gt; 1.30KB
            23506 -&gt; 22.9KB
            2400016 -&gt; 2.29MB
            2400000000 -&gt; 2.23GB
            </remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.ShlwapiDll.Helpers.StrFormatByteSize(System.Int64)">
            <summary>
            Converts a numeric value into a string that represents the number expressed as a size value in bytes, kilobytes, megabytes, or gigabytes, depending on the size.
            </summary>
            <param name="nSize">Numeric value to be converted.</param>
            <returns>Returns the size string.</returns>
            <remarks>
            The following table illustrates how this function converts a numeric value into a text string.
            Numeric value -> Text string
            532 532 -> bytes
            1340 -> 1.30KB
            23506 -> 22.9KB
            2400016 -> 2.29MB
            2400000000 -> 2.23GB
            </remarks>
        </member>
        <member name="T:JetBrains.Interop.WinApi.NtDllDll">
            <summary>
            NtDll.dll functions.
            Must be 64bit-safe.
            </summary>
            <remarks>
            IMPORTANT! Rules for authoring the class (v1.1):
            (1) All the function declarations MUST be 64-bit aware.
            (2) When copypasting from older declarations, you MUST check against the MSDN help or header declaration, 
               and you MUST ensure that each parameter has a proper size.
            (3) Call the Wide version of the functions (UCS-2-LE) unless there's a strong reason for calling the ANSI version 
               (such a reason MUST be indicated in XmlDoc). <c>CharSet = CharSet.Unicode</c>.
            (4) ExactSpelling MUST be TRUE. Add the "…W" suffix wherever needed.
            (5) SetLastError SHOULD be considered individually for each function. Setting it to <c>True</c> allows to report the errors,
               but slows down the execution of critical members.
            (6) These properties MUST be explicitly set on DllImport attributes of EACH import: 
               CharSet, PreserveSig, SetLastError, ExactSpelling.
            (7) CLR names MUST be used for types instead of C# ones, eg "Int32" not "int" and "Int64" not "long".
               This greately improves the understanding of the parameter sizes.
            (8) Sign of the types MUST be favored, eg "DWORD" is "UInt32" not "Int32".
            (9) Unsafe pointer types should be used for explicit and implicit pointers rather than IntPtr. 
               This way we outline the unsafety of the native calls, and also make it more clear for the 64bit transition.
               Eg "HANDLE" is "void*". If the rule forces you to mark some assembly as unsafe, it's an indication a managed utility
               incapsulating the call and the handle should be provided in one of the already-unsafe assemblies.
            (A) Same rules must apply to members of the structures.
            (B) All of the structures MUST have the [StructLayout(LayoutKind.Sequential)], [NoReorder] attributes, as appropriate.
            </remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.NtDllDll.NtOpenSection(System.Void**,System.UInt32,System.Void*)">
            <summary>
            The NtOpenSection routine opens a handle for an existing section object.
            </summary>
            <param name="sectionHandle">Pointer to a HANDLE variable that receives a handle to the section object.</param>
            <param name="desiredAccess">Specifies an ACCESS_MASK value that determines the requested access to the object.</param>
            <param name="pObjectAttributes">Pointer to an OBJECT_ATTRIBUTES structure that specifies the object name and other attributes. Use InitializeObjectAttributes to initialize this structure.</param>
            <returns>Returns STATUS_SUCCESS on success, or the appropriate error code on failure.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.NtDllDll.NtClose(System.Void*)">
            <summary>
            The NtClose routine closes an object handle.
            </summary>
            <param name="handle">Handle to an object of any type.</param>
            <returns>Returns STATUS_SUCCESS on success, or the appropriate NTSTATUS error code on failure. </returns>
        </member>
        <member name="T:JetBrains.Interop.WinApi.SHFILEINFO">
            <summary>
            Contains information about a file object.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.SHFILEINFO.hIcon">
            <summary>
            A handle to the icon that represents the file. You are responsible for destroying this handle with DestroyIcon when you no longer need it.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.SHFILEINFO.iIcon">
            <summary>
            The index of the icon image within the system image list.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.SHFILEINFO.dwAttributes">
            <summary>
            An array of values that indicates the attributes of the file object. For information about these values, see the IShellFolder::GetAttributesOf method.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.SHFILEINFO.szDisplayName">
            <summary>
            A string that contains the name of the file as it appears in the Windows Shell, or the path and file name of the file that contains the icon representing the file.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.SHFILEINFO.szTypeName">
            <summary>
            A string that describes the type of file.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.PsApiDll">
            <summary>
            Kernel32.dll functions.
            Must be 64bit-safe.
            </summary>
            <remarks>
            IMPORTANT! Rules for authoring the class (v1.1):
            (1) All the function declarations MUST be 64-bit aware.
            (2) When copypasting from older declarations, you MUST check against the MSDN help or header declaration, 
               and you MUST ensure that each parameter has a proper size.
            (3) Call the Wide version of the functions (UCS-2-LE) unless there's a strong reason for calling the ANSI version 
               (such a reason MUST be indicated in XmlDoc). <c>CharSet = CharSet.Unicode</c>.
            (4) ExactSpelling MUST be TRUE. Add the "…W" suffix wherever needed.
            (5) SetLastError SHOULD be considered individually for each function. Setting it to <c>True</c> allows to report the errors,
               but slows down the execution of critical members.
            (6) These properties MUST be explicitly set on DllImport attributes of EACH import: 
               CharSet, PreserveSig, SetLastError, ExactSpelling.
            (7) CLR names MUST be used for types instead of C# ones, eg "Int32" not "int" and "Int64" not "long".
               This greately improves the understanding of the parameter sizes.
            (8) Sign of the types MUST be favored, eg "DWORD" is "UInt32" not "Int32".
            (9) Unsafe pointer types should be used for explicit and implicit pointers rather than IntPtr. 
               This way we outline the unsafety of the native calls, and also make it more clear for the 64bit transition.
               Eg "HANDLE" is "void*". If the rule forces you to mark some assembly as unsafe, it's an indication a managed utility
               incapsulating the call and the handle should be provided in one of the already-unsafe assemblies.
            (A) Same rules must apply to members of the structures.
            (B) All of the structures MUST have the [StructLayout(LayoutKind.Sequential)], [NoReorder] attributes, as appropriate.
            </remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.PsApiDll.EnumProcessModules(System.Void*,System.Void**,System.UInt32,System.UInt32*)">
            <summary>
            Retrieves a handle for each module in the specified process.
            To control whether a 64-bit application enumerates 32-bit modules, 64-bit modules, or both types of modules, use the EnumProcessModulesEx function.
            </summary>
            <param name="hProcess">A handle to the process.</param>
            <param name="lphModule">An array that receives the list of module handles.</param>
            <param name="cb">The size of the lphModule array, in bytes.</param>
            <param name="lpcbNeeded">The number of bytes required to store all module handles in the lphModule array.</param>
            <returns>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call GetLastError.</returns>
            <remarks>
            […]
            It is a good idea to specify a large array of HMODULE values, because it is hard to predict how many modules there will be in the process at the time you call EnumProcessModules. To determine if the lphModule array is too small to hold all module handles for the process, compare the value returned in lpcbNeeded with the value specified in cb. If lpcbNeeded is greater than cb, increase the size of the array and call EnumProcessModules again.
            To determine how many modules were enumerated by the call to EnumProcessModules, divide the resulting value in the lpcbNeeded parameter by sizeof(HMODULE).
            […]
            </remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.PsApiDll.GetModuleFileNameExW(System.Void*,System.Void*,System.Text.StringBuilder,System.UInt32)">
            <summary>
            Retrieves the fully qualified path for the file containing the specified module.
            </summary>
            <param name="hProcess">A handle to the process that contains the module. The handle must have the PROCESS_QUERY_INFORMATION and PROCESS_VM_READ access rights. </param>
            <param name="hModule">A handle to the module. If this parameter is NULL, GetModuleFileNameEx returns the path of the executable file of the process specified in hProcess.</param>
            <param name="lpFilename">A pointer to a buffer that receives the fully qualified path to the module. If the size of the file name is larger than the value of the nSize parameter, the function succeeds but the file name is truncated and null-terminated.</param>
            <param name="size">The size of the lpFilename buffer, in characters.</param>
            <returns>If the function succeeds, the return value specifies the length of the string copied to the buffer. If the function fails, the return value is zero. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.PsApiDll.GetProcessImageFileNameW(System.Void*,System.Text.StringBuilder,System.UInt32)">
            <summary>
            Retrieves the name of the executable file for the specified process.
            </summary>
            <param name="hProcess">A handle to the process. The handle must have the PROCESS_QUERY_INFORMATION or PROCESS_QUERY_LIMITED_INFORMATION access right.</param>
            <param name="lpFilename">A pointer to a buffer that receives the full path to the executable file.</param>
            <param name="size">The size of the lpImageFileName buffer, in characters.</param>
            <returns>If the function succeeds, the return value specifies the length of the string copied to the buffer. If the function fails, the return value is zero. </returns>
            <remarks>The GetProcessImageFileName function returns the path in device form, rather than drive letters. For example, the file name "C:\Windows\System32\Ctype.nls" would look as follows in device form: "\Device\Harddisk0\Partition1\Windows\System32\Ctype.nls".</remarks>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Declarations.Structures.BITMAPINFOHEADER">
            <summary>
            The BITMAPINFOHEADER structure contains information about the dimensions and color format of a DIB. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.BITMAPINFOHEADER.biSize">
            <summary>
            Specifies the number of bytes required by the structure. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.BITMAPINFOHEADER.biWidth">
            <summary>
            Specifies the width of the bitmap, in pixels. 
            Windows 98/Me, Windows 2000/XP: If biCompression is BI_JPEG or BI_PNG, the biWidth member specifies the width of the decompressed JPEG or PNG image file, respectively.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.BITMAPINFOHEADER.biHeight">
            <summary>
            Specifies the height of the bitmap, in pixels. If biHeight is positive, the bitmap is a bottom-up DIB and its origin is the lower-left corner. If biHeight is negative, the bitmap is a top-down DIB and its origin is the upper-left corner. 
            If biHeight is negative, indicating a top-down DIB, biCompression must be either BI_RGB or BI_BITFIELDS. Top-down DIBs cannot be compressed. 
            Windows 98/Me, Windows 2000/XP: If biCompression is BI_JPEG or BI_PNG, the biHeight member specifies the height of the decompressed JPEG or PNG image file, respectively. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.BITMAPINFOHEADER.biPlanes">
            <summary>
            Specifies the number of planes for the target device. This value must be set to 1. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.BITMAPINFOHEADER.biBitCount">
            <summary>
            Specifies the number of bits-per-pixel. The biBitCount member of the BITMAPINFOHEADER structure determines the number of bits that define each pixel and the maximum number of colors in the bitmap. This member must be one of the following values. 
            Value Meaning 
            0 Windows 98/Me, Windows 2000/XP: The number of bits-per-pixel is specified or is implied by the JPEG or PNG format.  
            1 The bitmap is monochrome, and the bmiColors member of BITMAPINFO contains two entries. Each bit in the bitmap array represents a pixel. If the bit is clear, the pixel is displayed with the color of the first entry in the bmiColors table; if the bit is set, the pixel has the color of the second entry in the table. 
            4 The bitmap has a maximum of 16 colors, and the bmiColors member of BITMAPINFO contains up to 16 entries. Each pixel in the bitmap is represented by a 4-bit index into the color table. For example, if the first byte in the bitmap is 0x1F, the byte represents two pixels. The first pixel contains the color in the second table entry, and the second pixel contains the color in the sixteenth table entry. 
            8 The bitmap has a maximum of 256 colors, and the bmiColors member of BITMAPINFO contains up to 256 entries. In this case, each byte in the array represents a single pixel. 
            16 The bitmap has a maximum of 2^16 colors. If the biCompression member of the BITMAPINFOHEADER is BI_RGB, the bmiColors member of BITMAPINFO is NULL. Each WORD in the bitmap array represents a single pixel. The relative intensities of red, green, and blue are represented with five bits for each color component. The value for blue is in the least significant five bits, followed by five bits each for green and red. The most significant bit is not used. The bmiColors color table is used for optimizing colors used on palette-based devices, and must contain the number of entries specified by the biClrUsed member of the BITMAPINFOHEADER. 
            If the biCompression member of the BITMAPINFOHEADER is BI_BITFIELDS, the bmiColors member contains three DWORD color masks that specify the red, green, and blue components, respectively, of each pixel. Each WORD in the bitmap array represents a single pixel.
            Windows NT/Windows 2000/XP: When the biCompression member is BI_BITFIELDS, bits set in each DWORD mask must be contiguous and should not overlap the bits of another mask. All the bits in the pixel do not have to be used. 
            Windows 95/98/Me: When the biCompression member is BI_BITFIELDS, the system supports only the following 16bpp color masks: A 5-5-5 16-bit image, where the blue mask is 0x001F, the green mask is 0x03E0, and the red mask is 0x7C00; and a 5-6-5 16-bit image, where the blue mask is 0x001F, the green mask is 0x07E0, and the red mask is 0xF800.
            24 The bitmap has a maximum of 2^24 colors, and the bmiColors member of BITMAPINFO is NULL. Each 3-byte triplet in the bitmap array represents the relative intensities of blue, green, and red, respectively, for a pixel. The bmiColors color table is used for optimizing colors used on palette-based devices, and must contain the number of entries specified by the biClrUsed member of the BITMAPINFOHEADER.  
            32 The bitmap has a maximum of 2^32 colors. If the biCompression member of the BITMAPINFOHEADER is BI_RGB, the bmiColors member of BITMAPINFO is NULL. Each DWORD in the bitmap array represents the relative intensities of blue, green, and red, respectively, for a pixel. The high byte in each DWORD is not used. The bmiColors color table is used for optimizing colors used on palette-based devices, and must contain the number of entries specified by the biClrUsed member of the BITMAPINFOHEADER. 
            If the biCompression member of the BITMAPINFOHEADER is BI_BITFIELDS, the bmiColors member contains three DWORD color masks that specify the red, green, and blue components, respectively, of each pixel. Each DWORD in the bitmap array represents a single pixel.
            Windows NT/ 2000: When the biCompression member is BI_BITFIELDS, bits set in each DWORD mask must be contiguous and should not overlap the bits of another mask. All the bits in the pixel do not need to be used.
            Windows 95/98/Me: When the biCompression member is BI_BITFIELDS, the system supports only the following 32-bpp color mask: The blue mask is 0x000000FF, the green mask is 0x0000FF00, and the red mask is 0x00FF0000. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.BITMAPINFOHEADER.biCompression">
            <summary>
            Use <see cref="T:JetBrains.Interop.WinApi.Declarations.Constants.BiCompression"/>.
            Specifies the type of compression for a compressed bottom-up bitmap (top-down DIBs cannot be compressed). This member can be one of the following values. 
            Value Description 
            BI_RGB An uncompressed format. 
            BI_RLE8 A run-length encoded (RLE) format for bitmaps with 8 bpp. The compression format is a 2-byte format consisting of a count byte followed by a byte containing a color index. For more information, see Bitmap Compression.  
            BI_RLE4 An RLE format for bitmaps with 4 bpp. The compression format is a 2-byte format consisting of a count byte followed by two word-length color indexes. For more information, see Bitmap Compression. 
            BI_BITFIELDS Specifies that the bitmap is not compressed and that the color table consists of three DWORD color masks that specify the red, green, and blue components, respectively, of each pixel. This is valid when used with 16- and 32-bpp bitmaps. 
            BI_JPEG Windows 98/Me, Windows 2000/XP: Indicates that the image is a JPEG image. 
            BI_PNG Windows 98/Me, Windows 2000/XP: Indicates that the image is a PNG image. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.BITMAPINFOHEADER.biSizeImage">
            <summary>
            Specifies the size, in bytes, of the image. This may be set to zero for BI_RGB bitmaps. 
            Windows 98/Me, Windows 2000/XP: If biCompression is BI_JPEG or BI_PNG, biSizeImage indicates the size of the JPEG or PNG image buffer, respectively. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.BITMAPINFOHEADER.biXPelsPerMeter">
            <summary>
            Specifies the horizontal resolution, in pixels-per-meter, of the target device for the bitmap. An application can use this value to select a bitmap from a resource group that best matches the characteristics of the current device. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.BITMAPINFOHEADER.biYPelsPerMeter">
            <summary>
            Specifies the vertical resolution, in pixels-per-meter, of the target device for the bitmap. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.BITMAPINFOHEADER.biClrUsed">
            <summary>
            Specifies the number of color indexes in the color table that are actually used by the bitmap. If this value is zero, the bitmap uses the maximum number of colors corresponding to the value of the biBitCount member for the compression mode specified by biCompression. 
            If biClrUsed is nonzero and the biBitCount member is less than 16, the biClrUsed member specifies the actual number of colors the graphics engine or device driver accesses. If biBitCount is 16 or greater, the biClrUsed member specifies the size of the color table used to optimize performance of the system color palettes. If biBitCount equals 16 or 32, the optimal color palette starts immediately following the three DWORD masks. 
            When the bitmap array immediately follows the BITMAPINFO structure, it is a packed bitmap. Packed bitmaps are referenced by a single pointer. Packed bitmaps require that the biClrUsed member must be either zero or the actual size of the color table. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.BITMAPINFOHEADER.biClrImportant">
            <summary>
            Specifies the number of color indexes that are required for displaying the bitmap. If this value is zero, all colors are required. 
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Declarations.Structures.BITMAPINFO">
            <summary>
            The BITMAPINFO structure defines the dimensions and color information for a DIB. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.BITMAPINFO.bmiHeader">
            <summary>
            Specifies a <see cref="T:JetBrains.Interop.WinApi.Declarations.Structures.BITMAPINFOHEADER"/> structure that contains information about the dimensions of color format.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.BITMAPINFO.bmiColors">
            <summary>
            <c>Null</c>, unless you're using a palette.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Declarations.Structures.BLENDFUNCTION">
            <summary>
            The BLENDFUNCTION structure controls blending by specifying the blending functions for source and destination bitmaps.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.BLENDFUNCTION.AC_SRC_OVER">
            <summary>
            When the BlendOp parameter is AC_SRC_OVER , the source bitmap is placed over the destination bitmap based on the alpha values of the source pixels. (<see cref="T:JetBrains.Interop.WinApi.Declarations.Structures.BLENDFUNCTION"/>)
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.BLENDFUNCTION.AC_SRC_ALPHA">
            <summary>
            This flag is set when the bitmap has an Alpha channel (that is, per-pixel alpha). Note that the APIs use premultiplied alpha, which means that the red, green and blue channel values in the bitmap must be premultiplied with the alpha channel value. For example, if the alpha channel value is x, the red, green and blue channels must be multiplied by x and divided by 0xff prior to the call.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.BLENDFUNCTION.BlendOp">
            <summary>
            Specifies the source blend operation. Currently, the only source and destination blend operation that has been defined is <see cref="F:JetBrains.Interop.WinApi.Declarations.Structures.BLENDFUNCTION.AC_SRC_OVER"/>. For details, see the following Remarks section.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.BLENDFUNCTION.BlendFlags">
            <summary>
            Must be zero.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.BLENDFUNCTION.SourceConstantAlpha">
            <summary>
            Specifies an alpha transparency value to be used on the entire source bitmap. The SourceConstantAlpha value is combined with any per-pixel alpha values in the source bitmap. If you set SourceConstantAlpha to 0, it is assumed that your image is transparent. Set the SourceConstantAlpha value to 255 (opaque) when you only want to use per-pixel alpha values.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.BLENDFUNCTION.AlphaFormat">
            <summary>
            This member controls the way the source and destination bitmaps are interpreted. AlphaFormat has the following value.
            <see cref="F:JetBrains.Interop.WinApi.Declarations.Structures.BLENDFUNCTION.AC_SRC_ALPHA"/> -&gt; This flag is set when the bitmap has an Alpha channel (that is, per-pixel alpha). Note that the APIs use premultiplied alpha, which means that the red, green and blue channel values in the bitmap must be premultiplied with the alpha channel value. For example, if the alpha channel value is x, the red, green and blue channels must be multiplied by x and divided by 0xff prior to the call.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Declarations.Structures.BLENDFUNCTION.GetPerPixelBlender(System.Byte)">
            <summary>
            Gets such a structure that supports per-pixel blending and applies an additional constant alpha to the whole bitmap (set <c>255</c> for no constant alpha, just per-pixel).
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Declarations.Structures.BLENDFUNCTION.GetPerPixelBlender">
            <summary>
            Gets a per-pixel blender without uniform transparency.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Declarations.Structures.BLENDFUNCTION.GetUniformBlender(System.Byte)">
            <summary>
            Gets such a structure that supports uniform transparency only.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Declarations.Structures.BLENDFUNCTION.GetUniformBlender">
            <summary>
            Gets an opaque blender that ignores per-pixel alpha and has no uniform transparency.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Advapi32Dll">
            <summary>
            User32.dll functions.
            Must be 64bit-safe.
            </summary>
            <remarks>
            IMPORTANT! Rules for authoring the class (v1.1):
            (1) All the function declarations MUST be 64-bit aware.
            (2) When copypasting from older declarations, you MUST check against the MSDN help or header declaration, 
               and you MUST ensure that each parameter has a proper size.
            (3) Call the Wide version of the functions (UCS-2-LE) unless there's a strong reason for calling the ANSI version 
               (such a reason MUST be indicated in XmlDoc). <c>CharSet = CharSet.Unicode</c>.
            (4) ExactSpelling MUST be TRUE. Add the "…W" suffix wherever needed.
            (5) SetLastError SHOULD be considered individually for each function. Setting it to <c>True</c> allows to report the errors,
               but slows down the execution of critical members.
            (6) These properties MUST be explicitly set on DllImport attributes of EACH import: 
               CharSet, PreserveSig, SetLastError, ExactSpelling.
            (7) CLR names MUST be used for types instead of C# ones, eg "Int32" not "int" and "Int64" not "long".
               This greately improves the understanding of the parameter sizes.
            (8) Sign of the types MUST be favored, eg "DWORD" is "UInt32" not "Int32".
            (9) Unsafe pointer types should be used for explicit and implicit pointers rather than IntPtr. 
               This way we outline the unsafety of the native calls, and also make it more clear for the 64bit transition.
               Eg "HANDLE" is "void*". If the rule forces you to mark some assembly as unsafe, it's an indication a managed utility
               incapsulating the call and the handle should be provided in one of the already-unsafe assemblies.
            (A) Same rules must apply to members of the structures.
            (B) All of the structures MUST have the [StructLayout(LayoutKind.Sequential)], [NoReorder] attributes, as appropriate.
            </remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Advapi32Dll.RegCreateKeyExW(System.Void*,System.String,System.UInt32,System.String,System.UInt32,System.UInt32,System.Void*,System.Void**,System.UInt32*)">
            <remarks>samDesired is of type REGSAM which is ACCESS_FLAGS which is a DWORD</remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Advapi32Dll.RegDeleteKeyExW(System.Void*,System.String,System.UInt32,System.UInt32)">
            <remarks>samDesired is of type REGSAM which is ACCESS_FLAGS which is a DWORD</remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Advapi32Dll.RegOpenKeyExW(System.Void*,System.String,System.UInt32,System.UInt32,System.Void**)">
            <remarks>samDesired is of type REGSAM which is ACCESS_FLAGS which is a DWORD</remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Advapi32Dll.StartTraceW(System.Int64@,System.String,System.Void*)">
            <summary>
            The StartTrace function registers and starts an event tracing session.
            </summary>
            <param name="sessionHandle">Handle to the event tracing session. Do not use this handle if the function fails. Do not compare the session handle to INVALID_HANDLE_VALUE; the session handle is 0 if the handle is not valid.</param>
            <param name="sessionName">Null-terminated string that contains the name of the event tracing session. The session name is limited to 1,024 characters, is case-insensitive, and must be unique. This function copies the session name that you provide to the offset that the LoggerNameOffset member of properties points to.</param>
            <param name="properties">Pointer to an EVENT_TRACE_PROPERTIES structure that specifies the behavior of the session. The following are key members of the structure to set: Wnode.BufferSize, Wnode.Guid, Wnode.ClientContext, Wnode.Flags, LogFileMode, LogFileNameOffset, LoggerNameOffset.</param>
            <returns>If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is one of the system error codes. </returns>
            <remarks>Sechost.dll on Windows 8.1 and Windows Server 2012 R2</remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Advapi32Dll.ControlTraceW(System.Int64,System.String,System.Void*,System.UInt32)">
            <summary>
            The ControlTrace function flushes, queries, updates, or stops the specified event tracing session.
            </summary>
            <param name="sessionHandle">Handle to an event tracing session, or NULL. You must specify SessionHandle if SessionName is NULL. However, ETW ignores the handle if SessionName is not NULL. The handle is returned by the StartTrace function.</param>
            <param name="sessionName">Name of an event tracing session, or NULL. You must specify SessionName if SessionHandle is NULL.</param>
            <param name="properties">Pointer to an initialized EVENT_TRACE_PROPERTIES structure. This structure should be zeroed out before it is used.</param>
            <param name="controlCode">Requested control function.</param>
            <returns>If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is one of the system error codes.</returns>
            <remarks>Sechost.dll on Windows 8.1 and Windows Server 2012 R2</remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Advapi32Dll.OpenTraceW(System.Void*)">
            <summary>
            The OpenTrace function opens a real-time trace session or log file for consuming.
            </summary>
            <param name="logfile">Pointer to an EVENT_TRACE_LOGFILE structure. The structure specifies the source from which to consume events (from a log file or the session in real time) and specifies the callbacks the consumer wants to use to receive the events.</param>
            <returns>
            <para>If the function succeeds, it returns a handle to the trace. If the function fails, it returns INVALID_PROCESSTRACE_HANDLE.</para>
            <para>If your code base supports Windows 7 and Windows Vista, and also supports earlier operating systems such as Windows XP and Windows Server 2003, do not use INVALID_PROCESSTRACE_HANDLE. Instead, determine the operating system on which you are running and compare the return value to the following values.</para>
            <para>Operating system                    Application     Return value to compare</para>
            <para>Windows 7 and Windows Vista         32-bit          0x00000000FFFFFFFF</para>
            <para>Windows 7 and Windows Vista         64-bit          0XFFFFFFFFFFFFFFFF</para>
            <para>Windows XP and Windows Server 2003  32- or 64-bit   0XFFFFFFFFFFFFFFFF</para>
            </returns>
            <remarks>Sechost.dll on Windows 8.1 and Windows Server 2012 R2</remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Advapi32Dll.ProcessTrace(System.Int64[],System.UInt32,System.IntPtr,System.IntPtr)">
            <summary>
            The ProcessTrace function delivers events from one or more event tracing sessions to the consumer.
            </summary>
            <param name="traceHandles">Pointer to an array of trace handles obtained from earlier calls to the OpenTrace function. The number of handles that you can specify is limited to 64. The array can contain the handles to multiple log files, but only one real-time trace session.</param>
            <param name="handleCount">Number of elements in traceHandles.</param>
            <param name="startTime">Pointer to an optional FILETIME structure that specifies the beginning time period for which you want to receive events. The function does not deliver events recorded prior to StartTime.</param>
            <param name="endTime">Pointer to an optional FILETIME structure that specifies the ending time period for which you want to receive events. The function does not deliver events recorded after EndTime.</param>
            <returns>If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is one of the system error codes.</returns>
            <remarks>Sechost.dll on Windows 8.1 and Windows Server 2012 R2</remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Advapi32Dll.CloseTrace(System.Int64)">
            <summary>
            The CloseTrace function closes a trace.
            </summary>
            <param name="traceHandle">Handle to the trace to close. The OpenTrace function returns this handle.</param>
            <returns>If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is one of the system error codes.</returns>
            <remarks>Sechost.dll on Windows 8.1 and Windows Server 2012 R2</remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Advapi32Dll.EnableTrace(System.UInt32,System.UInt32,System.UInt32,System.Guid@,System.Int64)">
            <summary>
            Enables or disables the specified classic event trace provider. On Windows Vista and later, call the EnableTraceEx function to enable or disable a provider.
            </summary>
            <param name="isEnable">If TRUE, the provider is enabled; otherwise, the provider is disabled.</param>
            <param name="enableFlag">Provider-defined value that specifies the class of events for which the provider generates events. A provider that generates only one class of events will typically ignore this flag.</param>
            <param name="level">Provider-defined value that specifies the level of information the event generates.</param>
            <param name="providerId">GUID of the event trace provider that you want to enable or disable.</param>
            <param name="sessionHandle">Handle of the event tracing session to which you want to enable, disable, or change the logging level of the provider. The StartTrace function returns this handle.</param>
            <returns>If the function is successful, the return value is ERROR_SUCCESS. If the function fails, the return value is one of the system error codes. </returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Advapi32Dll.EnableTraceEx(System.Guid@,System.Guid@,System.Int64,System.UInt32,System.UInt16,System.UInt64,System.UInt64,System.UInt32,System.Void*)">
            <summary>
            Enables or disables the specified event trace provider. The EnableTraceEx2 function supersedes this function.
            </summary>
            <param name="providerId">GUID of the event trace provider that you want to enable or disable.</param>
            <param name="sourceId">GUID that uniquely identifies the session that is enabling or disabling the provider. Can be NULL. If the provider does not implement EnableCallback, the GUID is not used.</param>
            <param name="sessionHandle">Handle of the event tracing session to which you want to enable or disable the provider. The StartTrace function returns this handle.</param>
            <param name="isEnabled">Set to 1 to receive events when the provider is registered; otherwise, set to 0 to no longer receive events from the provider.</param>
            <param name="level">Provider-defined value that specifies the level of detail included in the event. Specify one of the following levels that are defined in Winmeta.h.</param>
            <param name="matchAnyKeyword">Bitmask of keywords that determine the category of events that you want the provider to write. The provider writes the event if any of the event's keyword bits match any of the bits set in this mask.</param>
            <param name="matchAllKeyword">This bitmask is optional. This mask further restricts the category of events that you want the provider to write. If the event's keyword meets the MatchAnyKeyword condition, the provider will write the event only if all of the bits in this mask exist in the event's keyword. This mask is not used if MatchAnyKeyword is zero</param>
            <param name="enableProperty">Optional information that ETW can include when writing the event. The data is written to the extended data item section of the event. To include the optional information, specify one or more of the following flags EVENT_ENABLE_PROPERTY_SID, EVENT_ENABLE_PROPERTY_TS_ID; otherwise, set to zero.</param>
            <param name="enableFilterDesc">An EVENT_FILTER_DESCRIPTOR structure that points to the filter data. The provider uses to filter data to prevent events that match the filter criteria from being written to the session; the provider determines the layout of the data and how it applies the filter to the event's data. A session can pass only one filter to the provider.<para>A session can call the TdhEnumerateProviderFilters function to determine the filters that it can pass to the provider.</para></param>
            <returns>If the function is successful, the return value is ERROR_SUCCESS. If the function fails, the return value is one of the system error codes.</returns>
            <remarks>Minimum supported client: Windows Vista [desktop apps only]. Minimum supported server: Windows Server 2008 [desktop apps only]</remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Advapi32Dll.EnableTraceEx2(System.Int64,System.Guid@,System.UInt32,System.UInt16,System.UInt64,System.UInt64,System.UInt32,System.Void*)">
            <summary>
            The EnableTraceEx2 function enables or disables the specified event trace provider. This function supersedes the EnableTraceEx function.
            </summary>
            <param name="sessionHandle">A handle of the event tracing session to which you want to enable or disable the provider. The StartTrace function returns this handle.</param>
            <param name="providerId">A GUID of the event trace provider that you want to enable or disable.</param>
            <param name="controlCode">See EVENT_CONTROL_CODE enum.</param>
            <param name="level">A provider-defined value that specifies the level of detail included in the event. Specify one of the following levels that are defined in the Winmeta.h header file.</param>
            <param name="matchAnyKeyword">A bitmask of keywords that determine the category of events that you want the provider to write. The provider writes the event if any of the event's keyword bits match any of the bits set in this mask.</param>
            <param name="matchAllkeyword">This bitmask is optional. This mask further restricts the category of events that you want the provider to write. If the event's keyword meets the MatchAnyKeyword condition, the provider will write the event only if all of the bits in this mask exist in the event's keyword. This mask is not used if MatchAnyKeyword is zero.</param>
            <param name="timeout">Set to zero to enable the trace asynchronously; this is the default. If the timeout value is zero, this function calls the provider's enable callback and returns immediately. To enable the trace synchronously, specify a timeout value, in milliseconds. If you specify a timeout value, this function calls the provider's enable callback and waits until the callback exits or the timeout expires. To wait forever, set to INFINITE.</param>
            <param name="parameters">The trace parameters used to enable the provider. For details, see ENABLE_TRACE_PARAMETERS and ENABLE_TRACE_PARAMETERS_V1.</param>
            <returns>If the function is successful, the return value is ERROR_SUCCESS. If the function fails, the return value is one of the system error codes.</returns>
            <remarks>Minimum supported client: Windows 7 [desktop apps only]. Minimum supported server: Windows Server 2008 R2 [desktop apps only]</remarks>
            <remarks>Sechost.dll on Windows 8.1 and Windows Server 2012 R2</remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Advapi32Dll.EnumerateTraceGuids(System.Void**,System.UInt32,System.UInt32*)">
            <summary>
            The EnumerateTraceGuids function retrieves information about registered event trace providers that are running on the computer.
            </summary>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Advapi32Dll.Helpers">
            <summary>
            Wrappers for the functions in this DLL.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.AccessRights">
            <remarks>
            <code>
             3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
             1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
            +---------------+---------------+-------------------------------+
            |G|G|G|G|Res'd|A| StandardRights|         SpecificRights        |
            |R|W|E|A|     |S|               |                               |
            +-+-------------+---------------+-------------------------------+
            </code>
            </remarks>
        </member>
        <member name="T:JetBrains.Interop.WinApi.CombineRgnStyles">
            <summary>
            Specifies the operation to be performed over the regions.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.CombineRgnStyles.RGN_AND">
            <summary>
            The new clipping region combines the overlapping areas of the current clipping region and the region identified by hrgn. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.CombineRgnStyles.RGN_OR">
            <summary>
            The new clipping region is a copy of the region identified by hrgn. This is identical to SelectClipRgn. If the region identified by hrgn is NULL, the new clipping region is the default clipping region (the default clipping region is a null region). 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.CombineRgnStyles.RGN_XOR">
            <summary>
            The new clipping region combines the areas of the current clipping region with those areas excluded from the region identified by hrgn. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.CombineRgnStyles.RGN_DIFF">
            <summary>
            The new clipping region combines the current clipping region and the region identified by hrgn. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.CombineRgnStyles.RGN_COPY">
            <summary>
            The new clipping region combines the current clipping region and the region identified by hrgn but excludes any overlapping areas. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.CombineRgnStyles.RGN_MIN">
            <summary>
            Same as <see cref="F:JetBrains.Interop.WinApi.CombineRgnStyles.RGN_AND"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.CombineRgnStyles.RGN_MAX">
            <summary>
            Same as <see cref="F:JetBrains.Interop.WinApi.CombineRgnStyles.RGN_COPY"/>.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Declarations.Constants.OBJID">
            <summary>
            Reserved IDs for system objects. See <see cref="F:JetBrains.Interop.WinApi.WindowsMessages.WM_GETOBJECT"/>.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.PDTIMER_FLAGS">
            <summary>
            // Time Actions (dwTimerAction)
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.PDTIMER_FLAGS.PDTIMER_RESET">
            <summary>
            // Reset the timer so the progress will be calculated from now until the first ::SetProgress() is called so those this time will correspond to the values passed to ::SetProgress().  Only do this before ::SetProgress() is called.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.PDTIMER_FLAGS.PDTIMER_PAUSE">
            <summary>
            Progress has been suspended.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.PDTIMER_FLAGS.PDTIMER_RESUME">
            <summary>
            Progress has resumed.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.PROGDLG_FLAGS">
            <summary>
            // Flags for IProgressDialog::StartProgressDialog() (dwFlags)
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.PROGDLG_FLAGS.PROGDLG_NORMAL">
            <summary>
            default normal progress dlg behavior
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.PROGDLG_FLAGS.PROGDLG_MODAL">
            <summary>
            the dialog is modal to its hwndParent (default is modeless)
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.PROGDLG_FLAGS.PROGDLG_AUTOTIME">
            <summary>
            automatically updates the "Line3" text with the "time remaining" (you cant call SetLine3 if you passs this!)
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.PROGDLG_FLAGS.PROGDLG_NOTIME">
            <summary>
            we dont show the "time remaining" if this is set. We need this if dwTotal &lt; dwCompleted for sparse files
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.PROGDLG_FLAGS.PROGDLG_NOMINIMIZE">
            <summary>
            Do not have a minimize button in the caption bar.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.PROGDLG_FLAGS.PROGDLG_NOPROGRESSBAR">
            <summary>
            Don't display the progress bar
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.PROGDLG_FLAGS.PROGDLG_MARQUEEPROGRESS">
            <summary>
            Use marquee progress (comctl32 v6 required)
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.PROGDLG_FLAGS.PROGDLG_NOCANCEL">
            <summary>
            No cancel button (operation cannot be canceled) (use sparingly)  
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.DialogBoxCommandId">
            <summary>
            Standard command IDs for the dialog boxes.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.DialogCodes">
            <summary>
            Dialog Codes.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.MessageBoxFlags">
            <summary>
            Flags for the <see cref="M:JetBrains.Interop.WinApi.User32Dll.MessageBoxW(System.Void*,System.String,System.String,System.UInt32)"/> function.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.OleCmdErr">
            <summary>
             OLE CMD Errors from <c>DocObj.h</c>.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.ProcessorArchitecture.PROCESSOR_ARCHITECTURE_INTEL">
            <summary>
            x86
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.ProcessorArchitecture.PROCESSOR_ARCHITECTURE_IA64">
            <summary>
            Intel Itanium-based
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.ProcessorArchitecture.PROCESSOR_ARCHITECTURE_AMD64">
            <summary>
            x64 (AMD or Intel)
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.ProcessorArchitecture.PROCESSOR_ARCHITECTURE_UNKNOWN">
            <summary>
            Unknown architecture.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.StockLogicalObjects">
            <summary>
            The stock GDI objects for the <see cref="M:JetBrains.Interop.WinApi.Gdi32Dll.GetStockObject(System.Int32)"/> function.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.StockLogicalObjects.BLACK_BRUSH">
            <summary>
            Black brush.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.StockLogicalObjects.DKGRAY_BRUSH">
            <summary>
            Dark gray brush.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.StockLogicalObjects.DC_BRUSH">
            <summary>
            Windows 2000/XP: Solid color brush. The default color is white. The color can be changed by using the SetDCBrushColor function. For more information= , see the Remarks section.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.StockLogicalObjects.GRAY_BRUSH">
            <summary>
            Gray brush.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.StockLogicalObjects.HOLLOW_BRUSH">
            <summary>
            Hollow brush (equivalent to NULL_BRUSH).
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.StockLogicalObjects.LTGRAY_BRUSH">
            <summary>
            Light gray brush.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.StockLogicalObjects.NULL_BRUSH">
            <summary>
            Null brush (equivalent to HOLLOW_BRUSH).
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.StockLogicalObjects.WHITE_BRUSH">
            <summary>
            White brush.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.StockLogicalObjects.BLACK_PEN">
            <summary>
            Black pen.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.StockLogicalObjects.DC_PEN">
            <summary>
            Windows 2000/XP: Solid pen color. The default color is white. The color can be changed by using the SetDCPenColor function. For more information= , see the Remarks section.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.StockLogicalObjects.WHITE_PEN">
            <summary>
            White pen.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.StockLogicalObjects.ANSI_FIXED_FONT">
            <summary>
            Windows fixed-pitch (monospace) system font.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.StockLogicalObjects.ANSI_VAR_FONT">
            <summary>
            Windows variable-pitch (proportional space) system font.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.StockLogicalObjects.DEVICE_DEFAULT_FONT">
            <summary>
            Windows NT/2000/XP: Device-dependent font.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.StockLogicalObjects.DEFAULT_GUI_FONT">
            <summary>
            Default font for user interface objects such as menus and dialog boxes. This is MS Sans Serif. Compare this with SYSTEM_FONT.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.StockLogicalObjects.OEM_FIXED_FONT">
            <summary>
            Original equipment manufacturer (OEM) dependent fixed-pitch (monospace) font.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.StockLogicalObjects.SYSTEM_FONT">
            <summary>
            System font. By default= , the system uses the system font to draw menus= , dialog box controls= , and text. Windows 95/98 and Windows NT: The system font is MS Sans Serif. Windows 2000/XP: The system font is Tahoma
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.StockLogicalObjects.SYSTEM_FIXED_FONT">
            <summary>
            Fixed-pitch (monospace) system font. This stock object is provided only for compatibility with 16-bit Windows versions earlier than 3.0.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.StockLogicalObjects.DEFAULT_PALETTE">
            <summary>
            Default palette. This palette consists of the static colors in the system palette.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.SystemMetricsCodes">
            <summary>
            Codes for the <see cref="M:JetBrains.Interop.WinApi.User32Dll.GetSystemMetrics(System.Int32)"/> function.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Declarations.Constants.WaitResult">
            <summary>
            Result flags for the wait functions.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.WaitResult.WAIT_ABANDONED">
            <summary>
             The specified object is a mutex object that was not released by the thread that owned the mutex object before the owning thread terminated. Ownership of the mutex object is granted to the calling thread, and the mutex is set to nonsignaled.
            If the mutex was protecting persistent state information, you should check it for consistency.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.WaitResult.WAIT_OBJECT_0">
            <summary>
            The state of the specified object is signaled.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.WaitResult.WAIT_TIMEOUT">
            <summary>
            The time-out interval elapsed, and the object's state is nonsignaled.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Interfaces.IOleMessageFilter">
            <summary>
            Provides COM servers and applications with the ability to selectively handle incoming and outgoing COM messages while waiting for responses from synchronous calls. 
            Filtering messages helps to ensure that calls are handled in a manner that improves performance and avoids deadlocks. COM messages can be synchronous, asynchronous, 
            or input-synchronized; the majority of interface calls are synchronous.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Interfaces.IOleMessageFilter.HandleInComingCall(System.UInt32,System.Void*,System.UInt32,System.Void*)">
            <summary>
            Provides a single entry point for incoming calls.
            </summary>
            <remarks>
            This method is called prior to each method invocation originating outside the current process and provides the ability to filter or reject incoming calls (or callbacks) to an object or a process.
            DWORD HandleInComingCall([in] DWORD dwCallType, [in] HTASK htaskCaller, [in] DWORD dwTickCount, [in] LPINTERFACEINFO lpInterfaceInfo);
            </remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Interfaces.IOleMessageFilter.RetryRejectedCall(System.Void*,System.UInt32,System.UInt32)">
            <summary>
            Provides applications with an opportunity to display a dialog box offering retry, cancel, or task-switching options.
            </summary>
            <remarks>
            DWORD RetryRejectedCall([in] HTASK htaskCallee, [in] DWORD dwTickCount, [in] DWORD dwRejectType);
            </remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Interfaces.IOleMessageFilter.MessagePending(System.Void*,System.UInt32,System.UInt32)">
            <summary>
            Indicates that a message has arrived while COM is waiting to respond to a remote call.
            </summary>
            <remarks>
            Handling input while waiting for an outgoing call to finish can introduce complications. The application should determine whether to process the message without interrupting the call, to continue waiting, or to cancel the operation.
            DWORD MessagePending([in] HTASK htaskCallee, [in] DWORD dwTickCount, [in] DWORD dwPendingType);
            </remarks>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Interfaces.IProgressDialog">
            <summary>
              <code>
                INTERFACE: IProgressDialog
            
                DESCRIPTION:
                    CLSID_ProgressDialog/IProgressDialog exist to allow a caller to create
                a progress dialog, set it's title, animation, text lines, progress, and
                it will do all the work of updating on a background thread, being modeless,
                handling the user canceling the operation, and estimating the time remaining
                until the operation completes.
            
                USAGE:
                    This is how the dialog is used during operations that require progress
                and the ability to cancel:
                {
                    DWORD dwComplete, dwTotal;
                    IProgressDialog * ppd;
                    CoCreateInstance(CLSID_ProgressDialog, NULL, CLSCTX_INPROC_SERVER, IID_IProgressDialog, (void **)&amp;ppd);
                    ppd->SetTitle(L"My Slow Operation");                                // Set the title of the dialog.
                    ppd->SetAnimation(hInstApp, IDA_OPERATION_ANIMATION);               // Set the animation to play.
                    ppd->StartProgressDialog(hwndParent, punk, PROGDLG_AUTOTIME, NULL); // Display and enable automatic estimated time remaining.
                    ppd->SetCancelMsg(L"Please wait while the current operation is cleaned up", NULL);   // Will only be displayed if Cancel button is pressed.
            
                    dwComplete = 0;
                    dwTotal = CalcTotalUnitsToDo();
            
                    // Reset because CalcTotalUnitsToDo() took a long time and the estimated time
                    // is based on the time between ::StartProgressDialog() and the first
                    // ::SetProgress() call.
                    ppd->Timer(PDTIMER_RESET, NULL);
            
                    for (nIndex = 0; nIndex &lt; nTotal; nIndex++)
                    {
                        if (TRUE == ppd->HasUserCancelled())
                            break;
            
                        ppd->SetLine(2, L"I'm processing item n", FALSE, NULL);
                        dwComplete += DoSlowOperation();
            
                        ppd->SetProgress(dwCompleted, dwTotal);
                    }
            
                    ppd->StopProgressDialog();
                    ppd->Release();
                }
              </code>  
               </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Macros">
            <summary>
            Hosts the scattered WinAPI macros, in the form of functions.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Macros.GET_X_LPARAM(System.IntPtr)">
            <summary>
            Gets a signed x-coordinate packed into an LPARAM, usually in Windows messgaes.
            To create a point from an LPARAM, use casting thru the <see cref="T:JetBrains.Interop.WinApi.POINT"/> class.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Macros.GET_Y_LPARAM(System.IntPtr)">
            <summary>
            Gets a signed y-coordinate packed into an LPARAM, usually in Windows messgaes.
            To create a point from an LPARAM, use casting thru the <see cref="T:JetBrains.Interop.WinApi.POINT"/> class.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Macros.MAKEDWORD(System.UInt16,System.UInt16)">
            <summary>
            In WinAPI, this is called <c>MAKELONG</c> (C's <c>long</c> is of the same size as a DWORD, whilst in C# it's a QWORD).
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.MsImg32Dll">
            <summary>
            MsImg32.dll functions.
            Must be 64bit-safe.
            </summary>
            <remarks>
            IMPORTANT! Rules for authoring the class (v1.1):
            (1) All the function declarations MUST be 64-bit aware.
            (2) When copypasting from older declarations, you MUST check against the MSDN help or header declaration, 
               and you MUST ensure that each parameter has a proper size.
            (3) Call the Wide version of the functions (UCS-2-LE) unless there's a strong reason for calling the ANSI version 
               (such a reason MUST be indicated in XmlDoc). <c>CharSet = CharSet.Unicode</c>.
            (4) ExactSpelling MUST be TRUE. Add the "…W" suffix wherever needed.
            (5) SetLastError SHOULD be considered individually for each function. Setting it to <c>True</c> allows to report the errors,
               but slows down the execution of critical members.
            (6) These properties MUST be explicitly set on DllImport attributes of EACH import: 
               CharSet, PreserveSig, SetLastError, ExactSpelling.
            (7) CLR names MUST be used for types instead of C# ones, eg "Int32" not "int" and "Int64" not "long".
               This greately improves the understanding of the parameter sizes.
            (8) Sign of the types MUST be favored, eg "DWORD" is "UInt32" not "Int32".
            (9) Unsafe pointer types should be used for explicit and implicit pointers rather than IntPtr. 
               This way we outline the unsafety of the native calls, and also make it more clear for the 64bit transition.
               Eg "HANDLE" is "void*". If the rule forces you to mark some assembly as unsafe, it's an indication a managed utility
               incapsulating the call and the handle should be provided in one of the already-unsafe assemblies.
            (A) Same rules must apply to members of the structures.
            (B) All of the structures MUST have the [StructLayout(LayoutKind.Sequential)], [NoReorder] attributes, as appropriate.
            </remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.MsImg32Dll.AlphaBlend(System.Void*,System.Int32,System.Int32,System.Int32,System.Int32,System.Void*,System.Int32,System.Int32,System.Int32,System.Int32,JetBrains.Interop.WinApi.Declarations.Structures.BLENDFUNCTION)">
            <summary>
            The AlphaBlend function displays bitmaps that have transparent or semitransparent pixels.
            </summary>
            <param name="hdcDest">
            [in] Handle to the destination device context. </param>
            <param name="nXOriginDest">
            [in] Specifies the x-coordinate, in logical units, of the upper-left corner of the destination rectangle. </param>
            <param name="nYOriginDest">
            [in] Specifies the y-coordinate, in logical units, of the upper-left corner of the destination rectangle. </param>
            <param name="nWidthDest">
            [in] Specifies the width, in logical units, of the destination rectangle. </param>
            <param name="nHeightDest">
            [in] Specifies the height, in logical units, of the destination rectangle. </param>
            <param name="hdcSrc">
            [in] Handle to the source device context. </param>
            <param name="nXOriginSrc">
            [in] Specifies the x-coordinate, in logical units, of the upper-left corner of the source rectangle. </param>
            <param name="nYOriginSrc">
            [in] Specifies the y-coordinate, in logical units, of the upper-left corner of the source rectangle. </param>
            <param name="nWidthSrc">
            [in] Specifies the width, in logical units, of the source rectangle. </param>
            <param name="nHeightSrc">
            [in] Specifies the height, in logical units, of the source rectangle. </param>
            <param name="blendFunction">
            [in] Specifies the alpha-blending function for source and destination bitmaps, a global alpha value to be applied to the entire source bitmap, and format information for the source bitmap. The source and destination blend functions are currently limited to AC_SRC_OVER. See the <see cref="T:JetBrains.Interop.WinApi.Declarations.Structures.BLENDFUNCTION"/> and EMRALPHABLEND structures. </param>
            <returns>If the function succeeds, the return value is TRUE. If the function fails, the return value is FALSE.</returns>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Ole32Dll">
            <summary>
            Ole32.dll functions.
            Must be 64bit-safe.
            </summary>
            <remarks>
            IMPORTANT! Rules for authoring the class (v1.1):
            (1) All the function declarations MUST be 64-bit aware.
            (2) When copypasting from older declarations, you MUST check against the MSDN help or header declaration, 
               and you MUST ensure that each parameter has a proper size.
            (3) Call the Wide version of the functions (UCS-2-LE) unless there's a strong reason for calling the ANSI version 
               (such a reason MUST be indicated in XmlDoc). <c>CharSet = CharSet.Unicode</c>.
            (4) ExactSpelling MUST be TRUE. Add the "…W" suffix wherever needed.
            (5) SetLastError SHOULD be considered individually for each function. Setting it to <c>True</c> allows to report the errors,
               but slows down the execution of critical members.
            (6) These properties MUST be explicitly set on DllImport attributes of EACH import: 
               CharSet, PreserveSig, SetLastError, ExactSpelling.
            (7) CLR names MUST be used for types instead of C# ones, eg "Int32" not "int" and "Int64" not "long".
               This greately improves the understanding of the parameter sizes.
            (8) Sign of the types MUST be favored, eg "DWORD" is "UInt32" not "Int32".
            (9) Unsafe pointer types should be used for explicit and implicit pointers rather than IntPtr. 
               This way we outline the unsafety of the native calls, and also make it more clear for the 64bit transition.
               Eg "HANDLE" is "void*". If the rule forces you to mark some assembly as unsafe, it's an indication a managed utility
               incapsulating the call and the handle should be provided in one of the already-unsafe assemblies.
            (A) Same rules must apply to members of the structures.
            (B) All of the structures MUST have the [StructLayout(LayoutKind.Sequential)], [NoReorder] attributes, as appropriate.
            </remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Ole32Dll.CreateILockBytesOnHGlobal(System.Void*,System.Int32,JetBrains.Interop.WinApi.Declarations.Interfaces.ILockBytes@)">
            <summary>
            The CreateILockBytesOnHGlobal function creates a byte array object that uses an HGLOBAL memory handle to store the bytes intended for in-memory storage of a compound file. This object is the OLE-provided implementation of the ILockBytes interface.
            The returned byte array object supports both reading and writing, but does not support region locking . The object calls the GlobalReAlloc function to grow the memory block as required.
            </summary>
            <param name="hGlobal"></param>
            <param name="fDeleteOnRelease"></param>
            <param name="ppLkbyt"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Ole32Dll.CreateILockBytesOnHGlobal(System.Void*,System.Int32,System.Void**)">
            <summary>
            The CreateILockBytesOnHGlobal function creates a byte array object that uses an HGLOBAL memory handle to store the bytes intended for in-memory storage of a compound file. This object is the OLE-provided implementation of the ILockBytes interface.
            The returned byte array object supports both reading and writing, but does not support region locking . The object calls the GlobalReAlloc function to grow the memory block as required.
            </summary>
            <param name="hGlobal"></param>
            <param name="fDeleteOnRelease"></param>
            <param name="ppLkbyt"></param>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Interop.WinApi.OleAut32Dll">
            <summary>
            OleAut32.dll functions.
            Must be 64bit-safe.
            </summary>
            <remarks>
            IMPORTANT! Rules for authoring the class (v1.1):
            (1) All the function declarations MUST be 64-bit aware.
            (2) When copypasting from older declarations, you MUST check against the MSDN help or header declaration,
               and you MUST ensure that each parameter has a proper size.
            (3) Call the Wide version of the functions (UCS-2-LE) unless there's a strong reason for calling the ANSI version
               (such a reason MUST be indicated in XmlDoc). <c>CharSet = CharSet.Unicode</c>.
            (4) ExactSpelling MUST be TRUE. Add the "…W" suffix wherever needed.
            (5) SetLastError SHOULD be considered individually for each function. Setting it to <c>True</c> allows to report the errors,
               but slows down the execution of critical members.
            (6) These properties MUST be explicitly set on DllImport attributes of EACH import:
               CharSet, PreserveSig, SetLastError, ExactSpelling.
            (7) CLR names MUST be used for types instead of C# ones, eg "Int32" not "int" and "Int64" not "long".
               This greately improves the understanding of the parameter sizes.
            (8) Sign of the types MUST be favored, eg "DWORD" is "UInt32" not "Int32".
            (9) Unsafe pointer types should be used for explicit and implicit pointers rather than IntPtr.
               This way we outline the unsafety of the native calls, and also make it more clear for the 64bit transition.
               Eg "HANDLE" is "void*". If the rule forces you to mark some assembly as unsafe, it's an indication a managed utility
               incapsulating the call and the handle should be provided in one of the already-unsafe assemblies.
            (A) Same rules must apply to members of the structures.
            (B) All of the structures MUST have the [StructLayout(LayoutKind.Sequential)], [NoReorder] attributes, as appropriate.
            </remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.OleAut32Dll.VariantClear(System.Void*)">
            <summary>
             Clears a variant.
            </summary>
            <param name="pvarg">Pointer to the <c>VARIANTARG</c> to clear.</param>
            <returns>The return value obtained from the returned HRESULT is one of the following.</returns>
            <remarks>
             Use this function to clear variables of type VARIANTARG (or VARIANT) before the memory containing the VARIANTARG is freed (as when a local variable goes out of scope).
             The function clears a VARIANTARG by setting the vt field to VT_EMPTY. The current contents of the VARIANTARG are released first. If the vtfield is VT_BSTR, the string is freed. If the vtfield is VT_DISPATCH, the object is released. If the vt field has the VT_ARRAY bit set, the array is freed.
             If the variant to be cleared is a COM object that is passed by reference, the vtfield of the pvargparameter is VT_DISPATCH | VT_BYREF or VT_UNKNOWN | VT_BYREF. In this case, VariantClear does not release the object. Because the variant being cleared is a pointer to a reference to an object, VariantClear has no way to determine if it is necessary to release the object. It is therefore the responsibility of the caller to release the object or not, as appropriate.
             In certain cases, it may be preferable to clear a variant in code without calling VariantClear. For example, you can change the type of a VT_I4 variant to another type without calling this function. Safearrays of BSTR will have SysFreeString called on each element not VariantClear. However, you must call VariantClear if a VT_type is received but cannot be handled. Safearrays of variant will also have VariantClear called on each member. Using VariantClear in these cases ensures that code will continue to work if Automation adds new variant types in the future.
             Do not use VariantClear on unitialized variants; use VariantInit to initialize a new VARIANTARG or VARIANT.
             Variants containing arrays with outstanding references cannot be cleared. Attempts to do so will return an HRESULT containing DISP_E_ARRAYISLOCKED.
            </remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.OleAut32Dll.VariantInit(System.Void*)">
            <summary>
            Initializes a variant.
            </summary>
            <param name="pvarg">Pointer to the VARIANTARG that will be initialized.</param>
            <remarks>The VariantInit function initializes the VARIANTARG by setting the vt field to VT_EMPTY. Unlike VariantClear, this function does not interpret the current contents of the VARIANTARG. Use VariantInit to initialize new local variables of type VARIANTARG (or VARIANT). </remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.OleAut32Dll.VarR8FromStr(System.String,System.UInt32,System.UInt32,System.Double*)">
            <summary>
            Converts an OLECHAR string to a double value.
            </summary>
            <param name="strIn"></param>
            <param name="lcid"></param>
            <param name="dwFlags"></param>
            <param name="pdblOut"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Shell32Dll.SHGetFileInfoW(System.String,System.UInt32,JetBrains.Interop.WinApi.SHFILEINFO*,System.UInt32,System.UInt32)">
            <summary>
            Retrieves information about an object in the file system, such as a file, folder, directory, or drive root.
            </summary>
            <param name="pszPath">Type: LPCTSTR A pointer to a null-terminated string of maximum length MAX_PATH that contains the path and file name. Both absolute and relative paths are valid.  If the uFlags parameter includes the SHGFI_PIDL flag, this parameter must be the address of an ITEMIDLIST (PIDL) structure that contains the list of item identifiers that uniquely identifies the file within the Shell's namespace. The PIDL must be a fully qualified PIDL. Relative PIDLs are not allowed. If the uFlags parameter includes the SHGFI_USEFILEATTRIBUTES flag, this parameter does not have to be a valid file name. The function will proceed as if the file exists with the specified name and with the file attributes passed in the dwFileAttributes parameter. This allows you to obtain information about a file type by passing just the extension for pszPath and passing FILE_ATTRIBUTE_NORMAL in dwFileAttributes. This string can use either short (the 8.3 form) or long file names.</param>
            <param name="dwFileAttributes">A combination of one or more file attribute flags (FILE_ATTRIBUTE_ values as defined in Winnt.h). If uFlags does not include the SHGFI_USEFILEATTRIBUTES flag, this parameter is ignored.</param>
            <param name="psfi">Pointer to a SHFILEINFO structure to receive the file information.</param>
            <param name="cbFileInfo">The size, in bytes, of the SHFILEINFO structure pointed to by the psfi parameter.</param>
            <param name="uFlags">The flags that specify the file information to retrieve. This parameter can be a combination of the following values. <see cref="T:JetBrains.Interop.WinApi.Declarations.Constants.SHGetFileInfoFlags"/>.</param>
            <returns>Returns a value whose meaning depends on the uFlags parameter. If uFlags does not contain SHGFI_EXETYPE or SHGFI_SYSICONINDEX, the return value is nonzero if successful, or zero otherwise. If uFlags contains the SHGFI_EXETYPE flag, the return value specifies the type of the executable file. It will be one of the following values.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.SHFolderDll.SHGetFolderPathW(System.Void*,System.Int32,System.Void*,System.UInt32,System.Text.StringBuilder)">
            <param name="hwndOwner"></param>
            <param name="nFolder"><see cref="T:JetBrains.Interop.WinApi.CSIDL"/></param>
            <param name="hToken"></param>
            <param name="dwFlags"><see cref="T:JetBrains.Interop.WinApi.SHGFP_TYPE"/></param>
            <param name="lpszPath"></param>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Declarations.Structures.CURSORINFO">
            <summary>
            The CURSORINFO structure contains global cursor information.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.CURSORINFO.cbSize">
            <summary>
            Specifies the size, in bytes, of the structure. The caller must set this to <c>sizeof(CURSORINFO)</c>.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.CURSORINFO.flags">
            <summary>
            Specifies the cursor state. This parameter can be one of the following values. 
            • 0 — The cursor is hidden.
            • CURSOR_SHOWING — The cursor is showing.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.CURSORINFO.hCursor">
            <summary>
            Handle to the cursor. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.CURSORINFO.ptScreenPos">
            <summary>
            A <see cref="T:JetBrains.Interop.WinApi.POINT"/> structure that receives the screen coordinates of the cursor. 
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.CWPRETSTRUCT">
            <summary>
            The CWPRETSTRUCT structure defines the message parameters passed to a WH_CALLWNDPROCRET hook procedure, CallWndRetProc.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.CWPRETSTRUCT.lResult">
            <summary>
            Specifies the return value of the window procedure that processed the message specified by the message value. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.CWPRETSTRUCT.lParam">
            <summary>
            Specifies additional information about the message. The exact meaning depends on the message value. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.CWPRETSTRUCT.wParam">
            <summary>
            Specifies additional information about the message. The exact meaning depends on the message value. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.CWPRETSTRUCT.message">
            <summary>
            Specifies the message. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.CWPRETSTRUCT.hwnd">
            <summary>
            Handle to the window that processed the message specified by the message value.   
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.CWPSTRUCT">
            <summary>
            The CWPSTRUCT structure defines the message parameters passed to a WH_CALLWNDPROC hook procedure, CallWndProc. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.CWPSTRUCT.lParam">
            <summary>
            Specifies additional information about the message. The exact meaning depends on the message value. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.CWPSTRUCT.wParam">
            <summary>
            Specifies additional information about the message. The exact meaning depends on the message value. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.CWPSTRUCT.message">
            <summary>
            Specifies the message. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.CWPSTRUCT.hwnd">
            <summary>
            Handle to the window to receive the message.   
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.GUITHREADINFO">
            <summary>
            The GUITHREADINFO structure contains information about a graphical user interface (GUI) thread.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.GUITHREADINFO.cbSize">
            <summary>
            Specifies the size of this structure, in bytes. The caller must set this to sizeof(GUITHREADINFO). 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.GUITHREADINFO.flags">
            <summary>
            Specifies the thread state.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.GUITHREADINFO.hwndActive">
            <summary>
            Handle to the active window within the thread. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.GUITHREADINFO.hwndFocus">
            <summary>
            Handle to the window that has the keyboard focus. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.GUITHREADINFO.hwndCapture">
            <summary>
            Handle to the window that has captured the mouse. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.GUITHREADINFO.hwndMenuOwner">
            <summary>
            Handle to the window that owns any active menus. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.GUITHREADINFO.hwndMoveSize">
            <summary>
            Handle to the window in a move or size loop. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.GUITHREADINFO.hwndCaret">
            <summary>
            Handle to the window that is displaying the caret. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.GUITHREADINFO.rcCaret">
            <summary>
            A <c>RECT</c> structure that describes the caret's bounding rectangle, in client coordinates, relative to the window specified by the hwndCaret member. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.MEMORY_BASIC_INFORMATION.BaseAddress">
            <summary>
            A pointer to the base address of the region of pages.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.MEMORY_BASIC_INFORMATION.AllocationBase">
            <summary>
            A pointer to the base address of a range of pages allocated by the VirtualAlloc function. The page pointed to by the BaseAddress member is contained within this allocation range.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.MEMORY_BASIC_INFORMATION.AllocationProtect">
            <summary>
            The memory protection option when the region was initially allocated. This member can be one of the memory protection constants or 0 if the caller does not have access.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.MEMORY_BASIC_INFORMATION.RegionSize">
            <summary>
            The size of the region beginning at the base address in which all pages have identical attributes, in bytes.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.MEMORY_BASIC_INFORMATION.State">
            <summary>
            The state of the pages in the region. This member can be one of the following values: <see cref="F:JetBrains.Interop.WinApi.Declarations.Constants.MemoryAllocationTypes.MEM_COMMIT"/>, <see cref="F:JetBrains.Interop.WinApi.Declarations.Constants.MemoryAllocationTypes.MEM_RESERVE"/>, <see cref="F:JetBrains.Interop.WinApi.Declarations.Constants.MemoryAllocationTypes.MEM_FREE"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.MEMORY_BASIC_INFORMATION.Protect">
            <summary>
            The access protection of the pages in the region. This member is one of the values listed for the AllocationProtect member.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.MEMORY_BASIC_INFORMATION.Type">
            <summary>
            The type of pages in the region. See <see cref="T:JetBrains.Interop.WinApi.Declarations.Constants.MemoryPageTypes"/>.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.MOUSEHOOKSTRUCT">
            <summary>
            The MOUSEHOOKSTRUCT structure contains information about a mouse event passed to a WH_MOUSE hook procedure, MouseProc. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.MOUSEHOOKSTRUCT.pt">
            <summary>
            Specifies a POINT structure that contains the x- and y-coordinates of the cursor, in screen coordinates. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.MOUSEHOOKSTRUCT.hwnd">
            <summary>
            Handle to the window that will receive the mouse message corresponding to the mouse event. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.MOUSEHOOKSTRUCT.wHitTestCode">
            <summary>
            Specifies the hit-test value. For a list of hit-test values, see the description of the WM_NCHITTEST message. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.MOUSEHOOKSTRUCT.dwExtraInfo">
            <summary>
            Specifies extra information associated with the message. 
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.MSG">
            <summary>
            The MSG structure contains message information from a thread's message queue. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.MSG.hwnd">
            <summary>
            Handle to the window whose window procedure receives the message. hwnd is NULL when the message is a thread message.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.MSG.message">
            <summary>
            Specifies the message identifier. Applications can only use the low word; the high word is reserved by the system. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.MSG.wParam">
            <summary>
            Specifies additional information about the message. The exact meaning depends on the value of the message member. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.MSG.lParam">
            <summary>
            Specifies additional information about the message. The exact meaning depends on the value of the message member.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.MSG.time">
            <summary>
            Specifies the time at which the message was posted. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.MSG.pt">
            <summary>
            Specifies the cursor position, in screen coordinates, when the message was posted. 
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.MSLLHOOKSTRUCT">
            <summary>
            The MSLLHOOKSTRUCT structure contains information about a low-level keyboard input event. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.MSLLHOOKSTRUCT.pt">
            <summary>
            Specifies a POINT structure that contains the x- and y-coordinates of the cursor, in screen coordinates. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.MSLLHOOKSTRUCT.mouseData">
            <summary>
            <para>If the message is WM_MOUSEWHEEL, the high-order word of this member is the wheel delta. The low-order word is reserved. A positive value indicates that the wheel was rotated forward, away from the user; a negative value indicates that the wheel was rotated backward, toward the user. One wheel click is defined as WHEEL_DELTA, which is 120. </para>
            <para>If the message is WM_XBUTTONDOWN, WM_XBUTTONUP, WM_XBUTTONDBLCLK, WM_NCXBUTTONDOWN, WM_NCXBUTTONUP, or WM_NCXBUTTONDBLCLK, the high-order word specifies which X button was pressed or released, and the low-order word is reserved. This value can be one or more of the following values. Otherwise, mouseData is not used.</para>
            <para>XBUTTON1  The first X button was pressed or released.</para>
            <para>XBUTTON2  The second X button was pressed or released.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.MSLLHOOKSTRUCT.flags">
            <summary>
            <para>Specifies the event-injected flag. An application can use the following value to test the mouse flags. </para>
            <para>LLMHF_INJECTED Test the event-injected flag.</para>
            <para>0  Specifies whether the event was injected. The value is 1 if the event was injected; otherwise, it is 0.</para>
            <para>1-15  Reserved.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.MSLLHOOKSTRUCT.time">
            <summary>
            Specifies the time stamp for this message. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.MSLLHOOKSTRUCT.dwExtraInfo">
            <summary>
            Specifies extra information associated with the message.   
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.NMHDR">
            <summary>
            Contains information about a notification message.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.NMHDR.hwndFrom">
            <summary>
            A window handle to the control sending the message.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.NMHDR.idFrom">
            <summary>
            An identifier of the control sending the message.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.NMHDR.code">
            <summary>
            A notification code. This member can be one of the common notification codes (see Notifications under General Control Reference), or it can be a control-specific notification code.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.POINT">
            <summary>
            The POINT structure defines the x- and y- coordinates of a point. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.POINT.x">
            <summary>
            Specifies the x-coordinate of the point.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.POINT.y">
            <summary>
            Specifies the y-coordinate of the point. 
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.POINT.#ctor(System.IntPtr)">
            <summary>
            Creates a new point, unpacking its signed coordinates from an LPARAM, using the <see cref="M:JetBrains.Interop.WinApi.Macros.GET_X_LPARAM(System.IntPtr)"/> and <see cref="M:JetBrains.Interop.WinApi.Macros.GET_Y_LPARAM(System.IntPtr)"/> functions.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.POINT.ToString">
            <summary>
            Returns a <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </summary>
            
            <returns>
            A <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:JetBrains.Interop.WinApi.SECURITY_ATTRIBUTES">
            <summary>
            The <see cref="T:JetBrains.Interop.WinApi.SECURITY_ATTRIBUTES"/> structure contains the security descriptor for an object and specifies whether the handle retrieved by specifying this structure is inheritable. This structure provides security settings for objects created by various functions, such as CreateFile, CreatePipe, CreateProcess, RegCreateKeyEx, or RegSaveKeyEx.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.SECURITY_ATTRIBUTES.nLength">
            <summary>
            The size, in bytes, of this structure. Set this value to the size of the SECURITY_ATTRIBUTES structure.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.SECURITY_ATTRIBUTES.lpSecurityDescriptor">
            <summary>
            A pointer to a security descriptor for the object that controls the sharing of it. If NULL is specified for this member, the object is assigned the default security descriptor of the calling process. This is not the same as granting access to everyone by assigning a NULL discretionary access control list (DACL). The default security descriptor is based on the default DACL of the access token belonging to the calling process. By default, the default DACL in the access token of a process allows access only to the user represented by the access token. If other users must access the object, you can either create a security descriptor with the appropriate access, or add ACEs to the DACL that grants access to a group of users.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.SECURITY_ATTRIBUTES.bInheritHandle">
            <summary>
            A Boolean value that specifies whether the returned handle is inherited when a new process is created. If this member is TRUE, the new process inherits the handle.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.SERVICE_STATUS_PROCESS.dwServiceType">
            <summary>
            See <see cref="T:JetBrains.Interop.WinApi.ServiceType"/>
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.SERVICE_STATUS_PROCESS.dwCurrentState">
            <summary>
            See <see cref="T:JetBrains.Interop.WinApi.ServiceState"/>
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.SERVICE_STATUS_PROCESS.dwControlsAccepted">
            <summary>
            See <see cref="T:JetBrains.Interop.WinApi.ServiceAccept"/>
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.SERVICE_STATUS_PROCESS.dwServiceFlags">
            <summary>
            See <see cref="T:JetBrains.Interop.WinApi.ServiceFlags"/>
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.WinDef">
            <summary>
            Assorted constants.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.WinDef.CBM_INIT">
            <summary>
            /* constants for CreateDIBitmap */
            /* initialize bitmap */
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.WinDef.DesktopDefault">
            <summary>
            The name of the input desktop in the interactive window station.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.WinDef.MAXIMUM_WAIT_OBJECTS">
            <summary>
            Maximum number of wait objects.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.WinDef.SizeOfVariant">
            <summary>
            Size of the <c>VARIANT</c> / <c>VARIANTARG</c> COM structures.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.WinDef.USER_TIMER_MAXIMUM">
            <summary>
            The SetTimer function creates a timer with the specified time-out value.
            uElapse
            [in] Specifies the time-out value, in milliseconds. 
            Windows NT/2000/XP: If uElapse is greater than USER_TIMER_MAXIMUM, the timeout is set to 1.
            Windows 2000/XP: If uElapse is less than USER_TIMER_MINIMUM, the timeout is set to USER_TIMER_MINIMUM.
            Windows Server 2003: If uElapse is greater than USER_TIMER_MAXIMUM, the timeout is set to USER_TIMER_MAXIMUM.
            Windows XP SP2/Windows Server 2003 SP1: If uElapse is less than USER_TIMER_MINIMUM, the timeout is set to USER_TIMER_MINIMUM. If uElapse is greater than USER_TIMER_MAXIMUM, the timeout is set to USER_TIMER_MAXIMUM.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.WinDef.USER_TIMER_MINIMUM">
            <summary>
            The SetTimer function creates a timer with the specified time-out value.
            uElapse
            [in] Specifies the time-out value, in milliseconds. 
            Windows NT/2000/XP: If uElapse is greater than USER_TIMER_MAXIMUM, the timeout is set to 1.
            Windows 2000/XP: If uElapse is less than USER_TIMER_MINIMUM, the timeout is set to USER_TIMER_MINIMUM.
            Windows Server 2003: If uElapse is greater than USER_TIMER_MAXIMUM, the timeout is set to USER_TIMER_MAXIMUM.
            Windows XP SP2/Windows Server 2003 SP1: If uElapse is less than USER_TIMER_MINIMUM, the timeout is set to USER_TIMER_MINIMUM. If uElapse is greater than USER_TIMER_MAXIMUM, the timeout is set to USER_TIMER_MAXIMUM.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.WinDef.WinSta0">
            <summary>
            The interactive window station name, for use with <see cref="M:JetBrains.Interop.WinApi.User32Dll.OpenWindowStationW(System.String,System.Int32,System.UInt32)"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.WinDef.INFINITE">
            <summary>
            Infinite timeout.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.WinError">
             <summary>
             winerror.h --  error code definitions for the Win32 API functions.
             </summary>
             <remarks>
            <code>
              Values are 32 bit values laid out as follows:
            
               3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
               1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
              +---+-+-+-----------------------+-------------------------------+
              |Sev|C|R|     Facility          |               Code            |
              +---+-+-+-----------------------+-------------------------------+
            
              where
            
                  Sev - is the severity code
            
                      00 - Success
                      01 - Informational
                      10 - Warning
                      11 - Error
            
                  C - is the Customer code flag
            
                  R - is a reserved bit
            
                  Facility - is the facility code
            
                  Code - is the facility's status code
             </code>
             </remarks>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Gdi32Dll">
            <summary>
            User32.dll functions.
            Must be 64bit-safe.
            </summary>
            <remarks>
            IMPORTANT! Rules for authoring the class (v1.1):
            (1) All the function declarations MUST be 64-bit aware.
            (2) When copypasting from older declarations, you MUST check against the MSDN help or header declaration, 
               and you MUST ensure that each parameter has a proper size.
            (3) Call the Wide version of the functions (UCS-2-LE) unless there's a strong reason for calling the ANSI version 
               (such a reason MUST be indicated in XmlDoc). <c>CharSet = CharSet.Unicode</c>.
            (4) ExactSpelling MUST be TRUE. Add the "…W" suffix wherever needed.
            (5) SetLastError SHOULD be considered individually for each function. Setting it to <c>True</c> allows to report the errors,
               but slows down the execution of critical members.
            (6) These properties MUST be explicitly set on DllImport attributes of EACH import: 
               CharSet, PreserveSig, SetLastError, ExactSpelling.
            (7) CLR names MUST be used for types instead of C# ones, eg "Int32" not "int" and "Int64" not "long".
               This greately improves the understanding of the parameter sizes.
            (8) Sign of the types MUST be favored, eg "DWORD" is "UInt32" not "Int32".
            (9) Unsafe pointer types should be used for explicit and implicit pointers rather than IntPtr. 
               This way we outline the unsafety of the native calls, and also make it more clear for the 64bit transition.
               Eg "HANDLE" is "void*". If the rule forces you to mark some assembly as unsafe, it's an indication a managed utility
               incapsulating the call and the handle should be provided in one of the already-unsafe assemblies.
            (A) Same rules must apply to members of the structures.
            (B) All of the structures MUST have the [StructLayout(LayoutKind.Sequential)], [NoReorder] attributes, as appropriate.
            </remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Gdi32Dll.BitBlt(System.Void*,System.Int32,System.Int32,System.Int32,System.Int32,System.Void*,System.Int32,System.Int32,System.UInt32)">
            <summary>
            The BitBlt function performs a bit-block transfer of the color data corresponding to a rectangle of pixels from the specified source device context into a destination device context.
            </summary>
            <param name="hdcDest">handle to destination DC</param>
            <param name="nXDest">x-coord of destination upper-left corner</param>
            <param name="nYDest">y-coord of destination upper-left corner</param>
            <param name="nWidth">width of destination rectangle</param>
            <param name="nHeight">height of destination rectangle</param>
            <param name="hdcSrc">handle to source DC</param>
            <param name="nXSrc">x-coordinate of source upper-left corner</param>
            <param name="nYSrc">y-coordinate of source upper-left corner</param>
            <param name="dwRop">raster operation code. Use <see cref="T:JetBrains.Interop.WinApi.Declarations.Constants.RasterOperations"/>.</param>
            <returns>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Gdi32Dll.CreateCompatibleDC(System.Void*)">
            <summary>
            The CreateCompatibleDC function creates a memory device context (DC) compatible with the specified device. 
            </summary>
            <param name="hdc">Handle to an existing DC. If this handle is NULL, the function creates a memory DC compatible with the application's current screen.</param>
            <returns>If the function succeeds, the return value is the handle to a memory DC. If the function fails, the return value is NULL.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Gdi32Dll.CreateDCW(System.String,System.String,System.String,System.Void*)">
            <summary>
            The CreateDC function creates a device context (DC) for a device using the specified name. 
            </summary>
            <param name="lpszDriver">Windows 95/98/Me: The lpszDriver parameter can be NULL, WINSPL16 (a print provider), or (to obtain a display DC) it can be either the null-terminated string DISPLAY or the device name of a specific display device. If lpszDevice specifies a particular device, you must use NULL for lpszDriver. 
            Windows NT 4.0: Pointer to a null-terminated character string that specifies either DISPLAY or the name of a print provider, which is usually WINSPOOL. 
            Windows 2000/XP: Pointer to a null-terminated character string that specifies either DISPLAY or the name of a specific display device or the name of a print provider, which is usually WINSPOOL. </param>
            <param name="lpszDevice">[in] Pointer to a null-terminated character string that specifies the name of the specific output device being used, as shown by the Print Manager (for example, Epson FX-80). It is not the printer model name. The lpszDevice parameter must be used. 
            To obtain valid names for displays, call EnumDisplayDevices. 
            If lpszDriver is DISPLAY or the device name of a specific display device, then lpszDevice must be NULL or that same device name. If lpszDevice is NULL, then a DC is created for the primary display device. 
            Windows NT 3.51 and Windows NT 4.0: There is only one (thus the primary) display device. Set lpszDevice to NULL. 
            Windows 2000 and later: If there are multiple monitors on the system, calling CreateDC(TEXT("DISPLAY"),NULL,NULL,NULL) will create a DC covering all the monitors. </param>
            <param name="lpszOutput">This parameter is ignored and should be set to NULL. It is provided only for compatibility with 16-bit Windows.</param>
            <param name="lpInitData">[in] Pointer to a DEVMODE structure containing device-specific initialization data for the device driver. The DocumentProperties function retrieves this structure filled in for a specified device. The lpInitData parameter must be NULL if the device driver is to use the default initialization (if any) specified by the user. 
            If lpszDriver is DISPLAY, then lpInitData must be NULL. The display device's current DEVMODE is used</param>
            <returns>If the function succeeds, the return value is the handle to a DC for the specified device. If the function fails, the return value is NULL. The function will return NULL for a DEVMODE structure other than the current DEVMODE.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Gdi32Dll.GetDeviceCaps(System.Void*,System.Int32)">
            <summary>
            The GetDeviceCaps function retrieves device-specific information for the specified device.
            </summary>
            <param name="hdc">A handle to the DC.</param>
            <param name="capindex">The item to be returned. See <seealso cref="T:JetBrains.Interop.WinApi.Declarations.Constants.DeviceCapabilityIndex"/> for possible values</param>
            <returns>The return value specifies the value of the desired item.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Gdi32Dll.CreateDIBSection(System.Void*,JetBrains.Interop.WinApi.Declarations.Structures.BITMAPINFO*,System.UInt32,System.Void**,System.Void*,System.Int32)">
            <summary>
            The CreateDIBSection function creates a DIB that applications can write to directly. The function gives you a pointer to the location of the bitmap bit values. You can supply a handle to a file-mapping object that the function will use to create the bitmap, or you can let the system allocate the memory for the bitmap.
            </summary>
            <param name="hdc">handle to DC</param>
            <param name="pbmi">bitmap data</param>
            <param name="iUsage">data type indicator. Use <see cref="T:JetBrains.Interop.WinApi.Declarations.Constants.DibColors"/>.</param>
            <param name="ppvBits">bit values</param>
            <param name="hSection">handle to file mapping object</param>
            <param name="dwOffset">offset to bitmap bit values</param>
            <returns>If the function succeeds, the return value is a handle to the newly created DIB, and *ppvBits points to the bitmap bit values. 
            If the function fails, the return value is NULL, and *ppvBits is NULL. </returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Gdi32Dll.CreateDIBitmap(System.Void*,JetBrains.Interop.WinApi.Declarations.Structures.BITMAPINFOHEADER*,System.UInt32,System.Void*,JetBrains.Interop.WinApi.Declarations.Structures.BITMAPINFO*,System.UInt32)">
            <summary>
            The CreateDIBitmap function creates a compatible bitmap (DDB) from a DIB and, optionally, sets the bitmap bits.
            </summary>
            <param name="hdc">handle to DC</param>
            <param name="lpbmih">bitmap data</param>
            <param name="fdwInit">initialization option</param>
            <param name="lpbInit">initialization data</param>
            <param name="lpbmi">color-format data</param>
            <param name="fuUsage">color-data usage. Use <see cref="T:JetBrains.Interop.WinApi.Declarations.Constants.DibColors"/>.</param>
            <returns>If the function succeeds, the return value is a handle to the compatible bitmap. 
            If the function fails, the return value is NULL.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Gdi32Dll.CreatePen(System.Int32,System.Int32,System.UInt32)">
            <summary>
            The CreatePen function creates a logical pen that has the specified style, width, and color. The pen can subsequently be selected into a device context and used to draw lines and curves. 
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Gdi32Dll.DeleteDC(System.Void*)">
            <summary>
            The DeleteDC function deletes the specified device context (DC).
            </summary>
            <param name="hDC">handle to DC</param>
            <returns>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Gdi32Dll.DeleteObject(System.Void*)">
            <summary>
            The DeleteObject function deletes a logical pen, brush, font, bitmap, region, or palette, freeing all system resources associated with the object. After the object is deleted, the specified handle is no longer valid. 
            </summary>
            <param name="hGDIObj">[in] Handle to a logical pen, brush, font, bitmap, region, or palette. </param>
            <returns>If the function succeeds, the return value is nonzero.
            If the specified handle is not valid or is currently selected into a DC, the return value is zero. 
            Windows NT/2000/XP: To get extended error information, call GetLastError.</returns>
            <remarks>
            Do not delete a drawing object (pen or brush) while it is still selected into a DC.
            When a pattern brush is deleted, the bitmap associated with the brush is not deleted. The bitmap must be deleted independently.
            </remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Gdi32Dll.GdiFlush">
            <summary>
            The GdiFlush function flushes the calling thread's current batch.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Gdi32Dll.GetStockObject(System.Int32)">
            <summary>
            The GetStockObject function retrieves a handle to one of the stock pens, brushes, fonts, or palettes.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Gdi32Dll.SelectObject(System.Void*,System.Void*)">
            <summary>
            The SelectObject function selects an object into the specified device context (DC). The new object replaces the previous object of the same type. 
            </summary>
            <param name="hDC">[in] Handle to the DC. </param>
            <param name="hGDIObj">[in] Handle to the object to be selected. The specified object must have been created by using one of the following functions. 
            Object Functions 
            Bitmap CreateBitmap, CreateBitmapIndirect, CreateCompatibleBitmap, CreateDIBitmap, CreateDIBSection (Bitmaps can be selected for memory DCs only, and for only one DC at a time.)
            Brush CreateBrushIndirect, CreateDIBPatternBrush, CreateDIBPatternBrushPt, CreateHatchBrush, CreatePatternBrush, CreateSolidBrush 
            Font CreateFont, CreateFontIndirect 
            Pen CreatePen, CreatePenIndirect 
            Region CombineRgn, CreateEllipticRgn, CreateEllipticRgnIndirect, CreatePolygonRgn, CreateRectRgn, CreateRectRgnIndirect
            </param>
            <returns>
            If the selected object is not a region and the function succeeds, the return value is a handle to the object being replaced. If the selected object is a region and the function succeeds, the return value is one of the following values.
            Value Meaning 
            SIMPLEREGION Region consists of a single rectangle. 
            COMPLEXREGION Region consists of more than one rectangle. 
            NULLREGION Region is empty. 
            If an error occurs and the selected object is not a region, the return value is NULL. Otherwise, it is HGDI_ERROR. 
            </returns>
            <remarks>
            This function returns the previously selected object of the specified type. An application should always replace a new object with the original, default object after it has finished drawing with the new object. 
            An application cannot select a bitmap into more than one DC at a time. 
            ICM: If the object being selected is a brush or a pen, color management is performed. 
            </remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Gdi32Dll.StretchBlt(System.Void*,System.Int32,System.Int32,System.Int32,System.Int32,System.Void*,System.Int32,System.Int32,System.Int32,System.Int32,System.UInt32)">
            <summary>
            The StretchBlt function copies a bitmap from a source rectangle into a destination rectangle, stretching or compressing the bitmap to fit the dimensions of the destination rectangle, if necessary. The system stretches or compresses the bitmap according to the stretching mode currently set in the destination device context. 
            </summary>
            <param name="hdcDest">[in] Handle to the destination device context.</param>
            <param name="nXOriginDest">[in] Specifies the x-coordinate, in logical units, of the upper-left corner of the destination rectangle. </param>
            <param name="nYOriginDest">[in] Specifies the y-coordinate, in logical units, of the upper-left corner of the destination rectangle. </param>
            <param name="nWidthDest">[in] Specifies the width, in logical units, of the destination rectangle. </param>
            <param name="nHeightDest">[in] Specifies the height, in logical units, of the destination rectangle.</param>
            <param name="hdcSrc">[in] Handle to the source device context. </param>
            <param name="nXOriginSrc">[in] Specifies the x-coordinate, in logical units, of the upper-left corner of the source rectangle.</param>
            <param name="nYOriginSrc">[in] Specifies the y-coordinate, in logical units, of the upper-left corner of the source rectangle.</param>
            <param name="nWidthSrc">[in] Specifies the width, in logical units, of the source rectangle. </param>
            <param name="nHeightSrc">[in] Specifies the height, in logical units, of the source rectangle. </param>
            <param name="dwRop">[in] Specifies the raster operation to be performed. Raster operation codes define how the system combines colors in output operations that involve a brush, a source bitmap, and a destination bitmap. See BitBlt for a list of common raster operation codes (ROPs). Note that the CAPTUREBLT ROP generally cannot be used for printing device contexts. Use the <see cref="T:JetBrains.Interop.WinApi.Declarations.Constants.RasterOperations"/> enum.</param>
            <returns>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. Windows NT/2000/XP: To get extended error information, call GetLastError. </returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Gdi32Dll.CreateRectRgn(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            The CreateRectRgn function creates a rectangular region.
            </summary>
            <param name="nLeftRect">[in] Specifies the x-coordinate of the upper-left corner of the region in logical units. </param>
            <param name="nTopRect">[in] Specifies the y-coordinate of the upper-left corner of the region in logical units. </param>
            <param name="nRightRect">[in] Specifies the x-coordinate of the lower-right corner of the region in logical units.</param>
            <param name="nBottomRect">[in] Specifies the y-coordinate of the lower-right corner of the region in logical units.</param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Gdi32Dll.CombineRgn(System.Void*,System.Void*,System.Void*,System.Int32)">
            <summary>
            The CombineRgn function combines two regions and stores the result in a third region. The two regions are combined according to the specified mode.
            </summary>
            <param name="hrgnDest">[in] Handle to a new region with dimensions defined by combining two other regions. (This region must exist before CombineRgn is called.) </param>
            <param name="hrgnSrc1">[in] Handle to the first of two regions to be combined.</param>
            <param name="hrgnSrc2">[in] Handle to the second of two regions to be combined.</param>
            <param name="fnCombineMode">[in] Specifies a mode indicating how the two regions will be combined. This parameter can be one of the following values. </param>
            <returns>The return value specifies the type of the resulting region. It can be one of the following values. </returns>
            <remarks>The three regions need not be distinct. For example, the hrgnSrc1 parameter can equal the hrgnDest parameter. </remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Gdi32Dll.SetDCBrushColor(System.Void*,System.UInt32)">
            <summary>
            SetDCBrushColor function sets the current device context (DC) brush color to the specified color value. If the device cannot represent the specified color value, the color is set to the nearest physical color.
            </summary>
            <param name="hdc">[in] Handle to the DC.</param>
            <param name="colorref">[in] Specifies the new brush color.</param>
            <returns>If the function succeeds, the return value specifies the previous DC brush color as a COLORREF value. If the function fails, the return value is CLR_INVALID.</returns>
        </member>
        <member name="T:JetBrains.Interop.WinApi.HwndSpecial">
            <summary>
            Special HWND values.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.KeyStateMasks">
            <summary>
            Key State Masks for Mouse Messages.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.PenStyles">
            <summary>
            Pen Styles.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.PrintWindowFlags">
            <summary>
            Specifies the drawing options [for WM_PRINT]. You can combine one or more of the following flags.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.PrintWindowFlags.PRF_CHECKVISIBLE">
            <summary>
            Draw the window only if it is visible.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.PrintWindowFlags.PRF_NONCLIENT">
            <summary>
            Draw the non-client area of the window.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.PrintWindowFlags.PRF_CLIENT">
            <summary>
            Draw the client area of the window.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.PrintWindowFlags.PRF_ERASEBKGND">
            <summary>
            Erase the background before drawing the window.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.PrintWindowFlags.PRF_CHILDREN">
            <summary>
            Draw all visible child windows.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.PrintWindowFlags.PRF_OWNED">
            <summary>
            Draw all owned windows.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.WmActivateCodes">
            <summary>
            WM_ACTIVATE wParam loword value.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.WmActivateCodes.Inactive">
            <summary>
            Deactivated.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.WmActivateCodes.Active">
            <summary>
            Activated by some method other than a mouse click (for example, by a call to the <see cref="M:JetBrains.Interop.WinApi.User32Dll.SetActiveWindow(System.Void*)"/> function or by use of the keyboard interface to select the window).
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.WmActivateCodes.ClickActive">
            <summary>
            Activated by a mouse click.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.WmMouseActivateReturnCodes">
            <summary>
            <see cref="F:JetBrains.Interop.WinApi.WindowsMessages.WM_MOUSEACTIVATE"/> return codes.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.HResultHelpers">
            <summary>
            Helper methods related to the <c>HRESULT</c> type.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.HResultHelpers.Assert(System.Int32,System.Int32[])">
            <summary>
            Checks the given <c>HRESULT</c>, if it's a failure one (<see cref="M:JetBrains.Interop.WinApi.HResultHelpers.FAILED(System.Int32)"/>), and is not contained in <paramref name="expectedHRFailure"/>, then an exception-from-hresult is thrown.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.HResultHelpers.Assert(System.Int32)">
            <summary>
            Checks the given <c>HRESULT</c>, and throws an exception if it's a failure one (<see cref="M:JetBrains.Interop.WinApi.HResultHelpers.FAILED(System.Int32)"/>).
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.HResultHelpers.Assert(JetBrains.Interop.WinApi.HResults)">
            <summary>
            Checks the given <c>HRESULT</c>, and throws an exception if it's a failure one (<see cref="M:JetBrains.Interop.WinApi.HResultHelpers.FAILED(System.Int32)"/>).
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.HResultHelpers.Assert(System.Int32,System.String)">
            <summary>
            Checks the given <c>HRESULT</c>, and throws an exception if it's a failure one (<see cref="M:JetBrains.Interop.WinApi.HResultHelpers.FAILED(System.Int32)"/>).
            The comment is used in case of the failure only.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.HResultHelpers.Assert(JetBrains.Interop.WinApi.HResults,System.String)">
            <summary>
            Checks the given <c>HRESULT</c>, and throws an exception if it's a failure one (<see cref="M:JetBrains.Interop.WinApi.HResultHelpers.FAILED(System.Int32)"/>).
            The comment is used in case of the failure only.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.HResultHelpers.Assert(JetBrains.Interop.WinApi.HResults,System.Action{System.Exception})">
            <summary>
            Checks the given <c>HRESULT</c>, and throws an exception if it's a failure one (<see cref="M:JetBrains.Interop.WinApi.HResultHelpers.FAILED(System.Int32)"/>).
            The FComment function is called in case of the failure only, should use <see cref="!:ExceptionEx.AddData"/> to contribute to the exception report.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.HResultHelpers.FAILED(JetBrains.Interop.WinApi.HResults)">
            <summary>
            The <c>FAILED</c> WinAPI Macro.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.HResultHelpers.FAILED(System.Int32)">
            <summary>
            The <c>FAILED</c> WinAPI Macro.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.HResultHelpers.SUCCEEDED(JetBrains.Interop.WinApi.HResults)">
            <summary>
            The <c>SUCCEEDED</c> WinAPI Macro.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.HResultHelpers.SUCCEEDED(System.Int32)">
            <summary>
            The <c>SUCCEEDED</c> WinAPI Macro.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Kernel32Dll">
            <summary>
            Kernel32.dll functions.
            Must be 64bit-safe.
            </summary>
            <remarks>
            IMPORTANT! Rules for authoring the class (v1.1):
            (1) All the function declarations MUST be 64-bit aware.
            (2) When copypasting from older declarations, you MUST check against the MSDN help or header declaration, 
               and you MUST ensure that each parameter has a proper size.
            (3) Call the Wide version of the functions (UCS-2-LE) unless there's a strong reason for calling the ANSI version 
               (such a reason MUST be indicated in XmlDoc). <c>CharSet = CharSet.Unicode</c>.
            (4) ExactSpelling MUST be TRUE. Add the "…W" suffix wherever needed.
            (5) SetLastError SHOULD be considered individually for each function. Setting it to <c>True</c> allows to report the errors,
               but slows down the execution of critical members.
            (6) These properties MUST be explicitly set on DllImport attributes of EACH import: 
               CharSet, PreserveSig, SetLastError, ExactSpelling.
            (7) CLR names MUST be used for types instead of C# ones, eg "Int32" not "int" and "Int64" not "long".
               This greately improves the understanding of the parameter sizes.
            (8) Sign of the types MUST be favored, eg "DWORD" is "UInt32" not "Int32".
            (9) Unsafe pointer types should be used for explicit and implicit pointers rather than IntPtr. 
               This way we outline the unsafety of the native calls, and also make it more clear for the 64bit transition.
               Eg "HANDLE" is "void*". If the rule forces you to mark some assembly as unsafe, it's an indication a managed utility
               incapsulating the call and the handle should be provided in one of the already-unsafe assemblies.
            (A) Same rules must apply to members of the structures.
            (B) All of the structures MUST have the [StructLayout(LayoutKind.Sequential)], [NoReorder] attributes, as appropriate.
            </remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.CloseHandle(System.Void*)">
            <summary>
            Closes an open object handle.
            </summary>
            <param name="hObject">A valid handle to an open object.</param>
            <returns>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call GetLastError. If the application is running under a debugger, the function will throw an exception if it receives either a handle value that is not valid or a pseudo-handle value. This can happen if you close a handle twice, or if you call CloseHandle on a handle returned by the FindFirstFile function.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.ConvertThreadToFiber(System.Void*)">
            <summary>
            Converts the current thread into a fiber. You must convert a thread into a fiber before you can schedule other fibers.
            </summary>
            <param name="lpParameter">A pointer to a variable that is passed to the fiber. The fiber can retrieve this data by using the GetFiberData macro.</param>
            <returns>If the function succeeds, the return value is the address of the fiber. If the function fails, the return value is NULL. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.CreateFiber(System.IntPtr,System.Void*,System.Void*)">
            <summary>
            Allocates a fiber object, assigns it a stack, and sets up execution to begin at the specified start address, typically the fiber function. This function does not schedule the fiber. To specify both a commit and reserve stack size, use the CreateFiberEx function.
            </summary>
            <param name="dwStackSize">The initial size of the stack, in bytes. If this parameter is zero, the new fiber uses the default stack size for the executable. For more information, see Thread Stack Size.</param>
            <param name="lpStartAddress">A pointer to the application-defined function to be executed by the fiber and represents the starting address of the fiber. Execution of the newly created fiber does not begin until another fiber calls the SwitchToFiber function with this address. For more information of the fiber callback function, see FiberProc.</param>
            <param name="lpParameter">A pointer to a variable that is passed to the fiber. The fiber can retrieve this data by using the GetFiberData macro.</param>
            <returns>If the function succeeds, the return value is the address of the fiber. If the function fails, the return value is NULL. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.CreateToolhelp32Snapshot(System.UInt32,System.UInt32)">
            <summary>
            Takes a snapshot of the specified processes, as well as the heaps, modules, and threads used by these processes.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.DeleteFiber(System.Void*)">
            <summary>
            Deletes an existing fiber.
            </summary>
            <param name="lpFiber">The address of the fiber to be deleted.</param>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.FindResourceW(System.Void*,System.String,System.String)">
            <summary>
            Determines the location of a resource with the specified type and name in the specified module. To specify a language, use the FindResourceEx function.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.FindResourceW(System.Void*,System.Char*,System.Char*)">
            <summary>
            Determines the location of a resource with the specified type and name in the specified module. To specify a language, use the FindResourceEx function.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.GetCurrentProcess">
            <summary>
            Retrieves a pseudo handle for the current process.
            </summary>
            <returns>The return value is a pseudo handle to the current process.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.GetCurrentProcessId">
            <summary>
            Retrieves the process identifier of the calling process.
            </summary>
            <returns>The return value is the process identifier of the calling process.</returns>
            <remarks>Until the process terminates, the process identifier uniquely identifies the process throughout the system.</remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.OpenProcess(System.UInt32,System.Boolean,System.UInt32)">
            <summary>
            Opens an existing local process object.
            </summary>
            <param name="access">The access to the process object.</param>
            <param name="inherit">If this value is TRUE, processes created by this process will inherit the handle.</param>
            <param name="processId">The identifier of the local process to be opened. If the specified process is the System Process (0x00000000), the function fails and the last error code is ERROR_INVALID_PARAMETER. If the specified process is the Idle process or one of the CSRSS processes, this function fails and the last error code is ERROR_ACCESS_DENIED because their access restrictions prevent user-level code from opening them.</param>
            <returns>If the function succeeds, the return value is an open handle to the specified process. If the function fails, the return value is NULL. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.GetCurrentThreadId">
            <summary>
            The GetCurrentThreadId function retrieves the thread identifier of the calling thread.
            Note: same as <see cref="M:System.AppDomain.GetCurrentThreadId"/>, but doesn't raise the “Obsolete” warning.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.GetFileAttributesW(System.String)">
            <summary>
            Retrieves file system attributes for a specified file or directory.
            </summary>
            <param name="lpFileName">[in] The name of the file or directory.</param>
            <returns>If the function succeeds, the return value contains the attributes of the specified file or directory.
            If the function fails, the return value is INVALID_FILE_ATTRIBUTE.
            </returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.GetFileAttributesExW(System.String,JetBrains.Interop.WinApi.Declarations.Constants.GET_FILEEX_INFO_LEVELS,JetBrains.Interop.WinApi.Declarations.Structures.WIN32_FILE_ATTRIBUTE_DATA@)">
            <summary>
            Retrieves attributes for a specified file or directory.
            </summary>
            <param name="lpFileName">The name of the file or directory.</param>
            <param name="fInfoLevelId">A class of attribute information to retrieve. This parameter can be the following value from the GET_FILEEX_INFO_LEVELS enumeration.</param>
            <param name="lpFileInformation">A pointer to a buffer that receives the attribute information. The type of attribute information that is stored into this buffer is determined by the value of <paramref name="fInfoLevelId"/></param>
            <returns>If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero (0). To get extended error information, call <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/>.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.GetModuleFileNameW(System.Void*,System.Char*,System.UInt32)">
            <summary>
            Retrieves the fully-qualified path for the file that contains the specified module. The module must have been loaded by the current process. 
            To locate the file for a module that was loaded by another process, use the GetModuleFileNameEx function. 
            </summary>
            <param name="hModule">
            A handle to the loaded module whose path is being requested. If this parameter is NULL, GetModuleFileName retrieves the path of the executable file of the current process.
            The GetModuleFileName function does not retrieve the path for modules that were loaded using the LOAD_LIBRARY_AS_DATAFILE flag. For more information, see LoadLibraryEx. 
            </param>
            <param name="lpFilename">
            A pointer to a buffer that receives the fully-qualified path of the module. If the length of the path is less than the size that the nSize parameter specifies, the function succeeds and the path is returned as a null-terminated string. 
            If the length of the path exceeds the size that the nSize parameter specifies, the function succeeds and the string is truncated to nSize characters including the terminating null character. 
            Windows XP/2000:  The string is truncated to nSize characters and is not null terminated. 
            The string returned will use the same format that was specified when the module was loaded. Therefore, the path can be a long or short file name, and can use the prefix "\\?\". For more information, see Naming a File. 
            </param>
            <param name="nSize">The size of the lpFilename buffer, in TCHARs.</param>
            <returns>
            If the function succeeds, the return value is the length of the string that is copied to the buffer, in characters, not including the terminating null character. If the buffer is too small to hold the module name, the string is truncated to nSize characters including the terminating null character, the function returns nSize, and the function sets the last error to ERROR_INSUFFICIENT_BUFFER. 
            Windows XP/2000:  If the buffer is too small to hold the module name, the function returns nSize. The last error code remains ERROR_SUCCESS. If nSize is zero, the return value is zero and the last error code is ERROR_SUCCESS. 
            If the function fails, the return value is 0 (zero). To get extended error information, call GetLastError. 
            </returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.GetModuleHandleW(System.String)">
            <summary>
            Retrieves a module handle for the specified module. The module must have been loaded by the calling process. 
            To avoid the race conditions described in the Remarks section, use the GetModuleHandleEx function.
            </summary>
            <param name="lpModuleName">The name of the loaded module (either a .dll or .exe file). 
            If the file name extension is omitted, the default library extension .dll is appended. 
            The file name string can include a trailing point character (.) to indicate that the module name has no extension. 
            The string does not have to specify a path. When specifying a path, be sure to use backslashes (\), not forward slashes (/). 
            The name is compared (case independently) to the names of modules currently mapped into the address space of the calling process. 
            If this parameter is NULL, GetModuleHandle returns a handle to the file used to create the calling process (.exe file). 
            The GetModuleHandle function does not retrieve handles for modules that were loaded using the LOAD_LIBRARY_AS_DATAFILE flag. 
            For more information, see LoadLibraryEx.</param>
            <returns>If the function succeeds, the return value is a handle to the specified module. 
            If the function fails, the return value is NULL. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.GetNativeSystemInfo(JetBrains.Interop.WinApi.SYSTEM_INFO*)">
            <summary>
            Retrieves information about the current system to an application running under WOW64. If the function is called from a 64-bit application, it is equivalent to the GetSystemInfo function.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.GetPrivateProfileIntW(System.String,System.String,System.Int32,System.String)">
            <summary>
            Retrieves an integer associated with a key in the specified section of an initialization file. Note: This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.GetPrivateProfileStringW(System.String,System.String,System.String,System.UInt16*,System.UInt32,System.String)">
            <summary>
            Retrieves a string from the specified section in an initialization file.
            Note: This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.GetProcAddress(System.Void*,System.String)">
            <summary>
            Retrieves the address of an exported function or variable from the specified dynamic-link library (DLL).
            </summary>
            <param name="hModule">A handle to the DLL module that contains the function or variable. The LoadLibrary or GetModuleHandle function returns this handle.</param>
            <param name="lpProcName">The function or variable name, or the function's ordinal value. If this parameter is an ordinal value, it must be in the low-order word; the high-order word must be zero.</param>
            <returns>If the function succeeds, the return value is the address of the exported function or variable. If the function fails, the return value is NULL. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.GetSystemInfo(JetBrains.Interop.WinApi.SYSTEM_INFO*)">
            <summary>
            Retrieves information about the current system. To retrieve accurate information for an application running on WOW64, call the GetNativeSystemInfo function.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.LoadLibraryW(System.String)">
            <summary>
            The LoadLibrary function maps the specified executable module into the address space of the calling process. 
            For additional load options, use the LoadLibraryEx function.
            </summary>
            <param name="lpFileName">[in] Pointer to a null-terminated string that names the executable module (either a .dll or .exe file). The name specified is the file name of the module and is not related to the name stored in the library module itself, as specified by the LIBRARY keyword in the module-definition (.def) file. 
            If the string specifies a path but the file does not exist in the specified directory, the function fails. When specifying a path, be sure to use backslashes (\), not forward slashes (/).
            If the string does not specify a path, the function uses a standard search strategy to find the file. See the Remarks for more information.</param>
            <returns>If the function succeeds, the return value is a handle to the module.
            If the function fails, the return value is NULL. To get extended error information, call GetLastError.
            Windows Me/98/95:  If you are using LoadLibrary to load a module that contains a resource whose numeric identifier is greater than 0x7FFF, LoadLibrary fails. 
            If you are attempting to load a 16-bit DLL directly from 32-bit code, LoadLibrary fails. If you are attempting to load a DLL whose subsystem version is greater than 4.0, LoadLibrary fails. If your DllMain function tries to call the Unicode version of a function, LoadLibrary fails.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.FreeLibrary(System.Void*)">
            <summary>
            Frees the loaded dynamic-link library (DLL) module and, if necessary, decrements its reference count. 
            When the reference count reaches zero, the module is unloaded from the address space of the calling process and the handle is no longer valid.
            </summary>
            <param name="hModule">[in] A handle to the loaded library module. 
            The LoadLibrary, LoadLibraryEx, GetModuleHandle, or GetModuleHandleEx function returns this handle.</param>
            <returns>If the function succeeds, the return value is nonzero. 
            If the function fails, the return value is zero. To get extended error information, call the GetLastError function.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.SetDllDirectoryW(System.String)">
            <summary>
            Adds a directory to the search path used to locate DLLs for the application.
            The <c>SetDllDirectory</c> function affects all subsequent calls to the <c>LoadLibrary</c> and <c>LoadLibraryEx</c> functions. 
            It also effectively disables safe DLL search mode while the specified directory is in the search path.
            </summary>
            <param name="lpPathName">[in, optional] The directory to be added to the search path. 
            If this parameter is an empty string (""), the call removes the current directory from the default DLL search order.
            If this parameter is NULL, the function restores the default search order.</param>
            <returns>If the function succeeds, the return value is nonzero. 
            If the function fails, the return value is zero. To get extended error information, call GetLastError. </returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.LoadResource(System.Void*,System.Void*)">
            <summary>
            Loads the specified resource into global memory. 
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.LockResource(System.Void*)">
            <summary>
            Locks the specified resource in memory. 
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.OutputDebugStringW(System.String)">
            <summary>
            The OutputDebugString function sends a string to the debugger for display.
            </summary>
            <param name="lpOutputString">[in] Pointer to the null-terminated string to be displayed.</param>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.Process32FirstW(System.Void*,System.Void*)">
            <summary>
            Retrieves information about the first process encountered in a system snapshot.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.Module32FirstW(System.Void*,System.Void*)">
            <summary>
            Retrieves information about the first module associated with a process.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.Module32NextW(System.Void*,System.Void*)">
            <summary>
            Retrieves information about the next module associated with a process or thread.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.QueryPerformanceCounter(System.UInt64*)">
            <summary>
            The QueryPerformanceCounter function retrieves the current value of the high-resolution performance counter.
            </summary>
            <param name="lpPerformanceCount">[out] Pointer to a variable that receives the current performance-counter value, in counts.</param>
            <returns>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call GetLastError.</returns>
            <remarks>On a multiprocessor computer, it should not matter which processor is called. However, you can get different results on different processors due to bugs in the basic input/output system (BIOS) or the hardware abstraction layer (HAL). To specify processor affinity for a thread, use the SetThreadAffinityMask function. </remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.QueryPerformanceFrequency(System.UInt64*)">
            <summary>
            The QueryPerformanceFrequency function retrieves the frequency of the high-resolution performance counter, if one exists. The frequency cannot change while the system is running.
            </summary>
            <param name="lpFrequency">[out] Pointer to a variable that receives the current performance-counter frequency, in counts per second. If the installed hardware does not support a high-resolution performance counter, this parameter can be zero. </param>
            <returns>If the installed hardware supports a high-resolution performance counter, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call GetLastError. For example, if the installed hardware does not support a high-resolution performance counter, the function fails. </returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.RtlCopyMemory(System.Void*,System.Void*,System.UIntPtr)">
            <summary>
            The <see cref="M:JetBrains.Interop.WinApi.Kernel32Dll.RtlCopyMemory(System.Void*,System.Void*,System.UIntPtr)"/> routine copies the contents of one buffer to another.
            </summary>
            <param name="Destination">Pointer to the destination of the move.</param>
            <param name="Source">Pointer to the memory to be copied.</param>
            <param name="Length">Specifies the number of bytes to be copied.</param>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.RtlMoveMemory(System.Void*,System.Void*,System.UIntPtr)">
            <summary>
            The <see cref="M:JetBrains.Interop.WinApi.Kernel32Dll.RtlMoveMemory(System.Void*,System.Void*,System.UIntPtr)"/> routine moves memory either forward or backward, aligned or unaligned, in 4-byte blocks, followed by any remaining bytes.
            </summary>
            <param name="Destination">Pointer to the destination of the move.</param>
            <param name="Source">Pointer to the memory to be copied.</param>
            <param name="Length">Specifies the number of bytes to be copied.</param>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.SizeofResource(System.Void*,System.Void*)">
            <summary>
            Returns the size, in bytes, of the specified resource. 
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.SwitchToFiber(System.Void*)">
            <summary>
            Schedules a fiber. The function must be called on a fiber.
            </summary>
            <param name="lpFiber">The address of the fiber to be scheduled.</param>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.VirtualAlloc(System.Void*,System.IntPtr,System.UInt32,System.UInt32)">
            <summary>
            Reserves or commits a region of pages in the virtual address space of the calling process. Memory allocated by this function is automatically initialized to zero, unless MEM_RESET is specified.
            To allocate memory in the address space of another process, use the VirtualAllocEx function.
            </summary>
            <param name="lpAddress">The starting address of the region to allocate. If the memory is being reserved, the specified address is rounded down to the nearest multiple of the allocation granularity. If the memory is already reserved and is being committed, the address is rounded down to the next page boundary. To determine the size of a page and the allocation granularity on the host computer, use the GetSystemInfo function. If this parameter is NULL, the system determines where to allocate the region.</param>
            <param name="dwSize">The size of the region, in bytes. If the lpAddress parameter is NULL, this value is rounded up to the next page boundary. Otherwise, the allocated pages include all pages containing one or more bytes in the range from lpAddress to lpAddress+dwSize. This means that a 2-byte range straddling a page boundary causes both pages to be included in the allocated region.</param>
            <param name="flAllocationType">The type of memory allocation. See <see cref="T:JetBrains.Interop.WinApi.Declarations.Constants.MemoryAllocationTypes"/>.</param>
            <param name="flProtect">The memory protection for the region of pages to be allocated. If the pages are being committed, you can specify any one of the <see cref="T:JetBrains.Interop.WinApi.Declarations.Constants.MemoryProtectionConstants">memory protection constants</see>.</param>
            <returns>If the function succeeds, the return value is the base address of the allocated region of pages.
            If the function fails, the return value is NULL. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.VirtualProtect(System.Void*,System.IntPtr,System.UInt32,System.UInt32*)">
            <summary>
            Changes the protection on a region of committed pages in the virtual address space of the calling process.
            To change the access protection of any process, use the VirtualProtectEx function.
            </summary>
            <param name="lpAddress">A pointer to the base address of the region of pages whose access protection attributes are to be changed. 
            All pages in the specified region must be within the same reserved region allocated when calling the VirtualAlloc or VirtualAllocEx function using MEM_RESERVE. The pages cannot span adjacent reserved regions that were allocated by separate calls to VirtualAlloc or VirtualAllocEx using MEM_RESERVE.The size of the region whose access protection attributes are to be changed, in bytes. The region of affected pages includes all pages containing one or more bytes in the range from the lpAddress parameter to (lpAddress+dwSize). This means that a 2-byte range straddling a page boundary causes the protection attributes of both pages to be changed.</param>
            <param name="dwSize">The size of the region whose access protection attributes are to be changed, in bytes. The region of affected pages includes all pages containing one or more bytes in the range from the lpAddress parameter to (lpAddress+dwSize). This means that a 2-byte range straddling a page boundary causes the protection attributes of both pages to be changed.</param>
            <param name="flNewProtect">The memory protection option. This parameter can be one of the <see cref="T:JetBrains.Interop.WinApi.Declarations.Constants.MemoryProtectionConstants">memory protection constants</see>.
            This value must be compatible with the access protection specified for the pages using VirtualAlloc or VirtualAllocEx.</param>
            <param name="lpflOldProtect">A pointer to a variable that receives the previous access protection value of the first page in the specified region of pages. If this parameter is NULL or does not point to a valid variable, the function fails.</param>
            <returns>If the function succeeds, the return value is nonzero.
            If the function fails, the return value is zero. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.VirtualQuery(System.Void*,JetBrains.Interop.WinApi.Declarations.Structures.MEMORY_BASIC_INFORMATION*,System.IntPtr)">
            <summary>
            Retrieves information about a range of pages in the virtual address space of the calling process.
            To retrieve information about a range of pages in the address space of another process, use the VirtualQueryEx function.
            </summary>
            <param name="lpAddress">A pointer to the base address of the region of pages to be queried. This value is rounded down to the next page boundary. To determine the size of a page on the host computer, use the GetSystemInfo function.
            If lpAddress specifies an address above the highest memory address accessible to the process, the function fails with ERROR_INVALID_PARAMETER.
            </param>
            <param name="lpBuffer">A pointer to a <see cref="T:JetBrains.Interop.WinApi.Declarations.Structures.MEMORY_BASIC_INFORMATION"/> structure in which information about the specified page range is returned.</param>
            <param name="dwLength">The size of the buffer pointed to by the lpBuffer parameter, in bytes.</param>
            <returns>The return value is the actual number of bytes returned in the information buffer.
            If the function fails, the return value is zero. To get extended error information, call GetLastError. Possible error values include ERROR_INVALID_PARAMETER.
            </returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.WaitForMultipleObjects(System.UInt32,System.Void**,System.Int32,System.UInt32)">
            <summary>
            Waits until one or all of the specified objects are in the signaled state or the time-out interval elapses. To enter an alertable wait state, use the WaitForMultipleObjectsEx function.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.WaitForSingleObject(System.Void*,System.UInt32)">
            <summary>
            Waits until the specified object is in the signaled state or the time-out interval elapses. To enter an alertable wait state, use the WaitForSingleObjectEx function. To wait for multiple objects, use the WaitForMultipleObjects.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.WritePrivateProfileStringW(System.String,System.String,System.String,System.String)">
            <summary>
            Copies a string into the specified section of an initialization file.
            Note  This function is provided only for compatibility with 16-bit versions of Windows. Applications should store initialization information in the registry.
            </summary>
            <param name="lpAppName">The name of the section to which the string will be copied. If the section does not exist, it is created. The name of the section is case-independent; the string can be any combination of uppercase and lowercase letters.</param>
            <param name="lpKeyName">The name of the key to be associated with a string. If the key does not exist in the specified section, it is created. If this parameter is NULL, the entire section, including all entries within the section, is deleted.</param>
            <param name="lpString">A null-terminated string to be written to the file. If this parameter is NULL, the key pointed to by the lpKeyName parameter is deleted. 
            Windows Me/98/95:  The system does not support the use of the TAB (\t) character as part of this parameter.</param>
            <param name="lpFileName">The name of the initialization file.
            If the file was created using Unicode characters, the function writes Unicode characters to the file. Otherwise, the function writes ANSI characters.</param>
            <returns>If the function successfully copies the string to the initialization file, the return value is nonzero. If the function fails, or if it flushes the cached version of the most recently accessed initialization file, the return value is zero. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.CreateFileW(System.String,System.UInt32,System.UInt32,JetBrains.Interop.WinApi.SECURITY_ATTRIBUTES*,System.UInt32,System.UInt32,System.Void*)">
            <summary>
            The CreateFile function creates or opens a file, file stream, directory, physical disk, volume, console buffer, tape drive,
            communications resource, mailslot, or named pipe. The function returns a handle that can be used to access an object.
            </summary>
            <param name="lpFileName"></param>
            <param name="dwDesiredAccess"> access to the object, which can be read, write, or both</param>
            <param name="dwShareMode">The sharing mode of an object, which can be read, write, both, or none</param>
            <param name="securityAttributes">A pointer to a SECURITY_ATTRIBUTES structure that determines whether or not the returned handle can
            be inherited by child processes. Can be null</param>
            <param name="dwCreationDisposition">An action to take on files that exist and do not exist</param>
            <param name="dwFlagsAndAttributes">The file attributes and flags. </param>
            <param name="hTemplateFile">A handle to a template file with the GENERIC_READ access right. The template file supplies file attributes
            and extended attributes for the file that is being created. This parameter can be null</param>
            <returns>If the function succeeds, the return value is an open handle to a specified file. If a specified file exists before the function
            all and dwCreationDisposition is CREATE_ALWAYS or OPEN_ALWAYS, a call to GetLastError returns ERROR_ALREADY_EXISTS, even when the function
            succeeds. If a file does not exist before the call, GetLastError returns 0 (zero).
            If the function fails, the return value is INVALID_HANDLE_VALUE. To get extended error information, call GetLastError.
            </returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.ReadDirectoryChangesW(Microsoft.Win32.SafeHandles.SafeFileHandle,System.Runtime.InteropServices.HandleRef,System.UInt32,System.Boolean,System.IO.NotifyFilters,System.UInt32@,System.Threading.NativeOverlapped*,System.Runtime.InteropServices.HandleRef)">
            <summary>
            Retrieves information that describes the changes within the specified directory. The function does not report changes to the specified directory itself.
            </summary>
            <param name="hDirectory">A handle to the directory to be monitored. This directory must be opened with the FILE_LIST_DIRECTORY access right.</param>
            <param name="lpBuffer">A pointer to the DWORD-aligned formatted buffer in which the read results are to be returned. The structure of this buffer is defined by the FILE_NOTIFY_INFORMATION structure. This buffer is filled either synchronously or asynchronously, depending on how the directory is opened and what value is given to the lpOverlapped parameter.</param>
            <param name="nBufferLength">The size of the buffer that is pointed to by the lpBuffer parameter, in bytes.</param>
            <param name="bWatchSubtree">If this parameter is TRUE, the function monitors the directory tree rooted at the specified directory. If this parameter is FALSE, the function monitors only the directory specified by the hDirectory parameter.</param>
            <param name="dwNotifyFilter">The filter criteria that the function checks to determine if the wait operation has completed.</param>
            <param name="lpBytesReturned">For synchronous calls, this parameter receives the number of bytes transferred into the lpBuffer parameter. For asynchronous calls, this parameter is undefined. You must use an asynchronous notification technique to retrieve the number of bytes transferred.</param>
            <param name="overlappedPointer">A pointer to an OVERLAPPED structure that supplies data to be used during asynchronous operation. Otherwise, this value is NULL. The Offset and OffsetHigh members of this structure are not used.</param>
            <param name="lpCompletionRoutine">A pointer to a completion routine to be called when the operation has been completed or canceled and the calling thread is in an alertable wait state.</param>
            <returns>If the function succeeds, the return value is nonzero. For synchronous calls, this means that the operation succeeded. For asynchronous calls, this indicates that the operation was successfully queued. If the function fails, the return value is zero. To get extended error information, call GetLastError. If the network redirector or the target file system does not support this operation, the function fails with ERROR_INVALID_FUNCTION.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.GetFileSizeEx(System.IntPtr,System.Int64@)">
            <summary>
            Retrieves the size of the specified file.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.SetFileAttributesW(System.String,System.UInt32)">
            <summary>
            Sets the attributes for a file or directory.
            </summary>
            <param name="lpFileName">The name of the file whose attributes are to be set</param>
            <param name="dwFileAttributes">The file attributes to set for the file. This parameter can be one or more values, combined using the bitwise-OR operator. However, all other values override FILE_ATTRIBUTE_NORMAL</param>
            <returns>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/>.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.CopyFileW(System.String,System.String,System.Boolean)">
            <summary>
            Copies an existing file to a new file.
            </summary>
            <remarks>
            Security attributes for the existing file are copied to the new file. File attributes for the existing file are copied to the new file. For example, if an existing file has the FILE_ATTRIBUTE_READONLY file attribute, a copy created through a call to CopyFile will also have the FILE_ATTRIBUTE_READONLY file attribute. When CopyFile is used to copy an encrypted file, it attempts to encrypt the destination file with the keys used in the encryption of the source file. If this cannot be done, this function attempts to encrypt the destination file with default keys. If neither of these methods can be done, CopyFile fails with an ERROR_ENCRYPTION_FAILED error code. Symbolic link behavior—If the source file is a symbolic link, the actual file copied is the target of the symbolic link. If the destination file already exists and is a symbolic link, the target of the symbolic link is overwritten by the source file.
            </remarks>
            <param name="lpExistingFileName">The name of an existing file. If lpExistingFileName does not exist, CopyFile fails, and GetLastError returns ERROR_FILE_NOT_FOUND.</param>
            <param name="lpNewFileName">The name of the new file.</param>
            <param name="bFailIfExists">If this parameter is TRUE and the new file specified by lpNewFileName already exists, the function fails. If this parameter is FALSE and the new file already exists, the function overwrites the existing file and succeeds.</param>
            <returns>If the function succeeds, the return value is nonzero.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.MoveFileW(System.String,System.String)">
            <summary>
            Moves an existing file or a directory, including its children.
            </summary>
            <param name="lpExistingFileName">The current name of the file or directory on the local computer.</param>
            <param name="lpNewFileName">The new name for the file or directory. The new name must not already exist. A new file may be on a different file system or drive. A new directory must be on the same drive.</param>
            <returns>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/>.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.DeleteFileW(System.String)">
            <summary>
            Deletes an existing file.
            </summary>
            <param name="lpFileName">The name of the file to be deleted.</param>
            <returns>If the function fails, the return value is zero (0). To get extended error information, call <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/>.</returns>
            <remarks>See MSDN page for behaviour explanation</remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.GetLongPathName(System.String,System.Text.StringBuilder,System.UInt32)">
            <summary>
            Converts the specified path to its long form.
            </summary>
            <param name="lpszShortPath">The path to be converted.</param>
            <param name="lpszLongPath">A pointer to the buffer to receive the long path. You can use the same buffer you used for the lpszShortPath parameter.</param>
            <param name="cchBuffer">The size of the buffer lpszLongPath points to, in TCHARs.</param>
            <returns>If the function succeeds, the return value is the length, in TCHARs, of the string copied to lpszLongPath, not including the terminating null character. If the lpBuffer buffer is too small to contain the path, the return value is the size, in TCHARs, of the buffer that is required to hold the path and the terminating null character. If the function fails for any other reason, such as if the file does not exist, the return value is zero. To get extended error information, call <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/>.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.GetShortPathName(System.String,System.Text.StringBuilder,System.UInt32)">
            <summary>
            Retrieves the short path form of the specified path.
            </summary>
            <param name="lpszLongPath">The path string.</param>
            <param name="lpszShortPath">A pointer to a buffer to receive the null-terminated short form of the path that lpszLongPath specifies. Passing NULL for this parameter and zero for cchBuffer will always return the required buffer size for a specified lpszLongPath.</param>
            <param name="cchBuffer">The size of the buffer that lpszShortPath points to, in TCHARs. Set this parameter to zero if lpszShortPath is set to NULL.</param>
            <returns>If the function succeeds, the return value is the length, in TCHARs, of the string that is copied to lpszShortPath, not including the terminating null character. If the lpszShortPath buffer is too small to contain the path, the return value is the size of the buffer, in TCHARs, that is required to hold the path and the terminating null character. If the function fails for any other reason, the return value is zero. To get extended error information, call <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/>.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.RemoveDirectoryW(System.String)">
            <summary>
            Deletes an existing empty directory.
            </summary>
            <param name="lpPathName">The path of the directory to be removed. This path must specify an empty directory, and the calling process must have delete access to the directory.</param>
            <returns>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/>.</returns>
            <remarks>The RemoveDirectory function marks a directory for deletion on close. Therefore, the directory is not removed until the last handle to the directory is closed. RemoveDirectory removes a directory junction, even if the contents of the target are not empty; the function removes directory junctions regardless of the state of the target object.</remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.SetFileTime(Microsoft.Win32.SafeHandles.SafeFileHandle,JetBrains.Interop.WinApi.Declarations.Structures.FILE_TIME*,JetBrains.Interop.WinApi.Declarations.Structures.FILE_TIME*,JetBrains.Interop.WinApi.Declarations.Structures.FILE_TIME*)">
            <summary>
            Sets the date and time that the specified file or directory was created, last accessed, or last modified.
            </summary>
            <param name="hFile">A handle to the file or directory. The handle must have been created using the CreateFile function with the FILE_WRITE_ATTRIBUTES access right.</param>
            <param name="lpCreationTime">A pointer to a FILETIME structure that contains the new creation date and time for the file or directory. This parameter can be NULL if the application does not need to change this information.</param>
            <param name="lpLastAccessTime">A pointer to a FILETIME structure that contains the new last access date and time for the file or directory. The last access time includes the last time the file or directory was written to, read from, or (in the case of executable files) run. This parameter can be NULL if the application does not need to change this information. To prevent file operations using the given handle from modifying the last access time, call SetFileTime immediately after opening the file handle and pass a FILETIME structure whose dwLowDateTime and dwHighDateTime members are both set to 0xFFFFFFFF.</param>
            <param name="lpLastWriteTime">A pointer to a FILETIME structure that contains the new last modified date and time for the file or directory. This parameter can be NULL if the application does not need to change this information. To prevent file operations using the given handle from modifying the last access time, call SetFileTime immediately after opening the file handle and pass a FILETIME structure whose dwLowDateTime and dwHighDateTime members are both set to 0xFFFFFFFF.</param>
            <returns>If the function succeeds, the return value is nonzero.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.SetErrorMode(JetBrains.Interop.WinApi.Declarations.Constants.Win32ErrorMode)">
            <summary>
            Controls whether the system will handle the specified types of serious errors or whether the process will handle them.
            </summary>
            <param name="uMode">The process error mode</param>
            <returns>The return value is the previous state of the error-mode bit flags.</returns>
            <remarks>Each process has an associated error mode that indicates to the system how the application is going to respond to serious errors. A child process inherits the error mode of its parent process. To retrieve the process error mode, use the GetErrorMode function. Because the error mode is set for the entire process, you must ensure that multi-threaded applications do not set different error-mode flags. Doing so can lead to inconsistent error handling. The system does not make alignment faults visible to an application on all processor architectures. Therefore, specifying SEM_NOALIGNMENTFAULTEXCEPT is not an error on such architectures, but the system is free to silently ignore the request.</remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.IsWow64Process(System.Void*,System.Boolean@)">
            <summary>
            Determines whether the specified process is running under WOW64.
            </summary>
            <param name="hProcess">Process handle</param>
            <param name="wow64Process">A pointer to a value that is set to TRUE if the process is running under WOW64. If the process is running under 32-bit Windows, the value is set to FALSE. If the process is a 64-bit application running under 64-bit Windows, the value is also set to FALSE.</param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.GetPackageFullName(System.Void*,System.UInt32*,System.Char*)">
            <summary>
            Gets the package full name for the specified process.
            </summary>
            <remarks>Minimum supported client: Windows 8 [desktop apps only]. Minimum supported server: Windows Server 2012 [desktop apps only]</remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.CreateFileMappingW(System.Void*,JetBrains.Interop.WinApi.SECURITY_ATTRIBUTES*,System.UInt32,System.UInt32,System.UInt32,System.String)">
            <summary>
              Creates or opens a named or unnamed file mapping object for a specified file.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.MapViewOfFile(System.Void*,System.UInt32,System.UInt32,System.UInt32,System.UIntPtr)">
            <summary>
              Maps a view of a file mapping into the address space of a calling process.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.UnmapViewOfFile(System.Void*)">
            <summary>
              Unmaps a mapped view of a file from the calling process's address space.
            </summary>
            <param name="lpBaseAddress">A pointer to the base address of the mapped view of a file that is to be unmapped. This value must be identical to the value returned by a previous call to the MapViewOfFile or MapViewOfFileEx function.</param>
            <returns>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.MoveFileExW(System.String,System.String,System.UInt32)">
            <summary>
              Moves an existing file or directory, including its children, with various move options.
              The MoveFileWithProgress function is equivalent to the MoveFileEx function, except that MoveFileWithProgress allows you to provide a callback function that receives progress notifications.
              To perform this operation as a transacted operation, use the MoveFileTransacted function.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.QueryFullProcessImageNameW(System.Void*,System.UInt32,System.Text.StringBuilder,System.UInt32@)">
            <summary>
            Retrieves the full name of the executable image for the specified process.
            </summary>
            <param name="hProcess">A handle to the process. This handle must be created with the PROCESS_QUERY_INFORMATION or PROCESS_QUERY_LIMITED_INFORMATION access right.</param>
            <param name="flags">0 = The name should use the Win32 path format; PROCESS_NAME_NATIVE (0x01) = The name should use the native system path format.</param>
            <param name="buffer">The path to the executable image. If the function succeeds, this string is null-terminated.</param>
            <param name="size">On input, specifies the size of the lpExeName buffer, in characters. On success, receives the number of characters written to the buffer, not including the null-terminating character.</param>
            <returns>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call GetLastError.</returns>
            <remarks>Minimum supported client: Windows Vista [desktop apps only]. Minimum supported server: Windows Server 2008 [desktop apps only]</remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.BeginUpdateResourceW(System.String,System.Int32)">
            <summary>
            Retrieves a handle that can be used by the UpdateResource function to add, delete, or replace resources in a binary module.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.EndUpdateResourceW(System.Void*,System.Int32)">
            <summary>
            Commits or discards changes made prior to a call to UpdateResource.
            </summary>
            <returns>Returns TRUE if the function succeeds; FALSE otherwise. If the function succeeds and fDiscard is TRUE, then no resource updates are made to the file; otherwise all successful resource updates are made to the file. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.UpdateResourceW(System.Void*,System.Char*,System.Char*,System.UInt16,System.Void*,System.UInt32)">
            <summary>
            Adds, deletes, or replaces a resource in a portable executable (PE) file. There are some restrictions on resource updates in files that contain Resource Configuration (RC Config) data: language-neutral (LN) files and language-specific resource (.mui) files.
            </summary>
            <param name="hUpdate">A module handle returned by the BeginUpdateResource function, referencing the file to be updated. </param>
            <param name="lpType">The resource type to be updated. Alternatively, rather than a pointer, this parameter can be MAKEINTRESOURCE(ID), where ID is an integer value representing a predefined resource type. If the first character of the string is a pound sign (#), then the remaining characters represent a decimal number that specifies the integer identifier of the resource type. For example, the string "#258" represents the identifier 258. For a list of predefined resource types, see Resource Types. </param>
            <param name="lpName">The name of the resource to be updated. Alternatively, rather than a pointer, this parameter can be MAKEINTRESOURCE(ID), where ID is a resource ID. When creating a new resource do not use a string that begins with a '#' character for this parameter.</param>
            <param name="wLanguage">The language identifier of the resource to be updated. For a list of the primary language identifiers and sublanguage identifiers that make up a language identifier, see the MAKELANGID macro. </param>
            <param name="lpData">The resource data to be inserted into the file indicated by hUpdate. If the resource is one of the predefined types, the data must be valid and properly aligned. Note that this is the raw binary data to be stored in the file indicated by hUpdate, not the data provided by LoadIcon, LoadString, or other resource-specific load functions. All data containing strings or text must be in Unicode format. lpData must not point to ANSI data. If lpData is NULL and cbData is 0, the specified resource is deleted from the file indicated by hUpdate. Prior to Windows 7: If lpData is NULL and cbData is nonzero, the specified resource is NOT deleted and an exception is thrown.</param>
            <param name="cbData">The size, in bytes, of the resource data at lpData. </param>
            <returns>Returns TRUE if successful or FALSE otherwise. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.CompareStringW(System.UInt32,System.UInt32,System.Char*,System.Int32,System.Char*,System.Int32)">
            <summary>
            Compares two character strings, for a locale specified by identifier.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.CompareStringExW(System.String,System.UInt32,System.Char*,System.Int32,System.Char*,System.Int32,System.Void*,System.Void*,System.IntPtr)">
            <summary>
            Compares two Unicode (wide character) strings, for a locale specified by name.
            </summary>
            <since>Windows NT 6.0</since>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.LCMapStringW(System.UInt32,System.UInt32,System.Char*,System.Int32,System.Char*,System.Int32)">
            <summary>
            For a locale specified by identifier, maps one input character string to another using a specified transformation, or generates a sort key for the input string.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Kernel32Dll.Helpers">
            <summary>
            Wrappers for the functions in this DLL.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Kernel32Dll.Helpers._performancefrequency">
            <summary>
            Frequency of the performance counter, for <see cref="M:JetBrains.Interop.WinApi.Kernel32Dll.Helpers.GetHighPrecisionSystemTime"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.Helpers.CoCreateInstanceExplicit(System.String,System.Guid)">
            <summary>
            Creates an instance of a COM object without the Registry information, by loading the DLL and invoking its class factory.
            </summary>
            <param name="sDllFilename">Pathname of the DLL.</param>
            <param name="guidClsid">CLSID of the object to create.</param>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.Helpers.GetHighPrecisionSystemTime">
            <summary>
            Gets the high-precision system time value, in milliseconds.
            Throws if not supported on the system (unlikely).
            May yield irrelevant data on non-synchronized CPU cores.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.Helpers.GetProfileString(System.String,System.String,System.String,System.String)">
            <summary>
            Reads an .ini string.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.Helpers.GetWin32Resource(System.String,System.String,System.String)">
            <summary>
            Loads a native dll and looks up the resource.
            Throws on errors.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.Helpers.GetWin32Resource(System.String,JetBrains.Interop.WinApi.Declarations.Structures.NativeResourceTypeAndName)">
            <summary>
            Loads a native dll and looks up the resource.
            Throws on errors.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.Helpers.GetWin32Resource(System.Void*,JetBrains.Interop.WinApi.Declarations.Structures.NativeResourceTypeAndName,System.String)">
            <summary>
            Looks up the resource in the native DLL. <c>NULL</c> handle to look in the entry point executable.
            Throws on errors.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.Helpers.IsWow64Process">
            <summary>
            Calls the <c>IsWow64Process</c> API function, if one is present on this OS version.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.Helpers.Is64BitOperatingSystem">
            <summary>
            The function determines whether the current operating system is a 
            64-bit operating system.
            </summary>
            <returns>
            The function returns true if the operating system is 64-bit; 
            otherwise, it returns false.
            </returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.Helpers.IsWow64Process(System.Void*)">
            <summary>
            Calls the <c>IsWow64Process</c> API function, if one is present on this OS version.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.Helpers.IsWow64ProcessAvailable">
            <summary>
            Check if IsWow64Process API function is available on this OS version.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.Helpers.WaitForSingleObject(System.IntPtr,System.TimeSpan)">
            <summary>
            Waits for the object, returns whether the wait was successful.
            The abandoned state is considered success.
            </summary>
            <param name="handle">Handle to wait for.</param>
            <param name="timeout">Timeout. <see cref="F:System.TimeSpan.Zero"/> to test without waiting, <see cref="F:System.TimeSpan.MaxValue"/> to wait infinitely.</param>
            <returns>Whether the wait has succeeded.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.Helpers.GetModulePath(System.Void*)">
            <summary>
            Retrieves the fully qualified path for the file that contains the specified module. The module must have been loaded by the current process. 
            Wraps WinAPI function <see cref="M:JetBrains.Interop.WinApi.Kernel32Dll.GetModuleFileNameW(System.Void*,System.Char*,System.UInt32)"/>.
            </summary>
            <param name="hModule">A handle to the loaded module whose path is being requested. 
            If this parameter is NULL, GetModuleFileName retrieves the path of the executable file of the current process.</param>
            <returns>The fully qualified path of the module.</returns>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Kernel32Dll.Helpers.DllGetClassObjectDelegate">
            <summary>
            Helper for the <see cref="M:JetBrains.Interop.WinApi.Kernel32Dll.Helpers.CoCreateInstanceExplicit(System.String,System.Guid)"/> function.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Kernel32Dll.Helpers.IsWow64ProcessDelegate">
            <summary>
            Delegate to Kernel32 <c>IsWow64Process</c> API func.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.WindowClassStyles">
            <summary>
            “<c>CS_…</c>” window class styles from the <c>RegisterClassEx</c> function.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.WindowClassStyles.CS_BYTEALIGNCLIENT">
            <summary>
            Aligns the window's client area on a byte boundary (in the x direction). This style affects the width of the window and its horizontal placement on the display. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.WindowClassStyles.CS_BYTEALIGNWINDOW">
            <summary>
            Aligns the window on a byte boundary (in the x direction). This style affects the width of the window and its horizontal placement on the display. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.WindowClassStyles.CS_CLASSDC">
            <summary>
            Allocates one device context to be shared by all windows in the class. Because window classes are process specific, it is possible for multiple threads of an application to create a window of the same class. It is also possible for the threads to attempt to use the device context simultaneously. When this happens, the system allows only one thread to successfully finish its drawing operation.  
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.WindowClassStyles.CS_DBLCLKS">
            <summary>
            Sends a double-click message to the window procedure when the user double-clicks the mouse while the cursor is within a window belonging to the class.  
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.WindowClassStyles.CS_DROPSHADOW">
            <summary>
            Windows XP: Enables the drop shadow effect on a window. The effect is turned on and off through SPI_SETDROPSHADOW. Typically, this is enabled for small, short-lived windows such as menus to emphasize their Z order relationship to other windows. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.WindowClassStyles.CS_GLOBALCLASS">
            <summary>
            Specifies that the window class is an application global class. For more information, see Application Global Classes. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.WindowClassStyles.CS_HREDRAW">
            <summary>
            Redraws the entire window if a movement or size adjustment changes the width of the client area. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.WindowClassStyles.CS_NOCLOSE">
            <summary>
            Disables Close on the window menu. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.WindowClassStyles.CS_OWNDC">
            <summary>
            Allocates a unique device context for each window in the class.  
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.WindowClassStyles.CS_PARENTDC">
            <summary>
            Sets the clipping rectangle of the child window to that of the parent window so that the child can draw on the parent. A window with the CS_PARENTDC style bit receives a regular device context from the system's cache of device contexts. It does not give the child the parent's device context or device context settings. Specifying CS_PARENTDC enhances an application's performance.  
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.WindowClassStyles.CS_SAVEBITS">
            <summary>
            Saves, as a bitmap, the portion of the screen image obscured by a window of this class. When the window is removed, the system uses the saved bitmap to restore the screen image, including other windows that were obscured. Therefore, the system does not send WM_PAINT messages to windows that were obscured if the memory used by the bitmap has not been discarded and if other screen actions have not invalidated the stored image. This style is useful for small windows (for example, menus or dialog boxes) that are displayed briefly and then removed before other screen activity takes place. This style increases the time required to display the window, because the system must first allocate memory to store the bitmap.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.WindowClassStyles.CS_VREDRAW">
            <summary>
            Redraws the entire window if a movement or size adjustment changes the height of the client area. 
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.WindowExStyles">
            <summary>
            Specifies the extended window style of the window being created.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.WindowStyles">
            <summary>
            The following styles can be specified wherever a window style is required. After the control has been created, these styles cannot be modified, except as noted.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.ShowWindowCommands">
            <summary>
            <see cref="M:JetBrains.Interop.WinApi.User32Dll.ShowWindow(System.Void*,System.Int32)"/> Commands.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.EditBoxControlMargins">
            <summary>
            <see cref="F:JetBrains.Interop.WinApi.WindowsMessages.EM_SETMARGINS"/> constants.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.EditBoxControlMargins.EC_LEFTMARGIN">
            <summary>
            Sets the left margin.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.EditBoxControlMargins.EC_RIGHTMARGIN">
            <summary>
            Sets the right margin.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.EditBoxControlMargins.EC_USEFONTINFO">
            <summary>
            Rich edit controls: Sets the left and right margins to a narrow width calculated using the text metrics of the control's current font. If no font has been set for the control, the margins are set to zero. The lParam parameter is ignored. Edit controls: The EC_USEFONTINFO value cannot be used in the wParam parameter. It can only be used in the lParam parameter. 
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.MEMORYSTATUSEX">
            <summary>
            Helper structure for the <see cref="M:JetBrains.Interop.WinApi.Kernel32Dll.GlobalMemoryStatusEx(JetBrains.Interop.WinApi.MEMORYSTATUSEX*)"/> function.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.HResults.BUFFER_E_DEST_TOO_SMALL">
            <summary>
            Visual Studio specific.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.HResults.BUFFER_E_LOCKED">
            <summary>
            Visual Studio specific.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.HResults.BUFFER_E_READONLY">
            <summary>
            Visual Studio specific.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.HResults.BUFFER_E_READONLY_REGION">
            <summary>
            Visual Studio specific.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.HResults.BUFFER_E_SCC_READONLY">
            <summary>
            Visual Studio specific.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.HResults.BUFFER_E_TIMEOUT">
            <summary>
            Visual Studio specific.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.HResults.MARKER_E_BUFFERDESTROYED">
            <summary>
            Visual Studio specific.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.HResults.MARKER_E_INVALIDATED">
            <summary>
            Visual Studio specific.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.HResults.VIEW_E_LOCATION_HIDDEN">
            <summary>
            Visual Studio specific.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.HResults.VIEW_E_NO_BOOKMARKS">
            <summary>
            Visual Studio specific.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.HResults.VIEW_E_NO_DEBUGGER">
            <summary>
            Visual Studio specific.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.HResults.VIEW_E_USERREADONLY">
            <summary>
            Visual Studio specific.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.HResults.LINKEDUNDO_E_INTERVENING_ACTION">
            <summary>
            Visual Studio specific.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.HResults.UNDO_E_CLIENTABORT">
            <summary>
            Visual Studio specific.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.HResults.TIP_S_ONLYIFNOMARKER">
            <summary>
            Visual Studio specific.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.HResults.STG_E_INVALIDCODEPAGE">
            <summary>
            Visual Studio specific.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.HResults.STG_E_NOTTEXT">
            <summary>
            Visual Studio specific.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.HResults.STG_S_DATALOSS">
            <summary>
            Visual Studio specific.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.GetAncestorFlags">
            <summary>
            Flags for the <see cref="M:JetBrains.Interop.WinApi.User32Dll.GetAncestor(System.Void*,System.UInt32)"/> function.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.GetAncestorFlags.GA_PARENT">
            <summary>
            Retrieves the parent window. This does not include the owner, as it does with the GetParent function. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.GetAncestorFlags.GA_ROOT">
            <summary>
            Retrieves the root window by walking the chain of parent windows.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.GetAncestorFlags.GA_ROOTOWNER">
            <summary>
            Retrieves the owned root window by walking the chain of parent and owner windows returned by GetParent.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.SYSTEM_INFO.wProcessorArchitecture">
            <seealso cref="T:JetBrains.Interop.WinApi.ProcessorArchitecture"/>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Declarations.Structures.WINDOWPOS">
            <summary>
            The <c>WINDOWPOS</c> structure contains information about the size and position of a window. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.WINDOWPOS.hwnd">
            <summary>
            Handle to the window. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.WINDOWPOS.hwndInsertAfter">
            <summary>
            Specifies the position of the window in Z order (front-to-back position). This member can be a handle to the window behind which this window is placed, or can be one of the special values listed with the SetWindowPos function.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.WINDOWPOS.x">
            <summary>
            Specifies the position of the left edge of the window. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.WINDOWPOS.y">
            <summary>
            Specifies the position of the top edge of the window. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.WINDOWPOS.cx">
            <summary>
            Specifies the window width, in pixels. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.WINDOWPOS.cy">
            <summary>
            Specifies the window height, in pixels. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.WINDOWPOS.flags">
            <summary>
            Specifies the window position. This member can be one or more of the following values.  See <see cref="T:JetBrains.Interop.WinApi.SetWindowPosFlags"/> for details.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.VersionDll.GetFileVersionInfoSizeW(System.String,System.UInt32*)">
            <summary>
            Determines whether the operating system can retrieve version information for a specified file. If version information is available, <see cref="M:JetBrains.Interop.WinApi.VersionDll.GetFileVersionInfoSizeW(System.String,System.UInt32*)"/> returns the size, in bytes, of that information. 
            </summary>
            <param name="lptstrFilename">[in] Pointer to a null-terminated string that specifies the name of the file of interest. The function uses the search sequence specified by the LoadLibrary function. Windows 95/98/Me: The short path form of the specified file name must be less than 126 characters.</param>
            <param name="lpdwHandle">[out] Pointer to a variable that the function sets to zero.</param>
            <returns>If the function succeeds, the return value is the size, in bytes, of the file's version information. If the function fails, the return value is zero. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.VersionDll.GetFileVersionInfoW(System.String,System.UInt32,System.UInt32,System.Void*)">
            <summary>
            Retrieves version information for the specified file. 
            </summary>
            <param name="lptstrFilename">[in] Pointer to a null-terminated string that specifies the name of the file of interest. If a full path is not specified, the function uses the search sequence specified by the LoadLibrary function.Windows 95/98/Me: The short path form of the specified file name must be less than 126 characters.</param> 
            <param name="dwHandle">This parameter is ignored.</param>
            <param name="dwLen">[in] Specifies the size, in bytes, of the buffer pointed to by the lpData parameter. Call the <see cref="M:JetBrains.Interop.WinApi.VersionDll.GetFileVersionInfoSizeW(System.String,System.UInt32*)"/> function first to determine the size, in bytes, of a file's version information. The dwLen member should be equal to or greater than that value. If the buffer pointed to by lpData is not large enough, the function truncates the file's version information to the size of the buffer.</param>
            <param name="lpData">[out] Pointer to a buffer that receives the file-version information. You can use this value in a subsequent call to the <see cref="M:JetBrains.Interop.WinApi.VersionDll.VerQueryValueW(System.Void*,System.String,System.Void**,System.UInt32*)"/> function to retrieve data from the buffer.</param>
            <returns>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.VersionDll.VerQueryValueW(System.Void*,System.String,System.Void**,System.UInt32*)">
            <summary>
            The <see cref="M:JetBrains.Interop.WinApi.VersionDll.VerQueryValueW(System.Void*,System.String,System.Void**,System.UInt32*)"/> function retrieves specified version information from the specified version-information resource. To retrieve the appropriate resource, before you call <see cref="M:JetBrains.Interop.WinApi.VersionDll.VerQueryValueW(System.Void*,System.String,System.Void**,System.UInt32*)"/>, you must first call the <see cref="M:JetBrains.Interop.WinApi.VersionDll.GetFileVersionInfoSizeW(System.String,System.UInt32*)"/> function, and then the <see cref="M:JetBrains.Interop.WinApi.VersionDll.GetFileVersionInfoW(System.String,System.UInt32,System.UInt32,System.Void*)"/> function.
            </summary>
            <param name="pBlock">[in] Pointer to the buffer containing the version-information resource returned by the <see cref="M:JetBrains.Interop.WinApi.VersionDll.GetFileVersionInfoW(System.String,System.UInt32,System.UInt32,System.Void*)"/> function. </param>
            <param name="lpSubBlock">[in] Pointer to a zero-terminated string specifying which version-information value to retrieve. The string must consist of names separated by backslashes (\) and it must have one of the following forms. 
            <para><c>\</c></para>
            <para>Specifies the root block. The function retrieves a pointer to the VS_FIXEDFILEINFO structure for the version-information resource.</para>
            <para><c>\VarFileInfo\Translation</c></para>
            <para>Specifies the translation array in a Var variable information structure—the Value member of this structure. The function retrieves a pointer to this array of language and code page identifiers. An application can use these identifiers to access a language-specific StringTable /// structure (using the szKey member) in the version-information resource.</para>
            <para><c>\StringFileInfo\lang-codepage\string-name</c></para>
            <para>Specifies a value in a language-specific StringTable structure. The lang-codepage name is a concatenation of a language and code page identifier pair found as a DWORD in the translation array for the resource. Here the lang-codepage name must be specified as a hexadecimal string. The string-name name must be one of the predefined strings described in the following Remarks section. The function retrieves a string value specific to the language and code page indicated. </para>
            </param>
            <param name="lplpBuffer">[out] When this method returns, contains the address of a pointer to the requested version information in the buffer pointed to by pBlock. The memory pointed to by lplpBuffer is freed when the associated pBlock memory is freed. </param>
            <param name="puLen">[out] When this method returns, contains a pointer to the size of the requested data pointed to by lplpBuffer: for version information values, the length in TCHARs of the string stored at lplpBuffer; for translation array values, the size in bytes of the array stored at lplpBuffer; and for root block, the size in bytes of the structure.</param>
            <returns>If the specified version-information structure exists, and version information is available, the return value is nonzero. If the address of the length buffer is zero, no value is available for the specified version-information name. If the specified name does not exist or the specified resource is not valid, the return value is zero.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.VersionDll.Helpers.GetFileVersionInfo(System.String)">
            <summary>
            Gets the WinAPI file version of a native file.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.WinInetDll">
            <summary>
            WinInet.dll functions.
            Must be 64bit-safe.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.WinInetDll.Helpers.InternetGetCookie(System.String)">
            <summary>
            Gets the system HTTP cookie.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.WinInetDll.Helpers.InternetSetCookie(System.String,System.String)">
            <summary>
            Sets a system HTTP cookie.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Declarations.Constants.DibColors">
            <summary>
            Color usage constants for <see cref="M:JetBrains.Interop.WinApi.Gdi32Dll.CreateDIBSection(System.Void*,JetBrains.Interop.WinApi.Declarations.Structures.BITMAPINFO*,System.UInt32,System.Void**,System.Void*,System.Int32)"/>, <see cref="M:JetBrains.Interop.WinApi.Gdi32Dll.CreateDIBitmap(System.Void*,JetBrains.Interop.WinApi.Declarations.Structures.BITMAPINFOHEADER*,System.UInt32,System.Void*,JetBrains.Interop.WinApi.Declarations.Structures.BITMAPINFO*,System.UInt32)"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.DibColors.DIB_RGB_COLORS">
            <summary>
            The BITMAPINFO structure contains an array of literal RGB values.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.DibColors.DIB_PAL_COLORS">
            <summary>
            The bmiColors member is an array of 16-bit indexes into the logical palette of the device context specified by hdc.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.DeviceCapabilityIndex.DRIVERVERSION">
            <summary>
            Device driver version
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.DeviceCapabilityIndex.TECHNOLOGY">
            <summary>
            Device classification
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.DeviceCapabilityIndex.HORZSIZE">
            <summary>
            Horizontal size in millimeters
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.DeviceCapabilityIndex.VERTSIZE">
            <summary>
            Vertical size in millimeters
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.DeviceCapabilityIndex.HORZRES">
            <summary>
            Horizontal width in pixels
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.DeviceCapabilityIndex.VERTRES">
            <summary>
            Vertical height in pixels
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.DeviceCapabilityIndex.BITSPIXEL">
            <summary>
            Number of bits per pixel
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.DeviceCapabilityIndex.PLANES">
            <summary>
            Number of planes
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.DeviceCapabilityIndex.NUMBRUSHES">
            <summary>
            Number of brushes the device has
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.DeviceCapabilityIndex.NUMPENS">
            <summary>
            Number of pens the device has
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.DeviceCapabilityIndex.NUMMARKERS">
            <summary>
            Number of markers the device has
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.DeviceCapabilityIndex.NUMFONTS">
            <summary>
            Number of fonts the device has
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.DeviceCapabilityIndex.NUMCOLORS">
            <summary>
            Number of colors the device supports
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.DeviceCapabilityIndex.PDEVICESIZE">
            <summary>
            Size required for device descriptor
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.DeviceCapabilityIndex.CURVECAPS">
            <summary>
            Curve capabilities
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.DeviceCapabilityIndex.LINECAPS">
            <summary>
            Line capabilities
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.DeviceCapabilityIndex.POLYGONALCAPS">
            <summary>
            Polygonal capabilities
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.DeviceCapabilityIndex.TEXTCAPS">
            <summary>
            Text capabilities
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.DeviceCapabilityIndex.CLIPCAPS">
            <summary>
            Clipping capabilities
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.DeviceCapabilityIndex.RASTERCAPS">
            <summary>
            Bitblt capabilities
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.DeviceCapabilityIndex.ASPECTX">
            <summary>
            Length of the X leg
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.DeviceCapabilityIndex.ASPECTY">
            <summary>
            Length of the Y leg
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.DeviceCapabilityIndex.ASPECTXY">
            <summary>
            Length of the hypotenuse
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.DeviceCapabilityIndex.SHADEBLENDCAPS">
            <summary>
            Shading and Blending caps
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.DeviceCapabilityIndex.LOGPIXELSX">
            <summary>
            Logical pixels inch in X
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.DeviceCapabilityIndex.LOGPIXELSY">
            <summary>
            Logical pixels inch in Y
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.DeviceCapabilityIndex.SIZEPALETTE">
            <summary>
            Number of entries in physical palette
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.DeviceCapabilityIndex.NUMRESERVED">
            <summary>
            Number of reserved entries in palette
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.DeviceCapabilityIndex.COLORRES">
            <summary>
            Actual color resolution
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.DeviceCapabilityIndex.PHYSICALWIDTH">
            <summary>
            Physical Width in device units
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.DeviceCapabilityIndex.PHYSICALHEIGHT">
            <summary>
            Physical Height in device units
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.DeviceCapabilityIndex.PHYSICALOFFSETX">
            <summary>
            Physical Printable Area x margin
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.DeviceCapabilityIndex.PHYSICALOFFSETY">
            <summary>
            Physical Printable Area y margin
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.DeviceCapabilityIndex.SCALINGFACTORX">
            <summary>
            Scaling factor x
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.DeviceCapabilityIndex.SCALINGFACTORY">
            <summary>
            Scaling factor y
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.DeviceCapabilityIndex.VREFRESH">
            <summary>
            Current vertical refresh rate of the display device (for displays only) in Hz
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.DeviceCapabilityIndex.DESKTOPVERTRES">
            <summary>
            Horizontal width of entire desktop in pixels
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.DeviceCapabilityIndex.DESKTOPHORZRES">
            <summary>
            Vertical height of entire desktop in pixels
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.DeviceCapabilityIndex.BLTALIGNMENT">
            <summary>
            Preferred blt alignment
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Modules.UI.ControlPaintUnsafe">
            <summary>
            Encapsulates the utility classes for painting the controls.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.User32Dll">
            <summary>
            User32.dll functions.
            Must be 64bit-safe.
            </summary>
            <remarks>
            IMPORTANT! Rules for authoring the class (v1.1):
            (1) All the function declarations MUST be 64-bit aware.
            (2) When copypasting from older declarations, you MUST check against the MSDN help or header declaration, 
               and you MUST ensure that each parameter has a proper size.
            (3) Call the Wide version of the functions (UCS-2-LE) unless there's a strong reason for calling the ANSI version 
               (such a reason MUST be indicated in XmlDoc). <c>CharSet = CharSet.Unicode</c>.
            (4) ExactSpelling MUST be TRUE. Add the "…W" suffix wherever needed.
            (5) SetLastError SHOULD be considered individually for each function. Setting it to <c>True</c> allows to report the errors,
               but slows down the execution of critical members.
            (6) These properties MUST be explicitly set on DllImport attributes of EACH import: 
               CharSet, PreserveSig, SetLastError, ExactSpelling.
            (7) CLR names MUST be used for types instead of C# ones, eg "Int32" not "int" and "Int64" not "long".
               This greately improves the understanding of the parameter sizes.
            (8) Sign of the types MUST be favored, eg "DWORD" is "UInt32" not "Int32".
            (9) Unsafe pointer types should be used for explicit and implicit pointers rather than IntPtr. 
               This way we outline the unsafety of the native calls, and also make it more clear for the 64bit transition.
               Eg "HANDLE" is "void*". If the rule forces you to mark some assembly as unsafe, it's an indication a managed utility
               incapsulating the call and the handle should be provided in one of the already-unsafe assemblies.
            (A) Same rules must apply to members of the structures.
            (B) All of the structures MUST have the [StructLayout(LayoutKind.Sequential)], [NoReorder] attributes, as appropriate.
            </remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.BringWindowToTop(System.Void*)">
            <summary>
            The BringWindowToTop function brings the specified window to the top of the Z order. If the window is a top-level
            window, it is activated. If the window is a child window, the top-level parent window associated with the child window is activated.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.ClientToScreen(System.Void*,JetBrains.Interop.WinApi.POINT*)">
            <summary>
            The ClientToScreen function converts the client-area coordinates of a specified point to screen coordinates. 
            </summary>
            <param name="hWnd">[in] Handle to the window whose client area is used for the conversion. </param>
            <param name="lpPoint">[in/out] Pointer to a POINT structure that contains the client coordinates to be converted. The new screen coordinates are copied into this structure if the function succeeds. </param>
            <returns>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. Windows NT/2000/XP: To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.CreateDesktopW(System.String,System.String,System.Void*,System.UInt32,System.UInt32,System.Void*)">
            <summary>
            Creates a new desktop, associates it with the current window station of the calling process, and assigns it to the calling thread. The calling process must have an associated window station, either assigned by the system at process creation time or set by the SetProcessWindowStation function.
            </summary>
            <param name="lpszDesktop">The name of the desktop to be created. Desktop names are case-insensitive and may not contain backslash characters (\).</param>
            <param name="lpszDevice">Reserved; must be NULL.</param>
            <param name="pDevmode">Reserved; must be NULL.</param>
            <param name="dwFlags">This parameter can be zero or the following value. <c>DF_ALLOWOTHERACCOUNTHOOK</c> <c>0x0001</c> Enables processes running in other accounts on the desktop to set hooks in this process. </param>
            <param name="dwDesiredAccess">The access to the desktop. For a list of values, see Desktop Security and Access Rights. This parameter must include the DESKTOP_CREATEWINDOW access right, because internally CreateDesktop uses the handle to create a window.</param>
            <param name="lpsa">A pointer to a SECURITY_ATTRIBUTES structure that determines whether the returned handle can be inherited by child processes. If lpsa is NULL, the handle cannot be inherited. The lpSecurityDescriptor member of the structure specifies a security descriptor for the new desktop. If this parameter is NULL, the desktop inherits its security descriptor from the parent window station.</param>
            <returns>If the function succeeds, the return value is a handle to the newly created desktop. If the specified desktop already exists, the function succeeds and returns a handle to the existing desktop. When you are finished using the handle, call the CloseDesktop function to close it. If the function fails, the return value is NULL. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.DestroyIcon(System.Void*)">
            <summary>
            Destroys an icon and frees any memory the icon occupied. 
            </summary>
            <param name="hIcon">[in] Handle to the icon to be destroyed. The icon must not be in use. </param>
            <returns>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call GetLastError. </returns>
            <remarks>
            It is only necessary to call DestroyIcon for icons and cursors created with the following functions: CreateIconFromResourceEx (if called without the LR_SHARED flag), CreateIconIndirect, and CopyIcon. Do not use this function to destroy a shared icon. A shared icon is valid as long as the module from which it was loaded remains in memory. The following functions obtain a shared icon: LoadIcon, LoadImage (if you use the LR_SHARED flag), CopyImage (if you use the LR_COPYRETURNORG flag and the hImage parameter is a shared icon), CreateIconFromResource, CreateIconFromResourceEx (if you use the LR_SHARED flag) 
            </remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.DestroyWindow(System.Void*)">
            <summary>
            The DestroyWindow function destroys the specified window. The function sends WM_DESTROY and WM_NCDESTROY messages to the window to deactivate it and remove the keyboard focus from it. The function also destroys the window's menu, flushes the thread message queue, destroys timers, removes clipboard ownership, and breaks the clipboard viewer chain (if the window is at the top of the viewer chain). If the specified window is a parent or owner window, DestroyWindow automatically destroys the associated child or owned windows when it destroys the parent or owner window. The function first destroys child or owned windows, and then it destroys the parent or owner window. DestroyWindow also destroys modeless dialog boxes created by the CreateDialog function.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.DispatchMessageW(JetBrains.Interop.WinApi.MSG*)">
            <summary>
            The DispatchMessage function dispatches a message to a window procedure. It is typically used to dispatch a message retrieved by the GetMessage function.
            </summary>
            <param name="lpmsg">[in] Pointer to an MSG structure that contains the message.</param>
            <returns>The return value specifies the value returned by the window procedure. Although its meaning depends on the message being dispatched, the return value generally is ignored.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.EnableWindow(System.Void*,System.Int32)">
            <summary>
            The EnableWindow function enables or disables mouse and keyboard input to the specified window or control. When input is disabled, the window does not receive input such as mouse clicks and key presses. When input is enabled, the window receives all input.
            </summary>
            <param name="hWnd">[in] Handle to the window to be enabled or disabled.</param>
            <param name="bEnable">[in] Specifies whether to enable or disable the window. If this parameter is TRUE, the window is enabled. If the parameter is FALSE, the window is disabled.</param>
            <returns>If the window was previously disabled, the return value is nonzero. If the window was not previously disabled, the return value is zero.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.EnumChildWindows(System.Void*,System.Void*,System.IntPtr)">
            <summary>
            The EnumChildWindows function enumerates the child windows that belong to the specified parent window by passing the handle to each child window, in turn, to an application-defined callback function. EnumChildWindows continues until the last child window is enumerated or the callback function returns FALSE.
            </summary>
            <param name="hWndParent">[in] Handle to the parent window whose child windows are to be enumerated. If this parameter is NULL, this function is equivalent to EnumWindows. Windows 95/98/Me: hWndParent cannot be NULL.</param>
            <param name="lpEnumFunc">[in] Pointer to an application-defined callback function. For more information, see EnumChildProc.</param>
            <param name="lParam">[in] Specifies an application-defined value to be passed to the callback function.</param>
            <returns>Not used.</returns>
            <remarks>If a child window has created child windows of its own, EnumChildWindows enumerates those windows as well. A child window that is moved or repositioned in the Z order during the enumeration process will be properly enumerated. The function does not enumerate a child window that is destroyed before being enumerated or that is created during the enumeration process. </remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.EnumThreadWindows(System.UInt32,System.Void*,System.IntPtr)">
            <summary>
            The EnumThreadWindows function enumerates all nonchild windows associated with a thread by passing the handle to each window, in turn, to an application-defined callback function. EnumThreadWindows continues until the last window is enumerated or the callback function returns FALSE. To enumerate child windows of a particular window, use the EnumChildWindows function. 
            </summary>
            <param name="dwThreadId">[in] Identifies the thread whose windows are to be enumerated. </param>
            <param name="lpfn">[in] Pointer to an application-defined callback function. For more information, see EnumThreadWndProc. </param>
            <param name="lParam">[in] Specifies an application-defined value to be passed to the callback function. </param>
            <returns>If the callback function returns TRUE for all windows in the thread specified by dwThreadId, the return value is TRUE. If the callback function returns FALSE on any enumerated window, or if there are no windows found in the thread specified by dwThreadId, the return value is FALSE.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.EnumWindows(System.Void*,System.IntPtr)">
            <summary>
            The EnumWindows function enumerates all top-level windows on the screen by passing the handle to each window, in turn, to an application-defined callback function. EnumWindows continues until the last top-level window is enumerated or the callback function returns FALSE. 
            </summary>
            <param name="lpEnumFunc">[in] Pointer to an application-defined callback function. For more information, see EnumWindowsProc. </param>
            <param name="lParam">[in] Specifies an application-defined value to be passed to the callback function. </param>
            <returns>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call GetLastError.  If EnumWindowsProc returns zero, the return value is also zero. In this case, the callback function should call SetLastError to obtain a meaningful error code to be returned to the caller of EnumWindows. </returns>
            <remarks>
            The EnumWindows function does not enumerate child windows, with the exception of a few top-level windows owned by the system that have the WS_CHILD style.
            This function is more reliable than calling the GetWindow function in a loop. An application that calls GetWindow to perform this task risks being caught in an infinite loop or referencing a handle to a window that has been destroyed. 
            </remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.FillRect(System.Void*,JetBrains.Interop.WinApi.RECT*,System.Void*)">
            <summary>
            The FillRect function fills a rectangle by using the specified brush. This function includes the left and top borders, but excludes the right and bottom borders of the rectangle.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.FlashWindowEx(JetBrains.Interop.WinApi.Declarations.Structures.FLASHWINFO*)">
            <summary>
            The SetForegroundWindow function puts the thread that created the specified window into the foreground and
            activates the window. Keyboard input is directed to the window, and various visual cues are changed for the user.
            The system assigns a slightly higher priority to the thread that created the foreground window than it does to other threads.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.GetActiveWindow">
            <summary>
            The GetActiveWindow function retrieves the window handle to the active window attached to the calling thread's message queue. 
            </summary>
            <returns>The return value is the handle to the active window attached to the calling thread's message queue. Otherwise, the return value is NULL. </returns>
            <remarks>To get the handle to the foreground window, you can use GetForegroundWindow. Windows 98/Me and Windows NT 4.0 SP3 and later: To get the window handle to the active window in the message queue for another thread, use GetGUIThreadInfo.</remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.GetAncestor(System.Void*,System.UInt32)">
            <summary>
            The GetAncestor function retrieves the handle to the ancestor of the specified window. 
            </summary>
            <param name="hwnd">[in] Handle to the window whose ancestor is to be retrieved. If this parameter is the desktop window, the function returns <c>NULL</c>. </param>
            <param name="gaFlags">[in] Specifies the ancestor to be retrieved. This parameter can be one of the following values.</param>
            <returns>The return value is the handle to the ancestor window.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.GetClassNameW(System.Void*,System.Char*,System.Int32)">
            <summary>
            The GetClassName function retrieves the name of the class to which the specified window belongs. 
            </summary>
            <param name="hWnd">[in] Handle to the window and, indirectly, the class to which the window belongs. </param>
            <param name="lpClassName">[out] Pointer to the buffer that is to receive the class name string. </param>
            <param name="nMaxCount">[in] Specifies the length, in TCHAR, of the buffer pointed to by the lpClassName parameter. The class name string is truncated if it is longer than the buffer and is always null-terminated. </param>
            <returns>If the function succeeds, the return value is the number of TCHAR copied to the specified buffer. If the function fails, the return value is zero. To get extended error information, call GetLastError. </returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.GetClientRect(System.Void*,JetBrains.Interop.WinApi.RECT*)">
            <summary>
            The GetClientRect function retrieves the coordinates of a window's client area. The client coordinates specify the upper-left and lower-right corners of the client area. Because client coordinates are relative to the upper-left corner of a window's client area, the coordinates of the upper-left corner are (0,0). 
            </summary>
            <param name="hWnd">[in] Handle to the window whose client coordinates are to be retrieved. </param>
            <param name="lpRect">[out] Pointer to a RECT structure that receives the client coordinates. The left and top members are zero. The right and bottom members contain the width and height of the window. </param>
            <returns>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call GetLastError.</returns>
            <remarks>In conformance with conventions for the RECT structure, the bottom-right coordinates of the returned rectangle are exclusive. In other words, the pixel at (right, bottom) lies immediately outside the rectangle.</remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.GetCursorInfo(JetBrains.Interop.WinApi.Declarations.Structures.CURSORINFO*)">
            <summary>
            The GetCursorInfo function retrieves information about the global cursor.
            </summary>
            <param name="pci">Pointer to a CURSORINFO structure that receives the information. Note that you must set CURSORINFO.cbSize to sizeof(CURSORINFO) before calling this function.</param>
            <returns>If the function succeeds, the return value is nonzero. 
            If the function fails, the return value is zero. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.GetCursorPos(JetBrains.Interop.WinApi.POINT*)">
            <summary>
            Retrieves the cursor's position, in screen coordinates.
            </summary>
            <param name="lpPoint">[out] Pointer to a POINT structure that receives the screen coordinates of the cursor.</param>
            <returns>Returns nonzero if successful or zero otherwise. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.GetDlgItem(System.Void*,System.Int32)">
            <summary>
            The GetDlgItem function retrieves a handle to a control in the specified dialog box. 
            </summary>
            <param name="hDlg">[in] Handle to the dialog box that contains the control. </param>
            <param name="nIDDlgItem">[in] Specifies the identifier of the control to be retrieved.</param>
            <returns>If the function succeeds, the return value is the window handle of the specified control. 
            If the function fails, the return value is NULL, indicating an invalid dialog box handle or a nonexistent control. To get extended error information, call GetLastError.</returns>
            <remarks>You can use the GetDlgItem function with any parent-child window pair, not just with dialog boxes. As long as the hDlg parameter specifies a parent window and the child window has a unique identifier (as specified by the hMenu parameter in the CreateWindow or CreateWindowEx function that created the child window), GetDlgItem returns a valid handle to the child window.</remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.GetFocus">
            <summary>
            The GetFocus function retrieves the handle to the window that has the keyboard focus, if the window is attached to the calling thread's message queue. 
            </summary>
            <returns>The return value is the handle to the window with the keyboard focus. If the calling thread's message queue does not have an associated window with the keyboard focus, the return value is <c>NULL</c>.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.GetForegroundWindow">
            <summary>
            The GetForegroundWindow function returns a handle to the foreground window (the window with which the user is currently working). The system assigns a slightly higher priority to the thread that creates the foreground window than it does to other threads. 
            </summary>
            <returns>The return value is a handle to the foreground window. The foreground window can be NULL in certain circumstances, such as when a window is losing activation. </returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.GetGUIThreadInfo(System.UInt32,JetBrains.Interop.WinApi.GUITHREADINFO*)">
            <summary>
            Retrieves information about the active window or a specified graphical user interface (GUI) thread.
            </summary>
            <param name="idThread">Identifies the thread for which information is to be retrieved. To retrieve this value, use the GetWindowThreadProcessId function. If this parameter is NULL, the function returns information for the foreground thread.</param>
            <param name="lpgui">Pointer to a <see cref="T:JetBrains.Interop.WinApi.GUITHREADINFO"/> structure that receives information describing the thread. Note that you must set <c>GUITHREADINFO.cbSize</c> to <c>sizeof(GUITHREADINFO)</c> before calling this function.</param>
            <returns>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call GetLastError.</returns>
            <remarks>
            This function succeeds even if the active window is not owned by the calling process. If the specified thread does not exist or have an input queue, the function will fail. 
            This function is useful for retrieving out-of-context information about a thread. The information retrieved is the same as if an application retrieved the information about itself. 
            </remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.GetKeyState(System.Int32)">
            <summary>
            The GetKeyState function retrieves the status of the specified virtual key. The status specifies whether the key is up, down, or toggled (on, off—alternating each time the key is pressed). 
            </summary>
            <param name="nVirtKey">
            [in] Specifies a virtual key. If the desired virtual key is a letter or digit (A through Z, a through z, or 0 through 9), nVirtKey must be set to the ASCII value of that character. For other keys, it must be a virtual-key code.
            If a non-English keyboard layout is used, virtual keys with values in the range ASCII A through Z and 0 through 9 are used to specify most of the character keys. For example, for the German keyboard layout, the virtual key of value ASCII O (0x4F) refers to the "o" key, whereas VK_OEM_1 refers to the "o with umlaut" key.
            </param>
            <returns>
            The return value specifies the status of the specified virtual key, as follows:
            • If the high-order bit is 1, the key is down; otherwise, it is up.
            • If the low-order bit is 1, the key is toggled. A key, such as the CAPS LOCK key, is toggled if it is turned on. The key is off and untoggled if the low-order bit is 0. A toggle key's indicator light (if any) on the keyboard will be on when the key is toggled, and off when the key is untoggled.
            </returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.GetKeyboardState(System.Byte[])">
            <summary>
            Copies the status of the 256 virtual keys to the specified buffer.
            </summary>
            <param name="lpKeyState">[out] When the function returns, each member of the array pointed to by the lpKeyState parameter contains status data for a virtual key. If the high-order bit is 1, the key is down; otherwise, it is up. If the key is a toggle key, for example CAPS LOCK, then the low-order bit is 1 when the key is toggled and is 0 if the key is untoggled. The low-order bit is meaningless for non-toggle keys.</param>
            <returns>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.GetMessageW(JetBrains.Interop.WinApi.MSG*,System.Void*,System.UInt32,System.UInt32)">
            <summary>
            The GetMessage function retrieves a message from the calling thread's message queue. The function dispatches incoming sent messages until a posted message is available for retrieval. Unlike GetMessage, the <see cref="M:JetBrains.Interop.WinApi.User32Dll.PeekMessageW(JetBrains.Interop.WinApi.MSG*,System.Void*,System.UInt32,System.UInt32,System.UInt32)"/> function does not wait for a message to be posted before returning.
            </summary>
            <param name="lpMsg">[out] Pointer to an MSG structure that receives message information from the thread's message queue.</param>
            <param name="hWnd">[in] Handle to the window whose messages are to be retrieved. The window must belong to the current thread. If hWnd is NULL, GetMessage retrieves messages for any window that belongs to the current thread, and any messages on the current thread's message queue whose hwnd value is NULL (see the MSG structure). Therefore if hWnd is NULL, both window messages and thread messages are processed. If hWnd is -1, GetMessage retrieves only messages on the current thread's message queue whose hwnd value is NULL, that is, thread messages as posted by PostMessage (when the hWnd parameter is NULL) or PostThreadMessage.</param>
            <param name="wMsgFilterMin">[in] Specifies the integer value of the lowest message value to be retrieved. Use WM_KEYFIRST to specify the first keyboard message or WM_MOUSEFIRST to specify the first mouse message. Windows XP: Use WM_INPUT here and in wMsgFilterMax to specify only the WM_INPUT messages. If wMsgFilterMin and wMsgFilterMax are both zero, GetMessage returns all available messages (that is, no range filtering is performed).</param>
            <param name="wMsgFilterMax">[in] Specifies the integer value of the highest message value to be retrieved. Use WM_KEYLAST to specify the last keyboard message or WM_MOUSELAST to specify the last mouse message. Windows XP: Use WM_INPUT here and in wMsgFilterMin to specify only the WM_INPUT messages. If wMsgFilterMin and wMsgFilterMax are both zero, GetMessage returns all available messages (that is, no range filtering is performed).</param>
            <returns>If the function retrieves a message other than WM_QUIT, the return value is nonzero. If the function retrieves the WM_QUIT message, the return value is zero. If there is an error, the return value is -1. For example, the function fails if hWnd is an invalid window handle or lpMsg is an invalid pointer. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.GetParent(System.Void*)">
            <summary>
            The GetParent function retrieves a handle to the specified window's parent or owner. To retrieve a handle to a specified ancestor, use the GetAncestor function.
            </summary>
            <param name="hWnd">[in] Handle to the window whose parent window handle is to be retrieved. </param>
            <returns>If the window is a child window, the return value is a handle to the parent window. If the window is a top-level window, the return value is a handle to the owner window. If the window is a top-level unowned window or if the function fails, the return value is NULL. To get extended error information, call GetLastError. For example, this would determine, when the function returns NULL, if the function failed or the window was a top-level window.</returns>
            <remarks>Note that, despite its name, this function can return an owner window instead of a parent window. To obtain the parent window and not the owner, use GetAncestor with the GA_PARENT flag.</remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.GetSystemMetrics(System.Int32)">
            <summary>
            Retrieves the specified system metric or system configuration setting.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.GetThreadDesktop(System.UInt32)">
            <summary>
            Retrieves a handle to the desktop assigned to the specified thread. Windows Me/98/95:  The system does not support multiple desktops, so GetThreadDesktop always returns the same value.
            </summary>
            <param name="dwThreadId">A handle to the thread. The GetCurrentThreadId and CreateProcess functions return thread identifiers.</param>
            <returns>If the function succeeds, the return value is a handle to the desktop associated with the specified thread. You do not need to call the CloseDesktop function to close the returned handle. If the function fails, the return value is NULL. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.GetWindowLongPtrW(System.Void*,System.Int32)">
            <summary>
            The GetWindowLongPtrW function retrieves information about the specified window. The function also retrieves the value at a specified offset into the extra window memory.
            </summary>
            <remarks>void* is used instead of IntPtr here for safer casts on x64 systems: IntPtr is explicitly checked and throws an overflow exception.</remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.GetWindowRect(System.Void*,JetBrains.Interop.WinApi.RECT*)">
            <summary>
            The <see cref="M:JetBrains.Interop.WinApi.User32Dll.GetWindowRect(System.Void*,JetBrains.Interop.WinApi.RECT*)"/> function retrieves the dimensions of the bounding rectangle of the specified window. The dimensions are given in screen coordinates that are relative to the upper-left corner of the screen.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.GetWindowTextW(System.Void*,System.Char*,System.Int32)">
            <summary>
            The GetWindowText function copies the text of the specified window's title bar (if it has one) into a buffer. If the specified window is a control, the text of the control is copied. However, GetWindowText cannot retrieve the text of a control in another application.
            </summary>
            <param name="hWnd">[in] Handle to the window or control containing the text. </param>
            <param name="lpString">[out] Pointer to the buffer that will receive the text. If the string is as long or longer than the buffer, the string is truncated and terminated with a NULL character</param>
            <param name="nMaxCount">[in] Specifies the maximum number of characters to copy to the buffer, including the NULL character. If the text exceeds this limit, it is truncated.</param>
            <returns>If the function succeeds, the return value is the length, in characters, of the copied string, not including the terminating NULL character. If the window has no title bar or text, if the title bar is empty, or if the window or control handle is invalid, the return value is zero. To get extended error information, call GetLastError. This function cannot retrieve the text of an edit control in another application.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.GetWindowThreadProcessId(System.Void*,System.UInt32*)">
            <summary>
            The GetWindowThreadProcessId function retrieves the identifier of the thread that created the specified window and, optionally, the identifier of the process that created the window.
            </summary>
            <param name="hWnd">[in] Handle to the window. </param>
            <param name="lpdwProcessId">[out] Pointer to a variable that receives the process identifier. If this parameter is not NULL, GetWindowThreadProcessId copies the identifier of the process to the variable; otherwise, it does not. </param>
            <returns>The return value is the identifier of the thread that created the window. </returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.InvalidateRect(System.Void*,JetBrains.Interop.WinApi.RECT*,System.Int32)">
            <summary>
            The InvalidateRect function adds a rectangle to the specified window's update region. The update region represents the portion of the window's client area that must be redrawn. 
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.IsChild(System.Void*,System.Void*)">
            <summary>
            The IsChild function tests whether a window is a child window or descendant window of a specified parent window. A child window is the direct descendant of a specified parent window if that parent window is in the chain of parent windows; the chain of parent windows leads from the original overlapped or pop-up window to the child window. 
            </summary>
            <param name="hWndParent">[in] Handle to the parent window. </param>
            <param name="hWnd">[in] Handle to the window to be tested. </param>
            <returns>If the window is a child or descendant window of the specified parent window, the return value is nonzero. If the window is not a child or descendant window of the specified parent window, the return value is zero.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.IsIconic(System.Void*)">
            <summary>
            The IsIconic function return true is windows is minimized. 
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.IsWindow(System.Void*)">
            <summary>
            The IsWindow function determines whether the specified window handle identifies an existing window.
            </summary>
            <param name="hWnd">[in] Handle to the window to test.</param>
            <returns>If the window handle identifies an existing window, the return value is nonzero. If the window handle does not identify an existing window, the return value is zero.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.IsWindowEnabled(System.Void*)">
            <summary>
            The IsWindowEnabled function determines whether the specified window is enabled for mouse and keyboard input. 
            </summary>
            <param name="hWnd">[in] Handle to the window to test.</param>
            <returns>If the window is enabled, the return value is nonzero. If the window is not enabled, the return value is zero.</returns>
            <remarks>A child window receives input only if it is both enabled and visible.</remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.IsWindowVisible(System.Void*)">
            <summary>
            The IsWindowVisible function retrieves the visibility state of the specified window.
            </summary>
            <param name="hWnd">[in] Handle to the window to test.</param>
            <returns>If the specified window, its parent window, its parent's parent window, and so forth, have the WS_VISIBLE style, the return value is nonzero. Otherwise, the return value is zero. Because the return value specifies whether the window has the WS_VISIBLE style, it may be nonzero even if the window is totally obscured by other windows.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.IsZoomed(System.Void*)">
            <summary>
            The IsZoomed function return true is windows is maximized. 
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.IsWindowUnicode(System.Void*)">
            <summary>
            Determines whether the specified window is a native Unicode window.
            </summary>
            <param name="hWnd">[in] Handle to the window to be tested.</param>
            <returns>If the window is a native Unicode window, the return value is nonzero. If the window is not a native Unicode window, the return value is zero. The window is a native ANSI window..</returns>
            <remarks>
            The character set of a window is determined by the use of the RegisterClass function. 
            If the window class was registered with the ANSI version of RegisterClass (RegisterClassA), the character set of the window is ANSI. 
            If the window class was registered with the Unicode version of RegisterClass (RegisterClassW), the character set of the window is Unicode.
            
            The system does automatic two-way translation (Unicode to ANSI) for window messages. 
            For example, if an ANSI window message is sent to a window that uses the Unicode character set, the system translates that message into a Unicode message before calling the window procedure. 
            The system calls IsWindowUnicode to determine whether to translate the message.
            </remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.LoadCursorW(System.Void*,System.Char*)">
            <summary>
            The LoadCursor function loads the specified cursor resource from the executable (.EXE) file associated with an application instance.
            </summary>
            <param name="hInstance">[in] Handle to an instance of the module whose executable file contains the cursor to be loaded.</param>
            <param name="lpCursorName">[in] Pointer to a null-terminated string that contains the name of the cursor resource to be loaded. Alternatively, this parameter can consist of the resource identifier in the low-order word and zero in the high-order word. The MAKEINTRESOURCE macro can also be used to create this value. To use one of the predefined cursors, the application must set the hInstance parameter to NULL and the lpCursorName parameter to one the following values: <see cref="T:JetBrains.Interop.WinApi.StockCursors"/></param>
            <returns>If the function succeeds, the return value is the handle to the newly loaded cursor.
            If the function fails, the return value is NULL. To get extended error information, call GetLastError. </returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.LoadStringW(System.Void*,System.UInt32,System.UInt16*,System.Int32)">
            <summary>
            The LoadString function loads a string resource from the executable file associated with a specified module, copies the string into a buffer, and appends a terminating NULL character. 
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.MapWindowPoints(System.Void*,System.Void*,JetBrains.Interop.WinApi.POINT*,System.UInt32)">
             <summary>
             The MapWindowPoints function converts (maps) a set of points from a coordinate space relative to one window to a coordinate space relative to another window. 
             </summary>
             <param name="hWndFrom">[in] Handle to the window from which points are converted. If this parameter is NULL or HWND_DESKTOP, the points are presumed to be in screen coordinates. </param>
             <param name="hWndTo">[in] Handle to the window to which points are converted. If this parameter is NULL or HWND_DESKTOP, the points are converted to screen coordinates. </param>
             <param name="lpPoints">[in/out] Pointer to an array of POINT structures that contain the set of points to be converted. The points are in device units. This parameter can also point to a RECT structure, in which case the cPoints parameter should be set to 2. </param>
             <param name="cPoints">[in] Specifies the number of POINT structures in the array pointed to by the lpPoints parameter. </param>
             <returns>If the function succeeds, the low-order word of the return value is the number of pixels added to the horizontal coordinate of each source point in order to compute the horizontal coordinate of each destination point; the high-order word is the number of pixels added to the vertical coordinate of each source point in order to compute the vertical coordinate of each destination point. If the function fails, the return value is zero. Call SetLastError prior to calling this method to differentiate an error return value from a legitimate "0" return value.  Windows NT/2000/XP: To get extended error information, call GetLastError.</returns>
             <remarks>If hWndFrom or hWndTo (or both) are mirrored windows (that is, have WS_EX_LAYOUTRTL extended style), MapWindowPoints will automatically adjust mirrored coordinates if you pass two or less points in lpPoints. If you pass more than two points, the function will not fail but it will return erroneous positions. Thus, to guarantee the correct transformation of rectangle coordinates, you must call MapWindowPoints with two or less points at a time, as shown in the following example:
             <code>
               RECT        rc[10];
            
               for(int i =0; i &lt; (sizeof(rc)/sizeof(rc[0])); i++)
               {
                   MapWindowPoints(hWnd1, hWnd2, (LPPOINT)(&amp;rc[i]), (sizeof(RECT)/sizeof(POINT)) );
               }
             </code></remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.MessageBoxW(System.Void*,System.String,System.String,System.UInt32)">
            <summary>
            The MessageBox function creates, displays, and operates a message box. The message box contains an application-defined message and title, along with any combination of predefined icons and push buttons.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.MsgWaitForMultipleObjects(System.UInt32,System.Void**,System.Int32,System.UInt32,System.UInt32)">
            <summary>
            Waits until one or all of the specified objects are in the signaled state or the time-out interval elapses. The objects can include input event objects, which you specify using the dwWakeMask parameter. To enter an alertable wait state, use the <see cref="M:JetBrains.Interop.WinApi.User32Dll.MsgWaitForMultipleObjectsEx(System.UInt32,System.Void**,System.UInt32,System.UInt32,System.UInt32)"/> function.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.MsgWaitForMultipleObjectsEx(System.UInt32,System.Void**,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Waits until one or all of the specified objects are in the signaled state, an I/O completion routine or asynchronous procedure call (APC) is queued to the thread, or the time-out interval elapses. The array of objects can include input event objects, which you specify using the dwWakeMask parameter.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.OpenDesktopW(System.String,System.UInt32,System.Int32,System.UInt32)">
            <summary>
            Opens the specified desktop object.
            </summary>
            <param name="lpszDesktop">The name of the desktop to be opened. Desktop names are case-insensitive. This desktop must belong to the current window station.</param>
            <param name="dwFlags">This parameter can be zero or the following value. <c>DF_ALLOWOTHERACCOUNTHOOK</c> <c>0x0001</c> Allows processes running in other accounts on the desktop to set hooks in this process.</param>
            <param name="fInherit">If this value is TRUE, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.</param>
            <param name="dwDesiredAccess">The access to the desktop. For a list of access rights, see Desktop Security and Access Rights.</param>
            <returns>If the function succeeds, the return value is a handle to the opened desktop. When you are finished using the handle, call the CloseDesktop function to close it. If the function fails, the return value is NULL. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.OpenWindowStationW(System.String,System.Int32,System.UInt32)">
            <summary>
            Opens the specified window station.
            </summary>
            <param name="lpszWinSta">The name of the window station to be opened. Window station names are case-insensitive. This window station must belong to the current session.</param>
            <param name="fInherit">If this value is TRUE, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.</param>
            <param name="dwDesiredAccess">The access to the window station. For a list of access rights, see Window Station Security and Access Rights.</param>
            <returns>If the function succeeds, the return value is the handle to the specified window station. If the function fails, the return value is NULL. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.PeekMessageW(JetBrains.Interop.WinApi.MSG*,System.Void*,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            The PeekMessage function dispatches incoming sent messages, checks the thread message queue for a posted message, and retrieves the message (if any exist).
            </summary>
            <param name="lpMsg">[out] Pointer to an MSG structure that receives message information.</param>
            <param name="hWnd">[in] Handle to the window whose messages are to be retrieved. The window must belong to the current thread. 
            If hWnd is NULL, PeekMessage retrieves messages for any window that belongs to the current thread, and any messages on the current thread's message queue whose hwnd value is NULL (see the MSG structure). Therefore if hWnd is NULL, both window messages and thread messages are processed.
            If hWnd is -1, PeekMessage retrieves only messages on the current thread's message queue whose hwnd value is NULL, that is, thread messages as posted by PostMessage (when the hWnd parameter is NULL) or PostThreadMessage.
            </param>
            <param name="wMsgFilterMin">[in] Specifies the value of the first message in the range of messages to be examined. Use WM_KEYFIRST to specify the first keyboard message or WM_MOUSEFIRST to specify the first mouse message. If wMsgFilterMin and wMsgFilterMax are both zero, PeekMessage returns all available messages (that is, no range filtering is performed).</param>
            <param name="wMsgFilterMax">[in] Specifies the value of the last message in the range of messages to be examined. Use WM_KEYLAST to specify the last keyboard message or WM_MOUSELAST to specify the last mouse message. If wMsgFilterMin and wMsgFilterMax are both zero, PeekMessage returns all available messages (that is, no range filtering is performed).</param>
            <param name="wRemoveMsg">[in] Specifies how messages are handled. This parameter can be one of the following values. PM_NOREMOVE Messages are not removed from the queue after processing by PeekMessage. PM_REMOVE Messages are removed from the queue after processing by PeekMessage. You can optionally combine the value PM_NOYIELD with either PM_NOREMOVE or PM_REMOVE. This flag prevents the system from releasing any thread that is waiting for the caller to go idle (see WaitForInputIdle). By default, all message types are processed. To specify that only certain message should be processed, specify one or more of the following values. PM_QS_INPUT Windows 98/Me, Windows 2000/XP: Process mouse and keyboard messages. PM_QS_PAINT Windows 98/Me, Windows 2000/XP: Process paint messages. PM_QS_POSTMESSAGE Windows 98/Me, Windows 2000/XP: Process all posted messages, including timers and hotkeys.  PM_QS_SENDMESSAGE Windows 98/Me, Windows 2000/XP: Process all sent messages.</param>
            <returns>If a message is available, the return value is nonzero. If no messages are available, the return value is zero.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.PostMessageW(System.Void*,System.UInt32,System.IntPtr,System.IntPtr)">
            <summary>
            The PostMessageW function places (posts) a message in the message queue associated with the thread that created the specified window and returns without waiting for the thread to process the message. To post a message in the message queue associate with a thread, use the PostThreadMessage function.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.PostThreadMessageW(System.UInt32,System.UInt32,System.IntPtr,System.IntPtr)">
            <summary>
            The PostThreadMessage function posts a message to the message queue of the specified thread. It returns without waiting for the thread to process the message.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.PostQuitMessage(System.Int32)">
            <summary>
            Indicates to the system that a thread has made a request to terminate (quit). It is typically used in response to a WM_DESTROY message.
            </summary>
            <param name="exitCode">[in] The application exit code. This value is used as the wParam parameter of the WM_QUIT message.</param>
            <returns>This function does not return a value.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.WaitMessage">
            <summary>
            Yields control to other threads when a thread has no other messages in its message queue. 
            The WaitMessage function suspends the thread and does not return until a new message is placed in the thread's message queue.
            </summary>
            <returns>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.PrintWindow(System.Void*,System.Void*,System.UInt32)">
            <summary>
            The PrintWindow function copies a visual window into the specified device context (DC), typically a printer DC.
            </summary>
            <param name="hwnd">Window to copy</param>
            <param name="hdcBlt">HDC to print into</param>
            <param name="nFlags">Optional flags</param>
            <returns>If the function succeeds, it returns a nonzero value.
            If the function fails, it returns zero.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.ScreenToClient(System.Void*,JetBrains.Interop.WinApi.POINT*)">
            <summary>
            The ScreenToClient function converts the screen coordinates of a specified point on the screen to client-area coordinates. 
            </summary>
            <param name="hWnd">[in] Handle to the window whose client area will be used for the conversion. </param>
            <param name="lpPoint">[in] Pointer to a POINT structure that specifies the screen coordinates to be converted. </param>
            <returns>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. Windows NT/2000/XP: To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.SendMessageW(System.Void*,System.UInt32,System.IntPtr,System.IntPtr)">
            <summary>
            The SendMessage function sends the specified message to a window or windows. It calls the window procedure for the specified window and does not return until the window procedure has processed the message.
            To send a message and return immediately, use the SendMessageCallback or SendNotifyMessage function. To post a message to a thread's message queue and return immediately, use the PostMessageW or PostThreadMessage function.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.SetActiveWindow(System.Void*)">
            <summary>
            The SetActiveWindow function activates a window. The window must be attached to the calling thread's message queue. 
            </summary>
            <param name="hWnd">[in] Handle to the top-level window to be activated.</param>
            <returns>If the function succeeds, the return value is the handle to the window that was previously active. If the function fails, the return value is NULL. To get extended error information, call GetLastError.</returns>
            <remarks>
            <para>The SetActiveWindow function activates a window, but not if the application is in the background. The window will be brought into the foreground (top of Z-Order) if its application is in the foreground when the system activates the window. </para>
            <para>If the window identified by the hWnd parameter was created by the calling thread, the active window status of the calling thread is set to hWnd. Otherwise, the active window status of the calling thread is set to NULL.</para>
            <para>By using the AttachThreadInput function, a thread can attach its input processing to another thread. This allows a thread to call SetActiveWindow to activate a window attached to another thread's message queue. </para>
            </remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.SetCursor(System.Void*)">
            <summary>
            The SetCursor function sets the cursor shape. 
            </summary>
            <param name="hCursor">
            [in] 
            Handle to the cursor. The cursor must have been created by the CreateCursor function or loaded by the LoadCursor or LoadImage function. If this parameter is NULL, the cursor is removed from the screen.
            Windows 95/98/Me: The width and height of the cursor must be the values returned by the GetSystemMetrics function for SM_CXCURSOR and SM_CYCURSOR. For Microsoft Windows 95, either the cursor bit depth must match the bit depth of the display or the cursor must be monochrome. However, for Windows 98 and Windows 98, if the cursor bit depth does not match the bit depth of the display then the cursor is converted to 4bpp VGA color. 
            </param>
            <returns>
            The return value is the handle to the previous cursor, if there was one. 
            If there was no previous cursor, the return value is NULL. 
            </returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.SetFocus(System.Void*)">
            <summary>
            The SetFocus function sets the keyboard focus to the specified window. The window must be attached to the calling thread's message queue. The SetFocus function sends a WM_KILLFOCUS message to the window that loses the keyboard focus and a WM_SETFOCUS message to the window that receives the keyboard focus. It also activates either the window that receives the focus or the parent of the window that receives the focus. If a window is active but does not have the focus, any key pressed will produce the WM_SYSCHAR, WM_SYSKEYDOWN, or WM_SYSKEYUP message. If the VK_MENU key is also pressed, the lParam parameter of the message will have bit 30 set. Otherwise, the messages produced do not have this bit set. By using the AttachThreadInput function, a thread can attach its input processing to another thread. This allows a thread to call SetFocus to set the keyboard focus to a window attached to another thread's message queue. 
            </summary>
            <param name="hWnd">[in] Handle to the window that will receive the keyboard input. If this parameter is NULL, keystrokes are ignored. </param>
            <returns>If the function succeeds, the return value is the handle to the window that previously had the keyboard focus. If the hWnd parameter is invalid or the window is not attached to the calling thread's message queue, the return value is NULL. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.SetForegroundWindow(System.Void*)">
            <summary>
            The SetForegroundWindow function puts the thread that created the specified window into the foreground and
            activates the window. Keyboard input is directed to the window, and various visual cues are changed for the user.
            The system assigns a slightly higher priority to the thread that created the foreground window than it does to other threads.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.SetLayeredWindowAttributes(System.Void*,System.UInt32,System.Byte,System.UInt32)">
            <summary>
            The SetLayeredWindowAttributes function sets the opacity and transparency color key of a layered window.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.SetParent(System.Void*,System.Void*)">
            <summary>
            The SetParent function changes the parent window of the specified child window. 
            An application can use the SetParent function to set the parent window of a pop-up, overlapped, or child window. The new parent window and the child window must belong to the same application. If the window identified by the hWndChild parameter is visible, the system performs the appropriate redrawing and repainting. For compatibility reasons, SetParent does not modify the WS_CHILD or WS_POPUP window styles of the window whose parent is being changed. Therefore, if hWndNewParent is NULL, you should also clear the WS_CHILD bit and set the WS_POPUP style after calling SetParent. Conversely, if hWndNewParent is not NULL and the window was previously a child of the desktop, you should clear the WS_POPUP style and set the WS_CHILD style before calling SetParent. Windows 2000/XP: When you change the parent of a window, you should synchronize the UISTATE of both windows. For more information, see WM_CHANGEUISTATE and WM_UPDATEUISTATE. 
            </summary>
            <param name="hWndChild">[in] Handle to the child window.</param>
            <param name="hWndNewParent">[in] Handle to the new parent window. If this parameter is NULL, the desktop window becomes the new parent window. Windows 2000/XP: If this parameter is HWND_MESSAGE, the child window becomes a message-only window.</param>
            <returns>If the function succeeds, the return value is a handle to the previous parent window. If the function fails, the return value is NULL. To get extended error information, call GetLastError. </returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.SetProcessWindowStation(System.Void*)">
            <summary>
            Assigns the specified window station to the calling process. This enables the process to access objects in the window station such as desktops, the clipboard, and global atoms. All subsequent operations on the window station use the access rights granted to hWinSta.
            </summary>
            <param name="hWinSta">A handle to the window station. This can be a handle returned by the CreateWindowStation, OpenWindowStation, or GetProcessWindowStation function. This window station must be associated with the current session.</param>
            <returns>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.SetThreadDesktop(System.Void*)">
            <summary>
            Assigns the specified desktop to the calling thread. All subsequent operations on the desktop use the access rights granted to the desktop.
            </summary>
            <param name="hDesktop">A handle to the desktop to be assigned to the calling thread. This handle is returned by the CreateDesktop, GetThreadDesktop, OpenDesktop, or OpenInputDesktop function. This desktop must be associated with the current window station for the process.</param>
            <returns>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.SetWindowLongPtrW(System.Void*,System.Int32,System.Void*)">
            <summary>
            The SetWindowLongPtrW function changes an attribute of the specified window. The function also sets a value at the specified offset in the extra window memory.
            </summary>
            <remarks>void* is used instead of IntPtr here for safer casts on x64 systems: IntPtr is explicitly checked and throws an overflow exception.</remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.ShowWindow(System.Void*,System.Int32)">
            <summary>
            The ShowWindow function sets the specified window's show state. 
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.SwitchToThisWindow(System.Void*,System.UInt32)">
            <summary>
            The SwitchToThisWindow function is called to switch focus to a specified window and bring it to the foreground.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.TranslateMessage(JetBrains.Interop.WinApi.MSG*)">
            <summary>
            The TranslateMessage function translates virtual-key messages into character messages. The character messages are posted to the calling thread's message queue, to be read the next time the thread calls the <see cref="M:JetBrains.Interop.WinApi.User32Dll.GetMessageW(JetBrains.Interop.WinApi.MSG*,System.Void*,System.UInt32,System.UInt32)"/> or <see cref="M:JetBrains.Interop.WinApi.User32Dll.PeekMessageW(JetBrains.Interop.WinApi.MSG*,System.Void*,System.UInt32,System.UInt32,System.UInt32)"/> function.
            </summary>
            <param name="lpMsg">[in] Pointer to an <see cref="T:JetBrains.Interop.WinApi.MSG"/> structure that contains message information retrieved from the calling thread's message queue by using the GetMessage or PeekMessage function.</param>
            <returns>If the message is translated (that is, a character message is posted to the thread's message queue), the return value is nonzero. If the message is <see cref="F:JetBrains.Interop.WinApi.WindowsMessages.WM_KEYDOWN"/>, <see cref="F:JetBrains.Interop.WinApi.WindowsMessages.WM_KEYUP"/>, <see cref="F:JetBrains.Interop.WinApi.WindowsMessages.WM_SYSKEYDOWN"/>, or <see cref="F:JetBrains.Interop.WinApi.WindowsMessages.WM_SYSKEYUP"/>, the return value is nonzero, regardless of the translation. If the message is not translated (that is, a character message is not posted to the thread's message queue), the return value is zero.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.UpdateLayeredWindow(System.Void*,System.Void*,JetBrains.Interop.WinApi.POINT*,JetBrains.Interop.WinApi.Declarations.Structures.SIZE*,System.Void*,JetBrains.Interop.WinApi.POINT*,System.UInt32,JetBrains.Interop.WinApi.Declarations.Structures.BLENDFUNCTION*,System.UInt32)">
            <summary>
            The UpdateLayeredWindow function updates the position, size, shape, content, and translucency of a layered window.
            </summary>
            <param name="hwnd">[in] Handle to a layered window. A layered window is created by specifying WS_EX_LAYERED when creating the window with the CreateWindowEx function.</param>
            <param name="hdcDst">[in] 
            Handle to a device context (DC) for the screen. This handle is obtained by specifying NULL when calling the function. It is used for palette color matching when the window contents are updated. If hdcDst isNULL, the default palette will be used.
            If hdcSrc is NULL, hdcDst must be NULL.</param>
            <param name="pptDst">[in] Pointer to a POINT structure that specifies the new screen position of the layered window. If the current position is not changing, pptDst can be NULL. </param>
            <param name="psize">[in] Pointer to a SIZE structure that specifies the new size of the layered window. If the size of the window is not changing, psize can be NULL. If hdcSrc is NULL, psize must be NULL.</param>
            <param name="hdcSrc">[in] Handle to a DC for the surface that defines the layered window. This handle can be obtained by calling the CreateCompatibleDC function. If the shape and visual context of the window are not changing, hdcSrc can be NULL.</param>
            <param name="pptSrc">[in] Pointer to a POINT structure that specifies the location of the layer in the device context. If hdcSrc is NULL, pptSrc should be NULL.</param>
            <param name="crKey">[in] Pointer to a COLORREF value that specifies the color key to be used when composing the layered window. To generate a COLORREF, use the RGB macro.</param>
            <param name="pblend">[in] Pointer to a BLENDFUNCTION structure that specifies the transparency value to be used when composing the layered window.</param>
            <param name="dwFlags">[in] This parameter can be one of the following values. <see cref="F:JetBrains.Interop.WinApi.Declarations.Constants.UpdateLayeredWindowFlags.ULW_ALPHA"/>, <see cref="F:JetBrains.Interop.WinApi.Declarations.Constants.UpdateLayeredWindowFlags.ULW_COLORKEY"/>, <see cref="F:JetBrains.Interop.WinApi.Declarations.Constants.UpdateLayeredWindowFlags.ULW_OPAQUE"/>. If hdcSrc is NULL, dwFlags should be zero.</param>
            <returns>If the function succeeds, the return value is nonzero.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.ValidateRect(System.Void*,JetBrains.Interop.WinApi.RECT*)">
            <summary>
            The ValidateRect function validates the client area within a rectangle by removing the rectangle from the update region of the specified window.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.WindowFromPoint(JetBrains.Interop.WinApi.POINT)">
            <summary>
            <para>The WindowFromPoint function retrieves a handle to the window that contains the specified point. </para>
            </summary>
            <param name="Point">[in] Specifies a POINT structure that defines the point to be checked. </param>
            <returns>The return value is a handle to the window that contains the point. If no window exists at the given point, the return value is NULL. If the point is over a static text control, the return value is a handle to the window under the static text control. </returns>
            <remarks>The WindowFromPoint function does not retrieve a handle to a hidden or disabled window, even if the point is within the window. An application should use the ChildWindowFromPoint function for a nonrestrictive search.</remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.RegisterWindowMessageW(System.String)">
            <summary>
            Defines a new window message that is guaranteed to be unique throughout the system. The message value can be used when sending or posting messages.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.GetDesktopWindow">
            <summary>
            Retrieves a handle to the desktop window. The desktop window covers the entire screen. The desktop window is the area on top of which other windows are painted.
            </summary>
            <returns>The return value is a handle to the desktop window.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.mouse_event(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UIntPtr)">
            <summary>
            The mouse_event function synthesizes mouse motion and button clicks.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.keybd_event(System.Byte,System.Byte,System.UInt32,System.UIntPtr)">
            <summary>
            Synthesizes a keystroke. The system can use such a synthesized keystroke to generate a <see cref="F:JetBrains.Interop.WinApi.WindowsMessages.WM_KEYUP"/> or <see cref="F:JetBrains.Interop.WinApi.WindowsMessages.WM_KEYDOWN"/> message. The keyboard driver's interrupt handler calls the keybd_event function.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.VkKeyScanW(System.Char)">
            <summary>
            <para>[This function has been superseded by the VkKeyScanEx function. You can still use VkKeyScanW, however, if you do not need to specify a keyboard layout.]</para>
            <para>Translates a character to the corresponding virtual-key code and shift state for the current keyboard.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.GetAsyncKeyState(System.Int32)">
            <summary>
            Determines whether a key is up or down at the time the function is called, and whether the key was pressed after a previous call to GetAsyncKeyState.
            </summary>
            <returns>If the function succeeds, the return value specifies whether the key was pressed since the last call to GetAsyncKeyState, and whether the key is currently up or down. If the most significant bit is set, the key is down, and if the least significant bit is set, the key was pressed after the previous call to GetAsyncKeyState. However, you should not rely on this last behavior; for more information, see the Remarks.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.SetWindowRgn(System.Void*,System.Void*,System.Int32)">
            <summary>
            The SetWindowRgn function sets the window region of a window. The window region determines the area within the window where the system permits drawing. The system does not display any portion of a window that lies outside of the window region.
            </summary>
            <param name="hWnd"></param>
            <param name="hRgn"></param>
            <param name="bRedraw"></param>
            <returns>If the function succeeds, the return value is nonzero.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.SetWindowPos(System.Void*,System.Void*,System.Int32,System.Int32,System.Int32,System.Int32,System.UInt32)">
            <summary>
            Changes the size, position, and Z order of a child, pop-up, or top-level window. These windows are ordered according to their appearance on the screen. The topmost window receives the highest rank and is the first window in the Z order.
            </summary>
            <param name="hWnd"></param>
            <param name="hWndInsertAfter"></param>
            <param name="X"></param>
            <param name="Y"></param>
            <param name="cx"></param>
            <param name="cy"></param>
            <param name="uFlags"></param>
            <returns>If the function succeeds, the return value is nonzero.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.GetCapture">
            <summary>
            Retrieves a handle to the window (if any) that has captured the mouse. Only one window at a time can capture the mouse; this window receives mouse input whether or not the cursor is within its borders.
            </summary>
            <returns>The return value is a handle to the capture window associated with the current thread. If no window in the thread has captured the mouse, the return value is NULL.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.SetCapture(System.Void*)">
            <summary>
              <para>Sets the mouse capture to the specified window belonging to the current thread.SetCapture captures mouse input either when the mouse is over the capturing window, or when the mouse button was pressed while the mouse was over the capturing window and the button is still down. Only one window at a time can capture the mouse.</para>
              <para>If the mouse cursor is over a window created by another thread, the system will direct mouse input to the specified window only if a mouse button is down.</para>
            </summary>
            <param name="hWnd">A handle to the window in the current thread that is to capture the mouse. </param>
            <returns>The return value is a handle to the window that had previously captured the mouse. If there is no such window, the return value is NULL. </returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.ReleaseCapture">
            <summary>
            Releases the mouse capture from a window in the current thread and restores normal mouse input processing. A window that has captured the mouse receives all mouse input, regardless of the position of the cursor, except when a mouse button is clicked while the cursor hot spot is in the window of another thread.
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.MoveWindow(System.Void*,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            The MoveWindow function changes the position and dimensions of the specified window. For a top-level window, the position and dimensions are relative to the upper-left corner of the screen. For a child window, they are relative to the upper-left corner of the parent window's client area.
            </summary>
            <param name="hWnd">[in] Handle to the window. </param>
            <param name="X">[in] Specifies the new position of the left side of the window. </param>
            <param name="Y">[in] Specifies the new position of the top of the window. </param>
            <param name="nWidth">[in] Specifies the new width of the window. </param>
            <param name="nHeight">[in] Specifies the new height of the window. </param>
            <param name="bRepaint">[in] Specifies whether the window is to be repainted. If this parameter is TRUE, the window receives a message. If the parameter is FALSE, no repainting of any kind occurs. This applies to the client area, the nonclient area (including the title bar and scroll bars), and any part of the parent window uncovered as a result of moving a child window. </param>
            <returns>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.BeginPaint(System.Void*,JetBrains.Interop.WinApi.PAINTSTRUCT*)">
            <summary>
            The BeginPaint function prepares the specified window for painting and fills a PAINTSTRUCT structure with information about the painting.
            </summary>
            <param name="hwnd"></param>
            <param name="lpPaint">Pointer to the PAINTSTRUCT structure that will receive painting information.</param>
            <returns>If the function succeeds, the return value is the handle to a display device context for the specified window.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.EndPaint(System.Void*,JetBrains.Interop.WinApi.PAINTSTRUCT*)">
            <summary>
            The EndPaint function marks the end of painting in the specified window. This function is required for each call to the BeginPaint function, but only after painting is complete.
            </summary>
            <param name="hWnd"></param>
            <param name="lpPaint">Pointer to a PAINTSTRUCT structure that contains the painting information retrieved by BeginPaint.</param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.ScrollWindowEx(System.Void*,System.Int32,System.Int32,JetBrains.Interop.WinApi.RECT*,JetBrains.Interop.WinApi.RECT*,System.Void*,JetBrains.Interop.WinApi.RECT*,System.UInt32)">
            <summary>
            The ScrollWindowEx function scrolls the contents of the specified window's client area.
            </summary>
            <param name="hWnd">[in] Handle to the window where the client area is to be scrolled. </param>
            <param name="dx">[in] Specifies the amount, in device units, of horizontal scrolling. This parameter must be a negative value to scroll to the left.</param>
            <param name="dy">[in] Specifies the amount, in device units, of vertical scrolling. This parameter must be a negative value to scroll up. </param>
            <param name="prcScroll">[in] Pointer to a RECT structure that specifies the portion of the client area to be scrolled. If this parameter is NULL, the entire client area is scrolled.</param>
            <param name="prcClip">[in] Pointer to a RECT structure that contains the coordinates of the clipping rectangle. Only device bits within the clipping rectangle are affected. Bits scrolled from the outside of the rectangle to the inside are painted; bits scrolled from the inside of the rectangle to the outside are not painted. This parameter may be NULL.</param>
            <param name="hrgnUpdate">[in] Handle to the region that is modified to hold the region invalidated by scrolling. This parameter may be NULL.</param>
            <param name="prcUpdate">[out] Pointer to a RECT structure that receives the boundaries of the rectangle invalidated by scrolling. This parameter may be NULL.</param>
            <param name="flags">[in] Specifies flags that control scrolling. This parameter can be one of the following values. </param>
            <returns>If the function succeeds, the return value is <see cref="F:JetBrains.Interop.WinApi.Constants.RegionResult.SIMPLEREGION"/> (rectangular invalidated region), <see cref="F:JetBrains.Interop.WinApi.Constants.RegionResult.COMPLEXREGION"/> (nonrectangular invalidated region; overlapping rectangles), or <see cref="F:JetBrains.Interop.WinApi.Constants.RegionResult.NULLREGION"/> (no invalidated region).
            If the function fails, the return vaRegionResultcref="RegionResult.ERROR" /&gt;. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.GetCaretBlinkTime">
            <summary>
            Retrieves the time required to invert the caret's pixels. The user can set this value. 
            </summary>
            <returns></returns>
            <seealso cref="F:JetBrains.Interop.WinApi.WinDef.INFINITE"/>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.AdjustWindowRectEx(JetBrains.Interop.WinApi.RECT*,System.UInt32,System.Int32,System.UInt32)">
            <summary>
            The AdjustWindowRectEx function calculates the required size of the window rectangle, based on the desired size of the client rectangle. The window rectangle can then be passed to the CreateWindowEx function to create a window whose client area is the desired size.
            </summary>
            <param name="lpRect">[in, out] Pointer to a RECT structure that contains the coordinates of the top-left and bottom-right corners of the desired client area. When the function returns, the structure contains the coordinates of the top-left and bottom-right corners of the window to accommodate the desired client area. </param>
            <param name="dwStyle">[in] Specifies the window style of the window whose required size is to be calculated. Note that you cannot specify the WS_OVERLAPPED style. </param>
            <param name="bMenu">[in] Specifies whether the window has a menu.</param>
            <param name="dwExStyle">[in] Specifies the extended window style of the window whose required size is to be calculated. For more information, see CreateWindowEx.</param>
            <returns>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call GetLastError. </returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.GetDC(System.Void*)">
            <summary>
            The GetDC function retrieves a handle to a device context (DC) for the client area of a specified window or for the entire screen. You can use the returned handle in subsequent GDI functions to draw in the DC. The device context is an opaque data structure, whose values are used internally by GDI.
            The GetDCEx function is an extension to GetDC, which gives an application more control over how and whether clipping occurs in the client area.
            </summary>
            <param name="hWnd"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.ReleaseDC(System.Void*,System.Void*)">
            <summary>
            The ReleaseDC function releases a device context (DC), freeing it for use by other applications. The effect of the ReleaseDC function depends on the type of DC. It frees only common and window DCs. It has no effect on class or private DCs.
            </summary>
            <param name="hWnd"></param>
            <param name="hDC"></param>
            <returns>The return value indicates whether the DC was released. If the DC was released, the return value is 1.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.DrawFrameControl(System.Void*,JetBrains.Interop.WinApi.RECT*,System.UInt32,System.UInt32)">
            <summary>
            The DrawFrameControl function draws a frame control of the specified type and style.
            </summary>
            <param name="hdc">[in] Handle to the device context of the window in which to draw the control.</param>
            <param name="lprc">[in] Pointer to a RECT structure that contains the logical coordinates of the bounding rectangle for frame control.</param>
            <param name="uType">[in] Specifies the type of frame control to draw. This parameter can be one of the following values. (<see cref="T:JetBrains.Interop.WinApi.Constants.FrameControlType"/>)</param>
            <param name="uState">[in] Specifies the initial state of the frame control. If uType is DFC_BUTTON, uState can be one of the following values. (<see cref="T:JetBrains.Interop.WinApi.Constants.FrameControlState"/>)</param>
            <returns>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. Windows NT/2000/XP: To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.SetWindowsHookExW(System.Int32,JetBrains.Interop.WinApi.Functions.HOOKPROC,System.Void*,System.UInt32)">
            <summary>
            The SetWindowsHookEx function installs an application-defined hook procedure into a hook chain. You would install a hook procedure to monitor the system for certain types of events. These events are associated either with a specific thread or with all threads in the same desktop as the calling thread.
            </summary>
            <returns>If the function succeeds, the return value is the handle to the hook procedure.
            If the function fails, the return value is NULL. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.SetPropW(System.Void*,System.String,System.Void*)">
            <summary>
            Adds a new entry or changes an existing entry in the property list of the specified window. The function adds a new entry to the list if the specified character string does not exist already in the list. The new entry contains the string and the handle. Otherwise, the function replaces the string's current handle with the specified handle.
            </summary>
            <param name="hWnd"></param>
            <param name="lpString"></param>
            <param name="hData"></param>
            <returns>If the data handle and string are added to the property list, the return value is nonzero.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.RemovePropW(System.Void*,System.String)">
            <summary>
            Removes an entry from the property list of the specified window. The specified character string identifies the entry to be removed.
            </summary>
            <param name="hWnd"></param>
            <param name="lpString"></param>
            <returns>The return value identifies the specified data. If the data cannot be found in the specified property list, the return value is NULL.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.SystemParametersInfoW(System.UInt32,System.UInt32,System.Void*,System.UInt32)">
            <summary>
            Retrieves or sets the value of one of the system-wide parameters. This function can also update the user profile while setting a parameter.
            </summary>
            <param name="uiAction"></param>
            <param name="uiParam"></param>
            <param name="pvParam"></param>
            <param name="fWinIni"></param>
            <returns>If the function succeeds, the return value is a nonzero value.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.FindWindowW(System.String,System.String)">
            <summary>
            Retrieves a handle to the top-level window whose class name and window name match the specified strings. This function does not search child windows. This function does not perform a case-sensitive search.
            To search child windows, beginning with a specified child window, use the FindWindowEx function.
            </summary>
            <param name="lpClassName"></param>
            <param name="lpWindowName"></param>
            <returns>If the function succeeds, the return value is a handle to the window that has the specified class name and window name.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.BringWindowToTop(System.IntPtr)">
            <summary>
            The BringWindowToTop function brings the specified window to the top of the Z order. If the window is a top-level
            window, it is activated. If the window is a child window, the top-level parent window associated with the child window is activated.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.ClientToScreen(System.IntPtr,System.Drawing.Point)">
            <summary>
            Converts a point from window coordinates to screen coordinates, returns an empty point on failure.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.ClientToScreen(System.IntPtr,System.Drawing.Rectangle)">
            <summary>
            Converts a rectangle from window coordinates to screen coordinates, returns an empty rectangle on failure.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.DestroyWindow(System.IntPtr)">
            <summary>
            Calls <see cref="M:JetBrains.Interop.WinApi.User32Dll.DestroyWindow(System.Void*)"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.DisableWindow(System.IntPtr)">
            <summary>
            Disables the window given by its handle.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.EnableWindow(System.IntPtr)">
            <summary>
            Enables the window given by its handle.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.GetChildWindowHandles(System.IntPtr)">
            <summary>
            Lists the handles of all child windows of a specific window, recursively.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.GetClientRect(System.IntPtr)">
            <summary>
            Gets the client rectangle for the window.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.GetCursorInfo">
            <summary>
            Gets the point out of the <see cref="M:JetBrains.Interop.WinApi.User32Dll.GetCursorInfo(JetBrains.Interop.WinApi.Declarations.Structures.CURSORINFO*)"/> (note: <see cref="M:JetBrains.Interop.WinApi.User32Dll.GetCursorPos(JetBrains.Interop.WinApi.POINT*)"/> should not be used).
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.GetDlgItem(System.IntPtr,System.Int32)">
            <summary>
            The GetDlgItem function retrieves a handle to a control in the specified dialog box. 
            </summary>
            <param name="hDlg">[in] Handle to the dialog box that contains the control. </param>
            <param name="nDlgItem">[in] Specifies the identifier of the control to be retrieved.</param>
            <returns>If the function succeeds, the return value is the window handle of the specified control. 
            If the function fails, the return value is NULL, indicating an invalid dialog box handle or a nonexistent control. To get extended error information, call GetLastError.</returns>
            <remarks>You can use the GetDlgItem function with any parent-child window pair, not just with dialog boxes. As long as the hDlg parameter specifies a parent window and the child window has a unique identifier (as specified by the hMenu parameter in the CreateWindow or CreateWindowEx function that created the child window), GetDlgItem returns a valid handle to the child window.</remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.GetFocusOnAnyThreadInAnyProcess">
            <summary>
            Gets the window that currently has focus on this desktop — any thread, any process, etc.
            </summary>
            <seealso cref="M:JetBrains.Interop.WinApi.User32Dll.GetFocus"/>
            <seealso cref="M:JetBrains.Interop.WinApi.User32Dll.GetForegroundWindow"/>
            <seealso cref="M:JetBrains.Interop.WinApi.User32Dll.Helpers.GetFocusOnAnyThreadInOurProcess"/>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.GetFocusOnAnyThreadInOurProcess">
            <summary>
            Gets the window that currently has focus in our process — but on any thread, unlike <see cref="M:JetBrains.Interop.WinApi.User32Dll.GetFocus"/>.
            </summary>
            <seealso cref="M:JetBrains.Interop.WinApi.User32Dll.GetFocus"/>
            <seealso cref="M:JetBrains.Interop.WinApi.User32Dll.GetForegroundWindow"/>
            <seealso cref="M:JetBrains.Interop.WinApi.User32Dll.Helpers.GetFocusOnAnyThreadInAnyProcess"/>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.GetFocus">
            <summary>
            The GetFocus function retrieves the handle to the window that has the keyboard focus, if the window is attached to the calling thread's message queue. 
            </summary>
            <returns>The return value is the handle to the window with the keyboard focus. If the calling thread's message queue does not have an associated window with the keyboard focus, the return value is <c>NULL</c>.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.GetParent(System.IntPtr)">
            <summary>
            Gets parent window for the window
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.GetThreadTopLevelWindowHandles(System.UInt32)">
            <summary>
            Lists the handles of all the top-level windows that belong to the specific thread.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.GetTopLevelWindowHandles">
            <summary>
            Lists the handles of all the top-level windows currently available in the system.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.GetWindowClassName(System.IntPtr)">
            <summary>
            Wnd class name.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.GetWindowLongPtrW(System.IntPtr,JetBrains.Interop.WinApi.WindowLongPtrIndex)">
            <summary>
            NOTE: here void* is used as a return type because otherwise on 64-bit systems casting it to an int might get unsafe unexpectedly.
            </summary>
            <param name="hWnd"></param>
            <param name="nIndex"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.GetWindowProcessId(System.IntPtr)">
            <summary>
            Gets the ID of the process that owns the window.
            Note that creating a <see cref="T:System.Diagnostics.Process"/> wrapper for that is very expensive because it causes an enumeration of all the system processes to happen.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.GetWindowRect(System.IntPtr)">
            <summary>
            Wraps <see cref="M:JetBrains.Interop.WinApi.User32Dll.GetWindowRect(System.Void*,JetBrains.Interop.WinApi.RECT*)"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.GetWindowText(System.IntPtr)">
            <summary>
            Wnd text.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.GetWindowThreadId(System.IntPtr)">
            <summary>
            Gets the ID of the thread that owns the window.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.InvalidateRect(System.IntPtr,System.Nullable{System.Drawing.Rectangle},System.Boolean)">
            <summary>
            Invalidates the specific rectangle. If <paramref name="rect"/> is <c>Null</c>, the whole window is invalidated.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.IsIconic(System.IntPtr)">
            <summary>
            The IsIconic function return true is windows is minimized. 
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.IsThreadWithMessageQueue(System.UInt32)">
            <summary>
            Gets whether the given thread has a message pump created for it.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.IsWindow(System.IntPtr)">
            <summary>
            The IsWindow function determines whether the specified window handle identifies an existing window.
            </summary>
            <param name="handle">[in] Handle to the window to test.</param>
            <returns>If the window handle identifies an existing window, the return value is nonzero. If the window handle does not identify an existing window, the return value is zero.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.IsWindowEnabled(System.IntPtr)">
            <summary>
            The IsWindowEnabled function determines whether the specified window is enabled for mouse and keyboard input. 
            </summary>
            <param name="handle">[in] Handle to the window to test.</param>
            <returns>If the window is enabled, the return value is nonzero. If the window is not enabled, the return value is zero.</returns>
            <remarks>A child window receives input only if it is both enabled and visible.</remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.IsWindowVisible(System.IntPtr)">
            <summary>
            The IsWindowVisible function retrieves the visibility state of the specified window.
            </summary>
            <param name="handle">[in] Handle to the window to test.</param>
            <returns>If the specified window, its parent window, its parent's parent window, and so forth, have the WS_VISIBLE style, the return value is nonzero. Otherwise, the return value is zero. Because the return value specifies whether the window has the WS_VISIBLE style, it may be nonzero even if the window is totally obscured by other windows.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.IsZoomed(System.IntPtr)">
            <summary>
            The IsZoomed function return true is windows is maximized. 
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.PostMessage(System.IntPtr,JetBrains.Interop.WinApi.WindowsMessages,System.IntPtr,System.IntPtr)">
            <summary>
            The PostMessageW function places (posts) a message in the message queue associated with the thread that created the specified window and returns without waiting for the thread to process the message.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.ScreenToClient(System.IntPtr,System.Drawing.Point)">
            <summary>
            Converts a point from screen coordinates to window coordinates, returns an empty point on failure.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.ScreenToClient(System.IntPtr,System.Drawing.Rectangle)">
            <summary>
            Converts a rectangle from screen coordinates to window coordinates, returns an empty rectangle on failure.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.SendMessageW(System.IntPtr,JetBrains.Interop.WinApi.WindowsMessages,System.IntPtr,System.IntPtr)">
            <summary>
            The SendMessage function sends the specified message to a window or windows. It calls the window procedure for the specified window and does not return until the window procedure has processed the message.
            To send a message and return immediately, use the SendMessageCallback or SendNotifyMessage function. To post a message to a thread's message queue and return immediately, use the PostMessageW or PostThreadMessage function.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.SetActiveWindow(System.IntPtr)">
            <summary>
            The SetActiveWindow function activates a window. The window must be attached to the calling thread's message queue. 
            </summary>
            <param name="hWnd">[in] Handle to the top-level window to be activated.</param>
            <returns>If the function succeeds, the return value is the handle to the window that was previously active. If the function fails, the return value is NULL. To get extended error information, call GetLastError.</returns>
            <remarks>
            <para>The SetActiveWindow function activates a window, but not if the application is in the background. The window will be brought into the foreground (top of Z-Order) if its application is in the foreground when the system activates the window. </para>
            <para>If the window identified by the hWnd parameter was created by the calling thread, the active window status of the calling thread is set to hWnd. Otherwise, the active window status of the calling thread is set to NULL.</para>
            <para>By using the AttachThreadInput function, a thread can attach its input processing to another thread. This allows a thread to call SetActiveWindow to activate a window attached to another thread's message queue. </para>
            </remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.SetFocus(System.IntPtr)">
            <summary>
            The SetFocus function sets the keyboard focus to the specified window. The window must be attached to the calling thread's message queue. The SetFocus function sends a WM_KILLFOCUS message to the window that loses the keyboard focus and a WM_SETFOCUS message to the window that receives the keyboard focus. It also activates either the window that receives the focus or the parent of the window that receives the focus. If a window is active but does not have the focus, any key pressed will produce the WM_SYSCHAR, WM_SYSKEYDOWN, or WM_SYSKEYUP message. If the VK_MENU key is also pressed, the lParam parameter of the message will have bit 30 set. Otherwise, the messages produced do not have this bit set. By using the AttachThreadInput function, a thread can attach its input processing to another thread. This allows a thread to call SetFocus to set the keyboard focus to a window attached to another thread's message queue. 
            </summary>
            <param name="hWnd">[in] Handle to the window that will receive the keyboard input. If this parameter is NULL, keystrokes are ignored. </param>
            <returns>If the function succeeds, the return value is the handle to the window that previously had the keyboard focus. If the hWnd parameter is invalid or the window is not attached to the calling thread's message queue, the return value is NULL. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.SetForegroundWindow(System.IntPtr)">
            <summary>
            The SetForegroundWindow function puts the thread that created the specified window into the foreground and
            activates the window. Keyboard input is directed to the window, and various visual cues are changed for the user.
            The system assigns a slightly higher priority to the thread that created the foreground window than it does to other threads.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.SetLayeredWindowAttributes(System.Windows.Forms.IWin32Window,System.Drawing.Color,System.Double,JetBrains.Interop.WinApi.SetLayeredWindowAttributesFlags)">
            <summary>
            Wraps the <see cref="M:JetBrains.Interop.WinApi.User32Dll.SetLayeredWindowAttributes(System.Void*,System.UInt32,System.Byte,System.UInt32)"/> calls.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.SetWindowExStyle(System.Windows.Forms.IWin32Window,JetBrains.Interop.WinApi.WindowExStyles,System.Boolean)">
            <summary>
            Adds or removes window style bits given by the <paramref name="style"/> parameter (see WS_… in <see cref="T:JetBrains.Interop.WinApi.WindowStyles"/>), depending on the <paramref name="set"/> value.
            </summary>
            <returns>Whether the operation succeeded.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.SetWindowExStyle(System.Void*,JetBrains.Interop.WinApi.WindowExStyles,System.Boolean)">
            <summary>
            Adds or removes window style bits given by the <paramref name="style"/> parameter (see WS_… in <see cref="T:JetBrains.Interop.WinApi.WindowStyles"/>), depending on the <paramref name="set"/> value.
            </summary>
            <returns>Whether the operation succeeded.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.SetWindowStyle(System.Windows.Forms.IWin32Window,JetBrains.Interop.WinApi.WindowStyles,System.Boolean)">
            <summary>
            Adds or removes window style bits given by the <paramref name="style"/> parameter (see WS_… in <see cref="T:JetBrains.Interop.WinApi.WindowStyles"/>), depending on the <paramref name="set"/> value.
            </summary>
            <returns>Whether the operation succeeded.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.SetWindowStyle(System.Void*,JetBrains.Interop.WinApi.WindowStyles,System.Boolean)">
            <summary>
            Adds or removes window style bits given by the <paramref name="style"/> parameter (see WS_… in <see cref="T:JetBrains.Interop.WinApi.WindowStyles"/>), depending on the <paramref name="set"/> value.
            </summary>
            <returns>Whether the operation succeeded.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.SetWindowStyleRaw(System.Void*,System.UInt32,JetBrains.Interop.WinApi.WindowLongPtrIndex,System.Boolean)">
            <summary>
            Raw implementation for setting a window style.
            </summary>
            <param name="hwnd">Handle to the window whose style is being set/reset.</param>
            <param name="style">One or more styles.</param>
            <param name="index">Index telling whether it would be simple style or extended style.</param>
            <param name="set">Whether to set or reset the style.</param>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.ShowWindow(System.IntPtr,JetBrains.Interop.WinApi.ShowWindowCommands)">
            <summary>
            The ShowWindow function sets the specified window's show state. 
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.SwitchToThisWindow(System.IntPtr,System.Boolean)">
            <summary>
            The SwitchToThisWindow function is called to switch focus to a specified window and bring it to the foreground.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.TryGetWindowClassName(System.IntPtr)">
            <summary>
            Wnd class name. Throws no exceptions, returns <c>Null</c>.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.TryLoadStringResource(System.String,System.UInt32)">
            <summary>
            Loads a Win32 string resource from a native DLL.
            Returns <c>Null</c> on errors.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.LoadCursor(JetBrains.Interop.WinApi.StockCursors)">
            <summary>
            Loads the cursor by calling the <see cref="M:JetBrains.Interop.WinApi.User32Dll.LoadCursorW(System.Void*,System.Char*)"/> WinAPI function.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.User32Dll.Helpers.EnumWindowsProc">
            <summary>
            The EnumWindowsProc function is an application-defined callback function used with the EnumWindows or EnumDesktopWindows function. It receives top-level window handles. The WNDENUMPROC type defines a pointer to this callback function. EnumWindowsProc is a placeholder for the application-defined function name. 
            </summary>
            <param name="hwnd">[in] Handle to a top-level window. </param>
            <param name="lParam">[in] Specifies the application-defined value given in EnumWindows or EnumDesktopWindows. </param>
            <returns>To continue enumeration, the callback function must return TRUE; to stop enumeration, it must return FALSE.</returns>
            <remarks>An application must register this callback function by passing its address to EnumWindows or EnumDesktopWindows. </remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Only32Bit.GetWindowLongPtrW(System.Void*,System.Int32)">
            <summary>
            The GetWindowLongPtrW function retrieves information about the specified window. The function also retrieves the value at a specified offset into the extra window memory.
            </summary>
            <remarks>void* is used instead of IntPtr here for safer casts on x64 systems: IntPtr is explicitly checked and throws an overflow exception.</remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Only32Bit.SetWindowLongPtrW(System.Void*,System.Int32,System.Void*)">
            <summary>
            The SetWindowLongPtrW function changes an attribute of the specified window. The function also sets a value at the specified offset in the extra window memory.
            </summary>
            <remarks>void* is used instead of IntPtr here for safer casts on x64 systems: IntPtr is explicitly checked and throws an overflow exception.</remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Only64Bit.GetWindowLongPtrW(System.Void*,System.Int32)">
            <summary>
            The GetWindowLongPtrW function retrieves information about the specified window. The function also retrieves the value at a specified offset into the extra window memory.
            </summary>
            <remarks>void* is used instead of IntPtr here for safer casts on x64 systems: IntPtr is explicitly checked and throws an overflow exception.</remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Only64Bit.SetWindowLongPtrW(System.Void*,System.Int32,System.Void*)">
            <summary>
            The SetWindowLongPtrW function changes an attribute of the specified window. The function also sets a value at the specified offset in the extra window memory.
            </summary>
            <remarks>void* is used instead of IntPtr here for safer casts on x64 systems: IntPtr is explicitly checked and throws an overflow exception.</remarks>
        </member>
        <member name="T:JetBrains.Interop.WinApi.UxThemeDll">
            <summary>
            Declarations for the UxTheme.Dll.
            Must be 64bit-compatible.
            </summary>
            <remarks>
            IMPORTANT! Rules for authoring the class (v1.1):
            (1) All the function declarations MUST be 64-bit aware.
            (2) When copypasting from older declarations, you MUST check against the MSDN help or header declaration, 
               and you MUST ensure that each parameter has a proper size.
            (3) Call the Wide version of the functions (UCS-2-LE) unless there's a strong reason for calling the ANSI version 
               (such a reason MUST be indicated in XmlDoc). <c>CharSet = CharSet.Unicode</c>.
            (4) ExactSpelling MUST be TRUE. Add the "…W" suffix wherever needed.
            (5) SetLastError SHOULD be considered individually for each function. Setting it to <c>True</c> allows to report the errors,
               but slows down the execution of critical members.
            (6) These properties MUST be explicitly set on DllImport attributes of EACH import: 
               CharSet, PreserveSig, SetLastError, ExactSpelling.
            (7) CLR names MUST be used for types instead of C# ones, eg "Int32" not "int" and "Int64" not "long".
               This greately improves the understanding of the parameter sizes.
            (8) Sign of the types MUST be favored, eg "DWORD" is "UInt32" not "Int32".
            (9) Unsafe pointer types should be used for explicit and implicit pointers rather than IntPtr. 
               This way we outline the unsafety of the native calls, and also make it more clear for the 64bit transition.
               Eg "HANDLE" is "void*". If the rule forces you to mark some assembly as unsafe, it's an indication a managed utility
               incapsulating the call and the handle should be provided in one of the already-unsafe assemblies.
            (A) Same rules must apply to members of the structures.
            (B) All of the structures MUST have the [StructLayout(LayoutKind.Sequential)], [NoReorder] attributes, as appropriate.
            </remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.UxThemeDll.CloseThemeData(System.Void*)">
            <summary>
            Closes the theme data handle.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.UxThemeDll.DrawThemeBackground(System.Void*,System.Void*,System.Int32,System.Int32,JetBrains.Interop.WinApi.RECT*,JetBrains.Interop.WinApi.RECT*)">
            <summary>
            Draws the border and fill defined by the visual style for the specified control part.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.UxThemeDll.OpenThemeData(System.Void*,System.String)">
            <summary>
            Opens the theme data for a window and its associated class.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.UxThemeDll.Helpers.IsAvailable">
            <summary>
            Checks whether the UxTheme DLL is available on this platform.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.RECT">
            <summary>
            The RECT structure defines the coordinates of the upper-left and lower-right corners of a rectangle.
            By convention, the right and bottom edges of the rectangle are normally considered exclusive. In other words, the pixel whose coordinates are (right, bottom) lies immediately outside of the the rectangle. For example, when RECT is passed to the FillRect function, the rectangle is filled up to, but not including, the right column and bottom row of pixels. This structure is identical to the RECTL structure.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.RECT.ToString">
            <summary>
            Returns a <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </summary>
            
            <returns>
            A <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:JetBrains.Interop.WinApi.TH32CS">
            <summary>
            The portions of the system to be included in the snapshot.
            See <see cref="M:JetBrains.Interop.WinApi.Kernel32Dll.CreateToolhelp32Snapshot(System.UInt32,System.UInt32)"/>.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.ScrollWindowFlags">
            <summary>
            Flags for the <c>ScrollWindowEx</c> functions.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.ScrollWindowFlags.SW_ERASE">
            <summary>
            Erases the newly invalidated region by sending a WM_ERASEBKGND message to the window when specified with the SW_INVALIDATE flag.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.ScrollWindowFlags.SW_INVALIDATE">
            <summary>
            Invalidates the region identified by the hrgnUpdate parameter after scrolling.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.ScrollWindowFlags.SW_SCROLLCHILDREN">
            <summary>
            Scrolls all child windows that intersect the rectangle pointed to by the prcScroll parameter. The child windows are scrolled by the number of pixels specified by the dx and dy parameters. The system sends a WM_MOVE message to all child windows that intersect the prcScroll rectangle, even if they do not move.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.ScrollWindowFlags.SW_SMOOTHSCROLL">
            <summary>
            Windows 98/Me, Windows 2000/XP: Scrolls using smooth scrolling. Use the HIWORD portion of the flags parameter to indicate how much time the smooth-scrolling operation should take.      
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.SetWindowPosFlags">
            <summary>
            Flags for the <see cref="M:JetBrains.Interop.WinApi.User32Dll.SetWindowPos(System.Void*,System.Void*,System.Int32,System.Int32,System.Int32,System.Int32,System.UInt32)"/> fucntion.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.SetWindowPosFlags.SWP_NOSIZE">
            <summary>
            Retains the current size (ignores the cx and cy parameters).
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.SetWindowPosFlags.SWP_NOMOVE">
            <summary>
            Retains the current position (ignores X and Y parameters).
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.SetWindowPosFlags.SWP_NOZORDER">
            <summary>
            Retains the current Z order (ignores the hWndInsertAfter parameter).
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.SetWindowPosFlags.SWP_NOREDRAW">
            <summary>
            Does not redraw changes. If this flag is set, no repainting of any kind occurs. This applies to the client area, the nonclient area (including the title bar and scroll bars), and any part of the parent window uncovered as a result of the window being moved. When this flag is set, the application must explicitly invalidate or redraw any parts of the window and parent window that need redrawing.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.SetWindowPosFlags.SWP_NOACTIVATE">
            <summary>
            Does not activate the window. If this flag is not set, the window is activated and moved to the top of either the topmost or non-topmost group (depending on the setting of the hWndInsertAfter parameter).
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.SetWindowPosFlags.SWP_FRAMECHANGED">
            <summary>
            Applies new frame styles set using the SetWindowLong function. Sends a WM_NCCALCSIZE message to the window, even if the window's size is not being changed. If this flag is not specified, WM_NCCALCSIZE is sent only when the window's size is being changed.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.SetWindowPosFlags.SWP_SHOWWINDOW">
            <summary>
            Displays the window.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.SetWindowPosFlags.SWP_HIDEWINDOW">
            <summary>
            Hides the window.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.SetWindowPosFlags.SWP_NOCOPYBITS">
            <summary>
            Discards the entire contents of the client area. If this flag is not specified, the valid contents of the client area are saved and copied back into the client area after the window is sized or repositioned.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.SetWindowPosFlags.SWP_NOOWNERZORDER">
            <summary>
            Does not change the owner window's position in the Z order.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.SetWindowPosFlags.SWP_NOSENDCHANGING">
            <summary>
            Prevents the window from receiving the WM_WINDOWPOSCHANGING message.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.SetWindowPosFlags.SWP_DEFERERASE">
            <summary>
            Prevents generation of the WM_SYNCPAINT message.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.SetWindowPosFlags.SWP_ASYNCWINDOWPOS">
            <summary>
            If the calling thread and the thread that owns the window are attached to different input queues, the system posts the request to the thread that owns the window. This prevents the calling thread from blocking its execution while other threads process the request. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.SetWindowPosFlags.SWP_NOREPOSITION">
            <summary>
            Same as the <see cref="F:JetBrains.Interop.WinApi.SetWindowPosFlags.SWP_NOOWNERZORDER"/> flag.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.SetWindowPosFlags.SWP_DRAWFRAME">
            <summary>
            Draws a frame (defined in the window's class description) around the window.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Declarations.Constants.RasterOperations">
            <summary>
            Possible raster operations for the <see cref="M:JetBrains.Interop.WinApi.Gdi32Dll.BitBlt(System.Void*,System.Int32,System.Int32,System.Int32,System.Int32,System.Void*,System.Int32,System.Int32,System.UInt32)"/> function.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.RasterOperations.SRCCOPY">
            <summary>dest = source</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.RasterOperations.SRCPAINT">
            <summary>dest = source OR dest</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.RasterOperations.SRCAND">
            <summary>dest = source AND dest</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.RasterOperations.SRCINVERT">
            <summary>dest = source XOR dest</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.RasterOperations.SRCERASE">
            <summary>dest = source AND (NOT dest )</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.RasterOperations.NOTSRCCOPY">
            <summary>dest = (NOT source)</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.RasterOperations.NOTSRCERASE">
            <summary>dest = (NOT src) AND (NOT dest)</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.RasterOperations.MERGECOPY">
            <summary>dest = (source AND pattern)</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.RasterOperations.MERGEPAINT">
            <summary>dest = (NOT source) OR dest</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.RasterOperations.PATCOPY">
            <summary>dest = pattern</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.RasterOperations.PATPAINT">
            <summary>dest = DPSnoo</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.RasterOperations.PATINVERT">
            <summary>dest = pattern XOR dest</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.RasterOperations.DSTINVERT">
            <summary>dest = (NOT dest)</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.RasterOperations.BLACKNESS">
            <summary>dest = BLACK</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.RasterOperations.WHITENESS">
            <summary>dest = WHITE</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.RasterOperations.NOMIRRORBITMAP">
            <summary>Do not Mirror the bitmap in this call</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.RasterOperations.CAPTUREBLT">
            <summary>Include layered windows</summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Declarations.Constants.UpdateLayeredWindowFlags">
            <summary>
            Flags for the <see cref="M:JetBrains.Interop.WinApi.User32Dll.UpdateLayeredWindow(System.Void*,System.Void*,JetBrains.Interop.WinApi.POINT*,JetBrains.Interop.WinApi.Declarations.Structures.SIZE*,System.Void*,JetBrains.Interop.WinApi.POINT*,System.UInt32,JetBrains.Interop.WinApi.Declarations.Structures.BLENDFUNCTION*,System.UInt32)"/> function.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.UpdateLayeredWindowFlags.ULW_COLORKEY">
            <summary>
            Use crKey as the transparency color. (see <see cref="M:JetBrains.Interop.WinApi.User32Dll.UpdateLayeredWindow(System.Void*,System.Void*,JetBrains.Interop.WinApi.POINT*,JetBrains.Interop.WinApi.Declarations.Structures.SIZE*,System.Void*,JetBrains.Interop.WinApi.POINT*,System.UInt32,JetBrains.Interop.WinApi.Declarations.Structures.BLENDFUNCTION*,System.UInt32)"/>)
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.UpdateLayeredWindowFlags.ULW_ALPHA">
            <summary>
            Use pblend as the blend function. If the display mode is 256 colors or less, the effect of this value is the same as the effect of <see cref="F:JetBrains.Interop.WinApi.Declarations.Constants.UpdateLayeredWindowFlags.ULW_OPAQUE"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.UpdateLayeredWindowFlags.ULW_OPAQUE">
            <summary>
            Draw an opaque layered window. 
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Declarations.Structures.SIZE">
            <summary>
            The SIZE structure specifies the width and height of a rectangle.
            </summary>
            <remarks>The rectangle dimensions stored in this structure may correspond to viewport extents, window extents, text extents, bitmap dimensions, or the aspect-ratio filter for some extended functions. </remarks>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.SIZE.cx">
            <summary>
            Specifies the rectangle's width. The units depend on which function uses this.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.SIZE.cy">
            <summary>
            Specifies the rectangle's height. The units depend on which function uses this. 
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Declarations.Structures.SIZE.Equals(JetBrains.Interop.WinApi.Declarations.Structures.SIZE)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            true if the current object is equal to the <paramref name="other"/> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Declarations.Structures.SIZE.Equals(System.Object)">
            <summary>
            Indicates whether this instance and a specified object are equal.
            </summary>
            <returns>
            true if <paramref name="obj"/> and this instance are the same type and represent the same value; otherwise, false.
            </returns>
            <param name="obj">Another object to compare to. </param><filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Declarations.Structures.SIZE.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns>
            A 32-bit signed integer that is the hash code for this instance.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Declarations.Structures.SIZE.ToString">
            <summary>
            Returns a <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </summary>
            
            <returns>
            A <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:JetBrains.Interop.WinApi.StockCursors">
            <summary>
            Stock cursors enum for <see cref="!:LoadCursor(StockCursors)"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.StockCursors.IDC_APPSTARTING">
            <summary>
            Standard arrow and small hourglass
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.StockCursors.IDC_ARROW">
            <summary>
            Standard arrow
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.StockCursors.IDC_CROSS">
            <summary>
            Crosshair
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.StockCursors.IDC_HAND">
            <summary>
            Windows 98/Me, Windows 2000/XP: Hand
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.StockCursors.IDC_HELP">
            <summary>
            Arrow and question mark
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.StockCursors.IDC_IBEAM">
            <summary>
            I-beam
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.StockCursors.IDC_ICON">
            <summary>
            Obsolete for applications marked version 4.0 or later.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.StockCursors.IDC_NO">
            <summary>
            Slashed circle
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.StockCursors.IDC_SIZE">
            <summary>
            Obsolete for applications marked version 4.0 or later. Use IDC_SIZEALL.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.StockCursors.IDC_SIZEALL">
            <summary>
            Four-pointed arrow pointing north, south, east, and west
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.StockCursors.IDC_SIZENESW">
            <summary>
            /Double-pointed arrow pointing northeast and southwest
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.StockCursors.IDC_SIZENS">
            <summary>
            Double-pointed arrow pointing north and south
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.StockCursors.IDC_SIZENWSE">
            <summary>
            Double-pointed arrow pointing northwest and southeast
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.StockCursors.IDC_SIZEWE">
            <summary>
            Double-pointed arrow pointing west and east
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.StockCursors.IDC_UPARROW">
            <summary>
            Vertical arrow
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.StockCursors.IDC_WAIT">
            <summary>
            Hourglass
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.WindowsMessages">
            <summary>
            Windows message constants.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.WindowsMessages.WM_PRINT">
            <summary>
            The WM_PRINT message is sent to a window to request that it draw itself in the specified device context, most commonly in a printer device context.
            wParam is hdc, lParam is drawing options (PRF_…)
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.WindowLongPtrIndex">
            <summary>
            Index constants for the <see cref="M:JetBrains.Interop.WinApi.User32Dll.GetWindowLongPtrW(System.Void*,System.Int32)"/> and <see cref="M:JetBrains.Interop.WinApi.User32Dll.SetWindowLongPtrW(System.Void*,System.Int32,System.Void*)"/> functions.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.WindowLongPtrIndex.GWL_EXSTYLE">
            <summary>
            Sets a new extended window style. For more information, see CreateWindowEx. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.WindowLongPtrIndex.GWL_STYLE">
            <summary>
            Sets a new window style.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.WindowLongPtrIndex.GWLP_WNDPROC">
            <summary>
            Sets a new address for the window procedure. 
            Same as GWL_WNDPROC that is for non-“ptr” versions.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.WindowLongPtrIndex.GWLP_HINSTANCE">
            <summary>
            Sets a new application instance handle.
            Same as GWL_HINSTANCE that is for non-“ptr” versions.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.WindowLongPtrIndex.GWLP_HWNDPARENT">
            <summary>
            Do not call <see cref="M:JetBrains.Interop.WinApi.User32Dll.SetWindowLongPtrW(System.Void*,System.Int32,System.Void*)"/> with the <see cref="F:JetBrains.Interop.WinApi.WindowLongPtrIndex.GWLP_HWNDPARENT"/> index to change the parent of a child window. Instead, use the SetParent function.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.WindowLongPtrIndex.GWLP_ID">
            <summary>
            Sets a new identifier of the window.
            Same as GWL_ID that is for non-“ptr” versions.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.WindowLongPtrIndex.GWLP_USERDATA">
            <summary>
            Sets the user data associated with the window. This data is intended for use by the application that created the window. Its value is initially zero.
            Same as GWL_USERDATA that is for non-“ptr” versions.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.WindowLongPtrIndex.DWLP_DLGPROC">
            <summary>
            Sets the new pointer to the dialog box procedure.
            Valid for dialog boxes only.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.WindowLongPtrIndex.DWLP_MSGRESULT">
            <summary>
            Sets the return value of a message processed in the dialog box procedure.
            Valid for dialog boxes only.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.WindowLongPtrIndex.DWLP_USER">
            <summary>
            Sets new extra information that is private to the application, such as handles or pointers.      
            Valid for dialog boxes only.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Win32InteropException">
            <summary>
            Denotes an exception that occurs during the interop calls.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Wrappers.AuthenticodeHelpers.StripEmbeddedSignatures(System.String)">
            <summary>
            Strips an embedded Authenticode signature off the file, e.g. when you're about to modify its contents, which would render the existing signature invalid and prevent come of the tools from signing it once again after modification.
            </summary>
            <param name="sFilePath"></param>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Wrappers.AuthenticodeHelpers.VerifyEmbeddedSignature(System.String)">
            <summary>
            Asserts that the file has a valid signature. Throws an explanation exception if not.
            </summary>
            <param name="sFilePath"></param>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Wrappers.AuthenticodeHelpers.AuthenticodeSignatureException.VerificationFunctionError">
            <summary>
            The error returned by the verification function.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Wrappers.AuthenticodeHelpers.AuthenticodeSignatureException.VerificationGetLastError">
            <summary>
            The error returned by <c>GetLastError</c>.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Wrappers.ComStreamStream">
            <summary>
            Wraps a COM stream as a managed stream.
            NOTE: <see cref="T:System.IDisposable"/> is not wired.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Wrappers.ComStreamStream.#ctor(JetBrains.Interop.WinApi.Declarations.Interfaces.IStream,System.IO.FileAccess)">
            <summary>
            Wraps a stream whose lifetime is controlled from outside.
            The <see cref="M:System.IDisposable.Dispose"/> method does not do anything.
            If you'd like to close the native stream when the consumer disposes of the Stream object, use <c>StreamUnderLifetime</c> to wrap.
            </summary>
            <param name="stream"></param>
            <param name="overrideFileAccess">Optional. Some COM streams incorrectly report their READ/WRITE capabilities, or we have to open a stream with wider access than requested by client. In this case you can supply the desired file access which should determine what's exposed and allowed to the client.</param>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Wrappers.LockBytesWithGrowthStrategy">
            <summary>
            Wraps ILockBytes created by CreateILockBytesOnHGlobal. Constrains possible size changes via the <see cref="M:JetBrains.Interop.WinApi.Wrappers.LockBytesWithGrowthStrategy.ApplySizeStrategy(System.UInt64)"/> function.
            (the system implementation for <c>CreateILockBytesOnHGlobal</c> has a naive growth strategy which reallocs memory to just fit the bytes being written in the current operation, so it's O(N2) when writing much data with small buffers)
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Wrappers.LockBytesWithGrowthStrategy.ApplySizeStrategy(System.UInt64)">
            <summary>
            Rounds up to the nearest power of two.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Wrappers.LockBytesOnHGlobal">
            <summary>
            Wraps ILockBytes created by CreateILockBytesOnHGlobal. Implements size growth on write by doubling the current size, but not exceeding the limit.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Wrappers.StreamLockBytes">
            <summary>
            Implements ILockBytes over a managed stream.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Wrappers.StreamLockBytes.myBuffer">
            <summary>
            Reusable buffer for RW functions. Assumes there is no reentrancy (thread-safety is usually guaranteed due to the COM nature).
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Wrappers.Win32Window">
            <summary>
            Implements the <see cref="T:System.Windows.Forms.IWin32Window"/> interface by just wrapping the handle.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Wrappers.Win32Window.#ctor(System.IntPtr)">
            <summary>
            Wraps a native window handle.
            Can be <c>Null</c>.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Wrappers.Win32Window.#ctor(System.Void*)">
            <summary>
            Wraps a native window handle.
            Can be <c>Null</c>.
            </summary>
        </member>
        <member name="P:JetBrains.Interop.WinApi.Wrappers.Win32Window.Handle">
            <summary>
            Gets the handle to the window represented by the implementer.
            </summary>
            
            <returns>
            A handle to the window represented by the implementer.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
    </members>
</doc>
