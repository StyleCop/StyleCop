<?xml version="1.0"?>
<doc>
    <assembly>
        <name>JetBrains.ReSharper.Psi</name>
    </assembly>
    <members>
        <member name="T:JetBrains.ReSharper.Psi.Resources.W3CEntities">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Resources.W3CEntities.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Resources.W3CEntities.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Resources.W3CEntities.Stream">
            <summary>
              Looks up a localized resource of type System.IO.UnmanagedMemoryStream similar to System.IO.MemoryStream.
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons">
             <summary>
              <para>
                <para>Autogenerated identifier classes and identifier objects to Themed Icons registered with <see cref="T:JetBrains.UI.Icons.IThemedIconManager"/>.</para>
                <para>Identifier classes should be used in attributes, XAML, or generic parameters. Where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected, use the identifier object in the <c>Id</c> field of the identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>This code was compile-time generated to support Themed Icons in the JetBrains application.</para>
              <para>It has two primary goals: load the icons of this assembly to be registered with <see cref="T:JetBrains.UI.Icons.IThemedIconManager"/> so that they were WPF-accessible and theme-sensitive; and emit early-bound accessors for referencing icons in codebehind in a compile-time-validated manner.</para>
              <h1>XAML</h1>
              <para>For performance reasons, the icons are not individually exposed with application resources. There is a custom markup extension to bind an image source in markup.</para>
              <para>To use an icon from XAML, set an <see cref="T:System.Windows.Media.ImageSource"/> property to the <see cref="T:JetBrains.UI.Icons.ThemedIconExtension"/> markup extension, which takes an icon identifier class (nested in <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class) as a parameter.</para>
              <para>Example:</para>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+AnonymousMethod}" /&gt;</code>
              <h1>Attributes</h1>
              <para>Sometimes you have to reference an icon from a type attriute when you're defining objects in code. Typical examples are Options pages and Tool Windows.</para>
              <para>To avoid the use of string IDs which are not validated very well, we've emitted identifier classes to be used with <c>typeof()</c> expression, one per each icon. Use the attribute overload which takes a <see cref="T:System.Type"/> for an image, and choose your icon class from nested classes in the <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
              <para>Example:</para>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.AnonymousMethod))]</code>
              <h1>CodeBehind</h1>
              <para>In codebehind, we have two distinct tasks: (a) specify some icon in the APIs and (b) render icon images onscreen.</para>
              <para>On the APIs stage you should only manipulate icon identifier objects (of type <see cref="T:JetBrains.UI.Icons.IconId"/>, statically defined in <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> in <c>Id</c> fields). Icon identifier classes (nested in <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>) should be turned into icon identifier objects as early as possible. Rendering is about getting an <see cref="T:System.Windows.Media.ImageSource"/> to assign to WPF, or <see cref="T:System.Drawing.Bitmap"/> to use with GDI+ / Windows Forms.</para>
              <para>You should turn an identifier object into a rendered image as late as possible. The identifier is static and lightweight and does not depend on the current theme, while the image is themed and has to be loaded or generated/rasterized. You need an <see cref="T:JetBrains.UI.Icons.IThemedIconManager"/> instance to get the image out of an icon identifier object. Once you got the image, you should take care to change it with theme changes â€” either by using a live image property, or by listening to the theme change event. See <see cref="T:JetBrains.UI.Icons.IThemedIconManager"/> and its extensions for the related facilities.</para>
              <para>Example:</para>
              <code>// Getting IconId identifier object to use with APIs
            IconId iconid = PsiSymbolsThemedIcons.AnonymousMethod.Id;</code>
              <code>// Getting IconId out of an Icon Identifier Class type
            IconId iconid = CompiledIconClassAttribute.TryGetCompiledIconClassId(typeof(PsiSymbolsThemedIcons.AnonymousMethod), OnError.Throw);</code>
              <code>// Getting image for screen rendering by IconId
            themediconmanager.Icons[icnoid]</code>
              <code>// Getting image for screen rendering by Icon Identifier Class
            themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.AnonymousMethod&gt;()</code>
              <h1>Icons Origin</h1>
              <para>This code was generated by a pre-compile build task from a set of input files which are XAML files adhering to a certain convention, as convenient for exporting them from the Illustrator workspace, plus separate PNG files with raster icons. In the projects, these files are designated with <c>ThemedIconsXamlV3</c> and <c>ThemedIconPng</c> build actions and do not themselves get into the output assembly. All of such files are processed, vector images for different themes of the same icon are split and combined into the single list of icons in this assembly. This list is then written into the genearted XAML file (compiled into BAML within assembly), and serves as the source for this generated code.</para>
            </remarks>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.AnonymousMethod">
             <summary>
              <para>
                <para>Autogenerated identifier class for the AnonymousMethod Themed Icon.</para>
                <para>Identifier classes should be used in attributes, XAML, or generic parameters. Where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected, use the identifier object in the <see cref="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.AnonymousMethod.Id"/> field of the identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+AnonymousMethod}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.AnonymousMethod))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.AnonymousMethod.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.AnonymousMethod&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.AnonymousMethod.Id">
             <summary>
              <para>
                <para>Autogenerated identifier object for the AnonymousMethod Themed Icon.</para>
                <para>Identifier objects should be used where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected. In attributes, XAML, or generic parameters use the containing <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.AnonymousMethod"/> identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+AnonymousMethod}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.AnonymousMethod))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.AnonymousMethod.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.AnonymousMethod&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.AnonymousTypeProperty">
             <summary>
              <para>
                <para>Autogenerated identifier class for the AnonymousTypeProperty Themed Icon.</para>
                <para>Identifier classes should be used in attributes, XAML, or generic parameters. Where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected, use the identifier object in the <see cref="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.AnonymousTypeProperty.Id"/> field of the identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+AnonymousTypeProperty}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.AnonymousTypeProperty))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.AnonymousTypeProperty.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.AnonymousTypeProperty&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.AnonymousTypeProperty.Id">
             <summary>
              <para>
                <para>Autogenerated identifier object for the AnonymousTypeProperty Themed Icon.</para>
                <para>Identifier objects should be used where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected. In attributes, XAML, or generic parameters use the containing <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.AnonymousTypeProperty"/> identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+AnonymousTypeProperty}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.AnonymousTypeProperty))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.AnonymousTypeProperty.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.AnonymousTypeProperty&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Class">
             <summary>
              <para>
                <para>Autogenerated identifier class for the Class Themed Icon.</para>
                <para>Identifier classes should be used in attributes, XAML, or generic parameters. Where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected, use the identifier object in the <see cref="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Class.Id"/> field of the identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+Class}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.Class))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.Class.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.Class&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Class.Id">
             <summary>
              <para>
                <para>Autogenerated identifier object for the Class Themed Icon.</para>
                <para>Identifier objects should be used where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected. In attributes, XAML, or generic parameters use the containing <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Class"/> identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+Class}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.Class))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.Class.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.Class&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Const">
             <summary>
              <para>
                <para>Autogenerated identifier class for the Const Themed Icon.</para>
                <para>Identifier classes should be used in attributes, XAML, or generic parameters. Where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected, use the identifier object in the <see cref="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Const.Id"/> field of the identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+Const}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.Const))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.Const.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.Const&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Const.Id">
             <summary>
              <para>
                <para>Autogenerated identifier object for the Const Themed Icon.</para>
                <para>Identifier objects should be used where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected. In attributes, XAML, or generic parameters use the containing <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Const"/> identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+Const}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.Const))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.Const.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.Const&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Constructor">
             <summary>
              <para>
                <para>Autogenerated identifier class for the Constructor Themed Icon.</para>
                <para>Identifier classes should be used in attributes, XAML, or generic parameters. Where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected, use the identifier object in the <see cref="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Constructor.Id"/> field of the identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+Constructor}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.Constructor))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.Constructor.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.Constructor&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Constructor.Id">
             <summary>
              <para>
                <para>Autogenerated identifier object for the Constructor Themed Icon.</para>
                <para>Identifier objects should be used where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected. In attributes, XAML, or generic parameters use the containing <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Constructor"/> identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+Constructor}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.Constructor))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.Constructor.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.Constructor&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.CppHeader">
             <summary>
              <para>
                <para>Autogenerated identifier class for the CppHeader Themed Icon.</para>
                <para>Identifier classes should be used in attributes, XAML, or generic parameters. Where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected, use the identifier object in the <see cref="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.CppHeader.Id"/> field of the identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+CppHeader}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.CppHeader))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.CppHeader.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.CppHeader&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.CppHeader.Id">
             <summary>
              <para>
                <para>Autogenerated identifier object for the CppHeader Themed Icon.</para>
                <para>Identifier objects should be used where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected. In attributes, XAML, or generic parameters use the containing <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.CppHeader"/> identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+CppHeader}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.CppHeader))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.CppHeader.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.CppHeader&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.CppSource">
             <summary>
              <para>
                <para>Autogenerated identifier class for the CppSource Themed Icon.</para>
                <para>Identifier classes should be used in attributes, XAML, or generic parameters. Where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected, use the identifier object in the <see cref="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.CppSource.Id"/> field of the identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+CppSource}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.CppSource))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.CppSource.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.CppSource&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.CppSource.Id">
             <summary>
              <para>
                <para>Autogenerated identifier object for the CppSource Themed Icon.</para>
                <para>Identifier objects should be used where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected. In attributes, XAML, or generic parameters use the containing <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.CppSource"/> identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+CppSource}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.CppSource))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.CppSource.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.CppSource&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Delegate">
             <summary>
              <para>
                <para>Autogenerated identifier class for the Delegate Themed Icon.</para>
                <para>Identifier classes should be used in attributes, XAML, or generic parameters. Where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected, use the identifier object in the <see cref="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Delegate.Id"/> field of the identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+Delegate}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.Delegate))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.Delegate.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.Delegate&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Delegate.Id">
             <summary>
              <para>
                <para>Autogenerated identifier object for the Delegate Themed Icon.</para>
                <para>Identifier objects should be used where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected. In attributes, XAML, or generic parameters use the containing <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Delegate"/> identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+Delegate}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.Delegate))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.Delegate.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.Delegate&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.DynamicMethod">
             <summary>
              <para>
                <para>Autogenerated identifier class for the DynamicMethod Themed Icon.</para>
                <para>Identifier classes should be used in attributes, XAML, or generic parameters. Where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected, use the identifier object in the <see cref="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.DynamicMethod.Id"/> field of the identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+DynamicMethod}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.DynamicMethod))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.DynamicMethod.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.DynamicMethod&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.DynamicMethod.Id">
             <summary>
              <para>
                <para>Autogenerated identifier object for the DynamicMethod Themed Icon.</para>
                <para>Identifier objects should be used where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected. In attributes, XAML, or generic parameters use the containing <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.DynamicMethod"/> identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+DynamicMethod}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.DynamicMethod))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.DynamicMethod.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.DynamicMethod&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.DynamicProperty">
             <summary>
              <para>
                <para>Autogenerated identifier class for the DynamicProperty Themed Icon.</para>
                <para>Identifier classes should be used in attributes, XAML, or generic parameters. Where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected, use the identifier object in the <see cref="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.DynamicProperty.Id"/> field of the identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+DynamicProperty}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.DynamicProperty))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.DynamicProperty.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.DynamicProperty&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.DynamicProperty.Id">
             <summary>
              <para>
                <para>Autogenerated identifier object for the DynamicProperty Themed Icon.</para>
                <para>Identifier objects should be used where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected. In attributes, XAML, or generic parameters use the containing <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.DynamicProperty"/> identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+DynamicProperty}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.DynamicProperty))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.DynamicProperty.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.DynamicProperty&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Enum">
             <summary>
              <para>
                <para>Autogenerated identifier class for the Enum Themed Icon.</para>
                <para>Identifier classes should be used in attributes, XAML, or generic parameters. Where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected, use the identifier object in the <see cref="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Enum.Id"/> field of the identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+Enum}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.Enum))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.Enum.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.Enum&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Enum.Id">
             <summary>
              <para>
                <para>Autogenerated identifier object for the Enum Themed Icon.</para>
                <para>Identifier objects should be used where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected. In attributes, XAML, or generic parameters use the containing <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Enum"/> identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+Enum}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.Enum))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.Enum.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.Enum&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.EnumMember">
             <summary>
              <para>
                <para>Autogenerated identifier class for the EnumMember Themed Icon.</para>
                <para>Identifier classes should be used in attributes, XAML, or generic parameters. Where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected, use the identifier object in the <see cref="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.EnumMember.Id"/> field of the identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+EnumMember}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.EnumMember))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.EnumMember.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.EnumMember&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.EnumMember.Id">
             <summary>
              <para>
                <para>Autogenerated identifier object for the EnumMember Themed Icon.</para>
                <para>Identifier objects should be used where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected. In attributes, XAML, or generic parameters use the containing <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.EnumMember"/> identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+EnumMember}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.EnumMember))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.EnumMember.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.EnumMember&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Event">
             <summary>
              <para>
                <para>Autogenerated identifier class for the Event Themed Icon.</para>
                <para>Identifier classes should be used in attributes, XAML, or generic parameters. Where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected, use the identifier object in the <see cref="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Event.Id"/> field of the identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+Event}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.Event))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.Event.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.Event&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Event.Id">
             <summary>
              <para>
                <para>Autogenerated identifier object for the Event Themed Icon.</para>
                <para>Identifier objects should be used where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected. In attributes, XAML, or generic parameters use the containing <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Event"/> identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+Event}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.Event))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.Event.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.Event&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Field">
             <summary>
              <para>
                <para>Autogenerated identifier class for the Field Themed Icon.</para>
                <para>Identifier classes should be used in attributes, XAML, or generic parameters. Where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected, use the identifier object in the <see cref="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Field.Id"/> field of the identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+Field}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.Field))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.Field.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.Field&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Field.Id">
             <summary>
              <para>
                <para>Autogenerated identifier object for the Field Themed Icon.</para>
                <para>Identifier objects should be used where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected. In attributes, XAML, or generic parameters use the containing <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Field"/> identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+Field}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.Field))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.Field.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.Field&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.GlobalFunction">
             <summary>
              <para>
                <para>Autogenerated identifier class for the GlobalFunction Themed Icon.</para>
                <para>Identifier classes should be used in attributes, XAML, or generic parameters. Where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected, use the identifier object in the <see cref="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.GlobalFunction.Id"/> field of the identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+GlobalFunction}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.GlobalFunction))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.GlobalFunction.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.GlobalFunction&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.GlobalFunction.Id">
             <summary>
              <para>
                <para>Autogenerated identifier object for the GlobalFunction Themed Icon.</para>
                <para>Identifier objects should be used where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected. In attributes, XAML, or generic parameters use the containing <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.GlobalFunction"/> identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+GlobalFunction}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.GlobalFunction))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.GlobalFunction.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.GlobalFunction&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.GlobalVariable">
             <summary>
              <para>
                <para>Autogenerated identifier class for the GlobalVariable Themed Icon.</para>
                <para>Identifier classes should be used in attributes, XAML, or generic parameters. Where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected, use the identifier object in the <see cref="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.GlobalVariable.Id"/> field of the identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+GlobalVariable}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.GlobalVariable))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.GlobalVariable.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.GlobalVariable&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.GlobalVariable.Id">
             <summary>
              <para>
                <para>Autogenerated identifier object for the GlobalVariable Themed Icon.</para>
                <para>Identifier objects should be used where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected. In attributes, XAML, or generic parameters use the containing <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.GlobalVariable"/> identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+GlobalVariable}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.GlobalVariable))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.GlobalVariable.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.GlobalVariable&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Interface">
             <summary>
              <para>
                <para>Autogenerated identifier class for the Interface Themed Icon.</para>
                <para>Identifier classes should be used in attributes, XAML, or generic parameters. Where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected, use the identifier object in the <see cref="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Interface.Id"/> field of the identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+Interface}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.Interface))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.Interface.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.Interface&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Interface.Id">
             <summary>
              <para>
                <para>Autogenerated identifier object for the Interface Themed Icon.</para>
                <para>Identifier objects should be used where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected. In attributes, XAML, or generic parameters use the containing <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Interface"/> identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+Interface}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.Interface))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.Interface.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.Interface&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Internal">
             <summary>
              <para>
                <para>Autogenerated identifier class for the Internal Themed Icon.</para>
                <para>Identifier classes should be used in attributes, XAML, or generic parameters. Where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected, use the identifier object in the <see cref="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Internal.Id"/> field of the identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+Internal}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.Internal))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.Internal.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.Internal&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Internal.Id">
             <summary>
              <para>
                <para>Autogenerated identifier object for the Internal Themed Icon.</para>
                <para>Identifier objects should be used where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected. In attributes, XAML, or generic parameters use the containing <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Internal"/> identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+Internal}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.Internal))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.Internal.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.Internal&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Keyword">
             <summary>
              <para>
                <para>Autogenerated identifier class for the Keyword Themed Icon.</para>
                <para>Identifier classes should be used in attributes, XAML, or generic parameters. Where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected, use the identifier object in the <see cref="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Keyword.Id"/> field of the identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+Keyword}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.Keyword))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.Keyword.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.Keyword&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Keyword.Id">
             <summary>
              <para>
                <para>Autogenerated identifier object for the Keyword Themed Icon.</para>
                <para>Identifier objects should be used where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected. In attributes, XAML, or generic parameters use the containing <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Keyword"/> identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+Keyword}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.Keyword))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.Keyword.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.Keyword&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.LocalConst">
             <summary>
              <para>
                <para>Autogenerated identifier class for the LocalConst Themed Icon.</para>
                <para>Identifier classes should be used in attributes, XAML, or generic parameters. Where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected, use the identifier object in the <see cref="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.LocalConst.Id"/> field of the identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+LocalConst}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.LocalConst))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.LocalConst.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.LocalConst&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.LocalConst.Id">
             <summary>
              <para>
                <para>Autogenerated identifier object for the LocalConst Themed Icon.</para>
                <para>Identifier objects should be used where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected. In attributes, XAML, or generic parameters use the containing <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.LocalConst"/> identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+LocalConst}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.LocalConst))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.LocalConst.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.LocalConst&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Macro">
             <summary>
              <para>
                <para>Autogenerated identifier class for the Macro Themed Icon.</para>
                <para>Identifier classes should be used in attributes, XAML, or generic parameters. Where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected, use the identifier object in the <see cref="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Macro.Id"/> field of the identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+Macro}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.Macro))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.Macro.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.Macro&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Macro.Id">
             <summary>
              <para>
                <para>Autogenerated identifier object for the Macro Themed Icon.</para>
                <para>Identifier objects should be used where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected. In attributes, XAML, or generic parameters use the containing <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Macro"/> identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+Macro}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.Macro))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.Macro.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.Macro&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Method">
             <summary>
              <para>
                <para>Autogenerated identifier class for the Method Themed Icon.</para>
                <para>Identifier classes should be used in attributes, XAML, or generic parameters. Where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected, use the identifier object in the <see cref="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Method.Id"/> field of the identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+Method}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.Method))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.Method.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.Method&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Method.Id">
             <summary>
              <para>
                <para>Autogenerated identifier object for the Method Themed Icon.</para>
                <para>Identifier objects should be used where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected. In attributes, XAML, or generic parameters use the containing <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Method"/> identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+Method}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.Method))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.Method.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.Method&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.ModifiersAbstract">
             <summary>
              <para>
                <para>Autogenerated identifier class for the ModifiersAbstract Themed Icon.</para>
                <para>Identifier classes should be used in attributes, XAML, or generic parameters. Where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected, use the identifier object in the <see cref="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.ModifiersAbstract.Id"/> field of the identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+ModifiersAbstract}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.ModifiersAbstract))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.ModifiersAbstract.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.ModifiersAbstract&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.ModifiersAbstract.Id">
             <summary>
              <para>
                <para>Autogenerated identifier object for the ModifiersAbstract Themed Icon.</para>
                <para>Identifier objects should be used where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected. In attributes, XAML, or generic parameters use the containing <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.ModifiersAbstract"/> identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+ModifiersAbstract}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.ModifiersAbstract))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.ModifiersAbstract.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.ModifiersAbstract&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.ModifiersInternal">
             <summary>
              <para>
                <para>Autogenerated identifier class for the ModifiersInternal Themed Icon.</para>
                <para>Identifier classes should be used in attributes, XAML, or generic parameters. Where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected, use the identifier object in the <see cref="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.ModifiersInternal.Id"/> field of the identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+ModifiersInternal}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.ModifiersInternal))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.ModifiersInternal.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.ModifiersInternal&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.ModifiersInternal.Id">
             <summary>
              <para>
                <para>Autogenerated identifier object for the ModifiersInternal Themed Icon.</para>
                <para>Identifier objects should be used where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected. In attributes, XAML, or generic parameters use the containing <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.ModifiersInternal"/> identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+ModifiersInternal}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.ModifiersInternal))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.ModifiersInternal.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.ModifiersInternal&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.ModifiersPrivate">
             <summary>
              <para>
                <para>Autogenerated identifier class for the ModifiersPrivate Themed Icon.</para>
                <para>Identifier classes should be used in attributes, XAML, or generic parameters. Where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected, use the identifier object in the <see cref="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.ModifiersPrivate.Id"/> field of the identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+ModifiersPrivate}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.ModifiersPrivate))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.ModifiersPrivate.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.ModifiersPrivate&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.ModifiersPrivate.Id">
             <summary>
              <para>
                <para>Autogenerated identifier object for the ModifiersPrivate Themed Icon.</para>
                <para>Identifier objects should be used where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected. In attributes, XAML, or generic parameters use the containing <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.ModifiersPrivate"/> identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+ModifiersPrivate}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.ModifiersPrivate))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.ModifiersPrivate.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.ModifiersPrivate&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.ModifiersProtected">
             <summary>
              <para>
                <para>Autogenerated identifier class for the ModifiersProtected Themed Icon.</para>
                <para>Identifier classes should be used in attributes, XAML, or generic parameters. Where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected, use the identifier object in the <see cref="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.ModifiersProtected.Id"/> field of the identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+ModifiersProtected}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.ModifiersProtected))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.ModifiersProtected.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.ModifiersProtected&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.ModifiersProtected.Id">
             <summary>
              <para>
                <para>Autogenerated identifier object for the ModifiersProtected Themed Icon.</para>
                <para>Identifier objects should be used where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected. In attributes, XAML, or generic parameters use the containing <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.ModifiersProtected"/> identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+ModifiersProtected}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.ModifiersProtected))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.ModifiersProtected.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.ModifiersProtected&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.ModifiersProtectedInternal">
             <summary>
              <para>
                <para>Autogenerated identifier class for the ModifiersProtectedInternal Themed Icon.</para>
                <para>Identifier classes should be used in attributes, XAML, or generic parameters. Where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected, use the identifier object in the <see cref="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.ModifiersProtectedInternal.Id"/> field of the identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+ModifiersProtectedInternal}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.ModifiersProtectedInternal))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.ModifiersProtectedInternal.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.ModifiersProtectedInternal&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.ModifiersProtectedInternal.Id">
             <summary>
              <para>
                <para>Autogenerated identifier object for the ModifiersProtectedInternal Themed Icon.</para>
                <para>Identifier objects should be used where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected. In attributes, XAML, or generic parameters use the containing <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.ModifiersProtectedInternal"/> identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+ModifiersProtectedInternal}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.ModifiersProtectedInternal))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.ModifiersProtectedInternal.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.ModifiersProtectedInternal&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.ModifiersPublic">
             <summary>
              <para>
                <para>Autogenerated identifier class for the ModifiersPublic Themed Icon.</para>
                <para>Identifier classes should be used in attributes, XAML, or generic parameters. Where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected, use the identifier object in the <see cref="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.ModifiersPublic.Id"/> field of the identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+ModifiersPublic}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.ModifiersPublic))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.ModifiersPublic.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.ModifiersPublic&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.ModifiersPublic.Id">
             <summary>
              <para>
                <para>Autogenerated identifier object for the ModifiersPublic Themed Icon.</para>
                <para>Identifier objects should be used where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected. In attributes, XAML, or generic parameters use the containing <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.ModifiersPublic"/> identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+ModifiersPublic}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.ModifiersPublic))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.ModifiersPublic.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.ModifiersPublic&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.ModifiersRead">
             <summary>
              <para>
                <para>Autogenerated identifier class for the ModifiersRead Themed Icon.</para>
                <para>Identifier classes should be used in attributes, XAML, or generic parameters. Where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected, use the identifier object in the <see cref="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.ModifiersRead.Id"/> field of the identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+ModifiersRead}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.ModifiersRead))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.ModifiersRead.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.ModifiersRead&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.ModifiersRead.Id">
             <summary>
              <para>
                <para>Autogenerated identifier object for the ModifiersRead Themed Icon.</para>
                <para>Identifier objects should be used where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected. In attributes, XAML, or generic parameters use the containing <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.ModifiersRead"/> identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+ModifiersRead}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.ModifiersRead))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.ModifiersRead.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.ModifiersRead&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.ModifiersReadWrite">
             <summary>
              <para>
                <para>Autogenerated identifier class for the ModifiersReadWrite Themed Icon.</para>
                <para>Identifier classes should be used in attributes, XAML, or generic parameters. Where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected, use the identifier object in the <see cref="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.ModifiersReadWrite.Id"/> field of the identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+ModifiersReadWrite}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.ModifiersReadWrite))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.ModifiersReadWrite.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.ModifiersReadWrite&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.ModifiersReadWrite.Id">
             <summary>
              <para>
                <para>Autogenerated identifier object for the ModifiersReadWrite Themed Icon.</para>
                <para>Identifier objects should be used where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected. In attributes, XAML, or generic parameters use the containing <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.ModifiersReadWrite"/> identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+ModifiersReadWrite}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.ModifiersReadWrite))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.ModifiersReadWrite.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.ModifiersReadWrite&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.ModifiersStatic">
             <summary>
              <para>
                <para>Autogenerated identifier class for the ModifiersStatic Themed Icon.</para>
                <para>Identifier classes should be used in attributes, XAML, or generic parameters. Where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected, use the identifier object in the <see cref="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.ModifiersStatic.Id"/> field of the identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+ModifiersStatic}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.ModifiersStatic))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.ModifiersStatic.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.ModifiersStatic&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.ModifiersStatic.Id">
             <summary>
              <para>
                <para>Autogenerated identifier object for the ModifiersStatic Themed Icon.</para>
                <para>Identifier objects should be used where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected. In attributes, XAML, or generic parameters use the containing <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.ModifiersStatic"/> identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+ModifiersStatic}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.ModifiersStatic))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.ModifiersStatic.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.ModifiersStatic&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.ModifiersVirtual">
             <summary>
              <para>
                <para>Autogenerated identifier class for the ModifiersVirtual Themed Icon.</para>
                <para>Identifier classes should be used in attributes, XAML, or generic parameters. Where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected, use the identifier object in the <see cref="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.ModifiersVirtual.Id"/> field of the identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+ModifiersVirtual}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.ModifiersVirtual))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.ModifiersVirtual.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.ModifiersVirtual&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.ModifiersVirtual.Id">
             <summary>
              <para>
                <para>Autogenerated identifier object for the ModifiersVirtual Themed Icon.</para>
                <para>Identifier objects should be used where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected. In attributes, XAML, or generic parameters use the containing <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.ModifiersVirtual"/> identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+ModifiersVirtual}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.ModifiersVirtual))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.ModifiersVirtual.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.ModifiersVirtual&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.ModifiersWrite">
             <summary>
              <para>
                <para>Autogenerated identifier class for the ModifiersWrite Themed Icon.</para>
                <para>Identifier classes should be used in attributes, XAML, or generic parameters. Where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected, use the identifier object in the <see cref="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.ModifiersWrite.Id"/> field of the identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+ModifiersWrite}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.ModifiersWrite))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.ModifiersWrite.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.ModifiersWrite&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.ModifiersWrite.Id">
             <summary>
              <para>
                <para>Autogenerated identifier object for the ModifiersWrite Themed Icon.</para>
                <para>Identifier objects should be used where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected. In attributes, XAML, or generic parameters use the containing <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.ModifiersWrite"/> identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+ModifiersWrite}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.ModifiersWrite))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.ModifiersWrite.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.ModifiersWrite&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Namespace">
             <summary>
              <para>
                <para>Autogenerated identifier class for the Namespace Themed Icon.</para>
                <para>Identifier classes should be used in attributes, XAML, or generic parameters. Where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected, use the identifier object in the <see cref="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Namespace.Id"/> field of the identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+Namespace}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.Namespace))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.Namespace.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.Namespace&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Namespace.Id">
             <summary>
              <para>
                <para>Autogenerated identifier object for the Namespace Themed Icon.</para>
                <para>Identifier objects should be used where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected. In attributes, XAML, or generic parameters use the containing <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Namespace"/> identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+Namespace}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.Namespace))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.Namespace.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.Namespace&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Operator">
             <summary>
              <para>
                <para>Autogenerated identifier class for the Operator Themed Icon.</para>
                <para>Identifier classes should be used in attributes, XAML, or generic parameters. Where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected, use the identifier object in the <see cref="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Operator.Id"/> field of the identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+Operator}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.Operator))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.Operator.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.Operator&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Operator.Id">
             <summary>
              <para>
                <para>Autogenerated identifier object for the Operator Themed Icon.</para>
                <para>Identifier objects should be used where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected. In attributes, XAML, or generic parameters use the containing <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Operator"/> identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+Operator}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.Operator))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.Operator.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.Operator&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Parameter">
             <summary>
              <para>
                <para>Autogenerated identifier class for the Parameter Themed Icon.</para>
                <para>Identifier classes should be used in attributes, XAML, or generic parameters. Where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected, use the identifier object in the <see cref="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Parameter.Id"/> field of the identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+Parameter}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.Parameter))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.Parameter.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.Parameter&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Parameter.Id">
             <summary>
              <para>
                <para>Autogenerated identifier object for the Parameter Themed Icon.</para>
                <para>Identifier objects should be used where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected. In attributes, XAML, or generic parameters use the containing <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Parameter"/> identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+Parameter}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.Parameter))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.Parameter.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.Parameter&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Private">
             <summary>
              <para>
                <para>Autogenerated identifier class for the Private Themed Icon.</para>
                <para>Identifier classes should be used in attributes, XAML, or generic parameters. Where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected, use the identifier object in the <see cref="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Private.Id"/> field of the identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+Private}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.Private))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.Private.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.Private&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Private.Id">
             <summary>
              <para>
                <para>Autogenerated identifier object for the Private Themed Icon.</para>
                <para>Identifier objects should be used where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected. In attributes, XAML, or generic parameters use the containing <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Private"/> identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+Private}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.Private))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.Private.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.Private&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Property">
             <summary>
              <para>
                <para>Autogenerated identifier class for the Property Themed Icon.</para>
                <para>Identifier classes should be used in attributes, XAML, or generic parameters. Where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected, use the identifier object in the <see cref="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Property.Id"/> field of the identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+Property}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.Property))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.Property.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.Property&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Property.Id">
             <summary>
              <para>
                <para>Autogenerated identifier object for the Property Themed Icon.</para>
                <para>Identifier objects should be used where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected. In attributes, XAML, or generic parameters use the containing <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Property"/> identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+Property}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.Property))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.Property.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.Property&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.PropertyWrite">
             <summary>
              <para>
                <para>Autogenerated identifier class for the PropertyWrite Themed Icon.</para>
                <para>Identifier classes should be used in attributes, XAML, or generic parameters. Where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected, use the identifier object in the <see cref="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.PropertyWrite.Id"/> field of the identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+PropertyWrite}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.PropertyWrite))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.PropertyWrite.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.PropertyWrite&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.PropertyWrite.Id">
             <summary>
              <para>
                <para>Autogenerated identifier object for the PropertyWrite Themed Icon.</para>
                <para>Identifier objects should be used where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected. In attributes, XAML, or generic parameters use the containing <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.PropertyWrite"/> identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+PropertyWrite}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.PropertyWrite))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.PropertyWrite.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.PropertyWrite&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Protected">
             <summary>
              <para>
                <para>Autogenerated identifier class for the Protected Themed Icon.</para>
                <para>Identifier classes should be used in attributes, XAML, or generic parameters. Where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected, use the identifier object in the <see cref="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Protected.Id"/> field of the identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+Protected}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.Protected))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.Protected.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.Protected&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Protected.Id">
             <summary>
              <para>
                <para>Autogenerated identifier object for the Protected Themed Icon.</para>
                <para>Identifier objects should be used where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected. In attributes, XAML, or generic parameters use the containing <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Protected"/> identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+Protected}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.Protected))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.Protected.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.Protected&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.PsiSymbolTypicalSizePlaceholder">
             <summary>
              <para>
                <para>Autogenerated identifier class for the PsiSymbolTypicalSizePlaceholder Themed Icon.</para>
                <para>Identifier classes should be used in attributes, XAML, or generic parameters. Where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected, use the identifier object in the <see cref="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.PsiSymbolTypicalSizePlaceholder.Id"/> field of the identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+PsiSymbolTypicalSizePlaceholder}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.PsiSymbolTypicalSizePlaceholder))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.PsiSymbolTypicalSizePlaceholder.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.PsiSymbolTypicalSizePlaceholder&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.PsiSymbolTypicalSizePlaceholder.Id">
             <summary>
              <para>
                <para>Autogenerated identifier object for the PsiSymbolTypicalSizePlaceholder Themed Icon.</para>
                <para>Identifier objects should be used where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected. In attributes, XAML, or generic parameters use the containing <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.PsiSymbolTypicalSizePlaceholder"/> identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+PsiSymbolTypicalSizePlaceholder}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.PsiSymbolTypicalSizePlaceholder))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.PsiSymbolTypicalSizePlaceholder.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.PsiSymbolTypicalSizePlaceholder&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Public">
             <summary>
              <para>
                <para>Autogenerated identifier class for the Public Themed Icon.</para>
                <para>Identifier classes should be used in attributes, XAML, or generic parameters. Where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected, use the identifier object in the <see cref="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Public.Id"/> field of the identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+Public}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.Public))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.Public.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.Public&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Public.Id">
             <summary>
              <para>
                <para>Autogenerated identifier object for the Public Themed Icon.</para>
                <para>Identifier objects should be used where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected. In attributes, XAML, or generic parameters use the containing <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Public"/> identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+Public}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.Public))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.Public.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.Public&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Struct">
             <summary>
              <para>
                <para>Autogenerated identifier class for the Struct Themed Icon.</para>
                <para>Identifier classes should be used in attributes, XAML, or generic parameters. Where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected, use the identifier object in the <see cref="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Struct.Id"/> field of the identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+Struct}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.Struct))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.Struct.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.Struct&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Struct.Id">
             <summary>
              <para>
                <para>Autogenerated identifier object for the Struct Themed Icon.</para>
                <para>Identifier objects should be used where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected. In attributes, XAML, or generic parameters use the containing <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Struct"/> identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+Struct}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.Struct))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.Struct.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.Struct&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.SymbolUnitTest">
             <summary>
              <para>
                <para>Autogenerated identifier class for the SymbolUnitTest Themed Icon.</para>
                <para>Identifier classes should be used in attributes, XAML, or generic parameters. Where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected, use the identifier object in the <see cref="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.SymbolUnitTest.Id"/> field of the identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+SymbolUnitTest}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.SymbolUnitTest))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.SymbolUnitTest.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.SymbolUnitTest&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.SymbolUnitTest.Id">
             <summary>
              <para>
                <para>Autogenerated identifier object for the SymbolUnitTest Themed Icon.</para>
                <para>Identifier objects should be used where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected. In attributes, XAML, or generic parameters use the containing <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.SymbolUnitTest"/> identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+SymbolUnitTest}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.SymbolUnitTest))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.SymbolUnitTest.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.SymbolUnitTest&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.SymbolUnitTestSet">
             <summary>
              <para>
                <para>Autogenerated identifier class for the SymbolUnitTestSet Themed Icon.</para>
                <para>Identifier classes should be used in attributes, XAML, or generic parameters. Where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected, use the identifier object in the <see cref="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.SymbolUnitTestSet.Id"/> field of the identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+SymbolUnitTestSet}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.SymbolUnitTestSet))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.SymbolUnitTestSet.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.SymbolUnitTestSet&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.SymbolUnitTestSet.Id">
             <summary>
              <para>
                <para>Autogenerated identifier object for the SymbolUnitTestSet Themed Icon.</para>
                <para>Identifier objects should be used where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected. In attributes, XAML, or generic parameters use the containing <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.SymbolUnitTestSet"/> identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+SymbolUnitTestSet}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.SymbolUnitTestSet))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.SymbolUnitTestSet.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.SymbolUnitTestSet&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.TypeDef">
             <summary>
              <para>
                <para>Autogenerated identifier class for the TypeDef Themed Icon.</para>
                <para>Identifier classes should be used in attributes, XAML, or generic parameters. Where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected, use the identifier object in the <see cref="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.TypeDef.Id"/> field of the identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+TypeDef}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.TypeDef))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.TypeDef.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.TypeDef&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.TypeDef.Id">
             <summary>
              <para>
                <para>Autogenerated identifier object for the TypeDef Themed Icon.</para>
                <para>Identifier objects should be used where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected. In attributes, XAML, or generic parameters use the containing <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.TypeDef"/> identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+TypeDef}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.TypeDef))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.TypeDef.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.TypeDef&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Typeparameter">
             <summary>
              <para>
                <para>Autogenerated identifier class for the Typeparameter Themed Icon.</para>
                <para>Identifier classes should be used in attributes, XAML, or generic parameters. Where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected, use the identifier object in the <see cref="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Typeparameter.Id"/> field of the identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+Typeparameter}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.Typeparameter))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.Typeparameter.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.Typeparameter&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Typeparameter.Id">
             <summary>
              <para>
                <para>Autogenerated identifier object for the Typeparameter Themed Icon.</para>
                <para>Identifier objects should be used where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected. In attributes, XAML, or generic parameters use the containing <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Typeparameter"/> identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+Typeparameter}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.Typeparameter))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.Typeparameter.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.Typeparameter&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Union">
             <summary>
              <para>
                <para>Autogenerated identifier class for the Union Themed Icon.</para>
                <para>Identifier classes should be used in attributes, XAML, or generic parameters. Where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected, use the identifier object in the <see cref="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Union.Id"/> field of the identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+Union}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.Union))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.Union.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.Union&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Union.Id">
             <summary>
              <para>
                <para>Autogenerated identifier object for the Union Themed Icon.</para>
                <para>Identifier objects should be used where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected. In attributes, XAML, or generic parameters use the containing <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Union"/> identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+Union}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.Union))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.Union.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.Union&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.UnresolvedField">
             <summary>
              <para>
                <para>Autogenerated identifier class for the UnresolvedField Themed Icon.</para>
                <para>Identifier classes should be used in attributes, XAML, or generic parameters. Where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected, use the identifier object in the <see cref="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.UnresolvedField.Id"/> field of the identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+UnresolvedField}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.UnresolvedField))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.UnresolvedField.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.UnresolvedField&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.UnresolvedField.Id">
             <summary>
              <para>
                <para>Autogenerated identifier object for the UnresolvedField Themed Icon.</para>
                <para>Identifier objects should be used where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected. In attributes, XAML, or generic parameters use the containing <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.UnresolvedField"/> identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+UnresolvedField}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.UnresolvedField))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.UnresolvedField.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.UnresolvedField&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.UnresolvedMethod">
             <summary>
              <para>
                <para>Autogenerated identifier class for the UnresolvedMethod Themed Icon.</para>
                <para>Identifier classes should be used in attributes, XAML, or generic parameters. Where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected, use the identifier object in the <see cref="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.UnresolvedMethod.Id"/> field of the identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+UnresolvedMethod}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.UnresolvedMethod))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.UnresolvedMethod.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.UnresolvedMethod&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.UnresolvedMethod.Id">
             <summary>
              <para>
                <para>Autogenerated identifier object for the UnresolvedMethod Themed Icon.</para>
                <para>Identifier objects should be used where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected. In attributes, XAML, or generic parameters use the containing <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.UnresolvedMethod"/> identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+UnresolvedMethod}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.UnresolvedMethod))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.UnresolvedMethod.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.UnresolvedMethod&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Variable">
             <summary>
              <para>
                <para>Autogenerated identifier class for the Variable Themed Icon.</para>
                <para>Identifier classes should be used in attributes, XAML, or generic parameters. Where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected, use the identifier object in the <see cref="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Variable.Id"/> field of the identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+Variable}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.Variable))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.Variable.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.Variable&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Variable.Id">
             <summary>
              <para>
                <para>Autogenerated identifier object for the Variable Themed Icon.</para>
                <para>Identifier objects should be used where an <see cref="T:JetBrains.UI.Icons.IconId"/> value is expected. In attributes, XAML, or generic parameters use the containing <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons.Variable"/> identifier class.</para>
              </para>
            </summary>
            <remarks>
              <para>For details on Themed Icons and their use, see Remarks on <see cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/> class.</para>
            </remarks>
            <seealso cref="T:JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons"/>
            <example>
              <code>&lt;Image Source="{icons:ThemedIcon myres:PsiSymbolsThemedIcons+Variable}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
              <code>[Item(Name="Sample", Icon=typeof(PsiSymbolsThemedIcons.Variable))]        // C# Type attribute</code>
            </example>
            <example>
              <code>IconId iconid = PsiSymbolsThemedIcons.Variable.Id;        // IconId identifier object</code>
            </example>
            <example>
              <code>themediconmanager.GetIcon&lt;PsiSymbolsThemedIcons.Variable&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Caches.ICache.Load(JetBrains.Application.Progress.IProgressIndicator,System.Boolean)">
            <summary>
            Load data from persistent storage.
            If cache requires write lock to store data, then load into temporary object and later merge it in <see cref="M:JetBrains.ReSharper.Psi.Caches.ICache.MergeLoaded(System.Object)"/> method
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Caches.ICache.MergeLoaded(System.Object)">
            <summary>
            Merge loaded data into cache data structures. Executes under write lock
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Caches.ICache.SyncUpdate(System.Boolean)">
            <summary>
            Synchronously update caches.
            Happens either when <see cref="!:SyntheticAttribute.CommitAllDocuments"/> or <see cref="M:JetBrains.ReSharper.Psi.Caches.IPsiCaches.Update"/> is called.
            Every implementation should maintain list of dirty files by itself, usually by monitoring <see cref="M:JetBrains.ReSharper.Psi.Caches.ICache.OnPsiChange(JetBrains.ReSharper.Psi.Tree.ITreeNode,JetBrains.ReSharper.Psi.PsiChangedElementType)"/> or <see cref="M:JetBrains.ReSharper.Psi.Caches.ICache.OnDocumentChange(JetBrains.ReSharper.Psi.IPsiSourceFile,JetBrains.DocumentManagers.impl.ProjectFileDocumentCopyChange)"/> invocations.
            For performance reasons, implementation could postpone it's update if invoked under <paramref name="underTransaction"/> if the cache is irrelevant to reference resolve
            </summary>
            <param name="underTransaction"></param>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Caches.Job.Do(JetBrains.Application.Progress.IProgressIndicator,System.Boolean,System.Func{System.Boolean})">
            <summary>
            Runs the task. The <paramref name="progress"/> should be used only if the task requires additional progress display (like smooth execution progress or more text messages). Normally, for short-time tasks, the executing engine will handle the progress.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Caches.Job.Description">
            <summary>
            The individual description of the job. Not included into the status bar cache notifier.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Caches.Job.GroupId">
            <summary>
            Common ID for the group of jobs.
            It's the group progress that is displayed in the cache notifier, not jobs'.
            The group ID is displayed as the cache notifier main text (the only text of the status-bar cache notifier).
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Caches.LibrarySymbolScope.NONE">
            <summary>
            Do not include libraries
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Caches.LibrarySymbolScope.REFERENCED">
            <summary>
            Only libraries directly referenced from source projects
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Caches.LibrarySymbolScope.TRANSITIVE">
            <summary>
            Libraries referenced from source projects and their transitive closure
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Caches.LibrarySymbolScope.FULL">
            <summary>
            All libraries in code model
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Caches.ISwitchingCache.Initialize">
            <summary>
            Initializes the cache
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Caches.ISwitchingCache.Release">
            <summary>
            Release all data associated with cache. Cache won't receive any events any more. 
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Caches.ISymbolScope">
            <summary>
            Declarations cache provides access to cached information about types and namespaces.
            Depending on its scope declarations cache may provide information about types and namespaces
            <list>
            <item>in whole solution including libraries</item>
            <item>in whole solution exclusing libraries</item>
            <item>in project</item>
            <item>in project and its referenced libraries and projects</item>
            <item>in library and its referenced libraries</item>
            </list>
            </summary>
            <example>
            Following code demonstates use of <see cref="T:JetBrains.ReSharper.Psi.Caches.ISymbolScope">IDeclarationsCache</see> indexer
            to get information about given class.
            <code>
            bool ClassIsSealed(string qualifiedName, ISolution solution)
            {
              DeclarationsCacheScope scope = DeclarationsCacheScope.SolutionScope(solution, false);
              IDeclarationsCache cache = PsiManager.GetInstance(solution).GetDeclarationsCache(scope);
              IDeclaredElementInfo info = cache[qualifiedName];
              Logger.Assert(info.GetSymbolType() == DeclaredElementType.CLASS);
              return info.IsSealed();
            }
            </code>
            </example>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Caches.ISymbolScope.Contains(JetBrains.ReSharper.Psi.ITypeElement)">
            <summary>
            Checks if given typeElement is accepted by the scope of the cache
            </summary>
            <param name="typeElement"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Caches.ISymbolScope.GetElementsByQualifiedName(System.String)">
            <summary>
            Returns cached information about namespace or types with given <paramref name="qualifiedName">qualified name</paramref>
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Caches.ISymbolScope.GetElementsAtQualifiedName(System.String)">
            <summary>
            Takes cached information about namespace or type with given <paramref name="qualifiedName">qualified name</paramref>
            and returns array with cached information about its nested namespaces and types
            (or just types if qualified name is a typename).
            </summary>
            <param name="qualifiedName">Full qualified name of namespace or type</param>
            <remarks>Returns information about default namespace if empty string is passed.
            <code>null</code> should not be passed (throws NullReferenceException).</remarks>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Caches.ISymbolScope.GetAllShortNamesSorted">
            <summary>
            Returnes list of short names of all namespaces and types.
            Short name of a type is its declared name. Short name of a namespace is 
            last part of its name without dot, e.g. in the following code
            <code>
            namespace A.B
            {
            }
            </code>
            short name of namespace A.B is B.
            </summary>
            <returns>Lexicographically sorted array of all short names of namespaces and types.</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Caches.ISymbolScope.GetAllShortNames">
            <summary>
            Returnes list of short names of all namespaces and types.
            Short name of a type is its declared name. Short name of a namespace is 
            last part of its name without dot, e.g. in the following code
            <code>
            namespace A.B
            {
            }
            </code>
            short name of namespace A.B is B.
            </summary>
            <returns>List of all short names of namespaces and types.</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Caches.ISymbolScope.GetElementsByShortName(System.String)">
            <summary>
            Returns array of cached information about namespaces and types having given short name.
            (<see cref="M:JetBrains.ReSharper.Psi.Caches.ISymbolScope.GetAllShortNames">GetAllShortNames</see> for explanation of meaning of 'short name' term).
            </summary>
            <remarks>Empty arrray is returned if no elements with given name are found.
            Empty array is returned if <code>null</code> is passed.</remarks>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Caches.ISymbolScope.GetPossibleInheritors(System.String)">
            <summary>
            Returns array of cached information about types that might directly inherit type
            with given short name. Type A is supposed that it might directly inherit type B if 
            it contains reference that might resolve to B in its extends list.
            Reference might resolve to type B if its name is short name of type B.
            GetPossibleInheritors takes aliases into consideration.
            <example>
            <code>
            using X = B;
            class A : B {}
            </code>
            Cached information for type A will be returned in calls to GetPossibleInheritors for type B.
            (And for type X if any exists in this declarations cache scope).
            </example>
            (<see cref="M:JetBrains.ReSharper.Psi.Caches.ISymbolScope.GetAllShortNames">GetAllShortNames</see> for explanation of meaning of 'short name' term).
            </summary>
            <param name="shortTypeName">short name of type</param>
            <remarks><paramref name="shortTypeName">short type name</paramref> should not be null</remarks>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Caches.ISymbolScope.GetAllTypeMemberNames">
            <summary>
            Enumerates all possible names of the type members. The result could contains duplicate names, or names which do not match to any member
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Caches.IPsiSourceFileInvalidatingCache">
            <summary>
            PsiCaches notifies invalidating caches on any async file change (build/merge cycle). Use it when you need to invalidate your cache synchronously (in main thread under read-lock).
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IDeclaredElement.GetDeclarations">
            <summary>
             Potentially VERY expensive method. In case of a namespace will parse all the files with classes declared in the namespace
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IDeclaredElement.GetSourceFiles">
            <summary>Get the set of source files which contains the declaration of this element</summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IDeclaredElement.HasDeclarationsIn(JetBrains.ReSharper.Psi.IPsiSourceFile)">
            <summary>Checks if there are declarations of this element in given <paramref name="sourceFile"/></summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IDeclaredElement.PresentationLanguage">
            <summary>Get the language on which this element is declared</summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IDeclaredElementPresenter.Format(JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle,JetBrains.ReSharper.Psi.IDeclaredElement,JetBrains.ReSharper.Psi.Resolve.ISubstitution,JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking@)">
            <param name="style"></param>
            <param name="element">Contains <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/> to provide string presentation of.</param>
            <param name="substitution"></param>
            <param name="marking">Returns the markup of the string with a <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/> presentation.</param>
             <summary>
             Returns a string containing declared element text presentation made according to this presenter settings.
             This method is usefull when additional processing is required for the returned string,
             e.g. as is done in the following method:
             <code>
             RichText Foo(IMethod method)
             {
               DeclaredElementPresenterMarking marking;
               RichTextParameters rtp = new RichTextParameters(ourFont);
               // make rich text with declared element presentation
               RichText result = new RichText(ourInvocableFormatter.Format(method, out marking),rtp);
               // highlight name of declared element in rich text
               result.SetColors(SystemColors.HighlightText,SystemColors.Info,marking.NameRange.StartOffset,marking.NameRange.EndOffset);
               return result;
             }
             </code>
             </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IDeclaredElementPresenter.Format(JetBrains.ReSharper.Psi.ParameterKind)">
            <summary>
            Returns language specific presentation for a given parameter kind 
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IDeclaredElementPresenter.Format(JetBrains.ReSharper.Psi.AccessRights)">
            <summary>
            Returns language specific presentation for a given access rights value
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.DeclaredElementType">
            <summary>
            Type of the declared element. Each type should be singleton
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.DeclaredElementType.GetImage">
            <summary>
            Image of the declared element
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.DeclaredElementType.IsPresentable(JetBrains.ReSharper.Psi.PsiLanguageType)">
            <summary>
            Returns presentation of this element is sound for given language type
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementType.PresentableName">
            <summary>
            Presentable name of the declared element
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementType.DefaultPresenter">
            <summary>
            Default declared element presenter
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Colors.IColorElement.ShortName">
            Name for color , if exists
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Extensions.EnqueueJob(JetBrains.Application.Threading.Tasks.TaskBarrier,System.Action,JetBrains.Metadata.Reader.API.IModuleReferenceResolveContext)">
            <summary>
            Create and start a new task under the task barrier.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.ExternalAnnotations.IExternalAnnotationsFileProvider.GetAnnotationsFiles(JetBrains.Metadata.Utils.AssemblyNameInfo,JetBrains.Util.FileSystemPath)">
            <param name="assemblyName">If null - enumerate all annotations files</param>
            <param name="assemblyLocation"></param>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Resolve.IReference.GetTreeNode">
            <summary>
            Returns the "owner" of the reference.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Resolve.IReference.GetName">
            <summary>
            Returns reference name.
            This name usually coincides with short name of corresponding DeclaredElement.
            (Only known exception is constructor initializer, its name is "this" or "base".)
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Resolve.IReference.GetAllNames">
            <summary>
            Returns all reference names (i.e., all possible short names of corresponding DeclaredElement)
            <remarks>Can be invoked on invalid refernce!</remarks>
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Resolve.IReference.GetReferenceSymbolTable(System.Boolean)">
            <summary>
            Returns full symbol table for the reference
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Resolve.IReference.Resolve">
            <summary>
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Resolve.IReference.GetTreeTextRange">
            <summary>
            Returns text range of reference in the source file.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Resolve.IReference.BindTo(JetBrains.ReSharper.Psi.IDeclaredElement)">
            <summary>
            Bind this reference to given Declared Element. May insert using directive.
            </summary>
            <returns>new "this"</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Resolve.IReference.BindTo(JetBrains.ReSharper.Psi.IDeclaredElement,JetBrains.ReSharper.Psi.Resolve.ISubstitution)">
            <summary>
            Bind this reference to given Declared Element and substitution. May insert using directive.
            </summary>
            <returns>new "this"</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Resolve.IReference.GetAccessContext">
            <summary>
            Returns access context containing reference. It is useful to define, if context
            is static or to determine access rights of context.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Resolve.IReference.HasMultipleNames">
            <summary>
            Returns true if reference could be resolved in declared elements with different names.
            E.g., attribute [XXX] could be resolved into class with name 'XXX' or 'XXXAttribute' 
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Resolve.IReference.CurrentResolveResult">
            <summary>
            Resolve cache
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.ITreeNode.GetFirstClassReferences">
            <summary>
            Get references which should be visited by resolver,
            and which are syntax-dependent (not semantic)
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.ITreeNode.GetContainingNode``1(System.Boolean)">
            <param name="returnThis">Whether to include the starting element</param>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.ITreeNode.Contains(JetBrains.ReSharper.Psi.Tree.ITreeNode)">
            <summary>
            Returns true if the subtree rooted at this element contains other element
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.ITreeNode.IsPhysical">
            <summary>
            Checks if this element is located at physical file (and not in sandbox)
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.ITreeNode.IsValid">
            <summary>
            Checks if this element is valid
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.ITreeNode.IsFiltered">
            <summary>
            Checks if this element is filtered (whitespace, comment or error)
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.ITreeNode.GetNavigationRange">
            <summary>
            Returns an offset in the text to move caret to
            when positioning to the element
            </summary>
            <returns>An offset in the text</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.ITreeNode.GetText(System.Text.StringBuilder)">
            <return> Implementations must always return parameter.</return>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.ITreeNode.GetTextAsBuffer">
            <summary>
            Get the text as a buffer
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.ITreeNode.GetText">
            <summary>
            Returns text representation of an element
            </summary>
            <remarks>
            For performance reason, it's better to use another GetText method
            </remarks>
            <returns></returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.ITreeNode.FindNodeAt(JetBrains.ReSharper.Psi.TreeTextRange)">
            <summary>
            Finds the smallest element containing the specified text range
            </summary>
            <param name="treeTextRange">Text range in this element</param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.ITreeNode.FindNodesAt(JetBrains.ReSharper.Psi.TreeOffset)">
            <summary>
            Finds all elements containing the specified offset and such that none
            of the elements contains another element meeting this condition
            </summary>
            <param name="treeTextOffset">Offset to find element at</param>
            <returns>Array of found elements, or an empty array</returns>
            <remarks>If an element returned by this method is not a leaf, it should be empty</remarks>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.ITreeNode.FindTokenAt(JetBrains.ReSharper.Psi.TreeOffset)">
            <summary>
            Returns the token containing the character corresponding
            to the specified offset
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Tree.ITreeNode.UserData">
            <summary>User data bag</summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Tree.ITreeNode.PersistentUserData">
            <summary>
            <see cref="T:JetBrains.Util.IUserDataHolder"/> for this element
            which is copied with the element
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.TreeElement.myCachedOffsetData">
            <summary>
            Cached value of local node offset in parent.
            The value is valid only when parent.<see cref="F:JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.CompositeElement.myTextLength"/> is valid
            -1 means unknown
            zero or more: offset relative to parent
            less then -1: absolute offset in buffer, -2 means zero
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.TreeElement.FindElementsAtInternal(JetBrains.ReSharper.Psi.TreeOffset,System.Collections.Generic.List{JetBrains.ReSharper.Psi.Tree.ITreeNode})">
            <returns>
            Length of this element if it's less or equal
            than offset or any value greater than offset
            </returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.TreeElement.FindChameleonWhichCoversRange(JetBrains.ReSharper.Psi.TreeTextRange)">
            <summary>
            Finds the deepest sub-node implementing IChameleon
            interface which contains the given range internally
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Files.IDocumentRangeTranslator">
            <summary>
            Translates ranges in the primary tree to the ranges in actual documents
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IGeneratedDocumentsManager.CreateGeneratedDocument(JetBrains.ReSharper.Psi.IPsiSourceFile,System.String,JetBrains.ReSharper.Psi.PsiLanguageType)">
            <summary>
            Creates and registers secondary document.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IGeneratedDocumentsManager.GetPossibleLanguageTypes(JetBrains.ProjectModel.IProject,JetBrains.ProjectModel.ProjectFileType)">
            <summary>
            Returns all possible secondary languages of the project file
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IGeneratedDocumentsManager.ApplyTransactionDocumentChange(JetBrains.DocumentModel.DocumentChange,System.String,JetBrains.ReSharper.Psi.Transactions.IPsiTransactionAction)">
            <summary>
            Passes document change to the related documents
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IGeneratedDocumentsManager.GetServices(JetBrains.ProjectModel.ProjectFileType)">
            <summary>
            Enumerables services for specified project file type
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IGeneratedDocumentsManager.AssertGeneratedFilesValid(JetBrains.ReSharper.Psi.IPsiSourceFile)">
            <summary>
            Checks that generated files are not corrupted
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Files.GeneratedDocumentsManager.ReduceRanges(System.String@,System.String@,JetBrains.Util.TextRange@)">
            <summary>
            Find common parts
            Ignore whitespaces, for code formatter may work weirdly with "\r\n\n" sequences
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Files.ISecondaryRangeTranslator">
            <summary>
            Translates ranges from the secondary IFile to the ranges in the original IFile.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Files.ISecondaryRangeTranslator.GetCoveringRange(JetBrains.ReSharper.Psi.TreeTextRange)">
            <summary>Returns tuple of original and generated ranges, null if not successful</summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Files.IPsiFiles.CommitAllDocuments">
            <summary>
            Might be performance critical.
            Use RequirementsManager to execute an action asynchronously after committing the documents
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Files.PsiFilesExtensions.GetDominantPsiFile``1(JetBrains.ReSharper.Psi.IPsiSourceFile)">
            <summary>Should be used to get primary or main code behind file</summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CodeStyle.SettingsUpgrade.CodeStyleSettingsSharing.USER">
            <summary>
            Code style settings are pre user
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CodeStyle.SettingsUpgrade.CodeStyleSettingsSharing.SOLUTION">
            <summary>
            Code style settings are shared in solution
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CodeStyle.SettingsUpgrade.CodeStyleSettingsSharing.EXTERNAL">
            <summary>
            Code style settings are serialized to  external file
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExtensionsAPI.IInjectedFileContext">
            <summary>
            Here provider may store list of nodes with injects, status of generation (which nodes already has injected PSI generated),
            information about changes delayed until commit, etc.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.ICompositeElement.FindChildByRole(System.Int16)">
            <summary>
            Search for the child with given role
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.IScope.AddGlobalDeclarations(JetBrains.ReSharper.Psi.Resolve.ISymbolTable,System.Int32,JetBrains.ReSharper.Psi.Resolve.SymbolTableMode)">
            <summary>
            Provides symbols which are visible inside scope
            </summary>
            <param name="parentTable"></param>
            <param name="level"></param>
            <param name="mode"></param>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Impl.IResolveIsolationScope">
            <summary>
            Any PSI change inside this scope:
            <list type="number">
            <item>Affects resolve validity of inner references only</item>
            <item>Does not change 'global' model</item>
            </list>
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Impl.IResolveIsolationScope.ModificationStamp">
            <summary>
            Returns <c>null</c> if this element actually is not scope.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.ISandBox.ContextNode">
            <summary>
            The context for resolve for this sandbox.
            From dummy holder POV, it is located *inplace* of the context node
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.IInjectedPsiProvider.OriginalFileChanged(JetBrains.ReSharper.Psi.ExtensionsAPI.IInjectedFileContext,JetBrains.ReSharper.Psi.Tree.ITreeNode,System.Collections.Generic.IEnumerable{JetBrains.ReSharper.Psi.Tree.ITreeNode},System.Collections.Generic.IEnumerable{JetBrains.ReSharper.Psi.Tree.ITreeNode},System.Boolean)">
            <summary>
            Here we may support (incremental?) generation.
            processImmediately - whether we should process change immediately or can leave it until commit.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.IInjectedPsiProvider.GeneratedFileChanged(JetBrains.ReSharper.Psi.ExtensionsAPI.IInjectedFileContext,JetBrains.ReSharper.Psi.Tree.ITreeNode,System.Collections.Generic.IEnumerable{JetBrains.ReSharper.Psi.Tree.ITreeNode},System.Collections.Generic.IEnumerable{JetBrains.ReSharper.Psi.Tree.ITreeNode},System.Boolean)">
            <summary>
            Here we may support (incremental?) regeneration.
            processImmediately - whether we should process change immediately or can leave it until commit.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.IInjectedPsiProvider.SynchronizeOriginalAndGenerated(JetBrains.ReSharper.Psi.ExtensionsAPI.IInjectedFileContext)">
            <summary>
            If we delayed change processing until later, this method is where we should at last process everything.
            Would be usually called on transaction commit.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.IIndependentInjectedPsiProvider.CleanupNodeContextOnDelete(JetBrains.ReSharper.Psi.ExtensionsAPI.IInjectedNodeContext)">
            <summary>
            Don't forget to add transaction actions if you implement this
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resolve.IReferenceProvider">
            <summary>
            Custom reference provider
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Resolve.IReferenceProvider.GetReferences(JetBrains.ReSharper.Psi.Tree.ITreeNode,JetBrains.ReSharper.Psi.Resolve.IReferenceNameContainer)">
            <summary>
            References which depends on first class references. 
            If <paramref name="names"/> is null, all references should be enumerated.
            If not null, then there might be an optimization to return only the references
            which might have given name
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.GeneratedCode.IGeneratedFilesCacheProvider">
            <summary>
            Language-specific interface to check if file is generated
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.GeneratedCode.Settings.ExcludedFileState.ExplicitlyExcluded">
            <summary>
            Explicitly excluded from set of files to analyse
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.GeneratedCode.Settings.ExcludedFileState.ForceIncluded">
            <summary>
            Always run analysis
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.PsiDataConstants.DECLARED_ELEMENT">
            <summary>
            For getting data ONLY.
            You MUST NOT create data rules for this constant. You MUST always use <see cref="F:JetBrains.ReSharper.Psi.PsiDataConstants.DECLARED_ELEMENTS"/> instead when supplying data.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.PsiDataConstants.DECLARED_ELEMENTS_FROM_ALL_CONTEXTS">
            <summary>
            Use the constant when you need all declared elements from all contexts (i.e. in case of multiple target frameworks)
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.PsiDataConstants.REFERENCES_FROM_ALL_CONTEXTS">
            <summary>
            Use the constant when you need all declared elements from all contexts (i.e. in case of multiple target frameworks)
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.PsiDataConstantsExtensions.ToDeclaredElementsDataConstant(JetBrains.ReSharper.Psi.IDeclaredElement)">
            <summary>
            Returns the declared element as the declared elements data constant: a list of one non-Null item, or Null.
            Prevents getting collections with null elements inside.
            In other words, makes it valid for the data rule.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.PsiDataConstantsExtensions.ToDeclaredElementsDataConstant(System.Collections.Generic.ICollection{JetBrains.ReSharper.Psi.IDeclaredElement})">
            <summary>
            Makes sure the declared elements collection does not contain Null items and is non-empty.
            Filters out Nulls, returns Null instead of empty collections.
            In other words, makes it valid for the data rule.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Files.SmallCache`2.Update(`0,`1,System.Int32)">
            <summary>
            Returns <c>true</c> if item was added, <c>false</c> if existing usage was updates
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.CodeStyle.CodeFormattingContext.CanModifyInsideNodeRange(JetBrains.ReSharper.Psi.Tree.ITreeNode,JetBrains.ReSharper.Psi.Tree.ITreeNode)">
            <summary>
            Returns whether formatter can modify space between two elements.
            Currently it is prohibited if either element is fully or partially included from another document.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.CodeStyle.CodeFormattingContext.CanModifyNode(JetBrains.ReSharper.Psi.Tree.ITreeNode)">
            <summary>
            Returns whether formatter can modify element.
            Currently it is prohibited if element is fully or partially included from another document.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Impl.CodeStyle.IndentType.Transparent">
            <summary>
            Observed settings from indent region of this type will be added to parent indent region.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IClrDeclaredElement.Module">
            <summary>Get the owning module of this</summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.IModifiersOwner">
            <summary>
            Interface for a language construction that may have modifiers
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.IAccessRightsOwner">
            <summary>
            Interface for a language construction that may have access rights modifiers
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IXmlDocIdOwner.XMLDocId">
            <summary>
            Identifier of this member in XML documentation file
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ITypeMember.GetHiddenMembers">
            <summary>
            Find the members in supertypes which are hidden by this member
            </summary>
            <returns></returns>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.ITypeMember.AccessibilityDomain">
            <summary>
            Returns the accessibility domain of the type member, taking into account 
            the accessibility of the containing types
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.ITypeMember.HidePolicy">
            <summary>
            Get the hide policy
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Reflection2.Member.GetHashCode">
            <summary>
            Serves as a hash function for a particular type. 
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object"/>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.IParametersOwner">
            <summary>
            Represents a function-like construct that can be invoked.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IParametersOwner.GetSignature(JetBrains.ReSharper.Psi.Resolve.ISubstitution)">
            <summary>
            Signature of the invocable. 
            </summary>
            <seealso cref="T:JetBrains.ReSharper.Psi.InvocableSignature"/>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IParametersOwner.GetParametersOwnerDeclarations">
            <summary>
            Declaration that contains parameter declarations for this element (can be delegate declaration for its Invoke method, property declaration for its accessor etc.)
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IParametersOwner.Parameters">
            <summary>
            Set of formal parameters of the invocable
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IParametersOwner.ReturnType">
            <summary>
            Return type of the invocable 
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.IOverridableMember">
             <summary>
             Presents type member, that could be overridden. Currently overridable members are method,
             property, indexer and event.
             <list type="number">
             <item> SuperMember for class (struct) overridable member "foo" is class member that is overridden
                by "foo" or interface member that is implemented by "foo".
                
                Interface member cannot have supermembers. </item>
                
             <item> If "A" is a class, "I" is an interface, both "A" and "I" contains member "foo", class "B" extends
                "A" and implements "I", but "B" does not contain member "foo",
                then "I.foo" is QuasiSuperMember for "A.foo".
                <code>
                public interface I
                {
                  void Foo();
                }
            
                public class A
                {
                  public void Foo() {} // "I.foo" is QuasiSuperMember for "A.foo", if class B exists.
                }
            
                public class B : A, I
                {
                  // If we remove class B, "A.foo" becomes just a simple method without any supermembers/QuasiSuperMembers.
                }
                </code></item>
            
             <item> Let "A.foo" is supermember for "B.foo". If there is no "C.foo" such that "C.foo" is
                supermember for "B.foo" and "A.foo" is supermember foe "C.foo", then "A.foo" is immediate
                supermember for "B.foo".
            
                <para>All interface members are immediate supermembers.</para>
                <para>All quasisupermembers are immediate (quasi)supermembers.</para> </item>
                
             <item> If "A.foo" is supermember for "B.foo" and "A.foo" has no supermembers, then "A.foo" is root
                supermember for "B.foo".
                <para>All interface members are root supermembers.</para>
                <para>All quasisupermembers are root (quasi)supermembers.</para> </item>
             </list>
             </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IOverridableMember.IsExplicitImplementation">
            <summary>
            Returns <c>true</c> if this member is private implementation. See <see cref="P:JetBrains.ReSharper.Psi.IOverridableMember.ExplicitImplementations"/>
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IOverridableMember.ExplicitImplementations">
            <summary>
            Returns the list of the members which are implemented explicitly
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IOverridableMember.CanBeImplicitImplementation">
            <summary>
            Returns true if this member can implement interface member implicitly
            </summary>
            Language-dependent property of IOverridableMember. Reflection implementations should return true.
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ITypeElement.GetClrName">
            <summary>
            Get the CLR name of type element.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ITypeElement.GetSuperTypes">
            <summary>
            Immediate supertypes of the type
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ITypeElement.GetMembers">
            <summary>
            returns all members of this type (including nested types!)
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ITypeElement.GetContainingNamespace">
            <summary>
            Namespace containing this type
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ITypeElement.GetSingleOrDefaultSourceFile">
            <summary>
            Return single source files where the type is defined. Returns null in case it is defined in multiple files.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.ITypeElement.NestedTypes">
            <summary>
            returns all nested (= inner) types of this type
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.ITypeElement.Constructors">
            <summary>
            returns all constructors of this type
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.ITypeElement.Operators">
            <summary>
            returns all operators of this type
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.ITypeElement.Methods">
            <summary>
            returns all methods of this type
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.ITypeElement.Properties">
            <summary>
            returns all properties of this type
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.ITypeElement.Events">
            <summary>
            returns all events of this type
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.ITypeElement.MemberNames">
            <summary>
            Get the names of all type members. 
            This set is approximate (i.e. it can contain extra names).
            Constructor and nested type names are not included in this list.
            It is much faster than getting all members itself
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Reflection2.CompiledTypeElementFactory.IsImplementsInterface(JetBrains.Metadata.Reader.API.IMetadataTypeInfo,JetBrains.Metadata.Reader.API.IMetadataClassType)">
            <summary>
            Can hide implemented interface from API
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IConstantValueOwner.ConstantValue">
            <summary>
            Calculate compile time constant value 
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IField.FixedBufferSize">
            <summary>
            In C#2.0 for field, check if this field is fixed-size buffer.
            Returns <c>null</c> if this is not fixed-size buffer, otherwise returns it's size
            If the field is fixed-size buffer, then it's type is a pointer to it's element
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.IConstructor">
            <summary>
            Represents type constructor.
            <i>Note</i>: <c>ShortName</c> of all implementations should return <see cref="F:JetBrains.ReSharper.Psi.DeclaredElementConstants.CONSTRUCTOR_NAME"/>
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Impl.Reflection2.ExternalAnnotations.AnnotationsIndex">
            <summary>
            per annotation file information cache
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Impl.Reflection2.ExternalAnnotations.AnnotationsIndexBuilder">
            <summary>
            processes xml annotation files and extracts structural information..
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Impl.Reflection2.ExternalAnnotations.AssemblyAnnotation">
            <summary>
            Serializable part of annotations for assembly attributes.
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Impl.Reflection2.ExternalAnnotations.AttributeInstance">
            <summary>
            Serializable part of annotations for attribute instance.
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Impl.Reflection2.ExternalAnnotations.AttributeInstancePositionalArgument">
            <summary>
            serialisable part of annotations for attribute argument.
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Impl.Reflection2.ExternalAnnotations.AttributeInstancePropertyArgument">
            <summary>
            Serializable part of annotations for attribute argument.
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Impl.Reflection2.ExternalAnnotations.IExternalAnnotationsAttributeWatcher">
            <summary>
            External providers may register attributes that should be added to [AttributeName -> TypeMemberId] index.
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Impl.Search.Operations.FinderOperationCollection`2">
            <summary>
            Encapsulate an applying FinderOperation with collection of Elements
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Impl.Search.Operations.IFinderSearchRoot">
            <summary>
            Root, from which the search process will be started
            Represents order for search operations
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Impl.Search.Operations.FinderOperation`1">
            <summary>
            Represents an finder operation consists of number of states
            Operation can be interrupted and after starting (resuming) again
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Search.Operations.FinderOperation`1.RegisterCollectionAsOperationState``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Register collection of declared elements as "state" of operation
            This collection will be checked (IsValid invoken on all declared element) before each resume operation
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Search.Operations.FinderOperation`1.Start">
            <summary>
            Start or Resume operation
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Search.Operations.Impl.FindReferencesOperation`1.ProcessConstructors">
            <summary>
            Look for constructor usages in the immediate inheritors of the containing type
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Search.Operations.Impl.FindReferencesOperation`1.ProcessFindImplementatorsUsages">
            <summary>
            Search for inheritors usages
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Search.Operations.Impl.FindReferencesOperation`1.ProcessRelatedElements">
            <summary>
             Search for related elements
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Search.Operations.FinderOperationManager.Run(System.Collections.Generic.ICollection{JetBrains.ReSharper.Psi.IDeclaredElement},System.Func{System.Collections.Generic.ICollection{JetBrains.ReSharper.Psi.IDeclaredElement},JetBrains.ReSharper.Psi.Impl.Search.Operations.IFinderOperation},JetBrains.ReSharper.Psi.Impl.Search.Operations.IFinderAsyncCallback)">
            <summary>
            Schedule FinderOperation to run
            </summary>
            <param name="declaredElements">Declared Elements for operation</param>
            <param name="factory">FinderOperation factory</param>
            <param name="callback">Result processor</param>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Search.Operations.FinderOperationManager.RunSync(JetBrains.ReSharper.Psi.Impl.Search.Operations.IFinderOperation)">
            <summary>
            Run FinderOperation sync
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Impl.Search.Operations.FinderOperationManager.FinderOperationRequest">
            <summary>
              Structure for store FinderOperation and callback
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Search.SearchDomainVisitor">
            <summary>
            The visitor does not traverse PSI tree, all methods are just different entry points called _once_ for domain element.
            If you need to process subnodes call recursive element processor manually in both VisitPsiSourceFile and VisitElement.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Search.IFindResultConsumer`1.Build(JetBrains.ReSharper.Psi.Search.FindResult)">
            <summary>
            Transforms find result into user data. Can bind to PSI here. Method is unsyncronized.
            Returns <c>null</c> to skip result
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Search.IFindResultConsumer`1.Merge(`0)">
            <summary>
            Accepts data from <see cref="M:JetBrains.ReSharper.Psi.Search.IFindResultConsumer`1.Build(JetBrains.ReSharper.Psi.Search.FindResult)"/>. Method is syncronized.
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Impl.Search.Operations.IState">
            <summary>
            Represents a completed state of FinderOperation
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Modules.DelegatingProjectPsiModuleHandler">
            <summary>
            Base class for delegating handlers. Primary used in filters
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Modules.IProjectPsiModuleHandler.GetAllModules">
            <summary>
            Get all modules for the project
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Modules.IProjectPsiModuleHandler.GetPsiModulesToReference(JetBrains.Metadata.Reader.API.TargetFrameworkId)">
            <summary>
            Psi modules, that are referenced if a module (project or assembly) is referenced. Normally, the result contains
            primary module only but sometimes there might appear secondary modules either. I.e. global resources in web application.
            </summary>
            <param name="targetFrameworkId"></param>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Modules.IProjectPsiModuleHandler.GetPsiSourceFilesFor(JetBrains.ProjectModel.IProjectFile)">
            <summary>
            Get the PSI module for given project file
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Modules.IProjectPsiModuleHandler.OnProjectPropertiesChanged(JetBrains.ReSharper.Psi.Modules.PsiModuleChangeBuilder)">
            <summary>
            Process changes of properties on underlying project, and return list of modifications
            </summary>
            <param name="changeBuilder"></param>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Modules.IProjectPsiModuleHandler.OnExternalModuleSetChanged(JetBrains.ReSharper.Psi.Modules.PsiModuleChangeBuilder)">
            <summary>
            Called when other modules are added or removed, so the reference resolve ot this could change
            </summary>
            <param name="changeBuilder"></param>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Modules.IProjectPsiModuleHandler.OnProjectFileChanged(JetBrains.ProjectModel.IProjectFile,JetBrains.Util.FileSystemPath,JetBrains.ReSharper.Psi.Modules.PsiModuleChange.ChangeType,JetBrains.ReSharper.Psi.Modules.PsiModuleChangeBuilder)">
            <summary>
            Process changes for specific project file and return list of corresponding source file changes
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Modules.IProjectPsiModuleHandler.ChangeProvider">
            <summary>
            Handler could fire any additional changes
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Modules.IProjectPsiModuleHandler.PrimaryModule">
            <summary>
            Module which reflects project output assembly
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Modules.IProjectPsiModuleProviderFilter">
            <summary>
            Possibly aggregate existing handler.
            This interface should be implemented by a component
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IPsiSourceFileProperties.GetPreImportedNamespaces">
            <summary>
            Get pre-imported namespaces for specific project file
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IPsiSourceFileProperties.GetDefaultNamespace">
            <summary>
            Default namespace for specific project file
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IPsiSourceFileProperties.GetDefines">
            <summary>
            Preprocessor directives for this file (joint with defined in module)
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IPsiSourceFileProperties.ShouldBuildPsi">
            <summary>
            Indicates if this file should be parsed
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IPsiSourceFileProperties.IsGeneratedFile">
            <summary>
            Indicates this file is automatically generated
            Generally, modifying of generated files is useless, and no warnings/suggestions should be shown for it
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IPsiSourceFileProperties.IsICacheParticipant">
            <summary>
            Indicates that file should be processed in PsiCaches subsystem. If the property is to true it does not mean the PSI is built or entries in symbol cache are created.
            Use <see cref="P:JetBrains.ReSharper.Psi.IPsiSourceFileProperties.ShouldBuildPsi"/> and <see cref="P:JetBrains.ReSharper.Psi.IPsiSourceFileProperties.ProvidesCodeModel"/> correspondingly for PSI and caches.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IPsiSourceFileProperties.ProvidesCodeModel">
            <summary>
            Indicates that this file provides parts of code model. Usually, this value equals to <see cref="P:JetBrains.ReSharper.Psi.IPsiSourceFileProperties.ShouldBuildPsi"/>, i.e. all parsible files provides code model.
            The rare exceptions are something like "external sources" feature
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IPsiSourceFileProperties.IsNonUserFile">
            <summary>
            Indicates that file is out of user scope. For example, external source. No analysis and modification could be done on this file
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Modules.IPsiModuleDecorator">
            <summary>
            Decorator for PSI module properties. Returned by <see cref="M:JetBrains.ReSharper.Psi.Modules.IProjectPsiModuleProviderFilter.OverrideHandler(JetBrains.DataFlow.Lifetime,JetBrains.ProjectModel.IProject,JetBrains.ReSharper.Psi.Modules.IProjectPsiModuleHandler)"/>
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resolve.IReferenceNameContainer">
            <summary>
            Container with available element names
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Resolve.IReferenceNameContainer.HasAnyNameIn(System.String)">
            <summary>
            Return true if value contains any name with any case in container in any position
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Resolve.IReferenceNameContainer.HasAnyNameIn(JetBrains.Util.StringSlice)">
            <summary>
            Return true if value contains any name with any case in container in any position
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Resolve.IReferenceNameContainer.AsEnumerable">
            <summary>
            Represents container as enumerable of names
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Resolve.IAccessContext.GetStaticness">
            <summary>
            Determines whether static members are accessible in this context.
            Staticness should be consistent with qualifier kind of access context.
            All qualifier 
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Search.FindResult.MasterResult">
            <summary>
            For original (i.e. first-class) result, this is <c>null</c>.
            For related search, this points to original result.
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Modules.SolutionProjectPsiModuleProviderFactory">
            <summary>
            PSI module provider for special solution projects
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Modules.IProjectPsiModuleProvider">
            <summary>
            Provides PSI module interface for specific project
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.IPsiSourceFileWithLocation">
            <summary>
            PSI source file with some <see cref="T:JetBrains.Util.FileSystemPath">location</see> (physical or virtual).
            The location is used for paths resolution, not for navigation purposes. If navigation to the file is required use <see cref="T:JetBrains.ReSharper.Psi.INavigateablePsiSourceFile"/>
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.IPsiSourceFile">
            <summary>
            Abstraction layer between PSI and project model. Incorporates source file, item of the <see cref="T:JetBrains.ReSharper.Psi.Modules.IPsiModule"/>
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IPsiSourceFile.Properties">
            <summary>
            Get file properties
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IPsiSourceFile.PsiStorage">
            <summary>
            Storage for PSI-specific stuff. 
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IPsiSourceFile.InMemoryModificationStamp">
            <summary>
            Timestamp if unsaved in-memory modified document. <c>null</c> if document is not modified in memory
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IPsiSourceFile.ExternalModificationStamp">
            <summary>
            Timestamp if document is externally modified. <c>null</c> if document is not modified externally
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IPsiSourceFile.LastWriteTimeUtc">
            <summary>
            UTC Timestamp of persistent document
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.INavigateablePsiSourceFile">
            <summary>
            Implement the interface for IPSiSourceFiles that does not belong to solution, but exist on a HDD and must be navigateable.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.INavigateablePsiSourceFile.NavigationPath">
            <summary>
            Path to an existing file on a HDD that contain PsiSourceFile's source code
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Parsing.IArrayOfTokens.FindTokenAt(System.Int32)">
            <summary>
            Finds the token which covers the given position (i.e. offset in [start,end))
            </summary>
            <param name="offset"></param>
            <returns>Token index. Less than 0 if not found</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Parsing.PackedArrayOfTokens.FindTokenAt(System.Int32)">
            <summary>
            Finds the token which covers the given position (i.e. offset in [start,end))
            </summary>
            <param name="offset"></param>
            <returns>Token index. Less than 0 if not found</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Parsing.SparseArrayOfTokens.FindTokenAt(System.Int32)">
            <summary>
            Finds the token which covers the given position (i.e. offset in [start,end))
            </summary>
            <param name="offset"></param>
            <returns>Token index. Less than 0 if not found</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Parsing.TokenNodeType.GetSampleText">
            <summary>
            For use in formatter, to tell if we need to insert space/new line between two token types
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Parsing.TokenNodeType.GetDescription">
            <summary>
            Text to present token type to user, for example in error messages like "{0} expected"
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.IFile.ReParse(JetBrains.ReSharper.Psi.TreeTextRange,System.String)">
            <summary>
            Incrementally reparse file
            </summary>
            <param name="modifiedRange">range in the old file text which is changed</param>
            <param name="text">text which should replace given range</param>
            <returns>the new file (may be the same)</returns>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Tree.IFile.CachingLexer">
            <summary>
            Obtains the caching lexer on file text
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Tree.IFile.ModificationCounter">
            <summary>
            Starting from 0, each time the subtree is modified this counter increases
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Tree.TreeNodeExtensions">
            <summary>
            Herlper methods to work with <see cref="T:JetBrains.ReSharper.Psi.Tree.ITreeNode"/>
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.TreeNodeExtensions.FindFirstTokenIn(JetBrains.ReSharper.Psi.Tree.ITreeNode)">
            <summary>
            Returns first token, that supplied node consists of.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.TreeNodeExtensions.FindLastTokenIn(JetBrains.ReSharper.Psi.Tree.ITreeNode)">
            <summary>
            Returns last token, that supplied node consists of.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.TreeNodeExtensions.ComparePositionTo(JetBrains.ReSharper.Psi.Tree.ITreeNode,JetBrains.ReSharper.Psi.Tree.ITreeNode,System.Boolean)">
            <summary>
            Compare the position of two given nodes in the tree. By default compare nodes' StartOffset
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.TreeNodeExtensions.FindPrevNode(JetBrains.ReSharper.Psi.Tree.ITreeNode,System.Func{JetBrains.ReSharper.Psi.Tree.ITreeNode,JetBrains.ReSharper.Psi.Tree.TreeNodeActionType})">
            <summary>
            Returns first source element satisying the predicate and located before the current element
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.TreeNodeExtensions.FindNextNode(JetBrains.ReSharper.Psi.Tree.ITreeNode,System.Func{JetBrains.ReSharper.Psi.Tree.ITreeNode,JetBrains.ReSharper.Psi.Tree.TreeNodeActionType})">
            <summary>
            Returns first tree node satisfying the predicate and located after the current node
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.TreeNodeExtensions.GetNextMeaningfulChild(JetBrains.ReSharper.Psi.Tree.ITreeNode,JetBrains.ReSharper.Psi.Tree.ITreeNode)">
            <summary>
            Returns next child which is meaningful in the language (not a comment and not a whitespace)
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.TreeNodeExtensions.GetDocumentStartOffset(JetBrains.ReSharper.Psi.Tree.ITreeNode)">
            <summary>
            Get the starting coordinate of this subtree in real document
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.TreeNodeExtensions.GetDocumentStartOffsetThroughSandbox(JetBrains.ReSharper.Psi.Tree.ITreeNode)">
            <summary>
            Get the starting coordinate of this subtree in real document
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.TreeNodeExtensions.GetDocumentRange(JetBrains.ReSharper.Psi.Tree.ITreeNode)">
            <summary>
            Get the coordinates of this subtree in real document
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.TreeNodeExtensions.GetIntersectingDocumentRanges(JetBrains.ReSharper.Psi.Tree.ITreeNode)">
            <summary>
            Get the coordinates of insersecting parts of this subtree in real document
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.TreeNodeExtensions.GetCoveringDocumentRange(JetBrains.ReSharper.Psi.Tree.ITreeNode)">
            <summary>
            Get the union of intersecting document ranges
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.TreeNodeExtensions.Copy``1(``0,JetBrains.ReSharper.Psi.Tree.ITreeNode)">
            <summary>
            Creates the copy of this element and puts it into dummy holder.
            </summary>
            <param name="context">context for resolving, or <c>null</c> for none</param>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.TreeNodeExtensions.CopyWithResolve``1(``0)">
            <summary>
            Creates the copy of this element and puts it into dummy holder.
            All references in the copy are fake-resolved.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.TreeNodeExtensions.FindReferencesAt(JetBrains.ReSharper.Psi.Tree.ITreeNode,JetBrains.ReSharper.Psi.TreeTextRange)">
            <summary>
            Finds all references whose ranges in text contain the specified text range
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.PerformanceThreshold.PerformanceThresholds.#ctor(JetBrains.DataFlow.Lifetime,JetBrains.Application.Settings.ISettingsStore,JetBrains.ProjectModel.ProjectFileTypes,JetBrains.ReSharper.Psi.ILanguages)">
            <summary>
            See: DefaultPerformanceThresholdSettings.xml with predefined settings for this component.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.KnownLanguage.ANY">
            <summary>
            Specifies special language ID for services, which has semantic "for any language"
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.AccessUtil.IsAccessibilityConsistent(JetBrains.ReSharper.Psi.AccessibilityDomain,JetBrains.ReSharper.Psi.AccessibilityDomain)">
            <summary>
            Check that accessibilty if <paramref name="testDomain"/>
            is not lower that accessibility of <paramref name="contextDomain"/>
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.OverloadsUtil.FindOverloadWithParameter(JetBrains.ReSharper.Psi.IFunction,System.Predicate{JetBrains.ReSharper.Psi.IParameter})">
            <summary>
            Find optional parameter in current method, or parameter in overloaded method with same signature
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.OverloadsUtil.FindOverloadWithoutParameter(JetBrains.ReSharper.Psi.IFunction,System.Predicate{JetBrains.ReSharper.Psi.IParameter})">
            <summary>
            Find optional parameter in current method, or overloaded method with same signature without parameter
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.CodeStyle.IIndentingInfoProvider`2.GetPossibleIndentBoundInsideNode(JetBrains.ReSharper.Psi.Tree.ITreeNode)">
            <summary>
            If we indent only part of file, we need to calculate indent regions that start before this part but could be ended inside it.
            To do it, we take a suitable parent node (which starts at new line) and process all nodes (including children) till the start of our part.
            For example, to get the indent of class member, we take indent of the class and normally process all class members
            which precede ours. This could be very slow. To improve performance, this method could be used to provide
            a bound after which processing is not neccessary. For example, to calculate indent regions for class, we only need to process
            nodes until "{", and we could skip all nodes between "{" and the start of our class member.
            Return parent if this parent node should not be processed at all until the relevant child node
            (for example, in case of file).
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Impl.reflection2.elements.Compiled.Parameter.Next">
            <summary>
            Just for optimization. Parameters in methods are stored as single-linked list
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IStruct.HasHiddenInstanceFields">
            <summary>
            Returns <c>true</c> if struct not all fields are returned in <see cref="P:JetBrains.ReSharper.Psi.IStruct.Fields"/> property.
            This could happen since private fields are not loaded through metadata
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.reflection2.elements.Compiled.TypeParameter.FindInheritedTypeParameterOfMethod">
            <summary>
            Tries to find the type parameter of the inherited method.
            According to C# specs 25.6.2
            </summary>
            <returns></returns>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Modules.IPsiModuleFactory.Modules">
            <summary>
            Get current modules which aren't connected to a particular project
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Modules.IMiscFilesProjectPsiModuleProvider.GetModules">
            <summary>
            Get provided modules
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Modules.IMiscFilesProjectPsiModuleProvider.GetPsiSourceFilesFor(JetBrains.ProjectModel.IProjectFile)">
            <summary>
            Get the PSI module for given project file
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Modules.IMiscFilesProjectPsiModuleProvider.OnProjectFileChanged(JetBrains.ProjectModel.IProjectFile,JetBrains.ReSharper.Psi.Modules.PsiModuleChange.ChangeType,JetBrains.ReSharper.Psi.Modules.PsiModuleChangeBuilder,JetBrains.Util.FileSystemPath)">
            <summary>
            Process changes for specific project file and return list of corresponding source file changes
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Modules.IPsiModule.GetReferences(JetBrains.Metadata.Reader.API.IModuleReferenceResolveContext)">
            <summary>
             The method calculates all referenced modules. 
             The call is very expensive, use cached value <see cref="M:JetBrains.ReSharper.Psi.Modules.IPsiModules.GetModuleReferences(JetBrains.ReSharper.Psi.Modules.IPsiModule,System.Collections.Generic.IEnumerable{JetBrains.ReSharper.Psi.Modules.IPsiModule},JetBrains.Metadata.Reader.API.IModuleReferenceResolveContext)"/>
            </summary>
            <param name="moduleReferenceResolveContext"> </param>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Modules.IPsiModule.DisplayName">
            <summary>
            Module name to display in UI
            For regular modules the same as Name
            Primary for web modules useful
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Modules.IPsiModule.TargetFrameworkId">
            <summary>
            TargetFrameworkId corresponding to the source module. 
            <see cref="T:JetBrains.ReSharper.Psi.Modules.IAssemblyPsiModule"/> will always return <see cref="F:JetBrains.Metadata.Reader.API.TargetFrameworkId.Default"/>
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Modules.IPsiModule.PsiLanguage">
            <summary>
            "Primary" language of the PsiModule. For projects the property returns language obtained by <see cref="P:JetBrains.ReSharper.Psi.Modules.IPsiModule.ProjectFileType"/>
            For PsiModules corresponding to ASP files we return code-behind language.
            For Assembly PsiModules - UNKNOWN
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Modules.IPsiModule.ProjectFileType">
            <summary>
            Default language for a project, UNKNOWN for assembly, code-behind language for ASP file PsiModules...
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Modules.IPsiModule.ContainingProjectModule">
            <summary>
            IAssembly or IProject for which this PsiModule is created as either primary or secondary, null for empty project module
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Modules.IPsiModuleReference">
            <summary>
            Reference between PSI modules
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Modules.PsiModuleReferenceExtensions.HasGlobalExternAlias(JetBrains.ReSharper.Psi.Modules.IPsiModuleReference)">
            <summary>
            Checks if alias list got by <see cref="T:JetBrains.ReSharper.Psi.Modules.IPsiModuleReference"/> denotes for global alias
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Modules.PsiModulesExtensions.HasSourceProject(JetBrains.ReSharper.Psi.Modules.IPsiModules,JetBrains.ProjectModel.Model2.Assemblies.Interfaces.IAssembly)">
            <summary>
            takes a ReadLockCookie!
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Modules.IModuleReferencer.CanReferenceModule(JetBrains.ReSharper.Psi.Modules.IPsiModule,JetBrains.ReSharper.Psi.Modules.IPsiModule)">
            <summary>
            Check that module can reference another specified module
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Modules.IModuleReferencer.ReferenceModule(JetBrains.ReSharper.Psi.Modules.IPsiModule,JetBrains.ReSharper.Psi.Modules.IPsiModule)">
            <summary>
            Returns true if module is referenced
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Modules.IModuleReferencer.ReferenceModuleWithType(JetBrains.ReSharper.Psi.Modules.IPsiModule,JetBrains.ReSharper.Psi.ITypeElement)">
            <summary>
            Returns true if module with type is referenced
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Modules.ModuleReferencerAttribute.Priority">
            <summary>
            Referencer with lower priority executes first
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Modules.ReferencesResolveContextUtil.GetContextFromModule(JetBrains.ReSharper.Psi.Modules.IPsiModule,System.Boolean)">
            <summary>
            throws an assertion if the module is not source module
            </summary>
            <param name="module"></param>
            <param name="dontAssert"></param>
            <returns></returns>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Caches.Persistence.ITransientSourceFilesProvider">
            <summary>
            For modules that can't provide add/remove events on main thread in ChangeManager, like CppExternalModule files that are being created during better-not-interruptable parsing
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Caches.IWordIndex">
             <summary>
             Allows retrieving project items corresponding to source files 
             containing identifiers with given names.
             This index can be used to narrow search operations on JetBrains.ReSharper.Psi.CSharp.
             </summary>
             <example>
             Example demostrates narrowing of search domain:
             <code>
            ISearchDomain NarrowSearchDomain (ISearchDomain searchDomain, IDeclaredElement elementToSearch)
            {
              WordIndex wordIndex = WordIndex.GetInstance (elementToSearch.GetManager().Solution );
              IProjectItem [] itemsContainingNames = wordIndex.GetFilesContainingWords (elementToSearch.ShortName);
              ISearchDomain newDomain = SearchDomainFactory.CreateSearchDomain (itemsContainingNames);
              return SearchDomainFactory.CreateIntersectionDomain (searchDomain,newDomain);
            }
             </code>
             <seealso cref="T:JetBrains.ReSharper.Psi.Search.IFinder"/>
             </example>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Caches.IWordIndex.GetFilesContainingWord(System.String)">
             <summary>
             Returns array of project items corresponding to all source code files 
             containing identifiers which text is equal to given word
             </summary>
            <param name="word"></param>
            <remarks>Returns empty array if empty array is passed or no such files found.
             Does not expect null to be passed (throws exception)</remarks>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Caches.IWordIndex.GetFilesContainingWords(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Returns array of project items corresponding to all source code files 
            containing identifiers which text is equal to any of given words
            </summary>
            <remarks>Returns empty array if empty array is passed or no such files found.
            Does not expect null to be passed (throws exception)</remarks>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Caches.IWordIndex.CanContainWord(JetBrains.ReSharper.Psi.IPsiSourceFile,System.String)">
            <summary>
            Check if file contains given word
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Caches.IWordIndex.GetWords(System.String)">
            <summary>
            Tokenize
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Impl.BoundToSettingsProjectPropertiesRegister`2.myIsLanguageLevelOverriden">
            <summary>
            this is intentially globally
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Impl.BoundToSettingsProjectPropertiesRegister`2.myOverridenLanguageLevel">
            <summary>
            this is intentially globally
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Impl.Reflection2.ReflectionTypeNameCache">
            <summary>
            Interned and cached <see cref="T:JetBrains.Metadata.Reader.API.IClrTypeName"/> for <see cref="T:JetBrains.Metadata.Reader.API.IMetadataTypeInfo"/>
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Impl.Reflection2.WinMD.WinMDProjectedTypes">
            <summary>
            Imported from "C:\Program Files (x86)\Microsoft SDKs\Windows\v8.0A\bin\NETFX 4.0 Tools\WinMDExp.exe" class Microsoft.Tools.WinMDExp.ProjectedTypeInfo
            Updated with new entries from "C:\Program Files (x86)\Microsoft SDKs\Windows\v10.0A\bin\NETFX 4.6 Tools\WinMDExp.exe"
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.CompositeElement.FindChildByRole(System.Int16)">
            <summary>
            Search for the child with given role
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.CompositeElement.GetPrevFilteredChild(JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.TreeElement)">
            <summary>
            To be overriden for each language.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Transactions.IPsiTransactions.Execute(System.String,System.Action)">
            <summary>
            Do PSI write bulk operation.
            Upon success, ensure all modified documents are writable
            </summary>
            <returns>Status of attempt to modify involved documents</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Transactions.IPsiTransactions.AddTransactionAction(JetBrains.ReSharper.Psi.Transactions.IPsiTransactionAction)">
            <summary>
            Add transaction action with no change in PSI.
            </summary>
            <param name="action"></param>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Transactions.IPsiTransactions.CreateCustomCookie``1(``0)">
            <summary>
            After creation of the customly modification cookie and until its disposal 
            processing of changes from original to generated files (for example, from ASP to code behind C# filed and back) and vice versa are changed:
            1. Changes to original file are not promoted to generated files, only range translation is corrected as needed.
            2. Even if a changed range in generated file only partially intersects with translated range (but is not fully inside translated range) 
               and change is not whitespace transaction is still processed and range translation is corrected for unintersected ranges
               (without custom cookie such transaction would fail).
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.DefaultRegionsInfoProvider">
            <summary>
            default implementation when not daemon is available in the context.
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Parsing.LexerTokenIntern">
            <summary>
            Interns strings and text ranges without substrings creation.
            Stores only string in internal storage.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Parsing.MissingTokenInserterBase.Run(JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.TreeElement)">
            <remarks>
            This code relies that TokenStart and TokenEnd return -1 when it reaches end of file.
            </remarks>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Parsing.IIncrementalLexer.LexemIndent">
            <summary>
            Number of lexems that incremental re-lexing should step back to start relexing
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.MemberPresenceFlag.PUBLIC_DEFAULT_CTOR">
            <summary>
            Public instance parameterless constructor (without params/optional parameters)
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExpectedTypes.IsEnumerableConstraint">
            <summary>
            Accepts only types which can be enumerated
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExpectedTypes.IExpectedTypeConstraint">
            <summary>
            Represents an expectation constraint
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExpectedTypes.IExpectedTypeConstraint.Accepts(JetBrains.ReSharper.Psi.IType)">
            <summary>Checks if a type matches the constraint</summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExpectedTypes.IExpectedTypeConstraint.GetDefaultType">
            <summary>Gets some default appropriate type</summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExpectedTypes.IExpectedTypeConstraint.GetDefaultTypes">
            <summary>Gets some default appropriate types</summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExpectedTypes.IExpectedTypeConstraint.GetTypesEffectively">
            <summary>Gets array of expected types if can be performed effeciently</summary>
            <returns>null - if ineffective, array of types - if fast</returns>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ITypePointer">
            <summary>
            Interface for obtaining a type from some place
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ITypePointer.FindType">
            <summary>
            Resurrects the type being pointed to
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.ITypePointer.PsiModule">
            <summary>
            Solution in which the pointer was created
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resolve.ISubstitution">
            <summary>
            Implements a valuation of type parameters
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExtensionsAPI.ReferenceContextCodecFactory">
            <summary>
            Base class for custom context codec factory.
            Every custom factory should be used only in 'using' statement shell
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExtensionsAPI.IDomainSpecificSearcherFactory">
            <summary>
            Language service or some technology service should implement the searcher factory to allow the finder look into files with specific language or related
            to specific technology
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.IDomainSpecificSearcherFactory.GetAllPossibleWordsInFile(JetBrains.ReSharper.Psi.IDeclaredElement)">
            <summary>
            Enumerate words which should occur in the file to contain reference to <paramref name="element"/>. 
            Return <c>null</c> or <see cref="F:System.String.Empty"/> in enumeration to switch word filtering off
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.IDomainSpecificSearcherFactory.GetRelatedDeclaredElements(JetBrains.ReSharper.Psi.IDeclaredElement)">
            <summary>
            Get the declared elements which should be searched for along with the given element
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.IDomainSpecificSearcherFactory.GetDerivedFindRequest(JetBrains.ReSharper.Psi.Search.IFindResultReference)">
            <summary>
            Get the derived find request. When "Find Usages' found reference, this can return few more declared elements which should be found.
            </summary>
            <returns>Collection of declared elements which should be searched, predicate if their result should be consumed, and boolean value indicating if original find result is relevant, i.e. should be consumed</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.IDomainSpecificSearcherFactory.GetNavigateToTargets(JetBrains.ReSharper.Psi.IDeclaredElement)">
            <summary>
            Provider could override "Goto declaration" behaviour, by providing preferred elements
            The <c>bool</c> value indicates whether the original navigation target is relevant, out should be omitted
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.IDomainSpecificSearcherFactory.TransformNavigationTargets(System.Collections.Generic.ICollection{JetBrains.ReSharper.Psi.Search.FindResult})">
            <summary>
            Provider could transform navigation targets through this method.
            If not transformed, return the original collection or <c>null</c>. If transformed, return new one
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.IDomainSpecificSearcherFactory.GetDeclaredElementSearchDomain(JetBrains.ReSharper.Psi.IDeclaredElement)">
            <summary>
            Provides search domain for specified declared element.
            Search domains from different factories are merged.
            </summary>
            <returns>Search domain for specified declared element or empty domain if not applicable</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.IReferenceContextDecoder.Decode">
            <summary>
            Decode the references when the clone is inserted into the real tree, and returns the clone position in the tree
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.ISecondaryDocumentGenerationResult.CommitChanges">
            <summary>
            Since generation of documents must be pure (due to interruptibility of commit operation) all destructive actions should be done here.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.ReferenceIdentitySaver.ClosureRemap(JetBrains.ReSharper.Psi.Resolve.IReference)">
            <summary>
            Do chain remap
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.ExtensionsAPI.ReferenceIdentitySaver.PreviousIdentitySaver">
            <summary>
            User can set previous identity saver, so all events will be propagated to it
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Filters.UseLocalVariableBeforeDeclarationFilterBase">
            <summary>
            Filter local variable declarations by their position in the tree. Base class
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.ICachingScope">
            <summary>
            Scope which can store symbol table collected BEFORE this scope
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.IIncrementalScope">
            <summary>
            Indicates scope which provides additional symbols after/before specific children
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.IExpression.Type">
            <summary>
            Type of expression. This function never returns null, if type cannot be determined it returns UnknownType.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Managed.ManagedReferenceBase`1.GetAllNames">
            <summary>
            Override this method if your reference has multiple names
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Managed.ManagedReferenceBase`1.HasMultipleNames">
            <summary>
            Override this method if your reference has multiple names
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CodeStyle.ICodeFormatter.FormatFile(JetBrains.ReSharper.Psi.Tree.IFile,JetBrains.ReSharper.Psi.CodeStyle.CodeFormatProfile,JetBrains.Application.Progress.IProgressIndicator,JetBrains.Application.Settings.IContextBoundSettingsStore,JetBrains.ReSharper.Psi.CodeStyle.IPotentSettingsTracker)">
            <summary>
            Format the whole file
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CodeStyle.ICodeFormatter.Format(JetBrains.ReSharper.Psi.Tree.ITreeNode,JetBrains.ReSharper.Psi.CodeStyle.CodeFormatProfile,JetBrains.Application.Progress.IProgressIndicator,JetBrains.Application.Settings.IContextBoundSettingsStore,JetBrains.ReSharper.Psi.CodeStyle.IPotentSettingsTracker)">
            <summary>
            Format the given subtree
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CodeStyle.ICodeFormatter.Format(JetBrains.ReSharper.Psi.Tree.ITreeNode,JetBrains.ReSharper.Psi.Tree.ITreeNode,JetBrains.ReSharper.Psi.CodeStyle.CodeFormatProfile,JetBrains.Application.Progress.IProgressIndicator,JetBrains.Application.Settings.IContextBoundSettingsStore,JetBrains.ReSharper.Psi.CodeStyle.IPotentSettingsTracker)">
            <summary>
            Format the given range in the tree. The bounding nodes are random, not siblings
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CodeStyle.ICodeFormatter.Format(JetBrains.ProjectModel.ISolution,JetBrains.DocumentModel.DocumentRange,JetBrains.ReSharper.Psi.CodeStyle.CodeFormatProfile,System.Boolean,System.Boolean,JetBrains.Application.Progress.IProgressIndicator,JetBrains.Application.Settings.IContextBoundSettingsStore,JetBrains.ReSharper.Psi.CodeStyle.IPotentSettingsTracker)">
            <summary>
            Format the given range in document
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CodeStyle.ICodeFormatter.Format(JetBrains.ReSharper.Psi.Tree.IFile,JetBrains.ReSharper.Psi.TreeTextRange,JetBrains.ReSharper.Psi.CodeStyle.CodeFormatProfile,JetBrains.ReSharper.Psi.CodeStyle.OuterSpaceFormatType,JetBrains.ReSharper.Psi.CodeStyle.OuterSpaceFormatType,JetBrains.Application.Progress.IProgressIndicator,JetBrains.Application.Settings.IContextBoundSettingsStore,JetBrains.ReSharper.Psi.CodeStyle.IPotentSettingsTracker)">
            <summary>
            Format the given range in PSI file
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CodeStyle.ICodeFormatter.FormatInsertedNodes(JetBrains.ReSharper.Psi.Tree.ITreeNode,JetBrains.ReSharper.Psi.Tree.ITreeNode,System.Boolean)">
            <summary>
            Format code during WritePSI action
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CodeStyle.ICodeFormatter.FormatInsertedRange(JetBrains.ReSharper.Psi.Tree.ITreeNode,JetBrains.ReSharper.Psi.Tree.ITreeNode,JetBrains.ReSharper.Psi.ITreeRange)">
            <summary>
            Format code during WritePSI action
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CodeStyle.ICodeFormatter.FormatReplacedNode(JetBrains.ReSharper.Psi.Tree.ITreeNode,JetBrains.ReSharper.Psi.Tree.ITreeNode)">
            <summary>
            Format code during WritePSI action
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CodeStyle.ICodeFormatter.FormatDeletedNodes(JetBrains.ReSharper.Psi.Tree.ITreeNode,JetBrains.ReSharper.Psi.Tree.ITreeNode,JetBrains.ReSharper.Psi.Tree.ITreeNode)">
            <summary>
            Format code during WritePSI action
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.CodeStyle.ICodeFormatterImpl.GetMinimalSeparator(JetBrains.ReSharper.Psi.Tree.ITokenNode,JetBrains.ReSharper.Psi.Tree.ITokenNode)">
            <summary>
            Create the necessary separator between two given tokens (for example. space between identifiers)
            If there is no necessity for separator, then return <c>null</c>
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.CodeStyle.IIndentCache.GetLineIndent(JetBrains.ReSharper.Psi.Tree.ITreeNode)">
            <summary>
            Get the indentation of the line which contains given node
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.CodeStyle.IIndentCache.GetNodeIndent(JetBrains.ReSharper.Psi.Tree.ITreeNode)">
            <summary>
            Get the exact indentation of the given node
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.CodeStyle.IndentCache`1.GetLineIndent(JetBrains.ReSharper.Psi.Tree.ITreeNode)">
            <summary>
            Get the indentation of the line which contains given node
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.CodeStyle.IndentCache`1.GetNodeIndent(JetBrains.ReSharper.Psi.Tree.ITreeNode)">
            <summary>
            Get the exact indentation of the given node
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExtensionsAPI.IReferenceContextCodec">
            <summary>
            Part of the PSI write interface. 
            Provides the functionality to re-bind references when the subtree is inserted into physical tree
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.IReferenceContextCodec.Encode(JetBrains.ReSharper.Psi.Tree.ITreeNode,JetBrains.ReSharper.Psi.Tree.ITreeNode)">
            <summary>
            Encode the references from the <paramref name="original"/> tree into the <paramref name="clone"/> tree
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.IReferenceContextCodec.CopyWithResolve(JetBrains.ReSharper.Psi.Tree.ITreeNode,JetBrains.ReSharper.Psi.Tree.ITreeNode)">
            <summary>
            Create copy with preserving identity of ResolveResult
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.IReferenceContextCodec.ExtractBindableReferences(JetBrains.ReSharper.Psi.Tree.ITreeNode)">
            <summary>
            Try to extract reference from given element which could be bind
            </summary>
            <param name="element">Element to extract reference from</param>
            <returns>Array of references to the element itself (i.e. C in A.B.C), or empty array if no bindable reference found</returns>
        </member>
        <member name="E:JetBrains.ReSharper.Psi.ExtensionsAPI.IReferenceContextCodec.OnSubtreeInserted">
            <summary>
            Occurs when clone subtree is inserted into target, but reference identity is not yet started
            </summary>
        </member>
        <member name="E:JetBrains.ReSharper.Psi.ExtensionsAPI.IReferenceContextCodec.OnSetReferenceIdentity">
            <summary>
            Occurs during encoding when reference identity is set
            </summary>
        </member>
        <member name="E:JetBrains.ReSharper.Psi.ExtensionsAPI.IReferenceContextCodec.OnReferenceBinded">
            <summary>
            Occurs during decoding after reference was binded
            </summary>
        </member>
        <member name="E:JetBrains.ReSharper.Psi.ExtensionsAPI.IReferenceContextCodec.OnSetDeclarationIdentity">
            <summary>
            Called once after encoding and gices the match table between local declarations
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.IExplicitImplementation">
            <summary>
            Reference to <see cref="T:JetBrains.ReSharper.Psi.IOverridableMember"/> explicit interface implementation
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IExplicitImplementation.Resolve">
            <summary>Resolve</summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IExplicitImplementation.DeclaringType">
            <summary>Interface which contains implemented member</summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IExplicitImplementation.MemberName">
            <summary>Name of implemented member</summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.ControlFlow.Impl.ControlFlowVariableAccessState.ACCESSED_AS_ENUMERABLE">
            <summary>
            For language-specific analysis "possible twice enumeration"
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Modules.ProjectPsiModuleBase.#ctor(JetBrains.ProjectModel.IProject,System.String,JetBrains.ReSharper.Psi.PsiProjectFileTypeCoordinator,JetBrains.Metadata.Reader.API.TargetFrameworkId)">
            <summary>
            
            </summary>
            <param name="project"></param>
            <param name="nameSuffix"> Must Be const!!! Can't change after rename</param>
            <param name="coordinator"></param>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.IPsiProjectFile">
            <summary>
            PSI source file which corresponds to some <see cref="T:JetBrains.ProjectModel.IProjectFile"/>
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Shared.IGeneratedRangeMap.Add(JetBrains.ReSharper.Psi.TreeTextRange{JetBrains.ReSharper.Psi.Generated},JetBrains.ReSharper.Psi.TreeTextRange{JetBrains.ReSharper.Psi.Original})">
            <summary>
             Adds new generated pair
            </summary>
            <param name="generatedRange">TextRange in generated code</param>
            <param name="originalRange">Source range, if originalRange == ElementTange{T}.Invalid, the range is secondary</param>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Shared.IGeneratedRangeMap.Add(JetBrains.ReSharper.Psi.TreeTextRange{JetBrains.ReSharper.Psi.Generated},JetBrains.ReSharper.Psi.TreeTextRange{JetBrains.ReSharper.Psi.Original},JetBrains.ReSharper.Psi.Impl.Shared.MappedRangeType,System.Boolean,System.Boolean)">
            <summary>
             Adds new generated pair
            </summary>
            <param name="generatedRange">TextRange in generated code</param>
            <param name="originalRange">Source range, if originalRange == ElementTange{T}.Invalid, the range is secondary</param>
            <param name="rangeType">Range type, should be some static-like instance</param>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Shared.IGeneratedRangeMap.AddOrMerge(JetBrains.ReSharper.Psi.TreeTextRange{JetBrains.ReSharper.Psi.Generated},JetBrains.ReSharper.Psi.TreeTextRange{JetBrains.ReSharper.Psi.Original},JetBrains.ReSharper.Psi.Impl.Shared.MappedRangeType,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
             Adds new generated pair if it doesn't intersects with other ranges, or merge it with existing ranges. Range properties must be static!
            </summary>
            <param name="generatedRange">TextRange in generated code</param>
            <param name="originalRange">Source range, if originalRange == ElementTange{T}.Invalid, the range is secondary</param>
            <param name="rangeType">Range type, should be some static-like instance</param>
            <param name="greedyOnLeft"></param>
            <param name="greedyOnRight"></param>
            <param name="mapIsOrdered">You sure that map is ordered</param>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Shared.IGeneratedRangeMap.AppendWithShiftToGenerated(JetBrains.ReSharper.Psi.Impl.Shared.IGeneratedRangeMap,System.Int32,System.Boolean)">
            <summary>
            Used while code generation only
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Shared.IGeneratedRangeMap.AppendWithShiftToOriginal(JetBrains.ReSharper.Psi.Impl.Shared.IGeneratedRangeMap,JetBrains.ReSharper.Psi.TreeOffset)">
            <summary>
            Used during code decompilation (generated => original)
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Shared.IGeneratedRangeMap.GetCoveringRangeExceptZeroLengthAtBounds(JetBrains.ReSharper.Psi.TreeTextRange{JetBrains.ReSharper.Psi.Original})">
            <summary>
            If modifiedGeneratedRange.Length == 0 &amp;&amp; it is on the bound of covering range, then return null. Otherwise, return GetCoveringRange.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Shared.IGeneratedRangeMap.CloseAddedRange(JetBrains.ReSharper.Psi.TreeTextRange{JetBrains.ReSharper.Psi.Original},JetBrains.ReSharper.Psi.Impl.Shared.MappedRangeType)">
            <summary>
            Makes already added original range not greedy from right. Use only if you're sure map is ordered.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Shared.GeneratedRangeMapTree.Add(JetBrains.ReSharper.Psi.TreeTextRange{JetBrains.ReSharper.Psi.Generated},JetBrains.ReSharper.Psi.TreeTextRange{JetBrains.ReSharper.Psi.Original})">
            <summary>
             Adds new generated pair
            </summary>
            <param name="generatedRange">TextRange in generated code</param>
            <param name="originalRange">Source range, if originalRange == ElementRange{T}.Invalid, the range is secondary</param>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Shared.GeneratedRangeMapTree.Add(JetBrains.ReSharper.Psi.TreeTextRange{JetBrains.ReSharper.Psi.Generated},JetBrains.ReSharper.Psi.TreeTextRange{JetBrains.ReSharper.Psi.Original},JetBrains.ReSharper.Psi.Impl.Shared.MappedRangeType,System.Boolean,System.Boolean)">
            <summary>
             Adds new generated pair
            </summary>
            <param name="generatedRange">TextRange in generated code</param>
            <param name="originalRange">Source range, if originalRange == ElementRange{T}.Invalid, the range is secondary</param>
            <param name="rangeType">Range type, should be some static-like instance</param>
            <param name="greedyOnLeft"></param>
            <param name="greedyOnRight"></param>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Shared.GeneratedRangeMapTree.CloseAddedRange(JetBrains.ReSharper.Psi.TreeTextRange{JetBrains.ReSharper.Psi.Original},JetBrains.ReSharper.Psi.Impl.Shared.MappedRangeType)">
            <summary>
            Makes already added original range not greedy from right. Use only if you're sure map is ordered.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Shared.GeneratedRangeMapTree.AddOrMerge(JetBrains.ReSharper.Psi.TreeTextRange{JetBrains.ReSharper.Psi.Generated},JetBrains.ReSharper.Psi.TreeTextRange{JetBrains.ReSharper.Psi.Original},JetBrains.ReSharper.Psi.Impl.Shared.MappedRangeType,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
             Adds new generated pair if it doesn't intersects with other ranges, or merge it with existing ranges. Range properties must be static!
            </summary>
            <param name="generatedRange">TextRange in generated code</param>
            <param name="originalRange">Source range, if originalRange == ElementRange{T}.Invalid, the range is secondary</param>
            <param name="rangeType">Range type, should be some static-like instance</param>
            <param name="greedyOnLeft"></param>
            <param name="greedyOnRight"></param>
            <param name="mapIsOrdered">You sure that map is ordered</param>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Shared.GeneratedRangeMapTree.AppendWithShiftToGenerated(JetBrains.ReSharper.Psi.Impl.Shared.IGeneratedRangeMap,System.Int32,System.Boolean)">
            <summary>
            Used while code generation only
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Shared.GeneratedRangeMapTree.AppendWithShiftToOriginal(JetBrains.ReSharper.Psi.Impl.Shared.IGeneratedRangeMap,JetBrains.ReSharper.Psi.TreeOffset)">
            <summary>
            Used during code decompilation (generated => original)
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Shared.GeneratedRangeMapTree.GetCoveringRangeExceptZeroLengthAtBounds(JetBrains.ReSharper.Psi.TreeTextRange{JetBrains.ReSharper.Psi.Original})">
            <summary>
            If modifiedGeneratedRange.Length == 0 &amp;&amp; it is on the bound of covering range, then return null. Otherwise, return GetCoveringRange.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Naming.Interfaces.INamingPolicyProvider.GetRuleName(JetBrains.ReSharper.Psi.IDeclaredElement)">
            <summary>Applies to all languages</summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Naming.Interfaces.INamingPolicyProvider.GetPolicy(JetBrains.ReSharper.Psi.IDeclaredElement)">
            <summary>Applies to all languages</summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Naming.Interfaces.INamingPolicyProvider.GetPolicy(JetBrains.ReSharper.Psi.Naming.Settings.NamedElementKinds,JetBrains.ReSharper.Psi.Naming.Elements.IElementKind,JetBrains.ReSharper.Psi.Naming.Settings.AccessRightKinds,JetBrains.ReSharper.Psi.Naming.Settings.StaticnessKinds)">
            <summary>Clr languages specific</summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Naming.Interfaces.INamingPolicyProvider.GetPolicy(JetBrains.ReSharper.Psi.Naming.Elements.IElementKind)">
            <summary>For custom rule based providers</summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.IPsiSourceFileStorage">
            <summary>
            Per-<see cref="T:JetBrains.ReSharper.Psi.IPsiSourceFile"/> storage for PSI specific data.
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.PsiSourceFileStorage">
            <summary>
            Default implementation of <see cref="T:JetBrains.ReSharper.Psi.IPsiSourceFileStorage"/>
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Resolve.Managed.ICascadingCache.Recall(System.Object,JetBrains.ReSharper.Psi.Impl.Resolve.Managed.ICalculationProcess@)">
            <summary>
            Returns cached value for key, or FORGET if recalculation is required
            </summary>
            <returns></returns>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Impl.Resolve.Managed.CascadingCache.myData">
            <summary>
            Data in this level of cache
            </summary>
            - No value for key means "look upstream if there is upstream, otherwise recalculate" 
            - Other value is calculated value
        </member>
        <member name="T:JetBrains.ReSharper.Psi.IDeclaredType">
            <summary>
            Interface for types which might have declaration (that is, correspond to some <see cref="T:JetBrains.ReSharper.Psi.ITypeElement"/>).
            For example, "IDeclaredType" and "int" are declared types.
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.IType">
            <summary>
            Represents a type. 
            Instances of <c>IType</c> can be compared by <see cref="M:System.Object.Equals(System.Object)"/> and are equal 
            if they represent the same type.
            </summary>
            <seealso cref="T:JetBrains.ReSharper.Psi.IDeclaredType"/>
            <seealso cref="T:JetBrains.ReSharper.Psi.IArrayType"/>
            <seealso cref="T:JetBrains.ReSharper.Psi.IDeclaredType"/>
            <seealso cref="T:JetBrains.ReSharper.Psi.IPointerType"/>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IExpressionType.IsImplicitlyConvertibleTo(JetBrains.ReSharper.Psi.IType,JetBrains.ReSharper.Psi.ITypeConversionRule)">
            <summary>
            Checks if this type can be implicitly converted to given type by the rules of the <param name="conversionRule"/>.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IExpressionType.IsExplicitlyConvertibleTo(JetBrains.ReSharper.Psi.IType,JetBrains.ReSharper.Psi.ITypeConversionRule)">
            <summary>
            Checks if this type can be explicitly converted to given type by the rules of the <param name="conversionRule"/>.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IExpressionType.ToIType">
            <summary>
            Convert type to corresponding IType if possible
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IExpressionType.GetLongPresentableName(JetBrains.ReSharper.Psi.PsiLanguageType)">
            <summary>
            Returns some presentation string for this type in which all names are shown in fully qualified form. 
            For example, for "System.Drawing.Point[]" it will be "System.Drawing.Point[]"
            and for "System.Int32" it will be "int".
            </summary>
            <remarks>
            Note: long presentable name should not be used for any purposes except presentation.
            For example, it should not be parsed to restore any information about original type.
            </remarks>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IExpressionType.GetPsiServices">
            <summary>
            Get the PSI services
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IExpressionType.IsValid">
            <summary>
            Check if this type is valid, i.e. referes to valid declared elements
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IExpressionType.IsResolved">
            <summary>
            Check if the type is resolved successfully (and it's substitution is resolved correctly)
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IExpressionType.IsUnknown">
            <summary>
            Check if this type is unknown, i.e. it can't have correct presentation
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IExpressionType.Module">
            <summary>
            Get the module where this type was built
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IType.GetPresentableName(JetBrains.ReSharper.Psi.PsiLanguageType)">
            <summary>
            Returns some presentation string for this type. 
            For example, for "System.Drawing.Point[]" it will be "Point[]"
            and for "System.Int32" it will be "int".
            </summary>
            <remarks>
            Note: presentable name should not be used for any purposes except presentation.
            For example, it should not be parsed to restore any information about original type.
            </remarks>
            <seealso cref="M:JetBrains.ReSharper.Psi.IExpressionType.GetLongPresentableName(JetBrains.ReSharper.Psi.PsiLanguageType)"/>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IType.GetScalarType">
            <summary>
            Returns type of the scalar value of this type.
            For examples for "int", "int[]", "int[][]" and "int*" it returns "int".
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IType.GetSymbolTable(JetBrains.ReSharper.Psi.Modules.IPsiModule)">
            <summary>
            Get the symbol table for this type to be used in given <paramref name="module"/>
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IType.IsWellFormed">
            <summary>
            Checks whether values of all type parameters satisfies their constrains
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IType.CreatePointer">
            <summary>
            Create the pointer to the type
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IType.IsOpenType">
            <summary>
            According to C# specs 25.5.2
            <list type="bullet">
            <item>type parameter defines an open type</item>
            <item>An array type is an open type if and only if its element type is an open type</item>
            <item>A constructed type is an open type if and only if one or more of its type arguments is an open type. A
              constructed nested type is an open type if and only if one or more of its type arguments or the type
              arguments of its containing type(s) is an open type</item>
            </list>
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IType.Classify">
            <summary>
            Get the type kind, represented by <see cref="T:JetBrains.ReSharper.Psi.TypeClassification"/> enumeration members.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IType.TypeModifiers">
            <summary>
            Get the 'modopt' and 'modreq'. Types which has differend type modifers sets are still equals.
            For now, they are compared in signatures <see cref="T:JetBrains.ReSharper.Psi.InvocableSignature"/>
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IDeclaredType.GetTypeElement">
            <summary>
            Returns ITypeElement corresponding to this type. 
            Can return null when it cannot "resolve" this type.
            For example, this can happen when you get type of a variable and
            the corresponding type usage in the source code cannot be resolved
            (that is, the code is not compilable).
            </summary>
            <returns>ITypeElement corresponding to this type or null if the type cannot be resolved.</returns>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IDeclaredType.Assembly">
            <summary>
            Assembly name of the assembly where this type is defined, or null if unspecified
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ICustomPsiSourceFileProperties">
            <summary>
            Marker interface for all additional PSI source file properties
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.PsiSourceFileExtensions.GetCustomProperties``1(JetBrains.ReSharper.Psi.IPsiSourceFile)">
            <summary>
            Get the properties specific for language or technology
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CodeStyle.CodeFormatterHelper">
            <summary>
            Helper methods to work with <see cref="T:JetBrains.ReSharper.Psi.CodeStyle.ICodeFormatter"/>
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CodeStyle.CodeFormatterHelper.FormatFile(JetBrains.ReSharper.Psi.CodeStyle.ICodeFormatter,JetBrains.ReSharper.Psi.Tree.IFile,JetBrains.ReSharper.Psi.CodeStyle.CodeFormatProfile)">
            <summary>
            Format the whole file
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExpectedTypes.ExpectedType">
            <summary>
            Represents an expectation based on expression context
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resolve.ISymbolTable">
            <summary>
            Symbol table deals with case-insensitive names
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Filters.ForwardedTypeFilter">
            <summary>
            Check that forwarded type assembly is referenced
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Filters.ForwardedTypeCompletionFilter">
            <summary>
            Check that forwarded type assembly is referenced
            If both forwarded to and forwarded from types are in list, then only "forwarded from" should survive
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.ResolveResultWithInfoExtensions.GetDynamicDeclaredElements(JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.ResolveResultWithInfo)">
            <summary>
            if result is dynamic returns candidates, otehrwise declared element.
            </summary>
            <param name="resultWithInfo"></param>
            <returns></returns>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.GeneratedCode.GeneratedUtils">
            <summary>
            Checks if file or code region was generated by custom tool (uses R# user settings)
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.GeneratedCode.DaemonExcludedFilesManager.Changed">
            <summary>
            On MainThread, with readlock
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking">
            <summary>
            This class describes positions of different components of the string presenting <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/>.
            This class is used as <code>out</code> parameter in calls to <see cref="M:JetBrains.ReSharper.Psi.IDeclaredElementPresenter.Format(JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle,JetBrains.ReSharper.Psi.IDeclaredElement,JetBrains.ReSharper.Psi.Resolve.ISubstitution,JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking@)"/> methods.
            See <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElementPresenter"/> methods for examples of use.
            <seealso cref="T:JetBrains.ReSharper.Psi.IDeclaredElementPresenter"/>
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking.EntityKindRange">
            <summary>
            The declared element entity kind range in a string presenting <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/>.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking.AccessRightsRange">
            <summary>
            The declared element access rights range in a string presenting <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/>.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking.ModifiersRange">
            <summary>
            The declared element modifier words range in a string presenting <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/>.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking.TypeRange">
            <summary>
            The declared element type (for variables) or return type (for functions) range in a string presenting <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/>.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking.ScalarTypeRange">
            <summary>
            The declared element scalar type range in a string presenting <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/>.
            E.g. in the string "int [] x" the scalar type range of "x" is the range of "int".
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking.ExplicitInterfaceRange">
            <summary>
            Range of the explicit interface qualification of the member.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking.NameRange">
            <summary>
            The declared element name range in a string presenting <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/>.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking.ParameterListRange">
            <summary>
            The declared element parameter list range in a string presenting <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/>.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking.TypeParameterListRange">
            <summary>
            The declared element type parameter list range in a string presenting <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/>.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking.TypeParameterRanges">
            <summary>
            An array of the declared element type parameter ranges in a string presenting <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/>.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking.ParameterRanges">
            <summary>
            An array of the declared element parameter ranges in a string presenting <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/>.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking.ContainerRange">
            <summary>
            The declared element container (type or namespace) range in a string presenting <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/>.
            //TODO: what it returns for parameter?
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking.ContainerNameRange">
            <summary>
            The range of the name of the container.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking.ConstantValueRange">
            <summary>
            The range of the value of a constant or a local constant in a string presenting <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/>.
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking.Parameter">
            <summary>
            This class describes position of parameter-related components of the string presenting <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/>.
            An instance of this class is stored in the marking per each parameter of the formatted <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/>.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking.Parameter.Range">
            <summary>
            The parameter range in a string presenting <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/>.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking.Parameter.KindRange">
            <summary>
            The parameter kind range in a string presenting <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/>.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking.Parameter.TypeRange">
            <summary>
            The parameter type range in a string presenting <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/>.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking.Parameter.ScalarTypeRange">
            <summary>
            The range of scalar type of the parameter type in a string presenting <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/>.
            E.g. in the string "void Foo(int [] x)" the scalar type range of parameter "x" is the range of "int".
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking.Parameter.NameRange">
            <summary>
            The parameter name range in a string presenting <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/>.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking.Parameter.DefaultValueRange">
            <summary>
            The parameter default value range in a string presenting <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/>.
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.EntityKindForm">
            <summary>
            Indicates how declared element entity kind is presented:
            <list type="table">
            <listheader><term>Enum member name</term><description>Description or example</description></listheader>
            <item><term>NONE</term><description>Do not show entity kind (default value)</description></item>
            <item><term>NORMAL</term><description>namespace</description></item>
            <item><term>NORMAL_IN_BRACKETS</term><description>(in namespace)</description></item>
            <item><term>IN</term><description>in namespace</description></item>
            <item><term>FROM</term><description>from namespace</description></item>
            </list>
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.CompositeElementExtensions">
            <summary>
            Extensions for <see cref="T:JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.CompositeElement"/>
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.CompositeElementExtensions.GetChildByRole(JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.ICompositeElement,System.Int16)">
            <summary>
            NotNull version of <see cref="M:JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.CompositeElement.FindChildByRole(System.Int16)"/>
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.IDynamicType">
            <summary>
            Dynamic type in CLR 4
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.GeneratedDocumentsManagerExtensions.GetServices(JetBrains.ReSharper.Psi.IGeneratedDocumentsManager,JetBrains.ReSharper.Psi.IPsiSourceFile)">
            <summary>
            Enumerables services for source file
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Caches.SymbolCache.ForwardedTypesTable.myForwardedTypesByClrName">
            <summary>
            CLRTypeName => {ForwardedTo, ForwardedFrom}
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Caches.SymbolCache.ForwardedTypesTable.myForwardedFromNamespaces">
            <summary>
            For every assembly, stores set of types' namespaces forwarded to it
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Caches.SymbolCache.ForwardedTypesTable.myForwardedFromAssemblies">
            <summary>
            For every assembly, store assembly names from which types are forwarded
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Caches.SymbolCache.ForwardedTypesTable.myForwardedTypes">
            <summary>
            For every assembly, store type names which are forwarded
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Caches.SymbolCache.ForwardedTypesTable.myClrTypeNameFactory">
            <summary>
            Caching factories for ClrTypeName and AssemblyNameInfos
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Caches.SymbolCache.StaticInheritorsIndex">
            <summary>
              Inheritors index implementation which is build once
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Caches.SymbolCache.DynamicInheritorsIndex">
            <summary>
              Inheritors index implementation which could be incrementally updated.
              Multithreaded access is guarded by read-write lock
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Impl.CodeStyle.CodeFormatterBase">
            <summary>
            Base implementation of <see cref="T:JetBrains.ReSharper.Psi.CodeStyle.ICodeFormatter"/> and of <see cref="T:JetBrains.ReSharper.Psi.Impl.CodeStyle.ICodeFormatterImpl"/>
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Pointers.DeclaredElementPointer">
            <summary>
            Implements element pointer funcitonality
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Pointers.DeclaredElementPointer.#ctor(JetBrains.ReSharper.Psi.IDeclaredElement)">
            <summary>
            Creates new smart element pointing to the specified declared element
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Files.DirtyFilesCollection">
            <summary>
            Project items for which PSI is outdated
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Files.CommitBuildResult">
            <summary>
            result of reparse or newly created psi-file.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Reflection2.IAssemblyDataCache.OnAssemblyLoadingFinished">
            <summary>
            Called when assembly loading is finished, so temporary data could be cleared
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Impl.Reflection2.ExternalAnnotations.AssemblyExternalAnnotations">
            <summary>
            per psi-assembly annotations bound to specific module. new instance of this class is created when psi-assembly is reused in tests.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Impl.Reflection2.ReflectionTypeFlags.StrippedTypeParametersFromName">
            <summary>
            Type parameters count was stripped from type name
            (i.e. no !1 or `1 at the end of type name)
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Impl.Reflection2.ReflectionTypeFlags.InvalidTypeParametersCount">
            <summary>
            Number after ' or ! is not equal to actual number of generic parameters
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Impl.Reflection2.ReflectionTypeFlags.OldTypeParametersSymbol">
            <summary>
            ! symbol used to specify number of generic parameters (i.e. !1)
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Modules.DefaultPsiModuleProvider">
            <summary>
            PSI module provider for regular projects
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IProjectFileLanguageService.GetPsiLanguageType(JetBrains.ProjectModel.IProjectFile)">
            <summary>
            Evaluates PsiLanguageType for a project file
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IProjectFileLanguageService.GetPsiProperties(JetBrains.ProjectModel.IProjectFile,JetBrains.ReSharper.Psi.IPsiSourceFile)">
            <summary>
            Get the PSI properties (if any) for the specific project file
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IProjectFileLanguageService.GetPsiLanguageType(JetBrains.ProjectModel.ProjectFileType)">
            <summary>
            Returns most likely PsiLanguageType for a project file of corresponing ProjectFileType.
            i.e. XAML files normally return XAML psi, but sometimes may return XML psi, but this method should
            return XAML
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IProjectFileLanguageService.GetMixedLexerFactory(JetBrains.ProjectModel.ISolution,JetBrains.Text.IBuffer,JetBrains.ReSharper.Psi.IPsiSourceFile)">
            <summary>
            Creates lexer, that corresponds to source file text (NOT generated!) 
            </summary>
            <param name="solution"></param>
            <param name="buffer">IBuffer with the text</param>
            <param name="sourceFile">Actual source file (if exists) for which the lexer is to be generated</param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Naming.Interfaces.INamingLanguageService.ExpandAndShortenKeywords(System.Collections.Generic.IEnumerable{JetBrains.ReSharper.Psi.Naming.Impl.NameRoot})">
            <summary>
            Populates inbound collection with language specific keywords abbreviations and lowers priority.
            Sample:
              Inbound: int (Essential)
              Outbound: i (Essential), int (Inane)
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Naming.Interfaces.INamingLanguageService.ConvertNameToUnmangledSafe(System.String)">
            <summary>Creates valid identifier and mangles name if necessary</summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Naming.Impl.ScopeKind.LocalSelfScoped">
            <summary>
            Lambda parameters, Range variables
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Parsing.IXmlTokenBuilder">
            <summary>
            Implement this language-specific interface if you need specific behaviour
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.PredefinedTypeExtensions.IsPredefinedNumeric(JetBrains.ReSharper.Psi.IType)">
            <summary>
            Checks if given type equals to predefined sbyte, byte, short, ushort, int, uint, long, ulong, decimal, double, float, char
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.PredefinedTypeExtensions.IsPredefinedIntegral(JetBrains.ReSharper.Psi.IType)">
            <summary>
            Checks if given type equals to predefined sbyte, byte, short, ushort, int, uint, long, ulong, char or string
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.PredefinedTypeExtensions.IsPredefinedIntegralNumeric(JetBrains.ReSharper.Psi.IType)">
            <summary>
            Checks if given type equals to predefined sbyte, byte, short, ushort, int, uint, long, ulong
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.PredefinedTypeExtensions.IsSimplePredefined(JetBrains.ReSharper.Psi.IType)">
            <summary>
            Checks if given type equals to predefined string, bool, sbyte, byte, short, ushort, int, uint, long, ulong, decimal, double, float, char
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resolve.FileFilters.Exists">
            <remarks>Slow!</remarks>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resolve.FileFilters.FileExists">
            <remarks>Slow!</remarks>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resolve.FileFilters.DirectoryExists">
            <remarks>Slow!</remarks>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resolve.FileFilters.IsProjectFileFilter">
            <summary>
            Match file by project file type (exactly, without inheritance)
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resolve.IReferenceProviderFactory">
            <summary>
            Creates custom reference provider for given file
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Resolve.IReferenceProviderFactory.CreateFactory(JetBrains.ReSharper.Psi.IPsiSourceFile,JetBrains.ReSharper.Psi.Tree.IFile)">
            <summary>
            Creates implementation of <see cref="T:JetBrains.ReSharper.Psi.Resolve.IReferenceFactory"/> for the <paramref name="sourceFile"/> and <paramref name="file"/>.
            </summary>
            <param name="sourceFile">the specified project file</param>
            <param name="file">the specified PSI file</param>
            <returns>implementation of <see cref="T:JetBrains.ReSharper.Psi.Resolve.IReferenceFactory"/> or <c>null</c></returns>
            <remarks><paramref name="file"/>.IsValid() is <c>false</c> for this method call!</remarks>
        </member>
        <member name="E:JetBrains.ReSharper.Psi.Resolve.IReferenceProviderFactory.OnChanged">
            <summary>
            Fired when factory settings is changed, and for all active files reference providers should be re-evaluated
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resolve.IReferenceFactory">
            <summary>
            Custom reference provider
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Resolve.IReferenceFactory.GetReferences(JetBrains.ReSharper.Psi.Tree.ITreeNode,JetBrains.ReSharper.Psi.Resolve.IReference[])">
            <summary>
            Incrementally update reference list.
            </summary>
            <param name="element"></param>
            <param name="oldReferences">Old references. Can be invalid.</param>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Resolve.IReferenceFactory.HasReference(JetBrains.ReSharper.Psi.Tree.ITreeNode,JetBrains.ReSharper.Psi.Resolve.IReferenceNameContainer)">
            <summary>
            Returns <c>true</c> if this reference provider may have reference on element with one of given names
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.IDomainSpecificSearcher.ProcessProjectItem``1(JetBrains.ReSharper.Psi.IPsiSourceFile,JetBrains.ReSharper.Psi.Search.IFindResultConsumer{``0})">
            <returns>True if further search is not needed</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.IDomainSpecificSearcher.ProcessElement``1(JetBrains.ReSharper.Psi.Tree.ITreeNode,JetBrains.ReSharper.Psi.Search.IFindResultConsumer{``0})">
            <returns>True if further search is not needed</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Search.FinderExtensions.FindInheritors(JetBrains.ReSharper.Psi.Search.IFinder,JetBrains.ReSharper.Psi.IDeclaredType,System.Func{JetBrains.ReSharper.Psi.IDeclaredType,JetBrains.ReSharper.Psi.Search.FindExecution},JetBrains.ReSharper.Psi.Search.ISearchDomain,JetBrains.Application.Progress.IProgressIndicator)">
            <summary>
            TODO: this method is incorrect because base type substitition applied to a derived class has no sense.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Search.FindResultAssemblyAttribute.Index">
            <summary>
            returns -1 if not initialized
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Search.SearchDomainFactory.Instance">
            <remarks>
            Inject or use <see cref="P:JetBrains.ReSharper.Psi.IPsiServices.SearchDomainFactory"/>
            </remarks>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.TreeTextRange`1.FromLength(JetBrains.ReSharper.Psi.TreeOffset,System.Int32)">
            <summary>
            Creates a new range from offset and length, rather than from start + end offsets, as the <c>.ctor</c> would do.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.TreeTextRange`1.FromLength(System.Int32)">
            <summary>
            Creates a new range from zero offset and length, rather than from start + end offsets, as the <c>.ctor</c> would do.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.TreeTextRange`1.GetMinOffset">
            <summary>
            Gets the <see cref="P:JetBrains.ReSharper.Psi.TreeTextRange`1.StartOffset"/> or <see cref="P:JetBrains.ReSharper.Psi.TreeTextRange`1.EndOffset"/>, whichever is smaller. Use for consistent processing of potentially non-normalized ranges.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.TreeTextRange`1.GetMaxOffset">
            <summary>
            Gets the <see cref="P:JetBrains.ReSharper.Psi.TreeTextRange`1.StartOffset"/> or <see cref="P:JetBrains.ReSharper.Psi.TreeTextRange`1.EndOffset"/>, whichever is greater. Use for consistent processing of potentially non-normalized ranges.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.TreeTextRange`1.ContainedIn(JetBrains.ReSharper.Psi.TreeTextRange{`0},System.Boolean)">
            <summary>
            Gets whether this range is a subset of the <paramref name="treeRange"/>.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.TreeTextRange`1.StrictContainedIn(JetBrains.ReSharper.Psi.TreeTextRange{`0})">
            <summary>
            Gets whether this range is a proper subset of the <paramref name="treeRange"/>.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.TreeTextRange`1.Contains(JetBrains.ReSharper.Psi.TreeOffset,System.Boolean)">
            <summary>
            Determines whether the offset falls within the range, start and end offsets included.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.TreeTextRange`1.ContainsCharIndex(JetBrains.ReSharper.Psi.TreeOffset)">
            <summary>
            <para>Checks whether the character at the <paramref name="charindex">given index</paramref> falls within this range.</para>
            <para>Unlike <see cref="!:Contains(int)"/>, the right offset is not included, because the range ends before the character with such an index.</para>
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.TreeTextRange`1.IsValid">
            <summary>
            Checks that the range is not the <see cref="F:JetBrains.ReSharper.Psi.TreeTextRange`1.InvalidRange"/>.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.TreeTextRange`1.AssertValid">
            <summary>
            Asserts that this range is normalized, which means that its <see cref="P:JetBrains.ReSharper.Psi.TreeTextRange`1.Length"/> is nonnegative.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.TreeTextRange`1.AssertNormalized">
            <summary>
            Asserts that this range is normalized, which means that its <see cref="P:JetBrains.ReSharper.Psi.TreeTextRange`1.Length"/> is nonnegative.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.TreeTextRange`1.Normalized">
            <summary>
            Returns a normalized version of the current text range (with a nonnegative length).
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.TreeTextRange`1.DistanceTo(JetBrains.ReSharper.Psi.TreeOffset)">
            <summary>
            Returns the distance between the <paramref name="offset"/> and the nearest point that belongs to the range.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.TreeTextRange`1.IsNormalized">
            <summary>
            Gets whether this range is normalized, which means that its <see cref="P:JetBrains.ReSharper.Psi.TreeTextRange`1.Length"/> is nonnegative.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.Caches.AbstractPersistendIdIndex`1.Update">
            <summary>
            The key feature - files with unchanged persistent id should keep old index
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ITypeConversionRule">
            <summary>  
            This interafce should be provided by corresponding language dependent tree node.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.FileSpecificUtil.SortDeclarationsByWritability(JetBrains.ReSharper.Psi.ITypeElement,JetBrains.ReSharper.Psi.Tree.IDeclaration,JetBrains.ReSharper.Psi.PsiLanguageType)">
            <summary>
            Returns all declarations of a type where type member can be created. Preferrable declarations are first.
            Methods acts as follow:
            1. Get all declaratinos of a type.
            2. Ask language specific services for extra declarations (e.g. base type of ASP page...)
            3. Filter declarations in other languages...
            4. Try filter generated declarations... Like windows forms desiner code...
            5. Filter declarations written in languages other then required...
            6. Try use prefered declaration...
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.FileSpecificUtil.SortDeclarationsByWritability(System.Collections.Generic.IEnumerable{JetBrains.ReSharper.Psi.Tree.IDeclaration},JetBrains.ReSharper.Psi.Tree.IDeclaration,JetBrains.ReSharper.Psi.PsiLanguageType)">
            <summary>
            Returns all declarations of a type where type member can be created. Preferrable declarations are first.
            Methods acts as follow:
            1. Get all declaratinos of a type.
            2. Ask language specific services for extra declarations (e.g. base type of ASP page...)
            3. Filter declarations in other languages...
            4. Try filter generated declarations... Like windows forms desiner code...
            5. Filter declarations written in languages other then required...
            6. Try use prefered declaration...
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.IFileTypeSpecificOwnerUtil.GetRelatedDeclarations(JetBrains.ReSharper.Psi.Tree.ITypeDeclaration)">
            <summary>
            By default: yield break
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.IFileTypeSpecificOwnerUtil.GetRelatedAndFilterHidden(JetBrains.ReSharper.Psi.Tree.ITypeDeclaration)">
            <summary>
            By default: yield return declaration
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.IFileTypeSpecificOwnerUtil.IsHidden(JetBrains.ReSharper.Psi.Tree.ITypeDeclaration)">
            <summary>
            Works on auto-generated code-behind classed. By default - false
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.IFileTypeSpecificOwnerUtil.IsCodeBehindClass(JetBrains.ReSharper.Psi.Tree.ITypeDeclaration)">
            <summary>
            By default - false
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.IFileTypeSpecificOwnerUtil.IsUserTextDeclaration(JetBrains.ReSharper.Psi.Tree.IDeclaration)">
            <summary>
            Works on auto-generated type members. By default - true
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.IFileTypeSpecificOwnerUtil.CanContainSeveralClasses(JetBrains.ReSharper.Psi.IPsiSourceFile)">
            <summary>
            Default - true
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.IFileTypeSpecificOwnerUtil.CanImplementInterfaces(JetBrains.ReSharper.Psi.Tree.ITypeDeclaration)">
            <summary>
            Default - true
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.IFileTypeSpecificOwnerUtil.CanHaveConstructors(JetBrains.ReSharper.Psi.Tree.ITypeDeclaration)">
            <summary>
            Default - true
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.IFileTypeSpecificOwnerUtil.SuperClassCanBeChanged(JetBrains.ReSharper.Psi.Tree.ITypeDeclaration)">
            <summary>
            Default - true
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.IFileTypeSpecificOwnerUtil.SuperClassNameMustBeFull(JetBrains.ReSharper.Psi.Tree.ITypeDeclaration)">
            <summary>
            Default - false
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.IFileTypeSpecificOwnerUtil.GetNamespaceForElementsMovedToExternalScope(JetBrains.ReSharper.Psi.Tree.ITypeDeclaration,JetBrains.ReSharper.Psi.Tree.ITreeNode)">
            <summary>
            Default - typeElement.GetContainingElement&lt;INamespaceDeclaration&gt;(false);
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.IFileTypeSpecificOwnerUtil.GetFolderForElementsMovedToExternalScope(JetBrains.ProjectModel.IProjectFile,System.String,JetBrains.ReSharper.Psi.Tree.ITreeNode)">
            <summary>
            Default - projectFile.Location.Directory
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.IFileTypeSpecificOwnerUtil.GetPrettyName(JetBrains.ReSharper.Psi.Tree.ITypeDeclaration,System.Boolean)">
            <summary>
            Default - element.DeclaredName
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.IFileTypeSpecificOwnerUtil.IsOperationPossibleOnUnmappedRange(JetBrains.ReSharper.Psi.Tree.ITreeNode)">
            <summary>
            Default - false
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.IFileTypeSpecificOwnerUtil.GetDocumentRangeForPartiallyUnmappedNode(JetBrains.ReSharper.Psi.Tree.ITreeNode)">
            <summary>
            Default - InvalidRange
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.IFileTypeSpecificOwnerUtil.IsOperationPossibleOnUnmappedRange(JetBrains.ReSharper.Psi.ITreeRange)">
            <summary>
            Default - false
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.IFileTypeSpecificOwnerUtil.CanDeclarationBeOverloaded(JetBrains.ReSharper.Psi.Tree.IDeclaration)">
            <summary>
            Default - true
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.IFileTypeSpecificOwnerUtil.GetMvcViewWithModelBaseTypes">
            <summary>
            Default - empty
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.ILanguageReferenceSelector.GetBaseConstructor(JetBrains.ReSharper.Psi.IConstructor)">
            <summary>
            Get the base constructor call from given constructor
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.ILanguageReferenceSelector.GetCandidates(JetBrains.ReSharper.Psi.Resolve.IReference,JetBrains.ReSharper.Psi.Util.ReferencePreferenceKind)">
            <summary>
            Return the candidates to go to declaration action
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Services.LiteralService.IsStringLiteral(JetBrains.ReSharper.Psi.Tree.ITreeNode)">
            <summary>
            Determines whether the specified <paramref name="element"/> is string literal.
            </summary>
            <param name="element">element for test</param>
            <returns><c>true</c> - if success; otherwise - <c>false</c></returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Services.LiteralService.IsConstantLiteral(JetBrains.ReSharper.Psi.Tree.ITreeNode)">
            <summary>
            Determines whether the specified <paramref name="element"/> is constant literal.
            </summary>
            <param name="element">element for test</param>
            <returns><c>true</c> - if success; otherwise - <c>false</c></returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.MoveComments.IMoveCommentHandler.MoveCommentBefore(JetBrains.ReSharper.Psi.Tree.IComment,JetBrains.ReSharper.Psi.Tree.ITreeNode)">
            <summary>
            Moves <paramref name="comment"/> from old tree and adds befor <paramref name="anchorNode"/>
            </summary>
            <returns> node after inserting </returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.MoveComments.IMoveCommentHandler.MoveCommentAfter(JetBrains.ReSharper.Psi.Tree.IComment,JetBrains.ReSharper.Psi.Tree.ITreeNode)">
            <summary>
            Moves <paramref name="comment"/> from old tree and adds after <paramref name="anchorNode"/>
            </summary>
            <returns> node after inserting </returns>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Util.MoveComments.TreeSnapshot">
            <summary>
            State for MoveCommentsUtil 
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Util.MoveComments.MoveCommentsUtil">
            <summary>
            Utility for saving comments after transformation of tree.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.MoveComments.MoveCommentsUtil.DoSnapshotTree(JetBrains.ReSharper.Psi.Tree.ITreeNode)">
            <summary>
            Creates snapshot of tree for moving comments
            </summary>   
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.MoveComments.MoveCommentsUtil.DoIncrementalSnapshotTree(JetBrains.ReSharper.Psi.Util.MoveComments.TreeSnapshot,System.Collections.Generic.IEnumerable{JetBrains.ReSharper.Psi.Tree.ITreeNode})">
            <summary>
            Creates incremental snapshot of tree (hack for replacement of placeholder in SSR)
            </summary>   
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.MoveComments.MoveCommentsUtil.DoMoveComments``1(JetBrains.ReSharper.Psi.Util.MoveComments.TreeSnapshot,``0)">
            <summary>
            Moves comments from old tree to new tree
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.ExpressionUtil.IsPure(JetBrains.ReSharper.Psi.Tree.IExpression)">
            <summary>
            Check if expression calls only to pure methods, and has no side effects
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.ExpressionUtil.IsPure(JetBrains.ReSharper.Psi.Tree.IExpression,System.Func{JetBrains.ReSharper.Psi.Tree.IExpression,System.Boolean})">
            <summary>
            Check if expression calls only to pure methods, and has no side effects.
            Custom check predicate allows to filter-out write to locals.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.HierarchyUtil.HaveCommonSubtype(JetBrains.ReSharper.Psi.IExpressionType,JetBrains.ReSharper.Psi.IExpressionType)">
            <summary>
            Checks if there is any type which is both <paramref name="type1"/> and <paramref name="type2"/>
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Resolve.IUriPathResolver.GetPathReferences``2(System.Uri,``0,``1,JetBrains.ReSharper.Psi.Resolve.IQualifier,System.Func{``0,JetBrains.ReSharper.Psi.Resolve.IQualifier,``1,JetBrains.ReSharper.Psi.TreeTextRange,JetBrains.ReSharper.Psi.Resolve.IPathReference},System.Func{``0,JetBrains.ReSharper.Psi.Resolve.IQualifier,``1,JetBrains.ReSharper.Psi.TreeTextRange,JetBrains.ReSharper.Psi.Resolve.IPathReference},System.String,System.Int32)">
            <returns>null if can't handle uri, pass forward</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.ObsoleteUtil.IsReferencingObsoleteEntity(JetBrains.ReSharper.Psi.Resolve.IReference,System.Boolean@,System.Boolean@,System.String@)">
            <summary>
            Check if reference resolves to obsolete entity.
            Note: Usage of obsolete references from obsolete method is not obsolete!
            </summary>
            <returns><c>null</c> if reference is not obsolete.
            Returns <c>true</c> in first pair member if should treat as error,
            and obsolete message in second component </returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.ICreationTarget.GetTargetDeclaration">
            <summary>
            Returns target declaration. 
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.ICreationTarget.GetTargetDeclarationFile">
            <summary>
            Returns target declaration file
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.TreeRangeUtil.PrepareAnchorForAddingBefore(JetBrains.ReSharper.Psi.Tree.ITreeNode,JetBrains.ReSharper.Psi.ITreeRange)">
            <summary>
            Sometimes we have messed up PSI structure like this:
            #if SOME_DEFINE // this belongs to file
              // Here starts UsingList
                  using Aaa;
                #endif // this still belongs to UsingList
                #if SOME_DEFINE
                  using Bbb;
              // Here ends UsingList
            #endif // this belongs to file, not to UsingList
            
            This is because preprocessor directives and comments are considered not meaningful,
            and UsingList must start with meaningful child.
            In this case, when we want to add a new using above first "#if SOME_DEFINE",
            we would need to move "non-meaningful" lexems after it inside UsingList.
            This method gets a range of meaningful or "non-meaningful" nodes, before which we want to add a new node, and
            a parent node where this new node should go according to PSI logic, and checks if we need to move anything
            inside parent. 
            </summary>
            <param name="parent">Node where a new node belongs according to PSI logic (like UsingList)</param>
            <param name="range">A range of nodes (meaningful or not), which we want to add our node before</param>
            <returns>Anchor, before which we should add our node</returns>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Util.TreeTextRangeTree`2">
            <summary>
            Works only with range lists where ranges cannot strictly intersect with each other and that are normalized
            </summary>
            <typeparam name="TKind"></typeparam>
            <typeparam name="TData"></typeparam>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.XMLDocUtil.Load(System.Text.StringBuilder,System.Xml.XmlNode@)">
            <remarks>
            Modifies passed <see cref="!:text">string builder</see>
            </remarks>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.XmlIndex.XmlDocIndex.#ctor(JetBrains.ReSharper.Psi.IPsiAssembly,System.Boolean,JetBrains.ReSharper.Psi.IPsiConfiguration,JetBrains.Application.platforms.PlatformManager,JetBrains.ReSharper.Psi.XmlIndex.XmlIndexThread)">
            <summary>
            Builds index for compiled XML docs
            </summary>
            <param name="assembly">assembly to index doc for</param>
            <param name="sync">indicates whether indexing should be synchronous, or may execute in another thread</param>
            <param name="psiConfiguration"></param>
            <param name="platformManager"></param>
            <param name="indexThread"></param>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.XmlIndex.XmlDocIndex.DoUpdateIndex">
            <summary>
            Returns <c>true</c> if index was updated
            </summary>
            <returns></returns>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Modules.MiscFilesProjectPsiModuleProviderFactory">
            <summary>
            PSI module provider for misc files project
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Search.SearchProcessorBase.ProcessProjectItem``1(JetBrains.ReSharper.Psi.IPsiSourceFile,JetBrains.ReSharper.Psi.Search.IFindResultConsumer{``0})">
            <returns>True if further search is not needed</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Search.SearchProcessorBase.ProcessElement``1(JetBrains.ReSharper.Psi.Tree.ITreeNode,JetBrains.ReSharper.Psi.Search.IFindResultConsumer{``0})">
            <returns>True if further search is not needed</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Search.SearchProcessorBase.ProcessLibraryFile``1(JetBrains.ReSharper.Psi.Caches.IPsiAssemblyFile,JetBrains.ReSharper.Psi.Search.IFindResultConsumer{``0})">
            <returns>True if further search is not needed</returns>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Impl.Search.MethodUsageInfo">
            <summary>
            Data class ...
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Types.DeclaredTypeBase.GetTypeElement">
            <summary>
            Returns type element retargeted in the current compilation context.
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Impl.Types.DeclaredTypeBase.DeclaredTypePointer">
            <summary>
            Type pointer for a declared type
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExtensionsAPI.ICrossProjectAnonymousTypeImpl">
            <summary>
            Solution wide and cross language anonymous type implementation.
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.MemberContainerStyle">
            <summary>
            Indicates where the container type of a type member should be shown.
            <list type="table">
            <listheader><term>Enum member name</term><description>Description or example</description></listheader>
            <item><term>NONE</term><description>Do not show type (default value)</description></item>
            <item><term>AFTER</term><description>foo() in ClassName</description></item>
            <item><term>AFTER_WITH_KIND</term><description>foo() in class ClassName</description></item>
            <item><term>AFTER_IN_PARENTHESIS</term><description>foo() (in ClassName)</description></item>
            <item><term>AFTER_IN_PARENTHESIS_WITH_KIND</term><description>foo() (in class ClassName)</description></item>
            <item><term>BEFORE_WITH_DOT</term><description>ClassName.foo()</description></item>
            </list>
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.NamespaceContainerStyle">
            <summary>
            Indicates if the containing type of a <see cref="T:JetBrains.ReSharper.Psi.INamespace"/> should be shown and where it should be shown.
            <list type="table">
            <listheader><term>Enum member name</term><description>Description or example</description></listheader>
            <item><term>NONE</term><description>Do not show type (default value)</description></item>
            <item><term>AFTER</term><description>Namespace in Namespace</description></item>
            <item><term>AFTER_IN_PARENTHESIS</term><description>Namespace (in Namespace)</description></item>
            </list>
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.NameStyle">
            <summary>
            Indicates how the entity name should be presented
            <list type="table">
            <listheader><term>Enum member name</term><description>Description or example</description></listheader>
            <item><term>NONE</term><description>Do not show name (default value)</description></item>
            <item><term>SHORT</term><description>Show name in short form</description></item>
            <item><term>SHORT_RAW</term><description>Show name in short non-verbatim form</description></item>
            <item><term>QUALIFIED</term><description>Show name in fully qualified form</description></item>
            <item><term>QUALIFIED_EXCEPT_MEMBERS</term><description>Show name in fully qualified form if the element is not type member</description></item>
            <item><term>FULL_NESTED_TYPE</term><description>Full nested type name without namespace</description></item>
            <item><term>FULL_NESTED_TYPE_EXCEPT_MEMBERS</term><description>Full nested type name without namespace if the element is not type member</description></item>
            </list>
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Naming.INameCanoniser">
            <summary>
            Interface for components performing language-specific canonisation of symbol names. 
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Naming.INameCanoniser.GetCanonicalShortName(System.String)">
            <summary>
            Canonises language-specific short name by returning the CLR-compilant equivalent
            </summary>
            <param name="name">Language-specific name (possibly escaped)</param>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Naming.INameCanoniser.GetCanonicalQualifiedName(System.String)">
            <summary>
            Converts language-specific qualified name into CLR-compliant equivalent
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ParameterContainerStyle">
            <summary>
            Indicates if the containing method should be shown and where it should be shown if the given element is a parameter.
            <list type="table">
            <listheader><term>Enum member name</term><description>Description or example</description></listheader>
            <item><term>NONE</term><description>Do not show method (default value)</description></item>
            <item><term>AFTER</term><description>parameter a of method foo</description></item>
            <item><term>AFTER_IN_PARENTHESIS</term><description>parameter a (of method foo)</description></item>
            </list>
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Search.FindResultOverridableMember.QuasiBasisElement">
            <summary>
            Type element which was used as basis for quasi-implemetation
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.TreeTextRange.FromLength(JetBrains.ReSharper.Psi.TreeOffset,System.Int32)">
            <summary>
            Creates a new range from offset and length, rather than from start + end offsets, as the <c>.ctor</c> would do.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.TreeTextRange.FromLength(System.Int32)">
            <summary>
            Creates a new range from zero offset and length, rather than from start + end offsets, as the <c>.ctor</c> would do.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.TreeTextRange.GetMinOffset">
            <summary>
            Gets the <see cref="P:JetBrains.ReSharper.Psi.TreeTextRange.StartOffset"/> or <see cref="P:JetBrains.ReSharper.Psi.TreeTextRange.EndOffset"/>, whichever is smaller. Use for consistent processing of potentially non-normalized ranges.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.TreeTextRange.GetMaxOffset">
            <summary>
            Gets the <see cref="P:JetBrains.ReSharper.Psi.TreeTextRange.StartOffset"/> or <see cref="P:JetBrains.ReSharper.Psi.TreeTextRange.EndOffset"/>, whichever is greater. Use for consistent processing of potentially non-normalized ranges.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.TreeTextRange.ContainedIn(JetBrains.ReSharper.Psi.TreeTextRange)">
            <summary>
            Gets whether this range is a subset of the <paramref name="treeRange"/>.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.TreeTextRange.StrictContainedIn(JetBrains.ReSharper.Psi.TreeTextRange)">
            <summary>
            Gets whether this range is a proper subset of the <paramref name="treeRange"/>.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.TreeTextRange.Contains(JetBrains.ReSharper.Psi.TreeOffset)">
            <summary>
            Determines whether the offset falls within the range, start and end offsets included.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.TreeTextRange.ContainsCharIndex(JetBrains.ReSharper.Psi.TreeOffset)">
            <summary>
            <para>Checks whether the character at the <paramref name="charindex">given index</paramref> falls within this range.</para>
            <para>Unlike <see cref="M:JetBrains.ReSharper.Psi.TreeTextRange.Contains(JetBrains.ReSharper.Psi.TreeOffset)"/>, the right offset is not included, because the range ends before the character with such an index.</para>
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.TreeTextRange.IsValid">
            <summary>
            Checks that the range is not the <see cref="F:JetBrains.ReSharper.Psi.TreeTextRange.InvalidRange"/>.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.TreeTextRange.AssertValid">
            <summary>
            Asserts that this range is normalized, which means that its <see cref="P:JetBrains.ReSharper.Psi.TreeTextRange.Length"/> is nonnegative.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.TreeTextRange.AssertNormalized">
            <summary>
            Asserts that this range is normalized, which means that its <see cref="P:JetBrains.ReSharper.Psi.TreeTextRange.Length"/> is nonnegative.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.TreeTextRange.Normalized">
            <summary>
            Returns a normalized version of the current text range (with a nonnegative length).
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.TreeTextRange.DistanceTo(JetBrains.ReSharper.Psi.TreeOffset)">
            <summary>
            Returns the distance between the <paramref name="offset"/> and the nearest point that belongs to the range.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.TreeTextRange.IsNormalized">
            <summary>
            Gets whether this range is normalized, which means that its <see cref="P:JetBrains.ReSharper.Psi.TreeTextRange.Length"/> is nonnegative.
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.TypeContainerStyle">
            <summary>
            Indicates if the containing type or namespace of a <see cref="T:JetBrains.ReSharper.Psi.ITypeElement"/> should be shown and where it should be shown.
            <list type="table">
            <listheader><term>Enum member name</term><description>Description or example</description></listheader>
            <item><term>NONE</term><description>Do not show type (default value)</description></item>
            <item><term>AFTER</term><description>ClassName in Namespace</description></item>
            <item><term>AFTER_WITH_KIND</term><description>ClassName in namespace Namespace</description></item>
            <item><term>AFTER_IN_PARENTHESIS_WITH_KIND</term><description>ClassName (in namespace Namespace)</description></item>
            </list>
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.TypeParameterStyle">
            <summary>
            The style of the type parameters presenting.
            <list type="table">
            <listheader><term>Enum member name</term><description>Description or example</description></listheader>
            <item><term>NONE</term><description>Do not show type parameters</description></item>
            <item><term>CLR</term><description>CLR-style, i.e. the number of type parameters after `</description></item>
            <item><term>INDICATE</term><description>Shows syntax indicating presence of type parameters, but doesn't list them</description></item>
            <item><term>FULL</term><description>Show type parameters with their names(default value)</description></item>
            <item><term>FULL_WITH_VARIANCE</term><description>Show type parameters with their names(default value) and in/ outs</description></item>
            </list>
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.TypeStyle">
            <summary>
            Indicates how return type of a function or type of a variable are presented
            <list type="table">
            <listheader><term>Enum member name</term><description>Description or example</description></listheader>
            <item><term>NONE</term><description>Do not show type (default value)</description></item>
            <item><term>BEFORE</term><description>Language default (for example: Type foo)</description></item>
            <item><term>AFTER</term><description>foo:Type</description></item>
            </list>
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.AccessibilityDomain">
            <summary>
            The accessibility domain of some type member
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.AccessibilityDomain.AccessibilityDomainType.PUBLIC">
            <summary>
            Unrestricted access to member
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.AccessibilityDomain.AccessibilityDomainType.INTERNAL">
            <summary>
            Access is restricted to assembly, in which member is defined
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.AccessibilityDomain.AccessibilityDomainType.PROTECTED">
            <summary>
            Access is restricted to <see cref="P:JetBrains.ReSharper.Psi.AccessibilityDomain.Container"/> and it derivates
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.AccessibilityDomain.AccessibilityDomainType.PROTECTED_OR_INTERNAL">
            <summary>
            Access is restricted to <see cref="P:JetBrains.ReSharper.Psi.AccessibilityDomain.Container"/>, all it derivates, and the assembly where member is defined
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.AccessibilityDomain.AccessibilityDomainType.PROTECTED_AND_INTERNAL">
            <summary>
            Access is restricted to <see cref="P:JetBrains.ReSharper.Psi.AccessibilityDomain.Container"/> and it derivates in assembly where member is declared
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.AccessibilityDomain.AccessibilityDomainType.PRIVATE">
            <summary>
            Access is restricted to <see cref="P:JetBrains.ReSharper.Psi.AccessibilityDomain.Container"/> only
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.AccessibilityDomain.AccessibilityDomainType.NONE">
            <summary>
            Error occured while computing accessibility domain
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.AsyncCommitService.RequestCommit(JetBrains.ReSharper.Psi.IAsyncCommitClient,System.Nullable{System.Int32})">
            <summary>
            Enroll listener of <see cref="M:JetBrains.ReSharper.Psi.Files.IPsiFiles.CommitAllDocumentsAsync(System.Action,System.Action)"/>.
            After commit (successful or interrupted), client must register itself
            again manually to participate in a next commit. Can be called in any thread.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.AsyncCommitService.DropRequest(JetBrains.ReSharper.Psi.IAsyncCommitClient)">
            <summary>
            Remove <see cref="!:client"/> from queue of registered commit listeners. Can be called in any thread.
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CachedPsiValue`1">
            <summary>
            Use this class for caching values that depend on PSI. It would NOT get invalidated on whitespace changes.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CachedPsiValue`1.GetValueRaw">
            <summary>
            Get value regardless of timastamp
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CachedPsiValueWithOffsets`1">
            <summary>
            Use this class for caching values that depend on document or tree offsets. It gets invalidated even on whitespace changes and it isn't contained in scopes.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Caches.IPsiCachesState.IsInitialUpdateFinished">
            <summary>
             Indicates that caches have completed initalization and inital update (exactly - Save Job) after start-up
             </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Caches.IPsiCachesState.IsIdle">
            <summary>
             Indicates if the async cache updater is idle right now (no foreground jobs)
             </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Caches.IPsiCachesState.IsBackgroundIdle">
            <summary>
             TODO: daivanov, describe it, please
             </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Caches.IPsiCachesState.IsLoadEnqued">
            <summary>
            Whether PsiCaches are started. Changes from false to true once. <see cref="P:JetBrains.ReSharper.Psi.Caches.IPsiCachesState.IsIdle"/> can't become true while <see cref="P:JetBrains.ReSharper.Psi.Caches.IPsiCachesState.IsLoadEnqued"/> is false.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Caches.IPsiCaches.WaitForCaches(System.String,System.String)">
            <summary>
             Syncroniously wait until caches are ready, with a popup progress window.
             Must be called under a read lock.
             </summary>
            <param name="callerName">Identifies the caller of the utility, so that he could understand the reason of the delay.</param>
            <param name="cancelButtonContent">Title of the Cancel button, or <c>Null</c> if the Cancel button should be disabled.</param>
            <returns><c>True</c> if the caches are ready, <c>False</c> if user-cancelled.</returns>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Caches.IPsiCaches.HasDirtyFiles">
            <summary>
             Check if cache contains dirty files due to document or PSI changes. This do not affect async cache update due to external changes (<see cref="P:JetBrains.ReSharper.Psi.Caches.CacheManager.IsIdle" />)
             </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Caches.SymbolCache.IDeclarationsScope">
            <summary>
            Repsents scope of declarations cache.
            Scope can be one of :
            <list>
            <item>whole solution including libraries - covers types and namespaces in solution</item>
            <item>whole solution exclusing libraries - covers types and namespaces in source code of solution</item>
            <item>project - covers types and namespaces in source code of given project</item>
            <item>project and its referenced libraries and projects- covers types and namespaces in given project and its references including transitive ones</item>
            <item>library and its referenced libraries - covers types and namespaces in given library and libraries referenced by it</item>
            </list>
            <example>See <see cref="T:JetBrains.ReSharper.Psi.Caches.ISymbolScope"/> for example of use.</example>
            </summary>
            <seealso cref="T:JetBrains.ReSharper.Psi.Caches.ISymbolScope"/>
            <seealso cref="M:JetBrains.ReSharper.Psi.Caches.ISymbolCache.GetSymbolScope(JetBrains.ReSharper.Psi.Caches.LibrarySymbolScope,System.Boolean)"/>
            <seealso cref="M:JetBrains.ReSharper.Psi.Caches.ISymbolCache.GetSymbolScope(JetBrains.ReSharper.Psi.Modules.IPsiModule,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CodeAnnotations.CodeAnnotationsCache.GetStringFormatMethodParameter(JetBrains.ReSharper.Psi.IParametersOwner)">
            <summary>
            Get the format parameter of the string format method. Returns <c>null</c> if method is not string format method
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CodeStyle.SettingsUpgrade.CodeStyleSettingsObsolete">
            <summary>
            The component-like holder for all code style settings
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CodeStyle.SettingsUpgrade.CodeStyleSettingsObsolete.FileHeaderText">
            <summary>
            Get the copyright header of the file. Empty string means no copyright info
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CodeStyle.SettingsUpgrade.CodeStyleSettingsObsolete.FileHeaderRegionName">
            <summary>
            Get if the copyright notice should be embraced in region. Empty region name means no embracement
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CodeStyle.SettingsUpgrade.CodeStyleSettingsAttribute">
            <summary>
            Specific code style settings (for specific language, for example) should be marked 
            by this attribute to be included in the code style settings container
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.ControlFlow.ControlFlowEdgeType.PHANTOM_NEXT">
            <summary>
            Phantom edge represents edge which actually doesn't present in the control flow graph.
            It is used in "what-if" analysis, such as control flow statement redundancy.
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ControlFlow.IControlFlowElement">
            <summary>
            Base element of control flow tree. Getters use class <see cref="T:System.Collections.Generic.List`1"/> for performance reasons to not to box enumerator
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.DeclaredElementEnvoy`1">
            <summary>
            Represents <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/> for presentations.
            </summary>
            <remarks>Provides ability to keep <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/> presentation when element becomes invalid</remarks>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IPathDeclaredElement.GetProjectItem">
            <summary>Returns random file at specified path</summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IPathDeclaredElement.Path">
            <summary>Logical path to some file</summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IPathDeclaredElement.PhysicalPath">
            <summary>Path to the actual physical file</summary>
            <remarks>May differs from logic path in XAML universal apps and WinRT resource file references.</remarks>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IPathDeclaredElement.IsDirectory">
            <summary>Returns Path.ExistsDirectory by default</summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.CollectionTypeUtil.ElementTypeByCollectionType(JetBrains.ReSharper.Psi.IType,JetBrains.ReSharper.Psi.Tree.ITreeNode,JetBrains.ReSharper.Psi.Resolve.IAccessContext)">
            <summary>
            Returns element type if collectionType is a _collection_type_ (described in specification, 15.8.4)
            otherwise, returns null
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.CollectionTypeUtil.GetTypeContainingEnumerable(JetBrains.ReSharper.Psi.IType,JetBrains.ReSharper.Psi.Tree.ITreeNode,JetBrains.ReSharper.Psi.Resolve.IAccessContext)">
            <summary>
            Get the topmost type which contains corresponding 'GetEnumerator' by given type of collection
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExpectedTypes.ConvertibleFromConstraint">
            <summary>
            Base class for constraint which accepts all types assignable to a given type
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExpectedTypes.ConvertibleFromExpressionTypeConstraint">
            <summary>
            Constraint implementation which accepts all types assignable to a given type
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExpectedTypes.ConvertibleToConstraint">
            <summary>
            Base class for constraint which accepts all types assignable to a given type
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExpectedTypes.ExpectedTypeMode">
            <summary>
            Completion Mode = Ignore tree after expression
            BlackHole Mode = Ignore only this expression
            Precise Mode = Take full tree
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExpectedTypes.IExpectedTypesProvider.GetExpectedTypes(JetBrains.ReSharper.Psi.Tree.IExpression,JetBrains.ReSharper.Psi.ExpectedTypes.ExpectedTypeMode)">
            <summary>
            Get all possible types which could present at expression's place
            If there are more than 1 type, then the first is more preferable.
            For example:
            <code>
              Foo(int);
              Foo(string);
            ........
              Foo({caret}"");
            </code>
            expected types at caret will be (string, int), but the string is first
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExpectedTypes.ExpectedTypesUtil.GuessTypesIntersectionOrComposition(System.Collections.Generic.IList{JetBrains.ReSharper.Psi.Tree.IExpression})">
            <summary>
            Returns type intersection, but if intersection is empty then returns composition
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExpectedTypes.IsSubtypeOfConstraint">
            <summary>
            Accepts types which inherit from the specified type
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExpectedTypes.JoinConstraint">
            <summary>
            Joins multiple constraints (a type matches joined constraint 
            if it matches at least one of nested constraints)
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExpectedTypes.ReferenceTypeConstraint">
            <summary>
            Constraint which accepts only reference types
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExpectedTypes.SuperTypeConstraint">
            <summary>
            Constraint which accepts only super types of  a given type
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.CachedTypeMemberBase.CanBindTo(JetBrains.ReSharper.Psi.Tree.IDeclaration)">
            <summary>
            Check by syntax. Shouldn't resolve here to prevent deadlocks!
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.TypePart">
            <summary>
            Base class for language-dependent cached type declarations
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.Part">
            <summary>
            a node of cache tree 
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.DeclarationPart.AssignDeclaredElement(JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ICachedDeclaration2)">
            <summary>
            Implementations should override this method to bind their declarations to their declared elements
            </summary>
            <param name="declaration"></param>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.TypePart.ExtendsListShortNames">
            Mustn't create PSI. Better to don't make this property lazy, cause it is used in ICache.Merge().
            If you invoke GetDeclarations() inside, it could lead to creating PSI and ProcessCancelledException.
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExpectedTypes.InvocationCandidate">
            <summary>
            An invocation target candidate for invocation context
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.CaseInsensitiveNamespaceRegistrar.myMap">
            keys are normalized qnames
        </member>
        <member name="F:JetBrains.ReSharper.Psi.DeclaredElementPresenter.KIND_PRESENTER">
            <summary>
            A presenter that returns strings containing declared element entity kind.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.DeclaredElementPresenter.INKIND_PRESENTER">
            <summary>
            A presenter that returns strings containing declared element entity kind with "in" preposition.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.DeclaredElementPresenter.FROMKIND_PRESENTER">
            <summary>
            A presenter that returns strings containing declared element entity kind with "from" preposition.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.DeclaredElementPresenter.KIND_NAME_PRESENTER">
            <summary>
            A presenter that returns strings containing declared element entity kind and declared element name.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.DeclaredElementPresenter.NAME_PRESENTER">
            <summary>
            A presenter that returns strings containing declared element name.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.DeclaredElementPresenter.KIND_QUALIFIED_NAME_PRESENTER">
            <summary>
            A presenter that returns strings containing declared element entity kind and declared element qualified name.
            Designed for <see cref="T:JetBrains.ReSharper.Psi.ITypeElement"/> and <see cref="T:JetBrains.ReSharper.Psi.INamespace"/>.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.DeclaredElementPresenter.QUALIFIED_NAME_PRESENTER">
            <summary>
            A presenter that returns strings containing declared element qualified name.
            Designed for <see cref="T:JetBrains.ReSharper.Psi.ITypeElement"/> and <see cref="T:JetBrains.ReSharper.Psi.INamespace"/>.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.DeclaredElementPresenter.MakeSmaller(JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle,System.String@,JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking@)">
            <summary>
            Tries to cut a long string with <see cref="T:JetBrains.ReSharper.Psi.IParametersOwner"/> by replacing some of the closing parameters with "â€¦".
            </summary>
            <param name="presenter"></param>
            <param name="str">"Long" string containing a presentation of a <see cref="T:JetBrains.ReSharper.Psi.IParametersOwner"/>.
            If cutting succeds the altered <code>str</code> contains a "shortened" presentation of the <see cref="T:JetBrains.ReSharper.Psi.IParametersOwner"/>.</param>
            <param name="marking">Marking of a <see cref="T:JetBrains.ReSharper.Psi.IParametersOwner"/>.
            If cutting succeds the altered <code>str</code> contains a "shortened" presentation of the <see cref="T:JetBrains.ReSharper.Psi.IParametersOwner"/>.</param>
            <returns><code>true</code> if succeds to shorten a string.</returns>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.ExtensionsAPI.Finder.TextOccurrenceSearcherBase`1.Predicate">
            <summary>
            Get the predicate to check if the given node should be checked for text occurrence
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.ExtensionsAPI.ReferenceContextCodec.myLocalDeclarations">
            <summary>
            Map from declared elements in original subtree into declaration in clone subtree
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.ReferenceContextCodec.FindDependentReferences(JetBrains.ReSharper.Psi.Resolve.IReference,System.Boolean)">
            <summary>
            Get references which should be fake-binded along with the given one
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Filters.LocalModuleNamesFilter">
            <summary>
            Prefer symbols defined in given assembly if their FQN is the same
            Note: symbols from assembly with "Embed Interop Types = true" counted as locals
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.IDocCommentReference.TagName">
            <summary>
            Tag name in which this reference occurs
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Verification.IVerifier.Verify(JetBrains.ReSharper.Psi.Resolve.Managed.IResolveContext,JetBrains.ReSharper.Psi.Tree.ITreeNode)">
            <summary>
            Returns <c>null</c> if for "no-problem"
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.IAsyncCommitClient">
            <summary>
            Implement this interface if you want your class to participate in async commit process <see cref="T:JetBrains.ReSharper.Psi.AsyncCommitService"/>. Commit will happen after this client executes
            <see cref="M:JetBrains.ReSharper.Psi.AsyncCommitService.RequestCommit(JetBrains.ReSharper.Psi.IAsyncCommitClient,System.Nullable{System.Int32})"/> (time is up to <code>200ms + nAttempt*30ms</code> where <code>nAttempt</code> depends whether PSI is in bad state - 
            current transaction not null, write lock is held, etc.)
            
            When commit happens <see cref="T:JetBrains.ReSharper.Psi.AsyncCommitService"/> invokes all registered for this commit <see cref="T:JetBrains.ReSharper.Psi.IAsyncCommitClient"/> and clear registered queue, so client must register
            itself again via <see cref="M:JetBrains.ReSharper.Psi.AsyncCommitService.RequestCommit(JetBrains.ReSharper.Psi.IAsyncCommitClient,System.Nullable{System.Int32})"/> to participate in the next async commit. 
            
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IAsyncCommitClient.BeforeCommit">
            <summary>
            Method is invoked on the main thread under ReadLock before actual <see cref="M:JetBrains.ReSharper.Psi.Files.IPsiFiles.CommitAllDocumentsAsync(System.Action,System.Action)"/> happens. Returns action
            that should be executed after async commit. Caution: if returns null, no <see cref="M:JetBrains.ReSharper.Psi.IAsyncCommitClient.OnInterrupt"/> invocation will be performed in case of async commit interruption.
            </summary>
            <returns>Action that should be executed after actual async commit in successful continuation (main thread, read lock)</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IAsyncCommitClient.OnInterrupt">
            <summary>
            Action that should be executed after actual async commit in failure continuation (main thread, read lock), if <see cref="T:JetBrains.Application.Progress.ProcessCancelledException"/> was thrown. Warning: 
            <see cref="M:JetBrains.ReSharper.Psi.IAsyncCommitClient.OnInterrupt"/> will be called ONLY if <see cref="M:JetBrains.ReSharper.Psi.IAsyncCommitClient.BeforeCommit"/> returned not null action (and, of course, async commit process was interrupted).
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Caches.CacheWorkItemSubprogress">
            <summary>
            If a cache job wants to display more detailed progress while it's running, it can request a <see cref="T:JetBrains.Application.Progress.IProgressIndicator"/>-based object from the <see cref="!:CacheJobServiceAsync"/>.
            It must be <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Stop"/>-ed before the job ends.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Caches.CacheWorkItemSubprogress.myNotifier">
            <summary>
            The owning notifier to which our display goes.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Caches.CacheWorkItemSubprogress.myThread">
            <summary>
            Thread affinity.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Caches.CacheWorkItemSubprogress.#ctor(JetBrains.ReSharper.Psi.Caches.PsiCacheNotifier,JetBrains.DataFlow.StandardPreconditions.ReadonlyToken,System.Func{System.Boolean},JetBrains.UI.Application.Progress.TaskThreadAffinity)">
            <summary>
            Creates a special progress for the cache work items.
            Ensures the progress is started/stopped appropriately and its threading is respected. Only progress and texts can be set in free-threaded manner.
            </summary>
            <param name="notifier">Owner of the global progress.</param>
            <param name="theCacheNotifierOwnershipCookie">Gives write access to the cache progress.</param>
            <param name="FIsCanceled">A function to check for canceling. Might be called on any thread, see <paramref name="threadaffinity"/>.</param>
            <param name="threadaffinity">Defines whether select methods are allowed to be called on another thread.</param>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Caches.CacheWorkItemSubprogress.Enable(System.Double,System.Double,System.String)">
            <summary>
            Enables the progress while a job is running, mapping it to the range occupied by the job; disables on disposal.
            Must be called on the cache thread.
            </summary>
            <param name="rangestart">Subprogress range.</param>
            <param name="rangelength">Subprogress range.</param>
            <param name="sJobIdentity">The job identity, so that to include its name in error messages.</param>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Caches.CacheWorkItemSubprogress.AssertApartmentThreadedCall">
            <summary>
            The call must be placed on the same thread this object was created on.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Caches.CacheWorkItemSubprogress.AssertFreeThreadedCall">
            <summary>
            This call can be placed on any thread, if allowed by <see cref="F:JetBrains.ReSharper.Psi.Caches.CacheWorkItemSubprogress.myThreadAffinity"/>.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Caches.CacheWorkItemSubprogress.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Caches.SymbolCache.TypeMembersBucket.UpdateCachesInProgress">
            <summary>
            Indicates that massive bulk oparetion is in progress
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Impl.DeclaredElementEqualityComparer">
            <summary>
            Check if given declared elements are 'equal'
            For type Elements: This will check possible runtime binding, i.e. 2 type elements from assemblies equals if their FQN equals, and assembly names are the same
            For Type Members: Containing type equality + signature equality
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Impl.DeclaredElementEqualityComparer.TypeElementComparer">
            <summary>
            Check possible runtime binding, i.e. 2 type elements from assemblies equals if their FQN equals, and assembly names are the same
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Impl.DeclaredElementEqualityComparer.MemberComparer">
            <summary>
            Containing type equality <see cref="F:JetBrains.ReSharper.Psi.Impl.DeclaredElementEqualityComparer.TypeElementComparer"/> + signature equality + extra checks
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Impl.DeclaredElementEqualityComparer.ElementComparer">
            <summary>
            Containing type equality <see cref="F:JetBrains.ReSharper.Psi.Impl.DeclaredElementEqualityComparer.TypeElementComparer"/> + signature equality + extra checks
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.DeclaredElementEqualityComparer.IsEqualEmbeddedComInteropTypes(JetBrains.ReSharper.Psi.ITypeElement,JetBrains.ReSharper.Psi.ITypeElement)">
            <summary>
            http://msdn.microsoft.com/en-us/library/dd997297%28VS.100%29.aspx
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Naming.Elements.NamedElementsBagAttribute.#ctor(System.Type)">
            <param name="languageType">'null' for cross language elements</param>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Naming.Extentions.NameChangeUtil.GetSuggestedName(JetBrains.ReSharper.Psi.Naming.Impl.NameRoot,JetBrains.ReSharper.Psi.Naming.Impl.NameRoot,JetBrains.ReSharper.Psi.Naming.Impl.NameRoot)">
            <summary>
            
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Naming.Impl.NameWord.ourSkipTailInfix">
            <summary>
            ElementOfPointer -> Pointer
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Naming.Impl.NameWord.ourPredefinedPrefixes">
            <summary>
            GetPointer -> Pointer
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Naming.Impl.NameWord.ourCollectionSuffixes">
            <summary>
            ElementList -> Element
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Resolve.IQualifier.Resolved">
            <summary>
            False means failed to resolve
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.Caches.AbstractPersistentCache`2.Load(JetBrains.Application.Progress.IProgressIndicator)">
            <summary>
            Returns false in the following cases:
              - cache directory does not exist
              - cache format version did not match
              - one or more record's CRC did not match
              - total cache CRC did not match
              - IO problem occured
            In all these cases it automatically resets the cache on the disk to an empty one.
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Util.StringLiteralConverter">
            <summary>
            Summary description for StringLiteralConverter.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.StringLiteralConverter.CharSequence.#ctor(System.String)">
            <summary>
            Creates a new instance of CharEscape
            </summary>
            <param name="hex"></param>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Impl.CodeStyle.IGeneratedCodeRegionDetector">
            <summary>
            Should be used in cooperation with recursive element processor to check generated code regions
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Impl.CodeStyle.OptimizeImportReferenceType.IGNORE">
            <summary>
            Do not optimize this reference
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Impl.CodeStyle.OptimizeImportReferenceType.DO_NOT_TOUCH">
            <summary>
            Do not optimize this reference, but remeber it's resolve
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Impl.CodeStyle.OptimizeImportReferenceType.DO_NOT_SHORTEN">
            <summary>
            Do not shorten this reference, but re-bind
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Impl.CodeStyle.OptimizeImportReferenceType.SIGNATURE">
            <summary>
            Reference is signature reference
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Impl.CodeStyle.OptimizeImportReferenceType.CODE_BLOCK">
            <summary>
            Reference is in code block
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Impl.CodeStyle.OptimizeImportReferenceType.EXTENSION_METHOD">
            <summary>
            Reference is for extension method
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.CodeStyle.IOptimizeImportsServiceProvider.GetReferenceType(JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.IQualifiableReference,JetBrains.ReSharper.Psi.IDeclaredElement)">
            <summary>
            Check if the given reference is located in code block, or in delcaration level
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.CodeStyle.OptimizeImportsEngine.Optimize(JetBrains.ReSharper.Psi.Tree.IFile,JetBrains.DocumentModel.IRangeMarker,System.Boolean,System.Boolean,JetBrains.Application.Progress.IProgressIndicator)">
            <summary>
            Do optimize imports and shorten references. 
            Parameter <paramref name="rangeMarker"/> specifies range in file which is 
            affected by the process, or set it to <see cref="F:JetBrains.DocumentModel.DocumentRange.InvalidRange"/> 
            to process whole file
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Impl.CodeStyle.OptimizeImportsEngine.OptimizeReferenceCollector">
            <summary>
            Collect and sort references which are affected bu optimze imports engine
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.CodeStyle.OptimizeImportsEngine.OptimizeReferenceCollector.Collect(JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.IQualifiableReference)">
            <summary>
            Returns true, if qualifier should not be visited
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.PredefinedOperator.#ctor(JetBrains.ReSharper.Psi.PsiLanguageType,System.String,JetBrains.ReSharper.Psi.IType,System.Int32)">
            <summary>
            For creating operators with common type for parameters and return type
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Resolve.ICompleteableReference.GetCompletionSymbolTable">
            <summary>
            Returns symbol table for code completion
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resolve.TypeInference.TypeEquationsSolver">
            <summary>
            Depends on language specific implementation of the interface ITypeInferenceBoundsSolver
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Tree.ITypeArgumentsOwnerElement">
            <summary>
            Unifies cross-language reference names and reference expressions
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.CLRTypeConversionUtil.VariantConvertible(System.Collections.Generic.IList{JetBrains.ReSharper.Psi.ITypeParameter},JetBrains.ReSharper.Psi.Resolve.ISubstitution,JetBrains.ReSharper.Psi.Resolve.ISubstitution,System.Func{JetBrains.ReSharper.Psi.IType,JetBrains.ReSharper.Psi.IType,System.Boolean})">
            <summary>
            A type T{A1, â€¦, An} is variance-convertible to a type T{B1, â€¦, Bn} if T is either an interface or a delegate type declared with the variant type parameters T{X1, â€¦, Xn}, and for each variant type parameter Xi one of the following holds:
            â€¢  Xi is covariant and an implicit reference or identity conversion exists from Ai to Bi
            â€¢  Xi is contravariant and an implicit reference or identity conversion exists from Bi to Ai
            â€¢  Xi is invariant and an identity conversion exists from Ai to Bi
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.CLRTypeConversionUtil.MostEncompassedType(System.Collections.Generic.IList{JetBrains.ReSharper.Psi.IType})">
            <summary>
            Select the single type in the collection, which is implictly convertible to all others
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ControlFlow.Impl.ControlFlowGraph.FixUp">
            <summary>
            Fixup graph into canonical representation. 
            Prepare reachable sequence for inspection and analyze reacability of elements
            Should be called from any inheritor constructor
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Impl.PsiIconManagerImpl">
            <summary>
            Implementation for <see cref="T:JetBrains.ReSharper.Psi.PsiIconManager"/>
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.PsiIconManager">
            <summary>
            Abstract interface for building model icon managers
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.PsiIconManager.GetDummyImage">
            <summary>
            Get the empty image of the typical size
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.PsiIconManager.GetImage(JetBrains.ReSharper.Psi.IDeclaredElement,JetBrains.ReSharper.Psi.PsiLanguageType,System.Boolean)">
            <summary>
            Gets image for declared element
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.PsiIconManager.GetImage(JetBrains.ReSharper.Psi.DeclaredElementType)">
            <summary>
            Gets image by declared element type
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.PsiIconManager.GetImage(JetBrains.ReSharper.Psi.DeclaredElementType,JetBrains.ReSharper.Psi.PsiIconExtension)">
            <summary>
            Gets image by declared element type
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.PsiIconManager.ExtendToTypicalSize(JetBrains.UI.Icons.IconId)">
            <summary>
            Extends the specified node image (16x16) to typical size
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.PsiIconManager.AttachExtensions(JetBrains.UI.Icons.IconId,JetBrains.ReSharper.Psi.PsiIconExtension)">
            <summary>
            Attaches extension to given image
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.PsiIconManager.AddExtension(JetBrains.DataFlow.Lifetime,JetBrains.ReSharper.Psi.IDeclaredElementIconProvider)">
            <summary>
            Use the method for non-shell-lifetime extensions
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.PsiIconManager.AddExtension(JetBrains.DataFlow.Lifetime,JetBrains.ReSharper.Psi.IDeclaredElementIconExtensionProvider)">
            <summary>
            Use the method for non-shell-lifetime extensions
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.PsiIconManager.TransparentIconOfTypicalPsiIconSize">
            <summary>
            Gets typical size of images produced by the manager
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Pointers.IElementInstancePointer`1">
            <summary>
            A smart element which resurrects from model changes by tracking its location
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Impl.Search.ConstructorSpecialReferenceSearchProcessor">
            <summary>
            Search for ":this()", ":base()" references....
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IProjectFileCustomPsiPropertiesProvider.GetCustomProperties``1(JetBrains.ProjectModel.IProjectFile,JetBrains.ReSharper.Psi.IPsiSourceFile)">
            <summary>
            Get custom PSI properties for specific project file type
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.PsiIconExtension">
            <summary>
            Enumerates possible node types
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.DeclaredElementIconProviderAttribute">
            <summary>
            Use this attribute if and only if your component's lifetime is PSI-shared (i.e. shell-level)
            Use other part attributes otherwise (this can be language or solution). See inheritors of IPsiIconManagerExtension
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resolve.ElementAccessContext">
            <summary>
            IAccessContext implementation based on element
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Tree.IDefaultNamespaceOwner">
            <summary> 
            This interface is implemented by <see cref="T:JetBrains.ReSharper.Psi.Tree.IFile"/> implementations when there is defaut namespace
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.IDocCommentBlock.GetXML(JetBrains.ReSharper.Psi.ITypeMember)">
             <summary>
             Get the XML node for this doc comment, using given <paramref name="element" /> as the header
             </summary>
            <param name="element"></param>
            <returns>Doc comment XML node</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.IDocCommentBlock.GetErrors">
            <summary>
            Get errors from XML parsing
            </summary>
            <returns>
            </returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.FileExtensions.Translate(JetBrains.ReSharper.Psi.Tree.IFile,JetBrains.DocumentModel.DocumentRange)">
            <summary>
            Translate coordinates in any document into range the given psi tree.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.FileExtensions.GetDocumentRange(JetBrains.ReSharper.Psi.Tree.IFile,JetBrains.ReSharper.Psi.TreeTextRange)">
            <summary>
            Translate the specified range in syncronized text into actual document range
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.FileExtensions.GetCoveringDocumentRange(JetBrains.ReSharper.Psi.Tree.IFile,JetBrains.ReSharper.Psi.TreeTextRange)">
            <summary>
            Get the union of intersecting document ranges
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.FileExtensions.GetIntersectingRanges(JetBrains.ReSharper.Psi.Tree.IFile,JetBrains.ReSharper.Psi.TreeTextRange)">
            <summary>
            Get all ranges in actual document which intersects with given range in syncronized text
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.FileExtensions.GetIntersectingRanges(JetBrains.ReSharper.Psi.Tree.IFile,JetBrains.DocumentModel.DocumentRange)">
            <summary>
            Get all ranges in the file which intersects with given range in actual document.
            Achtung! Implementation is not effective and should be optimized.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Tree.IIdentifier.Name">
            <summary>
            Returns name denoted by this identifier without language-specific stuff like '@' in C#
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.InterfaceEx.CanBeInstantiated(JetBrains.ReSharper.Psi.IInterface)">
            <summary>
            Indicates if the interface can be instantiated using object creation expression
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.OverridableMemberExtensions.GetImmediateSuperMembers(JetBrains.ReSharper.Psi.IOverridableMember,System.Boolean)">
            <summary>
            Finds all immediate supermembers for this member.
            </summary>
            <param name="overridableMember"></param>
            <param name="searchQuasi">if true, returns quasisupermembers too.</param>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.OverridableMemberExtensions.HasImmediateSuperMembers(JetBrains.ReSharper.Psi.IOverridableMember,System.Boolean)">
            <summary>
            Check if member has supers
            </summary>
            <param name="overridableMember"></param>
            <param name="searchQuasi">if true, returns quasisupermembers too.</param>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.OverridableMemberExtensions.GetRootSuperMembers(JetBrains.ReSharper.Psi.IOverridableMember,System.Boolean)">
            <summary>
            Finds all root supermembers for this member.
            </summary>
            <param name="overridableMember"></param>
            <param name="searchQuasi">if true, returns quasisupermembers too.</param>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.OverridableMemberExtensions.GetAllSuperMembers(JetBrains.ReSharper.Psi.IOverridableMember,System.Boolean)">
            <summary>
            Finds all supermembers for this member.
            </summary>
            <param name="overridableMember"></param>
            <param name="searchQuasi">if true, returns quasisupermembers too.</param>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.OverridableMemberExtensions.OverridesOrImplements(JetBrains.ReSharper.Psi.IOverridableMember,JetBrains.ReSharper.Psi.IOverridableMember)">
            <summary>
            Checks if the given member is supermember
            </summary>
            <param name="derivedMember"></param>
            <param name="superMember"></param>
            <returns></returns>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Tree.INamespaceDeclaration.QualifiedName">
            <summary>
            Returns qualified name of the namespace this declaration declares
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.TypeElementExtensions.IsDescendantOf(JetBrains.ReSharper.Psi.ITypeElement,JetBrains.ReSharper.Psi.ITypeElement)">
            <summary>
            Returns true if the type is (not necessary immediate) descendant of another type
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.TypeElementExtensions.GetMembers(JetBrains.ReSharper.Psi.ITypeElement,System.String)">
            <summary>
            returns all members of this type (including nested types!) with given name
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.TypeElementExtensions.GetAllTypeParameters(JetBrains.ReSharper.Psi.ITypeElement)">
            <summary>
            returns the enumerator through type parameters of this type and all container types
            </summary>
            Type parameters are enumerated in right-to-left, nested class first order
            In the following example
            <code>
            class A&lt;X,Y&gt;
            {
               class B&lt;Z,W&gt; {}
            }
            </code>
            AllTypeParameters for class B will be enumerated in order W,Z,Y,X
        </member>
        <member name="F:JetBrains.ReSharper.Psi.TypeParameterVariance.INVARIANT">
            <summary>No variance</summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.TypeParameterVariance.IN">
            <summary>Contra-Variant, in</summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.TypeParameterVariance.OUT">
            <summary>Co-Variant, out</summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.IChameleonNode.ReSync(JetBrains.ReSharper.Psi.Parsing.CachingLexer,JetBrains.ReSharper.Psi.TreeTextRange,System.Int32)">
            <summary>
            Try to incrementally reparse the chameleon block
            </summary>
            <param name="cachingLexer">lexer of the new text</param>
            <param name="changedRange">range in text which is modified</param>
            <param name="insertedTextLen">Length of the inserted portion of the text</param>
            <returns>new chameleon if successful. null if can't synchronize</returns>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle">
            <summary>
            This class is a convertor from IDeclaredElement into presentable string with various options.
            </summary>
            Generally this class is used to prepare strings for displaying information to user as is done
            in the following code fragment:
            <code>
            class SomeClass
            {
              private static ourFormatter;
              
              static SomeClass()
              {
                ourFormatter  = new DeclaratedElementPresenter();
                // set desired options
                ourFormatter.ShowParameterTypes = true;
                ourFormatter.ShowParameterNames = true;
                ourFormatter.ShowBrackets = false;
              }
              
              public string[] Display(IDeclaredElement element)
              {
                System.Windows.Forms.MessageBox.Show("Readable presentation of IDeclaredElement : " + ourFormatter.Format(element));
              }
              public string[] Display(IDeclaredElementInfo info)
              {
                System.Windows.Forms.MessageBox.Show("Readable presentation of IDeclaredElementInfo : " + ourFormatter.Format(info));
              }
            }
            </code>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle.ShowAccessRights">
            <summary>
            Indicates if we should show accees rights of a <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/> (if any)
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle.ShowModifiers">
            <summary>
            Indicates if we should show the modifiers other than access rights <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/>.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle.ShowParametersForDelegates">
            <summary>
            Indicates if we should show parameters for a <see cref="T:JetBrains.ReSharper.Psi.IDelegate"/>.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle.ShowEntityKind">
            <summary>
            Indicates if the result string should contain element entity kind
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle.ShowName">
            <summary>
            Indicates if the result string should contain element name
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle.ShowTypeParameters">
            <summary>
            Indicates if type parameters should be shown
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle.ShowExplicitInterfaceQualification">
            <summary>
            Indicates if the explicit interface qualification should be shown before type member name
            This option is incompatible with ShowName == NameStyle.QUALIFIED
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle.ShowNameInQuotes">
            <summary>
            Indicates if the result string should contain element name (including signature, return type, etc.) enclosed in quotes
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle.ShowType">
            <summary>
            Indicates where and how 
            <list type="bullet">
            <item>type of a variable </item>
            <item>return type of a function</item>
            </list>
            should be inserted into result
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle.ShowParameterTypes">
            <summary>
            Indicates if the parameter list of a function should contain parameter types
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle.ShowParameterNames">
            <summary>
            Indicates if the parameter list of a function should contain parameter names
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle.ShowTypesQualified">
            <summary>
            Indicates if  
            <list type="bullet">
            <item>return type of a function</item>
            <item>parameter types of a function</item>
            <item>type of a variable</item>
            </list>
            should be fully qualified.
            Does not affect <see cref="T:JetBrains.ReSharper.Psi.ITypeElement"/>.
            To specify qualified names for <see cref="T:JetBrains.ReSharper.Psi.ITypeElement"/> 
            use <see cref="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle.ShowTypeContainer"/> property.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle.ShowMemberContainer">
            <summary>
            Indicates where the container type of a type member should be shown.
            Affects only <see cref="T:JetBrains.ReSharper.Psi.ITypeMember"/>.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle.MemberContainerQualified">
            <summary>
            Indicates how the container type of a type member should be shown.
            Affects only <see cref="T:JetBrains.ReSharper.Psi.ITypeMember"/>.
            Workd only if 
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle.ShowTypeContainer">
            <summary>
            Indicates if the containing type or namespace of a <see cref="T:JetBrains.ReSharper.Psi.ITypeElement"/> should be shown and where it should be shown.
            Affects only <see cref="T:JetBrains.ReSharper.Psi.ITypeElement"/>.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle.ShowNamespaceContainer">
            <summary>
            Indicates if the containing namespace of a <see cref="T:JetBrains.ReSharper.Psi.INamespace"/> should be shown and where it should be shown.
            Affects only <see cref="T:JetBrains.ReSharper.Psi.INamespace"/>.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle.ShowParameterContainer">
            <summary>
            Indicates if the containing method of a <see cref="T:JetBrains.ReSharper.Psi.IParameter"/> should be shown and where it should be shown.
            Affects only <see cref="T:JetBrains.ReSharper.Psi.IParameter"/>.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle.LengthLimit">
            <summary>
            Sets the output string length limit.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle.LengthCheck">
            <summary>
            Returns interface for computing output string length
            Delagate for custom length checker. Length check is used to replace long parameter lists with "â€¦".
            <see cref="T:JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle"/> is capable of calculating length itself (<see cref="M:JetBrains.ReSharper.Psi.DeclaredElementPresenter.MakeSmaller(JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle,System.String@,JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking@)"/>.
            However, if there are other length considerations (e.g. UI limitations) this class may be used.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle.ShowConstantValue">
            <summary>
            Indicates if the value of a constants is to be shown.
            Affects constants and parameters default value.
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ProjectFilePart">
            <summary>
            Root of cached declarations tree for a file
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.NamespacePart">
            <summary>
            Base class for language-dependent cached namespace decls
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.DeclaredElements.TypeElementImplUtil.ComputeSubstitution(JetBrains.ReSharper.Psi.ITypeElement,JetBrains.ReSharper.Psi.ITypeElement)">
            <summary>
            Implemenatation of <a cref="!:ITypeElement.GetAncestorSubstitution"/>
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.DeclaredElements.TypeElementImplUtil.ComputeDistance(JetBrains.ReSharper.Psi.ITypeElement,JetBrains.ReSharper.Psi.ITypeElement)">
            <summary>
            Implemenatation of <a cref="!:ITypeElement.GetDistance"/>
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExtensionsAPI.GeneratedDocumentServiceAttribute">
            <summary>
            Indicates that the marked class provides service for generated document
            </summary>  
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.IGeneratedDocumentService.GetSecondaryPsiLanguageTypes(JetBrains.ProjectModel.IProject)">
            <summary>
            All possible languages of documents generated by this service.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.IGeneratedDocumentService.IsSecondaryPsiLanguageType(JetBrains.ProjectModel.IProject,JetBrains.ReSharper.Psi.PsiLanguageType)">
            <summary>
            Is language generated by this service
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.IGeneratedDocumentService.CanHandle(JetBrains.ProjectModel.ProjectFileType)">
            <summary>
            Additional checks, whether the file is handled by this service.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.IGeneratedDocumentService.Generate(JetBrains.ReSharper.Psi.Files.PrimaryFileModificationInfo)">
            <summary>
            Generates text of a secondary document. Temporary applied result of incremental (or full) reparse is provided.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.IGeneratedDocumentService.ExecuteSecondaryDocumentCommitWork(JetBrains.ReSharper.Psi.Files.PrimaryFileModificationInfo,JetBrains.ReSharper.Psi.Files.CachedPsiFile,JetBrains.ReSharper.Psi.TreeTextRange,System.String)">
            <summary>
            The process of generated document commit (in the case of primary document incremental reparse) can be overridden in this method.
            Returns null if full regeneration is required.
            This method is not allowed to do destructive changes due to interruptibility!
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.IGeneratedDocumentService.ProcessChangeFromGeneratedToPrimary(JetBrains.ReSharper.Psi.IPsiSourceFile,JetBrains.Util.TextRange,System.String,System.String,JetBrains.ReSharper.Psi.PsiLanguageType)">
            <summary>
            Called from transaction manager when generated document is changed.
            If method returns false current transaction fails.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.IGeneratedDocumentService.ProcessChangeFromPrimaryToGenerated(JetBrains.ReSharper.Psi.TreeTextRange,System.String,System.String,JetBrains.ReSharper.Psi.Files.ISecondaryRangeTranslator,JetBrains.ReSharper.Psi.Tree.IFile,JetBrains.ReSharper.Psi.Transactions.IPsiTransactionAction)">
            <summary>
             Called from transaction manager when primary document is changed
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.IGeneratedDocumentService.TryFindNavigationRangeInPrimaryDocument(JetBrains.ReSharper.Psi.Tree.ITreeNode)">
            <summary>
            Custom navigation range, for instance for page declarations in ASP
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.IGeneratedDocumentService.CreateSecondaryLexingService(JetBrains.ProjectModel.ISolution,JetBrains.ReSharper.Psi.Parsing.MixedLexer,JetBrains.ReSharper.Psi.IPsiSourceFile)">
            <summary>
            Creates provider of primary document composite lexer.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.IGeneratedDocumentService.AssertValid(JetBrains.ReSharper.Psi.Tree.IFile)">
            <summary>
            Checks that generated file is not corrupted
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.MultipleFilterSymbolTable">
            <summary>
            Filters symbol table with multiple filters
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Resolve.ISymbolInfo.Level">
            <summary>
              "depth level" of declared symbol
              for imported symbol (class or namespace)                          level = -1
              for namespaces and top-level classes without containing namespace level = 0
              for top-level classes with containing namespace                   level = 1
              for class members (including inner classes)                       level = level of containing class + 1
              for method parameters and local variables                         level = level of containing class + 2
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.FileElementBase.InitializeWithIdenticalDocumentRangeTranslator(JetBrains.DocumentModel.IDocument)">
            <summary>
            Set <see cref="P:JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.FileElementBase.DocumentRangeTranslator"/> to the given only if file has no yet any
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExtensionsAPI.LowLevelModificationUtil">
            <summary>
            Methods to modify PSI tree with commiting changes to document through PSI manager
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.ModificationUtil">
            <summary>
            Methods to modify PSI tree with reference re-binding
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.ModificationUtil.ReplaceChild``1(JetBrains.ReSharper.Psi.Tree.ITreeNode,``0)">
            <summary>
            Warning: <paramref name="newChild"/> should not be child of <paramref name="oldChild"/>
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.ModificationUtil.CreateCopyWithResolve(JetBrains.ReSharper.Psi.Tree.ITreeNode)">
            <summary>
            Create the copy of given ITreeNode under DummyHolder. All references are fake resolved
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.ModificationUtil.DeferredDecode(System.Action)">
            <summary>
            Execute the action with the deferred context decoding
            </summary>
            <param name="action"></param>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.IArrayType">
            <summary>
            Interface for array types.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IArrayType.ElementType">
            <summary>
            Obtain type of the array elements.
            Example: returns "int" for "int[]".
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IArrayType.Rank">
            <summary>
            Get the rank (number of dimensions) of the array
            Examples:
              int[]   -> Rank == 1
              int[][] -> Rank == 1 (since it's an array with elements type "int[]")
              int[,]  -> Rank == 2
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Pointers.IDeclaredElementPointer`1">
            <summary>
            A smart element which resurrects from model changes by tracking its location
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Pointers.TrivialElementPointer`1">
            <summary>
            Implements trivial element pointer functinality
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Pointers.NonPhysicalElementPointer`1">
            <summary>
            Implements trivial element pointer functinality
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Pointers.TrivialElementInstancePointer`1">
            <summary>
            Implements trivial element pointer functinality
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.INonCachableExpressionType">
            <summary>
            Marker interface indicating that give expression type couldn't be cached
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ModifiersOwnerExtension.CanBeOverriden(JetBrains.ReSharper.Psi.IModifiersOwner)">
            <summary>
            Checks if entity either abstract, virtual or override.
            That is to say, it can be overriden in derived classes
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Caches.PsiCacheNotifier.TakeOwnership(JetBrains.DataFlow.StandardPreconditions.ReadonlyToken)">
            <summary>
            Sets the ownership over the notifier, so that it could not be modified without a token.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Caches.PsiCacheNotifier.WaitForCaches(System.String,System.String)">
            <summary>
            Synchronously wait until caches are ready, with a popup progress window.
            </summary>
            <param name="callerName">Identifies the caller of the utility, so that he could understand the reason of the delay.</param>
            <param name="cancelButtonContent">Title of the Cancel button, or <c>Null</c> if the Cancel button should be disabled.</param>
            <returns><c>True</c> if the caches are ready, <c>False</c> if user-cancelled.</returns>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Caches.PsiCacheNotifier.Description">
            <summary>
            The additional (verbose comment) text for the notifier.
            This property can be set from any thread.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Caches.PsiCacheNotifier.Header">
            <summary>
            The main (title) text for the notifier.
            This property can be set from any thread.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Caches.PsiCacheNotifier.IsActive">
            <summary>
            Whether the cache notifier is current active.
            This means it should be visible on the screen, in either form, if additional conditions are met (eg VS window is active).
            This property can be set from any thread.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Caches.PsiCacheNotifier.Progress">
            <summary>
            The progress value for the cache notifier, must be in the [0â€¦1] range.
            This property can be set from any thread.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.CodeStyle.FormatterImplHelper.ReplaceSpaces(JetBrains.ReSharper.Psi.Tree.ITreeNode,JetBrains.ReSharper.Psi.Tree.ITreeNode,JetBrains.ReSharper.Psi.Tree.ITreeNode[],System.Boolean)">
            <summary>
            Replaces spaces between two nodes by specified new nodes.
            </summary>
            <remarks>Copy from CSharpFormattingStage.ReplaceSpaces() with no algorithmic changes</remarks>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.CodeStyle.FormatterImplHelper.TrimRight(JetBrains.ReSharper.Psi.Tree.ITreeNode)">
            <summary>
            Trim all left sibling nodes.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.CodeStyle.FormatterImplHelper.TrimLeft(JetBrains.ReSharper.Psi.Tree.ITreeNode)">
            <summary>
            Trim all left sibling nodes.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.CodeStyle.FormatterImplHelper.FindNodeToInsertIndentBefore(JetBrains.ReSharper.Psi.Tree.ITreeNode)">
            <summary>
            Skips node's zero-length prev siblings
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.CodeStyle.FormatterImplHelper.ComputeEndColumnOfNode(JetBrains.ReSharper.Psi.Tree.ITreeNode,System.Func{JetBrains.ReSharper.Psi.Tree.ITokenNode,System.Boolean},System.Func{JetBrains.ReSharper.Psi.Tree.ITokenNode,System.Boolean,System.Int32})">
            <summary>
            Calculates the end column of the given node. It is either
             - If node is multiline, the it the length of the first line
             - If the node is singleline, then it is the end position of the node
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.CodeStyle.FormatterImplHelper.HasTokenBetween(JetBrains.ReSharper.Psi.Tree.ITreeNode,JetBrains.ReSharper.Psi.Tree.ITreeNode,JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.NodeTypeSet)">
            <summary>
            Check if there are any of the given tokens set between two given nodes in the tree
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.SandBoxContextType.Replace">
            <summary>
            Indicates that sandbox is in-place of the context
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.SandBoxContextType.Child">
            <summary>
            Indicates that sandbox is a child of context
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.OverridableMemberImpl.ApplyOriginMemberSubstitution(JetBrains.ReSharper.Psi.OverridableMemberInstance,JetBrains.ReSharper.Psi.IOverridableMember,JetBrains.ReSharper.Psi.Resolve.ISubstitution)">
            <summary>
            Push method's type parameter substitutions from origin to result
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.OverridableMemberImpl.FindMembersInSuperInterfaces(JetBrains.ReSharper.Psi.OverridableMemberInstance,JetBrains.ReSharper.Psi.IDeclaredType,System.Collections.Generic.HashSet{JetBrains.ReSharper.Psi.IDeclaredType},System.Collections.Generic.HashSet{JetBrains.ReSharper.Psi.IDeclaredType})">
            <summary>
            find all interfaces of given type (except for ignored ones) which declared given member
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Files.CachedPsiFile.GetIncrementalReparseResultForSecondaryPsi(JetBrains.ReSharper.Psi.ExtensionsAPI.ISecondaryDocumentGenerationResult,JetBrains.DocumentModel.DocumentChange@)">
            <summary>
            Incremental reparse for secondary psi. 
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Files.CachedPsiFile.ReparseResult">
            <summary>
            Result of incremental reparse
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Files.CachedPsiFile.ReparseResult.CommitIncrementalReparse">
            <summary>
            Apply reparse result to the file
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Transactions.PsiTransactions">
            <summary>
            Manages nested PSI transactions
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Modules.IPsiModules.GetPsiModulesToReference(JetBrains.ProjectModel.IModule,JetBrains.Metadata.Reader.API.TargetFrameworkId)">
            <summary>
            Psi modules, that are referenced if a module (project or assembly) is referenced. Normally, the result contains
            primary module only but sometimes there might appear secondary modules, e.g. global resources in web application.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Modules.IPsiModules.GetPsiModules(JetBrains.ProjectModel.IProject)">
            <summary>All psi modules existing in project</summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Modules.IPsiModules.IsSourceProject(JetBrains.ProjectModel.IProject)">
            <summary>Returns true when compiled to CLR language of a project is supported</summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Modules.PsiModules.IsSourceProject(JetBrains.ProjectModel.IProject)">
            <summary>
            Returns true when compiled to CLR language of a project is supported
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Filters.StaticEnumMethodsFilter">
            <summary>
            Filters our static methods of class object
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.ResolveUtil.AddDeclarationsForProperDeclaredType(JetBrains.ReSharper.Psi.IDeclaredType,System.Int32,System.Boolean,JetBrains.ReSharper.Psi.Resolve.SymbolTableMode,JetBrains.ReSharper.Psi.Modules.IPsiModule,System.Collections.Generic.HashSet{JetBrains.ReSharper.Psi.IDeclaredType})">
            <summary>"Proper" declared type means that it does not refer to type parameter</summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Search.FinderUtil.CollectAllPossibleNames(JetBrains.ReSharper.Psi.IDeclaredElement)">
            <summary>
            collects all names by which elements can be used in code
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Search.FinderUtil.NarrowSearchDomainByAllWords(JetBrains.ProjectModel.ISolution,JetBrains.ReSharper.Psi.Search.ISearchDomain,System.String[])">
            <summary>
            Narrow search domain to files which contains ALL of the given words
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Search.FinderUtil.GetInheritorsClosure(JetBrains.ReSharper.Psi.ITypeElement)">
            <summary>
            Get all names of the possible inheritors and their count
            </summary>
            <param name="typeElement"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Search.FinderUtil.GetInheritorsClosure(JetBrains.ReSharper.Psi.IPsiServices,JetBrains.Metadata.Reader.API.IClrTypeName)">
            <summary>
            Get all names of the possible inheritors and their count
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Search.SearchDomain.DomainMeasuringHelper.Measure(JetBrains.ReSharper.Psi.Search.ISearchDomain)">
            <summary>
            Calculates total number of standalone elements + standalone files + assemblies + files in each PsiModule
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Search.SearchDomain.DomainMeasuringHelper.MeasureWithoutElements(JetBrains.ReSharper.Psi.Search.ISearchDomain)">
            <summary>
            Calculates total number of assemblies and files in each PsiModule
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Parsing.DocumentUpdatesAccumulator">
            <summary>
            Accumulates incremental changes in the document
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Parsing.LexerUtil.LookaheadToken(JetBrains.ReSharper.Psi.Parsing.ILexer,System.Int32)">
            <summary>
            Scan next k tokens
            </summary>
            <param name="lexer"></param>
            <param name="k"></param>
            <returns>Type of the k'th token</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Parsing.LexerUtil.LookaheadTokenSkipping(JetBrains.ReSharper.Psi.Parsing.ILexer,System.Int32,JetBrains.ReSharper.Psi.Parsing.TokenNodeType)">
            <summary>
            Scan next k tokens excepting node types of type "nodeTypeToSkip"
            </summary>
            <param name="lexer"></param>
            <param name="k"></param>
            <param name="nodeTypeToSkip">node types to skip while scanning</param>
            <returns>Type of the k'th token</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Parsing.LexerUtil.LookaheadToken``1(JetBrains.ReSharper.Psi.Parsing.ILexer{``0},System.Int32)">
            <summary>
            Scan next k tokens
            </summary>
            <param name="lexer"></param>
            <param name="k"></param>
            <returns>Type of the k'th token</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Parsing.LexerUtil.GetCurrTokenText(JetBrains.ReSharper.Psi.Parsing.ILexer)">
            <summary>
            Get the text of the current token of the lexer
            </summary>
            <param name="lexer"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Parsing.LexerUtil.AdvanceWhile``1(``0,JetBrains.ReSharper.Psi.Parsing.TokenNodeType)">
            <summary>
            Advance lexer while skip token is meet.
            </summary>
            <returns>Position of first node after advancing (can be end of buffer)</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Parsing.LexerUtil.AdvanceWhile``1(``0,JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.NodeTypeSet)">
            <summary>
            Advance lexer while skip tokens are meet.
            </summary>
            <returns>Position of first node after advancing (can be end of buffer)</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Parsing.TokenBuffer.ReScan(JetBrains.Util.TextRange,JetBrains.ReSharper.Psi.Parsing.ILexerFactory,JetBrains.Text.BufferRange)">
            <summary>
            Rescans the buffer incrementally and returns new instance of token buffer
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.PredefinedType.IsPredefinedNumeric(JetBrains.Metadata.Reader.API.IClrTypeName)">
            <summary>
            Checks if given type equals to predefined sbyte, byte, short, ushort, int, uint, long, ulong, decimal, double, float, char
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.PredefinedType.IsPredefinedIntegral(JetBrains.Metadata.Reader.API.IClrTypeName)">
            <summary>
            Checks if given type equals to predefined sbyte, byte, short, ushort, int, uint, long, ulong, char or string
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.PredefinedType.IsPredefinedIntegralNumeric(JetBrains.Metadata.Reader.API.IClrTypeName)">
            <summary>
            Checks if given type equals to predefined sbyte, byte, short, ushort, int, uint, long, ulong
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.PredefinedType.IsSimplePredefined(JetBrains.Metadata.Reader.API.IClrTypeName)">
            <summary>
            Checks if given type equals to predefined string, bool, sbyte, byte, short, ushort, int, uint, long, ulong, decimal, double, float, char
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.PredefinedType.IsSimplePredefinedClrName(JetBrains.Metadata.Reader.API.IClrTypeName)">
            <summary>
            Checks if given type equals to predefined string, bool, sbyte, byte, short, ushort, int, uint, long, ulong, decimal, double, float, char
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resolve.Refers.NO">
            <summary>
            Late-bound reference could never be resolved to given declared element
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resolve.Refers.MAYBE">
            <summary>
            Late-bound reference could be resolved to given declared element
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resolve.Refers.YES">
            <summary>
            Late-bound reference actually is not late-bound (i.e. statically typed), and resolves to given element
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Resolve.IFileReference.ExpectedExtensions">
            <summary>
            If empty, no filtering by extension is done
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resolve.ReferenceProviderFactoryAttribute">
            <summary>
            Attribute for custom reference provider factory
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resolve.FilterRunType.REGULAR">
            <summary>
            Just regular filter
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resolve.FilterRunType.MUST_RUN">
            <summary>
            Filter should be run, and if failed it produces candidates. 
            If failed on single result, the result doesnt become candidate!
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resolve.FilterRunType.MUST_RUN_NO_CANDIDATES">
            <summary>
            Filter should be run, and if failed it doesn't produce candidates
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resolve.SymbolTableMode">
            <summary>
            Used for symbol table builder. Determines if type members should be put into the table
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Resolve.SymbolTableMode.Accepts(JetBrains.ReSharper.Psi.Resolve.SymbolTableMode)">
            <summary>
            Check if the symbol table with <paramref name="mode"/> can be used when this mode is requested
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resolve.SymbolTableMode.TYPE_AND_NAMESPACES">
            <summary>
            Symbol table should contain only symbols, necessary for ReferenceName resolving. The vital that type members shouldn't be obtained
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resolve.SymbolTableMode.FULL">
            <summary>
            Complete symbol table - all necessary infos should be there
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Resolve.TypeInference.TypeInferenceUtil.ValidatePartialInferenceResultAgainstConstraints(JetBrains.ReSharper.Psi.Resolve.ISubstitution)">
            <summary>
            Validation of partial inference result for purposes of extension method symbol table filtering
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Resolve.TypeInference.TypeInferenceUtil.InferTypes(JetBrains.ReSharper.Psi.PsiLanguageType,JetBrains.ReSharper.Psi.IType,JetBrains.ReSharper.Psi.IType,System.Collections.Generic.ICollection{JetBrains.ReSharper.Psi.ITypeParameter},JetBrains.ReSharper.Psi.ITypeConversionRule)">
            <summary>
            Depends on language specific implementation of the interface ITypeInferenceBoundsSolver
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.TypeElementInheritanceCache.IsDescendantOf(JetBrains.ReSharper.Psi.ITypeElement,JetBrains.ReSharper.Psi.ITypeElement)">
            <summary>
            Determines if the given <paramref name="subType"/> is the descendant of the <paramref name="superType"/>
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.TypeElementInheritanceCache.IsImmidiateDescendantOf(JetBrains.ReSharper.Psi.ITypeElement,JetBrains.ReSharper.Psi.ITypeElement)">
            <summary>
            Determines if the given <paramref name="subType"/> is the descendant of the <paramref name="superType"/>
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Impl.Types.ArrayType.ArrayTypePointer">
            <summary>
            Holds pointer to an array type 
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ITypeDecorator">
            <summary>
            A type pointer which decorates another type pointer
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.ITypeDecorator.TypePointer">
            <summary>
            Get the underlying type pointer
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Impl.Types.ArrayType.ArrayTypePointer.TypePointer">
            <summary>
            Get the underlying type pointer
            </summary>  
        </member>
        <member name="T:JetBrains.ReSharper.Psi.IPointerType">
            <summary>
            Interface for unsafe code pointer type.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IPointerType.ElementType">
            <summary>
            Obtaing the underlying type, that is type of the element on which this pointer points.
            Example: for "int*" returns "int".
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Impl.Types.PointerType.PointerTypePointer">
            <summary>
            Points to a pointer type
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Impl.Types.PointerType.PointerTypePointer.TypePointer">
            <summary>
            Get the underlying type pointer
            </summary> 
        </member>
        <member name="T:JetBrains.ReSharper.Psi.InvocableSignature">
            <summary>
            The signature (name + parameters) of IInvocable. Signature is used to identify matching
            invocables, that is to say, invocables which have the same set of parameters and the identical name.
            </summary>
            Two InvocableSignature's are equal if they have the same name, parameter types and parameter kinds.
            Methods <see cref="M:System.Object.Equals(System.Object)"/> and <see cref="M:System.Object.GetHashCode"/> are implemented 
            by this class to match the above definition.
            <seealso cref="M:JetBrains.ReSharper.Psi.IParametersOwner.GetSignature(JetBrains.ReSharper.Psi.Resolve.ISubstitution)"/>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.InvocableSignature.Null">
            <summary>
            Instance of InvocableSignature that can be used as null value
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.InvocableSignature.#ctor(JetBrains.ReSharper.Psi.IParametersOwner,JetBrains.ReSharper.Psi.Resolve.ISubstitution,JetBrains.ReSharper.Psi.ISignatureComparer)">
            <summary>
            Creates signature by an IInvocable. It's better to use <see cref="M:JetBrains.ReSharper.Psi.IParametersOwner.GetSignature(JetBrains.ReSharper.Psi.Resolve.ISubstitution)"/>.
            </summary>
            <param name="parametersOwner">Invocable to create signature for</param>
            <param name="substitution"></param>
            <param name="defaultComparer">Specify default signature comparer. If <c>null</c> is given, then use strict comparer (as it is in CLR)</param>
            <seealso cref="M:JetBrains.ReSharper.Psi.IParametersOwner.GetSignature(JetBrains.ReSharper.Psi.Resolve.ISubstitution)"/>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.InvocableSignature.GetParameterKind(System.Int32)">
            <summary>
            Kind of parameter with index <c>parameterIndex</c>
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.InvocableSignature.Name">
            <summary>
            Name of IInvocable
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.InvocableSignature.ParameterCount">
            <summary>
            Parameter count of IInvocable
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.InvocableSignature.EqualitySubstitution">
            <summary>
            Returns substitution that should be applied to the types of this signature before comapring them for equality.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.SignatureComparers.Strict">
            <summary>
            Compare like Execution Engine does. Case sensitive, ref/out parameters differs and type modifiers are significant
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.TypeClassification.UNKNOWN">
            <summary>
            'Unresolved' and 'Unknown' types, unconstrained type parameter types, pointer types
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.TypeModifier.TypeModifierKind.OPTIONAL">
            <summary>modopt</summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.TypeModifier.TypeModifierKind.REQUIRED">
            <summary>modreq</summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.LanguageService.IsTypeMemberVisible(JetBrains.ReSharper.Psi.ITypeMember)">
            <summary>
            Check if the given type member is visible in this language
            </summary>
            <returns></returns>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.LanguageService.CodeFormatter">
            <summary>
            Get the code formatter
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.LanguageService.DeclaredElementPresenter">
            <summary>
            Provide language-specific presentation of the declared elements.
            Returns <c>null</c> if default presenter should be used
            </summary>
            You should never call this method directly.
            Use <cref>DeclaredElementPresenter.Format</cref>> instead.
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Parsing.IParser">
            <summary>
            Abstract parser interface
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Parsing.IParser.ParseFile">
            <summary>
            If a file contains non-trivial preprocessor or anything like that, RangeTranslator must be set befor file is returned
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Parsing.ParserService">
            <summary>
            Utility class for accessing Parsing services
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Search.SearchAction">
            <summary>
            Handy class for running search actions
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Transactions.TransactionResultEnum.Success">
            <summary>
            Transaction succeded
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Transactions.TransactionResultEnum.Failure">
            <summary>
            Transaction failed due to some internal reasons
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Transactions.TransactionResultEnum.Cancelled">
            <summary>
            Transaction failed due to ProcessCancelledException is caught (usually, user press "cancel" button in progress window)
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Transactions.TransactionResultEnum.EnsureWritableFailed">
            <summary>
            The attempt to ensure writable failed for some files
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Transactions.TransactionResultEnum.EnsureWritableChangesDetected">
            <summary>
            Some files were modified as a result of the attempt to make them writable
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.TypeFactory.CreateTypeWithDynamicSubsitution(JetBrains.ReSharper.Psi.ITypeElement,JetBrains.ReSharper.Psi.Modules.IPsiModule)">
            <summary>
            Creates declared type from given type element with dynamic substitution,
            i.e. where any type parameter corresponds to dynamic type
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.TypeFactory.CreateType(JetBrains.ReSharper.Psi.ITypeElement,JetBrains.ReSharper.Psi.IType[])">
            <summary>
            Creates a declared type for a given type element with given type parametre values
            </summary>
            Type parameter values should be specified for all type parameters of type element and its containing 
            type elements. They should appear in typeParameterValues array in outer-class-first, left-to-right order
            <returns></returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.TypeElementUtil.ContainsPossibleInfiniteInheritanceGraph(JetBrains.ReSharper.Psi.ITypeElement)">
            <summary>
            ECMA-335 part II (Metadata) paragraph 9.2 "Generics and recursive inheritance graphs"
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.TypeElementUtil.RetargetTo``1(``0,JetBrains.ReSharper.Psi.Modules.IPsiModule)">
            <summary>
            <para>Redirects given type to that one which is 'actual' in the context of given source module</para>
            <b>Rules of conversion:</b>
            <list>
            <item>convert embedded COM-interop type to original</item>
            <item>Convert framework classes to which are used in given source module (AKA binding redirect, AKA framework unification)</item>
            </list>
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.TypeElementUtil.IsFrameworkType(JetBrains.ReSharper.Psi.ITypeElement)">
            <summary>
            Check that given type is defined in standard BCL assembly
            </summary>
            <param name="typeElement"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.TypeElementUtil.StructFieldHasLayoutProblems(JetBrains.ReSharper.Psi.ITypeMember)">
            <summary>
            Ecma-335, Partition II, 13 Semantics of value types
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.TypeElementUtil.AddToFlatteningGraph(System.Collections.Generic.Dictionary{JetBrains.ReSharper.Psi.IDeclaredType,System.Collections.Generic.HashSet{JetBrains.ReSharper.Psi.IDeclaredType}},JetBrains.ReSharper.Psi.IDeclaredType,JetBrains.ReSharper.Psi.IType,System.Boolean)">
            <summary>
            return false if adding member causes problem in flattening graph
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.TypesUtil.IsTrueValueType(JetBrains.ReSharper.Psi.IType)">
            <summary>
            Check if type is value non-nullable type
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.TypesUtil.MostEncompassedType``1(System.Collections.Generic.ICollection{``0},JetBrains.ReSharper.Psi.ITypeConversionRule)">
            <summary>
            Select the single type in the collection, which is implictly convertible to all others
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.TypesUtil.MostEncompassingType(System.Collections.Generic.ICollection{JetBrains.ReSharper.Psi.IType},JetBrains.ReSharper.Psi.ITypeConversionRule)">
            <summary>
            Select the single type in the collection, to which all others are implicitly convertible
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.TypesUtil.RetargetType(JetBrains.ReSharper.Psi.IType,JetBrains.ReSharper.Psi.Modules.IPsiModule)">
            <summary>
            <para>Redirects given type to that one which is 'actual' in the context of given source module</para>
            <b>Rules of conversion:</b>
            <list>
            <item>convert embedded COM-interop type to original</item>
            <item>Convert framework classes to which are used in given source module (AKA binding redirect)</item>
            </list>
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.XmlIndex.XmlIndexingLexer">
            <summary>
            Xml file lexer with byte offset in file for each token
            </summary>
        </member>
    </members>
</doc>
