<?xml version="1.0"?>
<doc>
    <assembly>
        <name>JetBrains.Platform.Shell</name>
    </assembly>
    <members>
        <member name="T:JetBrains.Application.BuildScript.Application.IApplicationPackage">
            <summary>
            One application package (subplatform, plugin, etc).
            </summary>
        </member>
        <member name="P:JetBrains.Application.BuildScript.Application.IApplicationPackage.BestBefore">
            <summary>
            Gets the expiry date.
            </summary>
        </member>
        <member name="P:JetBrains.Application.BuildScript.Application.IApplicationPackage.BirthDate">
            <summary>
            The birth date of the package. Used for the lower copyright year and so on.
            </summary>
        </member>
        <member name="P:JetBrains.Application.BuildScript.Application.IApplicationPackage.BuiltOn">
            <summary>
            Gets the date and time when the current package was built.
            </summary>
        </member>
        <member name="P:JetBrains.Application.BuildScript.Application.IApplicationPackage.CompanyNameHuman">
            <summary>
              <para>Name of the company which has produced this unit.</para>
              <para>As plugins are becoming first-class packages in the app, not all the packages will be produced by JetBrains.</para>
              <para>This is the human-readable version, without "Inc" or "s.r.o." or else.</para>
            </summary>
            <seealso cref="P:JetBrains.Application.BuildScript.Application.IApplicationPackage.CompanyNameLegal"/>
        </member>
        <member name="P:JetBrains.Application.BuildScript.Application.IApplicationPackage.CompanyNameLegal">
            <summary>
              <para>Name of the company which has produced this unit.</para>
              <para>As plugins are becoming first-class packages in the app, not all the packages will be produced by JetBrains.</para>
              <para>This is the full legal version with all the "Inc" and "s.r.o." and else.</para>
            </summary>
            <seealso cref="!:IApplicationHost.CompanyNameHuman"/>
        </member>
        <member name="P:JetBrains.Application.BuildScript.Application.IApplicationPackage.Files">
            <summary>
            The list of files included with this package.
            </summary>
        </member>
        <member name="P:JetBrains.Application.BuildScript.Application.IApplicationPackage.Id">
            <summary>
            ID of this application package. Corresponds to the Nuget package ID.
            </summary>
        </member>
        <member name="P:JetBrains.Application.BuildScript.Application.IApplicationPackage.References">
            <summary>
            Gets the IDs of the referenced application packages.
            </summary>
        </member>
        <member name="P:JetBrains.Application.BuildScript.Application.IApplicationPackage.SubplatformName">
            <summary>
            Gets the subplatform name of the subplatform which has produced this package.
            </summary>
        </member>
        <member name="P:JetBrains.Application.BuildScript.Application.IApplicationPackage.Version">
            <summary>
            Gets the product full version.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Application.Catalogs.CalculateModuleZoneTraitsForPartCatalogTables">
            <summary>
            Module zones with which a certain type is marked.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Application.Catalogs.CalculateModuleZoneTraitsForPartCatalogTables.TraitNamespace">
            <summary>
            Namespace for all module zone based traits.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Application.Catalogs.PartCatalogs">
            <summary>
            Factory methods for standard catalogs.
            </summary>
        </member>
        <member name="M:JetBrains.Application.BuildScript.Application.Catalogs.PartCatalogs.Create(System.Collections.Generic.IList{JetBrains.Application.Catalogs.PartCatalogAssembly})">
            <summary>
            Creates the catalog from precalculated data.
            </summary>
            <param name="assemblies">The assemblies list.</param>
        </member>
        <member name="M:JetBrains.Application.BuildScript.Application.Catalogs.PartCatalogs.CreateWithMetadataReader(JetBrains.DataFlow.Lifetime,System.Collections.Generic.IEnumerable{JetBrains.Metadata.Utils.AssemblyNameInfo},JetBrains.Application.Bindings.IAssemblyMasterBinder)">
            <summary>
            Loads assembly files from streams with our fast metadata reader.
            </summary>
            <param name="lifetime">Holds the view to the part catalog.</param>
            <param name="assemblies">The list of assembly names for assemblies which should be included with the catalog (and scanned for types).</param>
            <param name="masterbinder">Knows how to bind assembly names for reading, including the listed names and their references.</param>
        </member>
        <member name="M:JetBrains.Application.BuildScript.Application.Catalogs.PartCatalogs.CreateWithMetadataReaderFromAssemblyFiles(JetBrains.DataFlow.Lifetime,System.Collections.Generic.ICollection{JetBrains.Util.FileSystemPath},System.Collections.Generic.IEnumerable{JetBrains.Util.FileSystemPath})">
            <summary>
            Loads assembly files from disk with our fast metadata reader.
            </summary>
        </member>
        <member name="M:JetBrains.Application.BuildScript.Application.Catalogs.PartCatalogs.CreateWithMetadataReaderFromAssemblyFiles(JetBrains.DataFlow.Lifetime,System.Collections.Generic.ICollection{JetBrains.Metadata.Utils.AssemblyNameAndLocation},System.Collections.Generic.IEnumerable{JetBrains.Metadata.Utils.AssemblyNameAndLocation})">
            <summary>
            Loads assembly files from disk with our fast metadata reader.
            </summary>
        </member>
        <member name="M:JetBrains.Application.BuildScript.Application.Catalogs.PartCatalogs.CreateWithMetadataReaderRaw(JetBrains.DataFlow.Lifetime,System.Collections.Generic.IEnumerable{JetBrains.Metadata.Utils.AssemblyNameInfo},JetBrains.Application.Bindings.IAssemblyMasterBinder,JetBrains.Util.OnError)">
            <summary>
            Loads assembly files from streams with our fast metadata reader.
            </summary>
            <param name="lifetime">Holds the view to the part catalog.</param>
            <param name="assemblies">The list of assembly names for assemblies which should be included with the catalog (and scanned for types).</param>
            <param name="masterbinder">Knows how to bind assembly names for reading, including the listed names and their references.</param>
            <param name="onerrorForMetadataLoaderTmp">TMP until adhoc catalog calculation at runtime is fixed.</param>
        </member>
        <member name="P:JetBrains.Application.BuildScript.Application.IApplicationPackageLocallyInstalled.LocalInstallDirectory">
            <summary>
            Base directory into which the package is locally installed.
            Package files are placed at <see cref="F:JetBrains.Application.BuildScript.Application.ApplicationPackageFile.myLocalInstallPath"/> under it.
            Note that packages might either share the same local install folder, or have it different.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Application.IApplicationTrait">
            <summary>
            Base interface for application traits, so that you could easily check which you're defining on your products and which you're not.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Application.IEndUserProduct">
            <summary>
            Denotes an end-user product.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Application.IProductNameAndVersion">
            <summary>
            The basic technical info of the product. That's all we need for discovering product-specific locations.
            </summary>
        </member>
        <member name="P:JetBrains.Application.BuildScript.Application.IProductNameAndVersion.CompanyNameHuman">
            <summary>
              <para>Name of the company which has produced this unit.</para>
              <para>As plugins are becoming first-class packages in the app, not all the packages will be produced by JetBrains.</para>
              <para>This is the human-readable version, without "Inc" or "s.r.o." or else.</para>
            </summary>
            <seealso cref="P:JetBrains.Application.BuildScript.Application.IApplicationPackage.CompanyNameLegal"/>
        </member>
        <member name="P:JetBrains.Application.BuildScript.Application.IProductNameAndVersion.ProductName">
            <summary>
              <para>Gets the <b>technical</b> product name in the shortest form (no company, no version, no spaces, identifier-syntax-compatible).</para>
              <para>Don't use for UI display strings, see Remarks on <see cref="!:IApplicationDescriptor.ProductDisplayName"/> for an explanation.</para>
              <para>See <see cref="!:IApplicationDescriptor"/> for other forms of product name: <see cref="!:IApplicationDescriptor.ProductDisplayName"/> and <see cref="!:IApplicationDescriptor.ProductFullName"/>.</para>
            </summary>
            <remarks>See Remarks on <see cref="!:IApplicationDescriptor.ProductDisplayName"/>.</remarks>
            <seealso cref="!:IApplicationDescriptor.ProductDisplayName"/>
            <seealso cref="!:IApplicationDescriptor.ProductFullName"/>
            <example>
              <code>“Receptor”</code>
              <code>“DotMemory”</code>
            </example>
        </member>
        <member name="P:JetBrains.Application.BuildScript.Application.IProductNameAndVersion.ProductVersion">
            <summary>
            Gets the product full version.
            </summary>
        </member>
        <member name="P:JetBrains.Application.BuildScript.Application.IEndUserProduct.CompanyNameLegal">
            <summary>
              <para>Name of the company which has produced this unit.</para>
              <para>As plugins are becoming first-class packages in the app, not all the packages will be produced by JetBrains.</para>
              <para>This is the full legal version with all the "Inc" and "s.r.o." and else.</para>
            </summary>
            <seealso cref="P:JetBrains.Application.BuildScript.Application.IProductNameAndVersion.CompanyNameHuman"/>
        </member>
        <member name="P:JetBrains.Application.BuildScript.Application.IEndUserProduct.ProductAboutBoxImage">
            <summary>
              <para>AboutBox for the product shows this image. Recommended minimum width: <c>200h</c>.</para>
              <para>Usually, it's the same image as the installer Welcome Page banner. So its width is 512 px.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Application.BuildScript.Application.IEndUserProduct.ProductDialogHeaderImage">
            <summary>
            All license-related dialogs shows this image to ease disambiguation between products. Recommended size: <c>521x54</c>.
            </summary>
        </member>
        <member name="P:JetBrains.Application.BuildScript.Application.IEndUserProduct.ProductDisplayName">
            <summary>
              <para>The user-friendly name of the product in the short form (no company, no version).</para>
              <para>The default choice if you want to mention the product name in UI.</para>
              <para>See Remarks for details.</para>
            </summary>
            <remarks>
              <para>There're three forms of the product name:</para>
              <h5>(1) <see cref="P:JetBrains.Application.BuildScript.Application.IProductNameAndVersion.ProductName"/></h5>
              <para>The short technical name which follows the identifier syntax.</para>
              <para>Use for IDs, filenames, Registry access, prefixes/disambiguations, etc.</para>
              <para><b>Example</b>: <c>“Receptor”</c>, <c>“DotMemory”</c>.</para>
              <h5>(2) <see cref="P:JetBrains.Application.BuildScript.Application.IEndUserProduct.ProductDisplayName"/></h5>
              <para>The short UI name for use in display strings. Still does not include the version number.</para>
              <para>The default choice if you want to mention the product name in UI.<br/>(NOTE: there's a special function for making window titles like “Receptor – Downloading”).</para>
              <para>Equal to <see cref="P:JetBrains.Application.BuildScript.Application.IProductNameAndVersion.ProductName"/> by default, but might differ in some products<br/> (e.g. DotMemory's technical product name is <c>“DotMemory”</c>, while its display product name is <c>“DotTrace Memory”</c>).</para>
              <para><b>Example</b>: <c>“Receptor”</c>, <c>“DotTrace Memory”</c>.</para>
              <h5>(3) <see cref="P:JetBrains.Application.BuildScript.Application.IEndUserProduct.ProductFullName"/></h5>
              <para>The expanded marketing product name for detailed UI strings which also includes the marketing version, beta/EAP/RC designation, etc.</para>
              <para>Its use is narrow (for about-boxes and alike), just compare:<br/>
            • “Receptor 7.0.2 Limited EAP – Code Cleanup” vs. “Receptor – Code Cleanup”<br/>
            • “Reset all Receptor 7.0.2 Limited EAP settings” vs. “Reset all Receptor settings”.</para>
              <para>This is the only property which exposes the marketing version of the build which, if it has more than two components, does not directly match the technical version. For example, “Receptor 7.0.2” has the service pack number of 2, while the technical version build component (the third number) is roughly the number of the nightly published.</para>
              <para><b>Example</b>: <c>“Receptor 7.0.2 RC”</c>, <c>“DotTrace Memory 1.0 Public EAP”</c>.</para>
              <para>—</para>
              <para>None of these include the Company Name, use <see cref="T:JetBrains.Application.CompanyInfo"/> to concatenate if needed for display.</para>
            </remarks>
            <example>
              <code>“Receptor”</code>
              <code>“DotTrace Memory”</code>
            </example>
            <seealso cref="P:JetBrains.Application.BuildScript.Application.IProductNameAndVersion.ProductName"/>
            <seealso cref="P:JetBrains.Application.BuildScript.Application.IEndUserProduct.ProductFullName"/>
        </member>
        <member name="P:JetBrains.Application.BuildScript.Application.IEndUserProduct.ProductFullName">
            <summary>
              <para>Gets the expanded marketing product name, which is typically the <see cref="P:JetBrains.Application.BuildScript.Application.IEndUserProduct.ProductDisplayName"/> plus the marketing version number, beta/EAP/RC designation, etc.</para>
              <para>Don't use it in UI except for a few special cases, see Remarks on <see cref="P:JetBrains.Application.BuildScript.Application.IEndUserProduct.ProductDisplayName"/> for an explanation.</para>
            </summary>
            <remarks>See Remarks on <see cref="P:JetBrains.Application.BuildScript.Application.IEndUserProduct.ProductDisplayName"/>.</remarks>
            <example>
              <code>“Receptor 7.0.2 RC”</code>
              <code>“DotTrace Memory 1.0 Public EAP”</code>
            </example>
            <seealso cref="P:JetBrains.Application.BuildScript.Application.IProductNameAndVersion.ProductName"/>
            <seealso cref="P:JetBrains.Application.BuildScript.Application.IEndUserProduct.ProductDisplayName"/>
        </member>
        <member name="P:JetBrains.Application.BuildScript.Application.IEndUserProduct.ProductIcon">
            <summary>
            Gets the product icon.
            </summary>
        </member>
        <member name="P:JetBrains.Application.BuildScript.Application.IEndUserProduct.ProductSplashScreenImage">
            <summary>
            Gets the splash screen clipart for this product.
            </summary>
        </member>
        <member name="P:JetBrains.Application.BuildScript.Application.IEndUserProduct.ProductUrl">
            <summary>
            Gets the URL that takes to the Product page.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Application.IWindowBranding">
            <summary>
              <para>Branding for windows and other UI controls. Supplies the application-specific icon, the title prefix, etc.</para>
              <para>
                Historically, the <c>IApplicationDescriptor</c> was used for this, but in a shared-shell world it's not an option.
              </para>
            </summary>
        </member>
        <member name="M:JetBrains.Application.BuildScript.Application.IWindowBranding.MakeWindowCaption(System.String)">
            <summary>
              Prepends a caption string with the product name, separated with an en-dash.
            </summary>
            <param name="caption">The original caption to prepend with the product name.</param>
        </member>
        <member name="P:JetBrains.Application.BuildScript.Application.IWindowBranding.CompanyName">
            <summary>
            Gets the name of the company providing the main product identified by <see creLf="ProductDisplayName" />.
            </summary>
        </member>
        <member name="P:JetBrains.Application.BuildScript.Application.IWindowBranding.ProductDisplayName">
            <summary>
              A string which can be used for representing the current product in the UI.
              In a single-product runtime, this is the <c>ProductDisplayName</c> value.
            </summary>
        </member>
        <member name="P:JetBrains.Application.BuildScript.Application.IWindowBranding.WindowIcon">
            <summary>
              <para>Gets the icon to use as product window icons, such as in dialogs.</para>
              <para>The icon might change with time, for example when theme is switched.</para>
              <para>
                An <c>IconId</c> cannot be used here because an icon is a rich format including multiple device images for the same icon.
              </para>
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Application.Zones.AutoselectZoneAttribute">
            <summary>
            Base attribute for self-chooser markers.
            </summary>
        </member>
        <member name="M:JetBrains.Application.BuildScript.Application.Zones.AutoselectZoneAttribute.AutoselectZoneByAttributePrimitiveValue``1(System.Collections.Generic.IEnumerable{JetBrains.Application.Catalogs.PartCatalog},System.UInt64,JetBrains.Util.OnError)">
            <summary>
            Looks up the <see cref="T:JetBrains.Application.BuildScript.Application.Zones.AutoselectZoneAttribute"/>-derived attributes of type <see cref="!:TAutoselectAttribute"/>, looks up the single item which has the only parameter set to the <paramref name="valuePrimitive"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Application.BuildScript.Application.Zones.AutoselectZoneAttribute.AutoselectZoneByAttributeValue``2(System.Collections.Generic.IEnumerable{JetBrains.Application.Catalogs.PartCatalog},``1,JetBrains.Util.OnError)">
            <summary>
            Looks up the <see cref="T:JetBrains.Application.BuildScript.Application.Zones.AutoselectZoneAttribute"/>-derived attributes of type <see cref="!:TAutoselectAttribute"/>, looks up the single item which has the only parameter set to the <paramref name="value"/>.
            <see cref="M:JetBrains.Application.BuildScript.Application.Zones.AutoselectZoneAttribute.AutoselectZoneByAttributePrimitiveValue``1(System.Collections.Generic.IEnumerable{JetBrains.Application.Catalogs.PartCatalog},System.UInt64,JetBrains.Util.OnError)"/> is faster for use on startup.
            </summary>
        </member>
        <member name="M:JetBrains.Application.BuildScript.Application.Zones.AutoselectZoneAttribute.AutoselectZonesByAttributePredicate``1(System.Collections.Generic.IEnumerable{JetBrains.Application.Catalogs.PartCatalog},System.Func{JetBrains.Application.Parts.PartCatalogEx.TypeAttribute{``0},System.Boolean},JetBrains.Util.OnError)">
            <summary>
            Looks up the <see cref="T:JetBrains.Application.BuildScript.Application.Zones.AutoselectZoneAttribute"/>-derived attributes of type <see cref="!:TAutoselectAttribute"/>, looks up the item which pass the predicate filter.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Application.Zones.AutoselectZoneByClrVersionAttribute">
            <summary>
            Marker to help choose the host zone by CLR version without referencing all instances (which is not possible from the base class).
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Application.Zones.AutoselectZoneByCpuArchitectureAttribute">
            <summary>
            Marker to help choose the host zone by CPU Architecture in an automatic fashion.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Application.Zones.IAmd64CpuArchitectureZone">
            <summary>
              <para>The AMD64 (aka x64) CPU.</para>
              <para>In effect on AMD64 systems when running in CPU-native processes (without WoW6432, which would show up as <see cref="T:JetBrains.Application.BuildScript.Application.Zones.IIntelCpuArchitectureZone"/>).</para>
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Application.Zones.ICpuArchitectureZone">
            <summary>
            Common root for CPU-specific zones.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Application.Zones.IHostSpecificZone">
            <summary>
            Base interface for zone axes which are available right out of the Host and apply to the Environment container.
            They're in effect during Environment startup, because other configs are only chosen for the Shell by environment components.
            They also normally choose which DLLs will be added to deployment, because product-preferred non-env configs might vary between all products installed on the machine.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Application.Zones.IZone">
            <summary>
            The base interface for all zone axes.
            Is not a zone on itself.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Application.Zones.IArmCpuArchitectureZone">
            <summary>
              <para>The ARM CPU.</para>
              <para>Haven't seen such in wild life, but MSFT is onto that, let's reserve the zone.</para>
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Application.Zones.IEnvironmentZone">
            <summary>
              <para>The root zone for environment-specific zones.</para>
              <para>These zones define the difference between VS / test / standalone / cmd environments which is not specific to the product, but to the common component implementations.</para>
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Application.Zones.IIntelCpuArchitectureZone">
            <summary>
              <para>The Intel (aka IA32 aka x86) CPU.</para>
              <para>In effect on x86 systems and inside WoW6432 processes on AMD64 systems.</para>
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Application.Zones.IInternalVisibilityZone">
            <summary>
            The internal-only visibility zone. These items are only active when running in Internal mode.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Application.Zones.IRequire`1">
            <summary>
              <para>An interface to mark some class as requiring a zone.</para>
              <para>Applies either to a component class, or to a special marker class which marks the whole namespace it's placed in.</para>
            </summary>
            <typeparam name="TZoneInterface">The zone.</typeparam>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Application.Zones.IOuterWorldConnectZone">
            <summary>
            All products allowed to connect outer world (internet)
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Application.Zones.IPublicVisibilityZone">
            <summary>
            The default visibility zone. These items are active in both Public and Internal zones.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Application.Zones.ISinceClr2Zone">
            <summary>
            The CLR zones root.
            Available when running on CLR version 2+.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Application.Zones.IStandaloneCmdZone">
            <summary>
            Commandline standalone products.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Application.Zones.IStandaloneZone">
            <summary>
            All products running in a standalone fashion — not under VS nor unit testing.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Application.Zones.IStandaloneTabWellUIZone">
            <summary>
            UI-interactive standalone IDE-like products with tabwell-based main window.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Application.Zones.IStandaloneUIZone">
            <summary>
            Base sone for UI-interactive standalone shells. They might have custom UI instead of the standard main window with the tab well.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Application.Zones.IUIInteractiveZone">
            <summary>
            All products which are allowed to show graphical user-interactive interface.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Application.Zones.ZoneMarkerAttribute">
            <summary>
              <para>This attribute allows to mark classes as belonging to Zone Axes. A Zone Axis is declared with <see cref="T:JetBrains.Application.BuildScript.Application.Zones.ZoneDefinitionAttribute"/>, after which one or more classes might be marked as belonging to that Zone Axis. A class is the only unit to which the Zone Axis actually applies.</para>
              <para>• • •</para>
              <para>Which classes are affected by a specific <see cref="T:JetBrains.Application.BuildScript.Application.Zones.ZoneMarkerAttribute"/> instance:</para>
              <para>If the attribute is applied to just a regular class, e.g. a component, then just this class is marked with the respective Zone Axes.</para>
              <para>If the attribute is applied to an empty class named <c>ZoneMarker</c>, or whose name ends with <c>_ZoneMarker</c>, then it's a syntax sugar for marking all of the classes under the current namespace by applying a single marker. This applies to classes from the same assembly, from the same namespace as the marked <c>ZoneMarker</c> class, and in all the nested namespaces.</para>
              <para>• • •</para>
              <para>Which Zone Axes are applied with a specific <see cref="T:JetBrains.Application.BuildScript.Application.Zones.ZoneMarkerAttribute"/> instance:</para>
              <para>First, you can specify the list of Zone Axis types as the attribute constructor parameters.</para>
              <para>Then, the class which is marked with the attribute might implement any number of <see cref="T:JetBrains.Application.BuildScript.Application.Zones.IRequire`1"/> interfaces (including those from its base classes), whose type parameters should be instantiated to the Zone Axis types.</para>
              <para>The total set of Zone Axes of the attribute is a union of all these, both for regular classes and for <c>ZoneMarker</c> classes.</para>
              <para>An empty set of the Zone Axes is a special case. It does not restrict the class to any zones, but marks an opt-in to the zoning system, which is required to make the class pass any of the zoning filters. A class to which no zone markers apply is invisible to the component container.</para>
              <para>• • •</para>
              <para>The total set of Zone Axes to which a certain class belongs is a union of:</para>
              <para>— Zone Axes applied by the <see cref="T:JetBrains.Application.BuildScript.Application.Zones.ZoneMarkerAttribute"/> on this class itself.</para>
              <para>— Zone Axes applied to all the <c>ZoneMarker</c> classes in the namespace of the class.</para>
              <para>— Zone Axes applied to all the <c>ZoneMarker</c> classes in any parent namespaces of this class (within the same assembly).</para>
            </summary>
        </member>
        <member name="M:JetBrains.Application.BuildScript.Application.Zones.ZoneMarkerAttribute.#ctor(System.Type[])">
            <summary>
            Lists the Zone Axes. Only Zone Axis types registered with <see cref="T:JetBrains.Application.BuildScript.Application.Zones.ZoneDefinitionAttribute"/> are allowed in this list.
            </summary>
            <param name="zones"></param>
        </member>
        <member name="P:JetBrains.Application.BuildScript.Application.Zones.ZoneMarkerAttribute.Zones">
            <summary>
              <para>Some of the zones required by the marked class.</para>
              <para>Note that zones might also be required by base interfaces of the class, <see cref="T:JetBrains.Application.BuildScript.Application.Zones.IRequire`1"/>.</para>
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Application.Zones.ZoneDefinitionAttribute">
            <summary>
              <para>Declares a new zone.</para>
              <para>If the marked class/interface derives some other zone, then it's a value in the existing axis. Otherwise it's a root of the new axis.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Application.BuildScript.Application.Zones.ZoneEx.GetZoneFlags(JetBrains.Application.BuildScript.Application.Zones.ZonePart)">
            <summary>
            On a zone from the part catalog, gets its flags from the attribute declaration.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Application.Zones.ZoneFlags.AutoEnable">
            <summary>
            Means thatthe zone is automatically enabled on startup once its dependencies are enables.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Application.Zones.ZonePart">
            <summary>
            Represents an <see cref="T:JetBrains.Application.BuildScript.Application.Zones.IZone"/>-derived interface without loading the runtime type, in part catalog terms.
            </summary>
        </member>
        <member name="M:JetBrains.Application.BuildScript.Application.Zones.ZonePart.FromType(System.Type,JetBrains.Application.Catalogs.PartCatalogSet)">
            <summary>
            Creates a zone part object from a runtime type.
            </summary>
            <param name="type">The module zone type.</param>
            <param name="catalogset">The part catalog to create the module zone type in a much more efficient manner. It's recommended to supply it in any perf-sensitive scenarios.</param>
        </member>
        <member name="M:JetBrains.Application.BuildScript.Application.Zones.ZonePart.FromType``1(JetBrains.Application.Catalogs.PartCatalogSet)">
            <summary>
            Creates a zone part object from a runtime type.
            </summary>
            <typeparam name="TIZone">The module zone type.</typeparam>
            <param name="catalogset">The part catalog to create the module zone type in a much more efficient manner. It's recommended to supply it in any perf-sensitive scenarios.</param>
        </member>
        <member name="T:JetBrains.Application.BuildScript.ArtifactStringsForNestedStage">
            <summary>
            Keeps string representation of the artifacts which should be applied to the binary stage of the build.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.ArtifactWithFileList">
            <summary>
            A quick helper for serializing an artifact which just holds a file list.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.BinaryStageObjectiveArtifact">
            <summary>
            When running a standard build, specifies which objective to invoke on the binary stage.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.BuildApp.IsCachingBuildStuff">
            <summary>
            Whether aggressive caching of the build stuff between runs is enabled.
            As some of it is a bit heuristic, this won't be enabled on the server by default, and is user-controllable.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.BuildApp.IsCachingBuildStuff.IsCachingEnabled">
            <summary>
            Whether aggressive caching of the build stuff between runs is enabled.
            As some of it is a bit heuristic, this won't be enabled on the server by default, and is user-controllable.
            </summary>
        </member>
        <member name="M:JetBrains.Application.BuildScript.BuildRunnerResultEx.ExtractOutputFiles(JetBrains.Build.Running.BuildRunnerResult)">
            <summary>
            Extracts any embedded files from the build runner results.
            </summary>
            <remarks>
            Actually, looks for any serialized records which look like files, and rips them out.
            </remarks>
        </member>
        <member name="P:JetBrains.Application.BuildScript.Compile.CodeSigning.IAuthenticodeSigningService.IsAvailable">
            <summary>
            Gets whether it's possible to sign with this server at this moment.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Compile.CodeSigning.AuthenticodeSigningService._regexContentNameNegativeCharset">
            <summary>
            The allowed charset for the content name (actually specified on server side, here's a snapshot at some moment of time; update to actual server value if it changes).
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Compile.CodeSigning.AuthenticodeSigningService._sInvalidCharsReplacementString">
            <summary>
            When replacing the content name chars which don't fit into the charset, use this string instead of each contiguous pack of invalid chars.
            </summary>
        </member>
        <member name="M:JetBrains.Application.BuildScript.Compile.CodeSigning.ISignAuthenticodeEx.SignIfAvailable(JetBrains.Application.BuildScript.Compile.CodeSigning.IAuthenticodeSigningService,JetBrains.Util.Storage.SimpleFileItem,System.String)">
            <summary>
            Returns the original content if the signing server has not been specified for this build (e.g. this is a local build).
            </summary>
            <param name="thіs"></param>
            <param name="input"></param>
            <param name="sContentName"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Application.BuildScript.Compile.CodeSigning.StrongNameSignatureHelpers.SignDelaySignedAssembly(JetBrains.Util.Storage.SimpleFileItem,System.Byte[])">
            <summary>
            Resigns a delayed-sign assembly with a valid signature.
            </summary>
            <param name="assembly">The assembly. Must be delay-signed, i.e. have the signature RVA in its CLI header, but no "Strong name signed"(0x8) flag, and "Has public key" flag and its RVA in the Assembly metadata table.</param>
            <param name="snk">Strong name key pair for signing, in the same format as the SNK file. The public key must match the one in the Assembly metadata table of the assembly. The private key must match the public key.</param>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Compile.CompiledSubplatformFile">
            <summary>
            A freshly-compiled file output from the Subplatform Compile stage. Will be turned into a SubplatformFileForPackaging automatically, or might be also put to use by some side steps.
            Don't consume unless pretty sure of what you're doing.
            Yield instead of a <see cref="T:JetBrains.Application.BuildScript.SubplatformFileForPackaging"/> if you consider your step to be a compilation-related one (but this is purely optional).
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Compile.SubplatformFileForPackagingBase">
            <summary>
              <para>Base class for different stages of files intended for being put into subplatform Nuget packages.</para>
              <para>The full family of these files includes:</para>
              <para>• <see cref="T:JetBrains.Application.BuildScript.SubplatformFileForPackaging"/> — the most common one ("Common"). Yield this if not sure and want to add smth to a package.</para>
              <para>• <see cref="T:JetBrains.Application.BuildScript.Compile.SubplatformFileForPackagingFast"/> — yield instead of the Common one if your yielding graph is FAST enough to be included with Prepare Working Copy. I.e. it shan't result in a build process. These items are merged into the Common list automatically.</para>
              <para>• <see cref="T:JetBrains.Application.BuildScript.Compile.CompiledSubplatformFile"/> — a special flavor of files which are the compilation result. Needed for some hacking when you need to reference other compiled files before they're in the package. These items also are merged into Common.</para>
              <para>• <see cref="T:JetBrains.Application.BuildScript.Compile.TransformedSubplatformFileForPackaging"/> — don't yield these. They're produced out of Common by applying <see cref="T:JetBrains.Application.BuildScript.Compile.ITransformSubplatformFilesForPackaging"/> handler. And that's what specifically gets added into the package.</para>
              <para>—</para>
              <para>Scenarios:</para>
              <para>• Main, or Full. When producing Nuget packages for subplatforms, either to deploy, or to local-install. All producers for Common, Fast and Compiled items are executed (all end up in the Common list), then transformers are applied, then the resulting Transformed list is fed into the package producing code. That's what also happens when you run the full version of the Extract to Bin Dir task. All the necessary compilations are invoked in the course.</para>
              <para>• Prepare Working Copy. Only FAST items are produced, and only them are written to the outdir. This should be somewhat enough to develop and run tests, even though a full Local Install or Extract to Bin Dir is recommended. But FAST is FAST and can be done before opening the solution.</para>
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Compile.CompileSubplatformsInput">
            <summary>
            Allows to link your execution before compiling subplatforms.
            // TODO: refactor? maybe we might want to generate more files instead?
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Compile.EmbedPackageInSubplatformArtifact">
            <summary>
            Yield this artifact to request embedding contents of a certain Nuget package into the subplatform package being compiled.
            Some native tools are distributed this way: they're pre-compiled into nuget form, and they're embedded to be always next to the managed DLLs which would be using them.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Compile.EmbedPackageInSubplatformArtifact.MoveToFolder">
            <summary>
            By default, the stuff is embedded right into the content folder of the package.
            This option allows to embed into a sub-path under the content folder.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Compile.EmbedPackageInSubplatformArtifact.PackageId">
            <summary>
            Nuget package which should be embedded into the subplatform.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Compile.EmbedPackageInSubplatformArtifact.PackageVersion">
            <summary>
            Nuget package which should be embedded into the subplatform.
            If the version is omitted, the package is supposed to be among the retrieved-package-references, a single version for this package ID.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Compile.EmbedPackageInSubplatformArtifact.Subplatform">
            <summary>
            The target subplatform of the embedding.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Compile.EmptyTransformSubplatformFilesForPackaging">
            <summary>
            A placeholder build helper to ensure some helpers are always registered for the <see cref="T:JetBrains.Application.BuildScript.Compile.ITransformSubplatformFilesForPackaging"/> interface, and resolve succeeds for them.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Compile.ITransformSubplatformFilesForPackaging">
            <summary>
            Allows to have a go on files which are to be packaged into a subplatform, after they all are produced, but before they are packaged.
            </summary>
        </member>
        <member name="M:JetBrains.Application.BuildScript.Compile.ITransformSubplatformFilesForPackaging.ApplyTransform(JetBrains.Application.BuildScript.SubplatformFileForPackaging[],JetBrains.Application.BuildScript.Compile.TransformSubplatformFilesForPackaging.AssertTransformationsOrder@)">
            <summary>
            Applies the transformation by modifying the list of files.
            You should not modify the file contents directly, but by removing the item and inserting another one for the same path you can effectively modify the file contents.
            Yield <c>Null</c> if you don't want to modify.
            </summary>
        </member>
        <member name="P:JetBrains.Application.BuildScript.Compile.ITransformSubplatformFilesForPackaging.Priority">
            <summary>
            Executed in ascending order.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Compile.ForceTargetFrameworkVersion">
            <summary>
              <para>Causes the all projects to be compiled targeting specified framework regardless of their settings.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Compile.ForceTargetFrameworkVersion.TargetFrameworkVersion">
            <summary>
              <para>TargetFrameworkVersion in the same format as in msbuild properties</para>
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Compile.INestedBuildRunnerOnSources">
            <summary>
            Runs a nested build which works off sources.
            Sets up parameters for the nested stage run correctly.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Compile.CodeSigning.SignServerInfo">
            <summary>
            Identifies the sign server which serves the authenticode signing request without exposing the private keys.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Compile.CodeSigning.SignServerFlavor">
            <summary>
            Flavor parameter that allows to override sign server behavior (like switch to some other certificate).
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Compile.LauncherCompileTimeConstants">
            <summary>
            Mocks <c>Launcher</c> in a compile-time-build-script-accessible form.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Compile.LauncherCompileTimeConstants.ConsoleMainMethod">
            <summary>
            Mocks <c>Launcher::ConsoleMainMethod</c> in a compile-time-build-script-accessible form.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Compile.LauncherCompileTimeConstants.ConsoleMainMethodScattered">
            <summary>
            Mocks <c>Launcher::ConsoleMainMethod</c> in a compile-time-build-script-accessible form.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Compile.LauncherCompileTimeConstants.MainMethod">
            <summary>
            Mocks <c>Launcher::MainMethod</c> in a compile-time-build-script-accessible form.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Compile.LauncherCompileTimeConstants.MainMethodScattered">
            <summary>
            Mocks <c>Launcher::MainMethod</c> in a compile-time-build-script-accessible form.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Compile.PackageFileRole.Other">
            <summary>
            Generic. Goes to the main package, <see cref="F:JetBrains.Util.Storage.SubplatformPackageLayoutConstants.JetBrainsContentFilesFolder"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Compile.PackageFileRole.ManagedAssembly">
            <summary>
            Managed assembly (DLL or EXE). Goes to the main package, <see cref="F:JetBrains.Util.Storage.SubplatformPackageLayoutConstants.JetBrainsContentFilesFolder"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Compile.PackageFileRole.UnmanagedDll">
            <summary>
            Unmanaged DLL file. Goes to the main package, <see cref="F:JetBrains.Util.Storage.SubplatformPackageLayoutConstants.JetBrainsContentFilesFolder"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Compile.PackageFileRole.UnmanagedLibrary">
            <summary>
            Unmanaged link library file. Goes to the main package, <see cref="F:JetBrains.Util.Storage.SubplatformPackageLayoutConstants.JetBrainsContentFilesFolder"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Compile.PackageFileRole.ProgramDatabase">
            <summary>
            PDB file. Goes to the separate .symbols package.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Compile.PackageFileRole.BuildTargets">
            <summary>
            .targets file to import in package main build file.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Compile.PackageFileRole.XmlDocumentation">
            <summary>
            XmlDoc file for some managed assembly. Goes to the main package, <see cref="F:JetBrains.Util.Storage.SubplatformPackageLayoutConstants.JetBrainsContentFilesFolder"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Compile.PackageFileRole.NugetBuildFile">
            <summary>
            A .Targets or .Props file which should be recognized as such by Nuget when processing the main package as a reference. Goes to the main package, Nuget's Build folder.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Compile.SubplatformOriginalRevision">
            <summary>
            Package-embedded metadata which points to the original SCC revision which compiled this package.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Compile.PackagePartCatalogArtifact">
            <summary>
            A component in the subplatform package components which holds the part catalog for the package managed assemblies.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Compile.RequestPlatformCleanCompile">
            <summary>
            The Platform project has been cleaned up of all the compilation warnings.
            Useless technical values have been suppressed, and useful ones have been fixed.
            Note that this is also possible to enable the warning for in-VisualStudio analysis yet disable it for compilation.
            To maintain this clean state, a validator is imposed.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Compile.SkipAssemblyRewrites">
            <summary>
            Skips the compilation stage steps (those before obtaining the nuget packages) that rewrite compiled assembly before they're added to the package.
            An example of such rewrites are obfuscation steps.
            This interferes with the "Do not compile" local scenario because after the DLLs are extracted to Bin Dir from the compiled nuget packages, it would be used as if it were just compile and will get into rewrite for the second time.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.ILocalBuildOptimizationArtifact">
            <summary>
            Marks artifacts which help with skipping certain operations when local-building.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Compile.SubplatformComponentForPackaging">
            <summary>
            Components which are to be serialized into the package metadata.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Compile.SubplatformComponentForPackaging.ComponentForSerialization">
            <summary>
            The component instance to be serialized into the package metadata.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Compile.SubplatformComponentForPackaging.SubplatformName">
            <summary>
            The target subplatform.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Compile.SubplatformFileForPackagingFast">
            <summary>
            A file which will be put into the Subplatform Binaries Package of the specified subplatform, which is the primary compilation output for that subplatform.
            You should yield this artifact if you want to add something to the package being produced for the subplatform.
            FAST mode: only yield this from steps which are fast to execute, so that this could be run as a part of the Prepare Working Copy task.
            </summary>
        </member>
        <member name="M:JetBrains.Application.BuildScript.Compile.SubplatformFileForPackagingFast.FastToCommon(JetBrains.Application.BuildScript.Compile.SubplatformFileForPackagingFast[],JetBrains.Util.ILogger)">
            <summary>
            Contributes the fast items to the full list of items.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Compile.SubplatformProjectExemptFromManagedAssemblies">
            <summary>
              <para>Allows to mark a subplatform project to be exempt from the <see cref="F:JetBrains.Application.BuildScript.Compile.PackageFileRole.ManagedAssembly"/> listing, its output will be packaged with the <see cref="F:JetBrains.Application.BuildScript.Compile.PackageFileRole.Other"/> instead.</para>
              <para>As a result, such a project output won't be listed with <see cref="P:JetBrains.Application.BuildScript.Application.IApplicationPackage.Files"/> as an assembly, catalogs won't be build for it, components won't run from it, and so on.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Compile.SubplatformProjectExemptFromManagedAssemblies.ProjectInSubplatform">
            <summary>
            Rel path to the project file in the subplatform. Must exist.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Compile.SubplatformProjectExemptFromManagedAssemblies.SubplatformName">
            <summary>
            Name of the subplatform with the project.
            Must exist as a subplatform-on-sources.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Compile.TimeBombSpan">
            <summary>
              <para>Causes the subplatform packages compiled in presence of this artifact to be timebombed at the moment given by the time span in this object.</para>
              <para>Specifies the timespan between <see cref="P:JetBrains.Application.BuildScript.Application.IApplicationPackage.BuiltOn"/> and <see cref="P:JetBrains.Application.BuildScript.Application.IApplicationPackage.BestBefore"/>.</para>
              <para>A NULL or nonpositive value (an empty string in string form) will result in no BB on packages.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Compile.TimeBombSpan.TimeSpan">
            <summary>
              <para>The timespan between <see cref="P:JetBrains.Application.BuildScript.Application.IApplicationPackage.BuiltOn"/> and <see cref="P:JetBrains.Application.BuildScript.Application.IApplicationPackage.BestBefore"/>.</para>
              <para>A NULL or nonpositive value will result in no BB on packages build in presence of this value.</para>
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Compile.TransformedSubplatformFileForPackaging">
            <summary>
            That's what actually gets packaged into the subplatform nugget, after applying all of the transforms.
            Don't yield these directly, use <see cref="T:JetBrains.Application.BuildScript.SubplatformFileForPackaging"/> instead.
            </summary>
        </member>
        <member name="M:JetBrains.Application.BuildScript.Compile.TransformedSubplatformFileForPackaging.ApplyTransform(JetBrains.Application.BuildScript.SubplatformFileForPackaging[],JetBrains.Application.BuildScript.Compile.ITransformSubplatformFilesForPackaging[],JetBrains.Util.ILogger)">
            <summary>
            Takes <see cref="T:JetBrains.Application.BuildScript.SubplatformFileForPackaging"/>, runs <see cref="T:JetBrains.Application.BuildScript.Compile.ITransformSubplatformFilesForPackaging"/> on them, produces <see cref="T:JetBrains.Application.BuildScript.Compile.TransformedSubplatformFileForPackaging"/> which will go into the nuggets.
            </summary>
        </member>
        <member name="M:JetBrains.Application.BuildScript.Compile.TransformSubplatformFilesForPackaging.AssertNoMoreManagedAssemblies(JetBrains.Application.BuildScript.Compile.ITransformSubplatformFilesForPackaging,System.Collections.Generic.JetHashSet{JetBrains.Application.BuildScript.SubplatformFileForPackaging})">
            <summary>
            Asserts the list of managed assemblies in this package is not modified after your transform runs.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Compile.TransformSubplatformFilesForPackaging.AssertTransformationsOrder">
            <summary>
            For a transform, asserts that subsequent transformations do not violate its expectations.
            Like, if it computes data from all assemblies in the package, subsequent transformations must not be adding new assemblies.
            </summary>
            <param name="resultsAttempted">The output of some later transform which should be tested for being consistent with expectations of this transform.</param>
            <param name="transformerAttempted">The transformer which did the transform we're inspecting. For using its name in the diagnostics.</param>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Compile.Validation.CanAutofixFilesOnDisk">
            <summary>
            Controls how the validate/autofix steps run.
            On the server, they should not be touching the sourcecontrolled files. On client, when run by command, they should apply fixes automatically where applicable.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Compile.Validation.SourcesValidationResult">
            <summary>
            Pulls various validations on the sources codebase — which don't require the compiled binary form, but require the source code to be available in the home dir.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Compile.Validation.ValidateCleanCompilation">
            <summary>
            Requests that compilation of certain subplatforms be clean.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Compile.Validation.ValidateCleanCompilation.SubplatformOrCollection">
            <summary>
            Denotes a subplatform or a collection of subplatforms for which clean compilation without warnings should be ensured.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Compile.Validation.ValidateFileEncoding.FileEncodingVerdict.OK">
            <summary>
            Either pure ASCII or UTF-8 with a BOM.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Compile.Validation.ValidateFileEncoding.FileEncodingVerdict.NonAsciiNoEncoding">
            <summary>
            A file without BOM with non-ASCII chars.
            Suspicious for a 8bit encoding, which means characters might be interpreted differently depending on the context: hg will think then utf8, C# will consider ANSI, either 1252 or 1251 or whatever else. The worst case scenario I've seen were a Japanese box on which some of the 1252-usual chars were illegal bytes breaking compilation. To deal with that, make it Unicode.
            Also might be a Unicode file without a BOM, but also to avoid ambiguity we'd like to enforce the BOM.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Compile.Validation.ValidateFileEncoding.FileEncodingVerdict.ZeroBytes">
            <summary>
            The file has zero bytes in it. Either a non-text file with a text extension. Or maybe UTF-16 without a byte order mark. See below for that.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Compile.Validation.ValidateFileEncoding.FileEncodingVerdict.Utf16">
            <summary>
            A UTF-16 file with a BOM.
            Should better be changed to UTF-8. For instance, HG thinks such files binary (by the zero bytes) and fails with all diff/merge stuff, so any merge conflicts are a mess.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Compile.Validation.ValidateFileEncoding.FileEncodingVerdict.Utf32">
            <summary>
            A UTF-32 file with a BOM.
            Should better be changed to UTF-8. For instance, HG thinks such files binary (by the zero bytes) and fails with all diff/merge stuff, so any merge conflicts are a mess.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Compile.Validation.ValidateFileEncoding.SourceFilesForEncodingCheck.RegexAllow">
            <summary>
            Allow-filters are applied to the file set first. Only matching files are let thru.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Compile.Validation.ValidateFileEncoding.SourceFilesForEncodingCheck.RegexDeny">
            <summary>
            Deny-filters are applied to the allowed file set. Matching files are dropped out.
            </summary>
        </member>
        <member name="M:JetBrains.Application.BuildScript.Compile.Validation.ValidateFileEncoding.SourceFilesForEncodingCheck.#ctor">
            <summary>
            Default files filter.
            </summary>
        </member>
        <member name="M:JetBrains.Application.BuildScript.Compression.ZipCompress(JetBrains.Util.RelativePath,System.Collections.Generic.IEnumerable{JetBrains.Util.Storage.SimpleFileItem},JetBrains.Util.ILogger,System.String)">
            <summary>
            Creates a ZIP file, streaming fashion, without using intermediate storage.
            Makes sure all entries have their sizes assigned correctly.
            Assesses each entry if it's compressable and writes in storing mode if not.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.EntryPoints.EntryLocalRunBinaryStage">
            <summary>
            The main local entry point for running second-stage builds which require already-compiled packages produced in the source stage.
            </summary>
            <remarks>The declaration is here so that to make it available to UI. The implementation requires CLR4.</remarks>
        </member>
        <member name="T:JetBrains.Application.BuildScript.EntryPoints.EntryOpenInVisualStudio">
            <summary>
            The end-user entry point artifact for preparing the local working copy + opening solution in Visual Studio.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.EntryPoints.EntryLocalMakePackedInstaller">
            <summary>
            The end-user entry point artifact to create a packed installer and copy it to Bin folder.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.EntryPoints.EntryStdAfx">
            <summary>
            The test entry point for fast debugging of build steps.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.EntryPoints.EntryLocalPrepareWorkingCopy">
            <summary>
            The end-user entry point artifact for preparing the local working copy.
            Runs <see cref="T:JetBrains.Application.BuildScript.PreCompile.LocalPrepareWorkingCopy"/> in a nested build with all the full context.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.IncrementalBuild">
            <summary>
            Basic control of the Incremental Build mode in the build process.
            Should be OFF on the server to ensure a clean and repeatable build.
            With a local process, allows to speed up things considerably by turning off much of the sandboxing and re-generation.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Install.ExtractPackagesToBinDir">
            <summary>
            Causes the packages be extracted into the Product Binaries Dir.
            </summary>
        </member>
        <member name="M:JetBrains.Application.BuildScript.Install.Launcher.CompileTimeLauncherHosts.EmbedCompileTimeLauncherHosts(JetBrains.Application.BuildScript.Install.Launcher.StandaloneLauncherHostInPackageArtifact[],System.Collections.Generic.ICollection{JetBrains.Application.BuildScript.Install.Launcher.CleanLauncherArtifact},JetBrains.Application.BuildScript.Compile.CodeSigning.IAuthenticodeSigningService,JetBrains.Util.ILogger,System.Collections.Generic.IList{JetBrains.Application.BuildScript.SubplatformFileForPackaging}@,System.Collections.Generic.IList{JetBrains.Application.BuildScript.Compile.SubplatformComponentForPackaging}@)">
            <summary>
            Generates the compile-time launcher hosts which are to be embedded in the package, <see cref="T:JetBrains.Application.BuildScript.Install.Launcher.StandaloneLauncherHostInPackageArtifact"/>.
            Os integration is run at install-time, so schedule some data for it to execute.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Install.Launcher.GuiLauncherNamingScheme">
            <summary>
            Default naming scheme which should produce shorter and non-techy-looking file names, preferring shorter for GUI.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Install.Launcher.ILauncherNamingScheme">
            <summary>
            Tells how to name launcher files depending on their config.
            </summary>
        </member>
        <member name="M:JetBrains.Application.BuildScript.Install.Launcher.ILauncherNamingScheme.GetExeFileSuffix(JetBrains.Application.BuildScript.Install.Launcher.LauncherConfig)">
            <summary>
            Gets the suffix to add to the launcher file name to disambig different configs on disk.
            Must be defined and distinct for all configs.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Install.Launcher.LauncherHostHelpers">
            <summary>
            Utilities for stuffing launchers into host entry points.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Install.GenerateLicensesDoc">
            <summary>
            Generate document with licenses from all used packages
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Install.Launcher.LauncherNamingScheme">
            <summary>
            Base impl.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Install.Launcher.StandaloneLauncherHostBase">
            <summary>
            Describes the standalone launcher, common properties.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Install.Launcher.StandaloneLauncherHostInPackageArtifact">
            <summary>
            Requests that a standalone host be embedded into a product package.
            The entry point executable is created on the Compile stage. It is explicitly included with the product packages and is just extracted on the target deployment machine. It thus cannot have host components which have any install-specific serialized info or know the full set of installed application packages. Such launchers have to collect available packages on startup by reading the package metadata files.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Install.Launcher.StandaloneLauncherHostInPackageArtifact.Subplatform">
            <summary>
            Specific to in-package hosts.
            The subplatform whose package is to deploy it.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Install.Launcher.StandaloneLauncherHostOsIntegration">
            <summary>
              <para>A subset of the <see cref="T:JetBrains.Application.BuildScript.Install.Launcher.StandaloneLauncherHostBase"/> properties which governs launcher's integration with the OS.</para>
              <para>For in-package hosts, this has to be carried out to the binary stage (which is executed upon installation) to be carried out.</para>
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Install.Launcher.StandaloneLauncherHostOsIntegration.LauncherLocation">
            <summary>
            Gives out the location of the stuffed launcher file, relatively to its originating package.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Install.Launcher.TechnicalConsoleLauncherNamingScheme">
            <summary>
            Alt naming scheme with technical names for entries, looks more techy and verbose, but better for service executables.
            Prefers shorter names for console executables.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Install.Launcher.TechnicalGuiLauncherNamingScheme">
            <summary>
            Alt naming scheme with technical names for entries, looks more techy and verbose, but better for service executables.
            Prefers shorter names for GUI executables.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Install.Launcher.WrappedNamingScheme">
            <summary>
            Augments another naming scheme.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Install.LocalInstallRootSuffix">
            <summary>
            Chooses the root suffix to be used when local-installing the host, both VS and standalone hosts.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Install.LocalSavePackagesToBinDir">
            <summary>
            Causes the packages be saved into the Product Binaries Dir.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Install.PostInstallExecutableArtifact">
            <summary>
            Local machine executables to run elevated on register and unregister.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Compile.Actions.SubplatformVsCommandsGuidArtifact">
            <summary>
            Specifies the GUID to be used for Visual Studio CommandID for the actions in this subplatform.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Compile.Actions.SubplatformVsCommandsGuidArtifact.ActionsCommandGroupGuid">
            <summary>
            Gets the VS Command Group GUID to be used for regular actions in this subplatform when they are turned into VS commands.
            </summary>
        </member>
        <member name="M:JetBrains.Application.BuildScript.Compile.Actions.SubplatformVsCommandsGuidArtifact.GenerateGuidForActions(JetBrains.Application.BuildScript.Solution.SubplatformName)">
            <summary>
            For subplatforms for which a custom hard-coded GUID is not set, generates a new dynamic GUID deterministically for use on action commands.
            </summary>
            <param name="sname"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Application.BuildScript.Compile.Actions.SubplatformVsCommandsGuidArtifact.GenerateGuidForGroups(JetBrains.Application.BuildScript.Solution.SubplatformName)">
            <summary>
            Generates a new dynamic GUID deterministically for use on subplatform's command groups.
            </summary>
            <param name="sname"></param>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Application.BuildScript.PreCompile.EntryLocalAutofixFiles">
            <summary>
            The entry point for running autofix of local projects.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.PreCompile.LocalPreExtractFastFilesForPackaging">
            <summary>
            As part of the <see cref="T:JetBrains.Application.BuildScript.PreCompile.LocalPrepareWorkingCopy"/>, extracts to Bin Dir those package-wannabe items which are fast to produce, hence <see cref="T:JetBrains.Application.BuildScript.Compile.SubplatformFileForPackagingFast"/>.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.PreCompile.LocalSavePackagesToShadowPackagesDir">
            <summary>
            Causes the packages be saved into the BinDir\ShadowPackages.
            </summary>
        </member>
        <member name="M:JetBrains.Application.BuildScript.PreCompile.PackageFileRoleEx.IsInstalled(JetBrains.Application.BuildScript.Compile.PackageFileRole)">
            <summary>
            Whether it might be installed to the Bin Dir with the installer (supposedly, symbols packages are also included — check for <see cref="M:JetBrains.Application.BuildScript.PreCompile.PackageFileRoleEx.IsIncludedInMainPackage(JetBrains.Application.BuildScript.Compile.PackageFileRole)"/> if you want to filter that as well).
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.ProductBinariesDirRelativeHintArtifact">
            <summary>
            A supplementary artifact for specifying a local product binaries dir as a path relative to the product home dir (as a relative path behaves better in persistent settings).
            If the <see cref="T:JetBrains.Application.BuildScript.ProductBinariesDirArtifact"/> is given a value, this value is ignored.
            If the <see cref="T:JetBrains.Application.BuildScript.ProductBinariesDirArtifact"/> has to be calculated, it uses this value or falls back to <see cref="F:JetBrains.Application.BuildScript.Solution.AllAssembliesLocator.DefaultProductBinariesDirFolderName"/> if not set.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.ProductBinariesDirRelativeHintArtifact.ProductBinariesDirRelativeHint">
            <summary>
            If relative, gives the desired <see cref="T:JetBrains.Application.BuildScript.ProductBinariesDirArtifact"/> path relatively to the <see cref="T:JetBrains.Application.BuildScript.ProductHomeDirArtifact"/>. Otherwise, the path to use as is.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.ShadowPackageDirArtifact">
            <summary>
            Allows the build to read some of the precalulated nupkgs.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.SkipSourcesValidation">
            <summary>
            If this artifact is set to <c>True</c>, sources will not be validated before being compiled into Nuget packages.
            Locally this speeds up repeated runs of packages generation.
            Shan't be set to <c>True</c> on the server.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.SkipSourcesValidation.IsSkipSourcesValidation">
            <summary>
            If this artifact is set to <c>True</c>, sources will not be validated before being compiled into Nuget packages.
            Locally this speeds up repeated runs of packages generation.
            Shan't be set to <c>True</c> on the server.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.SkipLocalCompilationCpp.Calculated">
            <summary>
            Calculates a ready value for CPP compliation criterion.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.SkipLocalCompilationCpp.Calculated.IsSkip">
            <summary>
            Calculates a ready value for CPP compliation criterion.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Install.InstallerExeBootstrapper">
            <summary>
            The executable of the installer bootstrapper, a single-exe responsible for downloading and executing installer form gallery.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Testing.UnitTestPlatform">
            <summary>
            Specifies the platform for running unit tests, which includes the CPU architecture and CLR version.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Testing.UnitTestFilter">
            <summary>
            Applies a filter to the unit tests, either by category or by assembly to run.
            To filter by subplatforms, set the <see cref="T:JetBrains.Application.BuildScript.Solution.AllAssembliesFilter"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Testing.UnitTestFilter.AssemblyBareNameFilter">
            <summary>
            A Regex which filters which subplatform assemblies are getting fed into the unit test runner.
            <see cref="T:JetBrains.Application.BuildScript.Solution.AllAssembliesFilter"/> filters subplatforms which are deployed for running the tests, and this allows to further limit it down.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Testing.UnitTestFilter.CategoryExclude">
            <summary>
            As in <see cref="T:JetBrains.Application.BuildScript.Testing.TestsFilter"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Testing.UnitTestFilter.CategoryInclude">
            <summary>
            As in <see cref="T:JetBrains.Application.BuildScript.Testing.TestsFilter"/>.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Serialization.JsonValueSerializerAlt`1">
            <summary>
            Uses the alternative JSON serializer, not the system one.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Serialization.JsonTypeConverterAlt`1">
            <summary>
            Uses the alternative JSON serializer, not the system one.
            </summary>
        </member>
        <member name="T:JetBrains.Application.AdvancedSettingsLayersEditingTrait">
            <summary>
            Takes all <see cref="P:JetBrains.Application.ISettingsApplicationTrait.IsAdvancedSettingsLayersEditingSupported"/> and applies the combining rule.
            </summary>
        </member>
        <member name="P:JetBrains.Application.IApplicationDescriptorUpdatesTmp.UpdatesFilterUri">
            <summary>
            Gets the URI to request for the product updates, if available. //TODO:link to updates format info
            </summary>
        </member>
        <member name="M:JetBrains.Application.ApplicationDescriptor.ApplicationPackagesFilesEx.GetExtensionsFileSystemPaths(JetBrains.Application.ApplicationDescriptor.ApplicationPackagesFiles,JetBrains.Util.RelativePath)">
            <summary>
            Returns files from the Extensions sub-folder
            </summary>
            <remarks>
            Extension settings and annotations files must be stored in a per-extension folder under
            "Extensions", e.g. "Extensions\{extensionId}\annotations\" or "Extensions\{extensionId}\settings\".
            This is to prevent name clashes since all packages are extracted to the main install directory.
            (Especially the case for annotations, where the filename is the name of the assembly being
            annotated). 
            </remarks>
            <param name="applicationPackagesFiles">An instance of <see cref="T:JetBrains.Application.ApplicationDescriptor.ApplicationPackagesFiles"/>.</param>
            <param name="root">The <see cref="T:JetBrains.Util.RelativePath"/> to be returned from the per-extension Extensions folder.</param>
            <returns>An enumerable of all the files under <see cref="!:root"/> in the per-extension Extensions folder.</returns>
        </member>
        <member name="T:JetBrains.Application.IApplicationHost">
            <summary>
            Aggregating interface to access host properties, host product and shortcuts to host folders
            </summary>
        </member>
        <member name="T:JetBrains.Application.IApplicationHostImages">
            <summary>
            Images of end user product.
            </summary>
        </member>
        <member name="P:JetBrains.Application.IApplicationHostImages.ProductAboutBoxImage">
            <summary>
              <para>AboutBox for the product shows this image. Recommended minimum width: <c>200h</c>.</para>
              <para>Usually, it's the same image as the installer Welcome Page banner. So its width is 512 px.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Application.IApplicationShortcutsTrait.IsOobeChoosingAltKeyboardScheme">
            <summary>
            Set to <c>True</c> in <see cref="!:IApplicationDescriptor.Bag"/> of the product to ask user whether he'd like to choose an alternative keyboard scheme during the product OOBE experience.
            </summary>
        </member>
        <member name="T:JetBrains.Application.IExceptionReportingApplicationTrait">
            <summary>
              <para>Allows hosts to override some of the exception processing related features.</para>
              <para>Currently it's only consumed in Shell components, so its impls should be Shell components themselves.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Application.IExceptionReportingApplicationTrait.OverrideDefaultExceptionReportStrategy">
            <summary>
            Allows to override the exception report strategy for the host. <c>NULL</c> to exempt from selecting the strategy.
            </summary>
        </member>
        <member name="P:JetBrains.Application.IExceptionReportingApplicationTrait.OverrideModeReportExceptions">
            <summary>
              <para>Allows to override the <c>IsModeReportException</c> modifier for a specific host.</para>
              <para>This runtime value takes precedence over the one compiled into the host's package on TC, but only takes effect after Shell is started and its reporter component is activated.</para>
            </summary>
        </member>
        <member name="T:JetBrains.Application.IHostProductInfo">
            <summary>
            Examples: ReSharperPlatform, DotPeek, InspectCode, etc.
            Implementations are environment components.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.IProductInfo">
            <summary>
            Either host or sub-product information
            </summary>
        </member>
        <member name="M:JetBrains.Application.ISettingsApplicationTrait.GetLegacySettingsFiles">
            <summary>
            Allows to look for older-version settings in non-standard folders when there are no up-to-date-version settings found and we would like to upgrade from an older version.
            The strings are file path names.
            The versions are versions of the product to which the settings supposedly belong.
            </summary>
        </member>
        <member name="P:JetBrains.Application.ISettingsApplicationTrait.IsAdvancedSettingsLayersEditingSupported">
            <summary>
              <para>Whether advanced layer editing should be available in Options etc.</para>
              <para><c>Null</c> or no handlers means “Yes” (this functionality is activated by default).</para>
              <para>Any <c>False</c> wins over all <c>Null</c>s and means “No”.</para>
              <para>Any <c>True</c> wins over all <c>False</c>s and <c>Null</c>s and means “Yes”.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Application.IStandaloneApplicationTrait.CommandLineHelpText">
            <summary>
            Set this metadata on <see cref="!:IApplicationDescriptor.Bag"/> to enable showing product help on this command line key.
            </summary>
        </member>
        <member name="P:JetBrains.Application.IStandaloneApplicationTrait.IsSingleInstanceStandaloneProduct">
            <summary>
              <para>When <c>True</c>, and an instance of this product is already running, starting the second instance will not create the host but will pass the command line to the first instance AS IS instead, and exit.</para>
              <para>To watch for the new command line arguments, see the <see cref="P:JetBrains.Application.ICommandLine.Parameters"/>.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Application.IStandaloneApplicationTrait.MainMenuActionID">
            <summary>
            Set this on the application descriptor to the Action ID of the main menu for your application. <c>Null</c> means your application does not have a main menu.
            </summary>
        </member>
        <member name="P:JetBrains.Application.IStandaloneApplicationTrait.MainToolbarActionID">
            <summary>
            Set this on the application descriptor to the Action ID of the main toolbar for your application. <c>Null</c> means your application does not have a main toolbar.
            </summary>
        </member>
        <member name="M:JetBrains.Application.ProductInfoExtensions.PresentableInfoForAboutBox(JetBrains.Application.BuildScript.IProductInfo)">
            <summary>
            Renders the product info in the same way as it's presented in ALL about-like UIs: About Box, VS About Box, VS Options, Exception Info, and so on.
            The first string is the company-name-marketversion part (“bold part”) and the second is the technical version. build date is omitted because it looks ugly.
            </summary>
        </member>
        <member name="M:JetBrains.Application.ProductInfoExtensions.PresentableInfoForAboutBox(JetBrains.Application.BuildScript.Application.HostInfo)">
            <summary>
            Renders the product info in the same way as it's presented in ALL about-like UIs: About Box, VS About Box, VS Options, Exception Info, and so on.
            The first string is the company-name-marketversion part (“bold part”) and the second is the technical version, builddate and alike (“faded part”).
            </summary>
        </member>
        <member name="T:JetBrains.Application.ProductInfoExtensions.MasterDetailInfo">
            <remarks>The cheat of using this instead of some <see cref="T:JetBrains.Util.Pair"/> is to have <see cref="M:JetBrains.Application.ProductInfoExtensions.MasterDetailInfo.ToString"/> format it decently by default.</remarks>
        </member>
        <member name="T:JetBrains.Application.BuildScript.UltimateLicensingConstants">
            <summary>
            Constants used to check ReSharper Ultimate license
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.UltimateLicensingConstants.LicenseVersion">
            <summary>
            Version of corresponding ReSharper Ultimate release
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.UltimateLicensingConstants.ProductBuiltDateUsedForSubscriptionCheck">
            <summary>
            DateTime of corresponding ReSharper Ultimate release
            </summary>
        </member>
        <member name="T:JetBrains.Application.Environment.ApplicationPackages">
            <summary>
            Caches info on the list of the currently installed application packages.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Environment.ApplicationStartupTraceHelpers.TraceCatalogSet(JetBrains.Application.Catalogs.IPartCatalogSet,System.String,System.Boolean,JetBrains.Util.ILogger)">
            <summary>
            All assemblies and types which pass the filter in the current catalog set.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Environment.DeployedPackagesCacheIdentity">
            <summary>
            Incapsulates calculating the identity for <see cref="T:JetBrains.Application.Environment.DeployedPackagesCache"/>.
            This allows to tell cache files for different contexts from one another, and also to check if the cache is still up-to-date, or should rather be recalculated.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Environment.DeployedPackagesCacheIdentity.FolderLastWriteTime">
            <summary>
            LWTime of the folder filesystem object itself.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Environment.DeployedPackagesCacheIdentity.ModuleFilesLastWriteTime">
            <summary>
            Newest LWtime of all the module (dll/exe) files in the folder.
            Might be <see cref="F:System.DateTime.MinValue"/> if there're none.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Environment.DeployedPackagesCacheIdentity.MinimalPackageSetFilter">
            <summary>
              <para>Filters subplatforms (=packages) whose DLLs are considered for caching and cataloging in this folder.</para>
              <para><c>NULL</c> means take em all.</para>
              <para>A specific value means that only the package which has this DLL and all of its referenced packages (transitively) should be taken.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Application.Environment.DeployedPackagesCacheIdentityEx.WithSubplatformPassFilter(JetBrains.Application.Environment.DeployedPackagesCacheIdentity,JetBrains.Metadata.Utils.AssemblyNameInfo)">
            <summary>
              <para>Filters subplatforms (=packages) whose DLLs are considered for caching and cataloging in this folder.</para>
              <para><c>NULL</c> means take em all.</para>
              <para>A specific value means that only the package which has this DLL and all of its referenced packages (transitively) should be taken.</para>
            </summary>
        </member>
        <member name="T:JetBrains.Application.Environment.EnvironmentPartCatalogSet">
            <summary>
            Holds the product's pre-Shell <see cref="T:JetBrains.Application.Catalogs.PartCatalogSet"/> for running the Environment, already filtered down with Environment zones.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Environment.MasterBinderDiskFilesList">
            <summary>
            Caches the list of assembly files which should be loadable by assembly name at runtime.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Environment.DeployedPackagesCache">
            <summary>
            For any folder into which a packages-based app is deployed, can cache the info which is normally extracted from the packages.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Environment.DeployedPackagesCache.LoadOrCreate(JetBrains.DataFlow.Lifetime,JetBrains.Util.FileSystemPath)">
            <summary>
            Tries to load the cached data for the specific bindir.
            </summary>
            <param name="lifetime"></param>
            <param name="bindir"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Application.Environment.DeployedPackagesCache.LoadOrCreate(JetBrains.DataFlow.Lifetime,JetBrains.Application.Environment.DeployedPackagesCacheIdentity)">
            <summary>
            Tries to load the cached data for the specific bindir.
            </summary>
            <param name="lifetime"></param>
            <param name="identity">Identifies the bindir, plus possibly some filtered view on it.</param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Application.Environment.DeployedPackagesCacheTasks.CreateNewCache(JetBrains.Application.Environment.DeployedPackagesCacheIdentity,System.IO.Stream)">
            <summary>
            Builds the new cache based on the Product Binaries Dir, as identified by <paramref name="identity" />.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Environment.DeployedPackagesCacheTasks.LoadCache(JetBrains.DataFlow.Lifetime,System.Byte*,JetBrains.Util.FileSystemPath,JetBrains.Util.OnError,JetBrains.Application.Table.CatalogTables@,JetBrains.Build.Serialization.SerializedValuesResolver@)">
            <summary>
            Loads the cache from the memory dump.
            Validates what it can (e.g. header and bindir path match).
            </summary>
            <param name="lifeFile"></param>
            <param name="pBuffer"></param>
            <param name="bindir">Validates that the memory dump has been created with this same bindir.</param>
            <param name="onerror">Defines the throw/canbenull behavior.</param>
            <param name="catables"></param>
            <param name="components"></param>
        </member>
        <member name="M:JetBrains.Application.Environment.DeployedPackagesCacheTasks.LoadCacheFile(JetBrains.DataFlow.Lifetime,JetBrains.Application.Environment.DeployedPackagesCacheIdentity,JetBrains.Util.OnError)">
            <summary>
            Tries to load the new cache file for the Product Binaries Dir of <paramref name="identity" />, from its location in Local App Data given by its <paramref name="identity" />.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Environment.DeployedPackagesCacheTasks.WriteNewCacheFile(JetBrains.Application.Environment.DeployedPackagesCacheIdentity)">
            <summary>
            Writes the new cache file for the Product Binaries Dir of <paramref name="identity" />, to its location in Local App Data given by its <paramref name="identity" />.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Environment.DeployedPackagesCacheTasks.EnsureAlignment(System.IO.Stream,System.Byte)">
            <summary>
            Makes sure that the end of stream (= next write) is aligned by a multiple of the given number of bytes.
            Useful for reading UTF-16 strings in the binary file (they must be aligned by WORD).
            Even more useful if you're about to map the file into memory, then many functions like to have their pointers WORD or DWORD aligned. Or reading unaligned structs might come out deadly slow.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Environment.DeployedPackagesCacheTasks.GetCacheDirectory">
            <summary>
            The place for this data.
            It's complicated to get the host name at this point, so just bind to the wave.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Environment.DeployedPackagesCacheTasks.CacheHeader.Signature">
            <summary>
            Format marker.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Environment.DeployedPackagesCacheTasks.CacheHeader.PartCatalogTables">
            <summary>
            RVA to the catalog tables. TODO: Format.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Environment.DeployedPackagesCacheTasks.CacheHeader.PackageTimeComponents">
            <summary>
            RVA to the serialized build-time components (all such collected from all the packages).
            </summary>
        </member>
        <member name="F:JetBrains.Application.Environment.DeployedPackagesCacheTasks.CacheHeader.ProductBinariesDir">
            <summary>
            RVA to the Product Binaries Dir full path. Format: a zero-terminated UTF-16 string.
            This is to validate that we're not colliding over the file name hash.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Environment.HostParameters.CollectProductPackagesInDirectoryFlatHostMixin">
            <summary>
              <para>Runs on a set of product packages as discovered in the actual Product Binaries Dir, extracted there in a flat manner.</para>
              <para>Applies appropriate caching for per-package components and the common part catalog.</para>
              <para>Starting with wave04, this is expected to be the main way of running the shell.</para>
            </summary>
        </member>
        <member name="T:JetBrains.Application.Environment.HostParameters.IHaveEnvironmentComponentsHostMixin">
            <summary>
            Allows to add custom components to the host container, at the very top level (fixes into the Env container resolve).
            </summary>
        </member>
        <member name="T:JetBrains.Application.Environment.HostParameters.IJetHostMixin">
            <summary>
            Marks the base requirement for all mixins.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Environment.HostParameters.IHaveEnvironmentComponentsHostMixin.Fill(JetBrains.Application.Components.ComponentContainer,JetBrains.Application.Environment.EnvironmentPartCatalogSet)">
            <summary>
            Called when you're to add components.
            Either call <c>Register</c> for an object, or <c>RegisterResolver</c> for a custom resolver, or you can even add descriptors.
            </summary>
            <param name="container">The container to modify.</param>
            <param name="catalogsetContainer">The catalog set over which the component is being constructed. We can't retrieve it from the catalog itself because it has not been composed yet at this point, though technically it would have been the preferred way.</param>
            // NOTE: this param is a hack, but the best effort to resolve the VS service provider wrappers autodiscovery
        </member>
        <member name="T:JetBrains.Application.Environment.HostParameters.IHaveFullPartCatalogSetHostMixin">
            <summary>
            The complete catalog set, as collected from the products currently known, plus their plugins and any parts introduced later. This is the origin of all the catalogsets in the component containers. It's not filtered yet, even by the environment.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Environment.HostParameters.IHaveFullPartCatalogSetHostMixin.GetFullPartCatalogSet(JetBrains.DataFlow.Lifetime)">
            <summary>
            The complete catalog set, as collected from the products currently known, plus their plugins and any parts introduced later. This is the origin of all the catalogsets in the component containers. It's not filtered yet, even by the environment.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Environment.HostParameters.CollectProductPackagesInDirectoryFlatHostMixin.myDeployedPackagesCache">
            <summary>
            Lazy-inited when we're asked for the env part catalog.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Environment.HostParameters.CollectProductPackagesInDirectoryFlatHostMixin.#ctor(System.Lazy{JetBrains.Application.BuildScript.ProductBinariesDirArtifact},System.Reflection.Assembly)">
            <summary>
            </summary>
            <param name="productBinariesDirArtifact">The dir with extracted packages. Lazy, to ensure any exceptions in getting it are trapped.</param>
            <param name="minimalPackageSetFilter">
              <para>Filters subplatforms (=packages) whose DLLs are considered for caching and cataloging in this folder.</para>
              <para><c>NULL</c> means take em all.</para>
              <para>A specific value means that only the package which has this DLL and all of its referenced packages (transitively) should be taken.</para>
            </param>
        </member>
        <member name="P:JetBrains.Application.Environment.EnvironmentZones.AllZoneParts">
            <summary>
            All zone parts in part catalogue
            </summary>
        </member>
        <member name="P:JetBrains.Application.Environment.EnvironmentZones.ZoneToSuccessorsMap">
            <summary>
            All immediate successors in zones graph
            </summary>
        </member>
        <member name="P:JetBrains.Application.Environment.EnvironmentZones.ZoneToPredecessorsMap">
            <summary>
            All immediate predecessors in zones graph
            </summary>
        </member>
        <member name="P:JetBrains.Application.Environment.EnvironmentZones.ZoneToInheritorsMap">
            <summary>
            immediate successors in zones graph which are derived type (not IReguire)
            </summary>
        </member>
        <member name="M:JetBrains.Application.Environment.EnvironmentZonesExtra.TryGetProductInfo(JetBrains.Application.BuildScript.Application.Zones.ZonePart)">
            <summary>
            Gets the attr of type <see cref="T:JetBrains.Application.BuildScript.Application.Zones.ZoneDefinitionProductAttribute"/> on the zone, if it got one.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Environment.EnvironmentZonesExtra.FeatureInfo">
            <summary>
            Gets feature info for a module zone, extracts from the <see cref="T:JetBrains.Application.BuildScript.Application.Zones.ZoneDefinitionConfigurableFeatureAttribute"/> attribute.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Environment.EnvironmentZonesExtra.ProductInfo">
            <summary>
            Gets feature info for a module zone, extracts from the <see cref="T:JetBrains.Application.BuildScript.Application.Zones.ZoneDefinitionProductAttribute"/> attribute.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Environment.HostParameters.InitExceptionReporterOnSerializedComponentsHostMixin.ShellLessExceptionReporting__CreateDeadEnd">
            <summary>
            Does not show exceptions to the user.
            Used in Production Mode when we shouldn't be showing the exceptions to the user.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Environment.PreviewShellPartCatalogSet">
            <summary>
            Previews the changes that are going to appear in <see cref="T:JetBrains.Application.Environment.ShellPartCatalogSet"/>.
            Available for import in Shell.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Environment.ShellPartCatalogSet">
            <summary>
            Gives out the product's main <see cref="T:JetBrains.Application.Catalogs.PartCatalogSet"/> of the running Shell.
            Available for import in Shell.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Communication.ShellWebProxySettingsReader">
            <summary>
            Web proxy settings. Use <see cref="T:JetBrains.Application.Communication.WebProxySettingsReader"/> to create a .NET-API-compatible proxy object.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Communication.WebProxySettingsReader.GetProxySettings">
            <summary>
            Gets the .NET-API-compatible proxy settings.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Deploy.LocalDeployScriptFile">
            <summary>
            Causes the deploy items be saved into the Product Binaries Dir.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Deploy.LocalDeployScriptFileTasks">
            <summary>
            <see cref="T:JetBrains.Application.Deploy.LocalDeployScriptFile"/> impl.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Deploy.PushToCdnDeployable.PathToArtifact">
            <summary>
            Relative path to artifact that we need to corporate CDN server
            </summary>
        </member>
        <member name="F:JetBrains.Application.Deploy.PushToChocolateyDeployable.PathToArtifact">
            <summary>
            Relative path to artifact that we need to publish to https://chocolatey.org
            </summary>
        </member>
        <member name="F:JetBrains.Application.Deploy.PushToPdbServerDeployable.PathToArtifact">
            <summary>
            Relative path to artifact that we need to push public pdb server for debugging purposes
            This file is zip file containing specially prepared symbol storage files with tags.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Deploy.PushToNugetOrgDeployable.PathToArtifact">
            <summary>
            Relative path to artifact that we need to push to nuget.org
            </summary>
        </member>
        <member name="F:JetBrains.Application.Deploy.PushToPdbServerArtifact.SimpleFileItem">
            <summary>
              Can only contains zip archive with symbol storage structure and tag information
            </summary>
        </member>
        <member name="F:JetBrains.Application.Deploy.PushToReSharperGalleryDeployable.PathToArtifact">
            <summary>
            Relative path to artifact that we need to push to resharper nuget gallery
            This file ma be a .nupkg file or zip file containing .nupkg files.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Deploy.SymbolStorageConstants.TagDirectory">
            <summary>
              DON'T CHANGE THIS DIRECTORY NAME!!!
            </summary>
        </member>
        <member name="F:JetBrains.Application.Deploy.SymbolStorageConstants.TagExtension">
            <summary>
              DON'T CHANGE THIS EXTENSION!!!
            </summary>
        </member>
        <member name="F:JetBrains.Application.ExceptionReport.IsModeReportExceptionsComponent.IsModeReportExceptionsCore">
            <summary>
            Exception reporting value in the Platform Core.
            </summary>
        </member>
        <member name="P:JetBrains.Application.ExceptionReport.IsModeReportExceptionsComponent.IsShowingExceptionsToUser">
            <summary>
              Central property for deciding whether to show any exceptions to the user. Sometimes we'd like to suppress exception notifications at all (eg for trade show demos), in these cases this flag goes low.
            The composite value of whether to report exceptions, this takes into account both the build config and current shell internal mode.
            </summary>
        </member>
        <member name="T:JetBrains.Application.ExceptionReport.SccRevisionExceptionReportDataProviderShell">
            <summary>
              <para>Exposes the SCC revision of the codebase off which the host package was built. Lists home packages of subproducts. As a Shell component, only activates in Shell.</para>
              <para>The About Box has detailed info on all packages' revisions.</para>
            </summary>
        </member>
        <member name="T:JetBrains.Application.ExceptionReport.IExceptionReportDataProvider">
            <summary>
            Components exporting this interface are called to add data to the exception when an exception is about to be reported.
            Use <see cref="M:JetBrains.Util.ExceptionEx.AddDataUnsafe``1(``0,System.String,System.Object)"/> (NOTE: it's important to use this overload as the others are non-functional in Production mode!) on the <see cref="T:System.Exception"/> object of the data you're given to add exception data to the exception object.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Install.FileAssociationHelper.UpdateSystemFileAssociation">
            <summary>
            Run this method every time file associations has been changed
            </summary>
        </member>
        <member name="M:JetBrains.Application.Install.FileAssociationHelper.RegisterApplicationAssociation(System.String,JetBrains.Util.FileSystemPath,System.String,System.String,System.Int32)">
            <summary>
            Register application and add file associations for local user
            http://support.microsoft.com/kb/257592
            http://msdn.microsoft.com/en-us/library/windows/desktop/cc144158(v=vs.85).aspx
            </summary>
            <param name="appId">Application id (cannot start with dot)</param>
            <param name="fullPath"></param>
            <param name="extension">File extension which be associated with the application (has to start with dot)</param>
            <param name="extDescription">Descripton which will be shown in Explorer</param>
            <param name="iconIndex"></param>
        </member>
        <member name="F:JetBrains.Application.Install.FileAssociationHelper.HChangeNotifyFlags.SHCNF_DWORD">
            <summary>
            The <i>dwItem1</i> and <i>dwItem2</i> parameters are DWORD values. 
            </summary>
        </member>
        <member name="F:JetBrains.Application.Install.FileAssociationHelper.HChangeNotifyFlags.SHCNF_IDLIST">
            <summary>
            <i>dwItem1</i> and <i>dwItem2</i> are the addresses of ITEMIDLIST structures that 
            represent the item(s) affected by the change. 
            Each ITEMIDLIST must be relative to the desktop folder. 
            </summary>
        </member>
        <member name="F:JetBrains.Application.Install.FileAssociationHelper.HChangeNotifyFlags.SHCNF_PATHA">
            <summary>
            <i>dwItem1</i> and <i>dwItem2</i> are the addresses of null-terminated strings of 
            maximum length MAX_PATH that contain the full path names 
            of the items affected by the change. 
            </summary>
        </member>
        <member name="F:JetBrains.Application.Install.FileAssociationHelper.HChangeNotifyFlags.SHCNF_PATHW">
            <summary>
            <i>dwItem1</i> and <i>dwItem2</i> are the addresses of null-terminated strings of 
            maximum length MAX_PATH that contain the full path names 
            of the items affected by the change. 
            </summary>
        </member>
        <member name="F:JetBrains.Application.Install.FileAssociationHelper.HChangeNotifyFlags.SHCNF_PRINTERA">
            <summary>
            <i>dwItem1</i> and <i>dwItem2</i> are the addresses of null-terminated strings that 
            represent the friendly names of the printer(s) affected by the change. 
            </summary>
        </member>
        <member name="F:JetBrains.Application.Install.FileAssociationHelper.HChangeNotifyFlags.SHCNF_PRINTERW">
            <summary>
            <i>dwItem1</i> and <i>dwItem2</i> are the addresses of null-terminated strings that 
            represent the friendly names of the printer(s) affected by the change. 
            </summary>
        </member>
        <member name="F:JetBrains.Application.Install.FileAssociationHelper.HChangeNotifyFlags.SHCNF_FLUSH">
            <summary>
            The function should not return until the notification 
            has been delivered to all affected components. 
            As this flag modifies other data-type flags, it cannot by used by itself.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Install.FileAssociationHelper.HChangeNotifyFlags.SHCNF_FLUSHNOWAIT">
            <summary>
            The function should begin delivering notifications to all affected components 
            but should return as soon as the notification process has begun. 
            As this flag modifies other data-type flags, it cannot by used by itself.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Install.FileAssociationHelper.HChangeNotifyEventID.SHCNE_ALLEVENTS">
            <summary>
            All events have occurred. 
            </summary>
        </member>
        <member name="F:JetBrains.Application.Install.FileAssociationHelper.HChangeNotifyEventID.SHCNE_ASSOCCHANGED">
            <summary>
            A file type association has changed. <see cref="F:JetBrains.Application.Install.FileAssociationHelper.HChangeNotifyFlags.SHCNF_IDLIST"/> 
            must be specified in the <i>uFlags</i> parameter. 
            <i>dwItem1</i> and <i>dwItem2</i> are not used and must be <see langword="null"/>. 
            </summary>
        </member>
        <member name="F:JetBrains.Application.Install.FileAssociationHelper.HChangeNotifyEventID.SHCNE_ATTRIBUTES">
            <summary>
            The attributes of an item or folder have changed. 
            <see cref="F:JetBrains.Application.Install.FileAssociationHelper.HChangeNotifyFlags.SHCNF_IDLIST"/> or 
            <see cref="!:HChangeNotifyFlags.SHCNF_PATH"/> must be specified in <i>uFlags</i>. 
            <i>dwItem1</i> contains the item or folder that has changed. 
            <i>dwItem2</i> is not used and should be <see langword="null"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Install.FileAssociationHelper.HChangeNotifyEventID.SHCNE_CREATE">
            <summary>
            A nonfolder item has been created. 
            <see cref="F:JetBrains.Application.Install.FileAssociationHelper.HChangeNotifyFlags.SHCNF_IDLIST"/> or 
            <see cref="!:HChangeNotifyFlags.SHCNF_PATH"/> must be specified in <i>uFlags</i>. 
            <i>dwItem1</i> contains the item that was created. 
            <i>dwItem2</i> is not used and should be <see langword="null"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Install.FileAssociationHelper.HChangeNotifyEventID.SHCNE_DELETE">
            <summary>
            A nonfolder item has been deleted. 
            <see cref="F:JetBrains.Application.Install.FileAssociationHelper.HChangeNotifyFlags.SHCNF_IDLIST"/> or 
            <see cref="!:HChangeNotifyFlags.SHCNF_PATH"/> must be specified in <i>uFlags</i>. 
            <i>dwItem1</i> contains the item that was deleted. 
            <i>dwItem2</i> is not used and should be <see langword="null"/>. 
            </summary>
        </member>
        <member name="F:JetBrains.Application.Install.FileAssociationHelper.HChangeNotifyEventID.SHCNE_DRIVEADD">
            <summary>
            A drive has been added. 
            <see cref="F:JetBrains.Application.Install.FileAssociationHelper.HChangeNotifyFlags.SHCNF_IDLIST"/> or 
            <see cref="!:HChangeNotifyFlags.SHCNF_PATH"/> must be specified in <i>uFlags</i>. 
            <i>dwItem1</i> contains the root of the drive that was added. 
            <i>dwItem2</i> is not used and should be <see langword="null"/>. 
            </summary>
        </member>
        <member name="F:JetBrains.Application.Install.FileAssociationHelper.HChangeNotifyEventID.SHCNE_DRIVEADDGUI">
            <summary>
            A drive has been added and the Shell should create a new window for the drive. 
            <see cref="F:JetBrains.Application.Install.FileAssociationHelper.HChangeNotifyFlags.SHCNF_IDLIST"/> or 
            <see cref="!:HChangeNotifyFlags.SHCNF_PATH"/> must be specified in <i>uFlags</i>. 
            <i>dwItem1</i> contains the root of the drive that was added. 
            <i>dwItem2</i> is not used and should be <see langword="null"/>. 
            </summary>
        </member>
        <member name="F:JetBrains.Application.Install.FileAssociationHelper.HChangeNotifyEventID.SHCNE_DRIVEREMOVED">
            <summary>
            A drive has been removed. <see cref="F:JetBrains.Application.Install.FileAssociationHelper.HChangeNotifyFlags.SHCNF_IDLIST"/> or 
            <see cref="!:HChangeNotifyFlags.SHCNF_PATH"/> must be specified in <i>uFlags</i>. 
            <i>dwItem1</i> contains the root of the drive that was removed.
            <i>dwItem2</i> is not used and should be <see langword="null"/>. 
            </summary>
        </member>
        <member name="F:JetBrains.Application.Install.FileAssociationHelper.HChangeNotifyEventID.SHCNE_EXTENDED_EVENT">
            <summary>
            Not currently used. 
            </summary>
        </member>
        <member name="F:JetBrains.Application.Install.FileAssociationHelper.HChangeNotifyEventID.SHCNE_FREESPACE">
            <summary>
            The amount of free space on a drive has changed. 
            <see cref="F:JetBrains.Application.Install.FileAssociationHelper.HChangeNotifyFlags.SHCNF_IDLIST"/> or 
            <see cref="!:HChangeNotifyFlags.SHCNF_PATH"/> must be specified in <i>uFlags</i>. 
            <i>dwItem1</i> contains the root of the drive on which the free space changed.
            <i>dwItem2</i> is not used and should be <see langword="null"/>. 
            </summary>
        </member>
        <member name="F:JetBrains.Application.Install.FileAssociationHelper.HChangeNotifyEventID.SHCNE_MEDIAINSERTED">
            <summary>
            Storage media has been inserted into a drive. 
            <see cref="F:JetBrains.Application.Install.FileAssociationHelper.HChangeNotifyFlags.SHCNF_IDLIST"/> or 
            <see cref="!:HChangeNotifyFlags.SHCNF_PATH"/> must be specified in <i>uFlags</i>. 
            <i>dwItem1</i> contains the root of the drive that contains the new media. 
            <i>dwItem2</i> is not used and should be <see langword="null"/>. 
            </summary>
        </member>
        <member name="F:JetBrains.Application.Install.FileAssociationHelper.HChangeNotifyEventID.SHCNE_MEDIAREMOVED">
            <summary>
            Storage media has been removed from a drive. 
            <see cref="F:JetBrains.Application.Install.FileAssociationHelper.HChangeNotifyFlags.SHCNF_IDLIST"/> or 
            <see cref="!:HChangeNotifyFlags.SHCNF_PATH"/> must be specified in <i>uFlags</i>. 
            <i>dwItem1</i> contains the root of the drive from which the media was removed. 
            <i>dwItem2</i> is not used and should be <see langword="null"/>. 
            </summary>
        </member>
        <member name="F:JetBrains.Application.Install.FileAssociationHelper.HChangeNotifyEventID.SHCNE_MKDIR">
            <summary>
            A folder has been created. <see cref="F:JetBrains.Application.Install.FileAssociationHelper.HChangeNotifyFlags.SHCNF_IDLIST"/> 
            or <see cref="!:HChangeNotifyFlags.SHCNF_PATH"/> must be specified in <i>uFlags</i>. 
            <i>dwItem1</i> contains the folder that was created. 
            <i>dwItem2</i> is not used and should be <see langword="null"/>. 
            </summary>
        </member>
        <member name="F:JetBrains.Application.Install.FileAssociationHelper.HChangeNotifyEventID.SHCNE_NETSHARE">
            <summary>
            A folder on the local computer is being shared via the network. 
            <see cref="F:JetBrains.Application.Install.FileAssociationHelper.HChangeNotifyFlags.SHCNF_IDLIST"/> or 
            <see cref="!:HChangeNotifyFlags.SHCNF_PATH"/> must be specified in <i>uFlags</i>. 
            <i>dwItem1</i> contains the folder that is being shared. 
            <i>dwItem2</i> is not used and should be <see langword="null"/>. 
            </summary>
        </member>
        <member name="F:JetBrains.Application.Install.FileAssociationHelper.HChangeNotifyEventID.SHCNE_NETUNSHARE">
            <summary>
            A folder on the local computer is no longer being shared via the network. 
            <see cref="F:JetBrains.Application.Install.FileAssociationHelper.HChangeNotifyFlags.SHCNF_IDLIST"/> or 
            <see cref="!:HChangeNotifyFlags.SHCNF_PATH"/> must be specified in <i>uFlags</i>. 
            <i>dwItem1</i> contains the folder that is no longer being shared. 
            <i>dwItem2</i> is not used and should be <see langword="null"/>. 
            </summary>
        </member>
        <member name="F:JetBrains.Application.Install.FileAssociationHelper.HChangeNotifyEventID.SHCNE_RENAMEFOLDER">
            <summary>
            The name of a folder has changed. 
            <see cref="F:JetBrains.Application.Install.FileAssociationHelper.HChangeNotifyFlags.SHCNF_IDLIST"/> or 
            <see cref="!:HChangeNotifyFlags.SHCNF_PATH"/> must be specified in <i>uFlags</i>. 
            <i>dwItem1</i> contains the previous pointer to an item identifier list (PIDL) or name of the folder. 
            <i>dwItem2</i> contains the new PIDL or name of the folder. 
            </summary>
        </member>
        <member name="F:JetBrains.Application.Install.FileAssociationHelper.HChangeNotifyEventID.SHCNE_RENAMEITEM">
            <summary>
            The name of a nonfolder item has changed. 
            <see cref="F:JetBrains.Application.Install.FileAssociationHelper.HChangeNotifyFlags.SHCNF_IDLIST"/> or 
            <see cref="!:HChangeNotifyFlags.SHCNF_PATH"/> must be specified in <i>uFlags</i>. 
            <i>dwItem1</i> contains the previous PIDL or name of the item. 
            <i>dwItem2</i> contains the new PIDL or name of the item. 
            </summary>
        </member>
        <member name="F:JetBrains.Application.Install.FileAssociationHelper.HChangeNotifyEventID.SHCNE_RMDIR">
            <summary>
            A folder has been removed. 
            <see cref="F:JetBrains.Application.Install.FileAssociationHelper.HChangeNotifyFlags.SHCNF_IDLIST"/> or 
            <see cref="!:HChangeNotifyFlags.SHCNF_PATH"/> must be specified in <i>uFlags</i>. 
            <i>dwItem1</i> contains the folder that was removed. 
            <i>dwItem2</i> is not used and should be <see langword="null"/>. 
            </summary>
        </member>
        <member name="F:JetBrains.Application.Install.FileAssociationHelper.HChangeNotifyEventID.SHCNE_SERVERDISCONNECT">
            <summary>
            The computer has disconnected from a server. 
            <see cref="F:JetBrains.Application.Install.FileAssociationHelper.HChangeNotifyFlags.SHCNF_IDLIST"/> or 
            <see cref="!:HChangeNotifyFlags.SHCNF_PATH"/> must be specified in <i>uFlags</i>. 
            <i>dwItem1</i> contains the server from which the computer was disconnected. 
            <i>dwItem2</i> is not used and should be <see langword="null"/>. 
            </summary>
        </member>
        <member name="F:JetBrains.Application.Install.FileAssociationHelper.HChangeNotifyEventID.SHCNE_UPDATEDIR">
            <summary>
            The contents of an existing folder have changed, 
            but the folder still exists and has not been renamed. 
            <see cref="F:JetBrains.Application.Install.FileAssociationHelper.HChangeNotifyFlags.SHCNF_IDLIST"/> or 
            <see cref="!:HChangeNotifyFlags.SHCNF_PATH"/> must be specified in <i>uFlags</i>. 
            <i>dwItem1</i> contains the folder that has changed. 
            <i>dwItem2</i> is not used and should be <see langword="null"/>. 
            If a folder has been created, deleted, or renamed, use SHCNE_MKDIR, SHCNE_RMDIR, or 
            SHCNE_RENAMEFOLDER, respectively, instead. 
            </summary>
        </member>
        <member name="F:JetBrains.Application.Install.FileAssociationHelper.HChangeNotifyEventID.SHCNE_UPDATEIMAGE">
            <summary>
            An image in the system image list has changed. 
            <see cref="F:JetBrains.Application.Install.FileAssociationHelper.HChangeNotifyFlags.SHCNF_DWORD"/> must be specified in <i>uFlags</i>.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Install.InstallerExePacked">
            <summary>
            The executable of the installer, a single-exe pack with all the installer DLLs, but without any embedded Nugets.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Install.InstallerExePackedWithEmbeddedPackages">
            <summary>
            The executable of the installer, a single-exe pack with all the installer DLLs, and with pre-embedded Nugets which can be used as a gallery for the installation.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Install.IsolationOptions">
            <summary>
            Should the local installer actions be system-wide or isolated.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Install.IsolationOptions.NotIsolated">
            <summary>
            Full local installation mode.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Install.IsolationOptions.IsolatedToProductBinariesDir">
            <summary>
            When set, the local installer will only execute file installs (putting aside Registry and Shell Links), and only those targeting the product binaries dir (skipping any VS/userfolder installs).
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Install.IsolationOptions.PerUserInstall">
            <summary>
            The install should go per-user, if there's an option.
            For example, the HKMU Registry hive should resolve to HKCU with this flag, and to HKLM without it.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Install.Launcher.LauncherConfig">
            <summary>
            Configuration of the launcher artifact (which bitness, and is it console).
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Install.Launcher.LauncherConfig.Subsystem">
            <summary>
            The windows/console subsystem.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Install.Launcher.LauncherInstaller.IDB_SPLASH">
            <summary>
            Splash bitmap, in PNG format.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Install.Launcher.LauncherInstaller.IDI_LAUNCHER">
            <summary>
            Icon of the EXE file.
            </summary>
        </member>
        <member name="M:JetBrains.Application.BuildScript.Install.Launcher.LauncherInstaller.IsHostComponentsResourcePresentInExecutable">
            <summary>
            Checks if the entry point executable has the resource which is expected to be present for the <see cref="M:JetBrains.Application.BuildScript.Install.Launcher.LauncherInstaller.ReadHostComponentsFromNativeExecutable(JetBrains.DataFlow.Lifetime)"/> to read its contents, without throwing if it's missing.
            </summary>
        </member>
        <member name="M:JetBrains.Application.BuildScript.Install.Launcher.LauncherInstaller.IsProductContentResourcePresentInExecutable">
            <summary>
            Checks if the entry point executable has the resource which holds the packed product content for single-exe distribution.
            </summary>
        </member>
        <member name="M:JetBrains.Application.BuildScript.Install.Launcher.LauncherInstaller.MakeSplashPngFile(System.String,System.String)">
            <summary>
            Renders the default boilerplate splash for the given product info.
            </summary>
        </member>
        <member name="M:JetBrains.Application.BuildScript.Install.Launcher.LauncherInstaller.MakeSplashVisual(System.String,System.String)">
            <summary>
            Creates the default boilerplate vector splash for the given product info.
            </summary>
        </member>
        <member name="M:JetBrains.Application.BuildScript.Install.Launcher.LauncherInstaller.ReadProductContentResourceFromNativeExecutable">
            <summary>
            Gets the resource which holds the packed product content for single-exe distribution from the entry point executable.
            </summary>
        </member>
        <member name="M:JetBrains.Application.BuildScript.Install.Launcher.LauncherInstaller.StuffLauncher_AddProductInfoNativeResourcesIfMissing(System.Collections.Generic.ICollection{JetBrains.Application.BuildScript.Install.Launcher.LauncherInstaller.NativeResourceForLauncher},JetBrains.Application.BuildScript.ProductNameAndVersionArtifact)">
            <summary>
            Write product branding into resources so that Launcher could use it with LoadString()
            </summary>
        </member>
        <member name="M:JetBrains.Application.BuildScript.Install.Launcher.LauncherInstaller.StuffLauncher_AddSplashNativeResourceIfMissing(System.Collections.Generic.ICollection{JetBrains.Application.BuildScript.Install.Launcher.LauncherInstaller.NativeResourceForLauncher},JetBrains.Application.BuildScript.ProductNameAndVersionArtifact)">
            <summary>
            Adds the boilerplate splash to the launcher, unless there's a custom one already.
            To have the boilerplate splash: do nothing.
            To have a custom splash image: supply a native resource with the splash.
            To have NO splash screen: supply an empty native resource for the splash.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Install.Launcher.LauncherInstaller.ProductContentFile">
            <summary>
            Describes a file which will be packed as product content, and what should be done to that file when product content is expanded.
            </summary>
        </member>
        <member name="M:JetBrains.Application.BuildScript.Install.Launcher.LauncherInstaller.ProductContentFile.GetEncodedFile">
            <summary>
            Gets the file name as it should be written into the product content package, to encode what should be done to it upon extraction.
            </summary>
        </member>
        <member name="M:JetBrains.Application.BuildScript.Install.Launcher.LauncherInstaller.ProductContentFile.GetEncodedFileName">
            <summary>
            Gets the file name as it should be written into the product content package, to encode what should be done to it upon extraction.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Install.Launcher.LauncherInstaller.ProductContentFile.ExpansionFlags.SaveFile">
            <summary>
            The file from the container should be saved to disk as a file (even if it's a container on itself).
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Install.Launcher.LauncherInstaller.ProductContentFile.ExpansionFlags.ExpandNuget">
            <summary>
            The file in the container is a Nuget package, and it should be expanded to disk following our general Nuget extraction rules rather than just saved as a file.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Install.Launcher.LauncherInstaller.ProductContentFile.ExpansionFlags.Gallery">
            <summary>
            The file should not be expanded onto disk. Instead, it's intended for reading into Gallery right from the packed form in the resources.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Install.LocalInstallPart">
            <summary>
            Denotes parts of the Local Install process. This art is requested when we're doing Local Install.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Install.LocalInstallWithPostInstallStepsPart">
            <summary>
            Denotes parts that should be evaluated after local install.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Install.LocalRegisterIsolationOptionsArtifact">
            <summary>
            Isolation options for local install.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Install.LocalRegisterIsolationOptionsArtifact.IsolationOptions">
            <summary>
            Isolation options for local install.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Install.LocalRegisterIsolationOptionsOverrideArtifact">
            <summary>
            Isolation options for local install.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Install.LocalRegisterIsolationOptionsOverrideArtifact.IsolationOptions">
            <summary>
            Isolation options for local install.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Install.PackagedMsi.SharedMsiArtifact">
            <summary>
            First stage build produces this artifact. Then we store it in package metadata and transfer to the second stage.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.OutputFileArtifact">
            <summary>
            A file which is a user-visible output of the whole build sequence.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.PackageDefaultPrereleaseMetadata">
            <summary>
              <para>Unless <see cref="T:JetBrains.Application.BuildScript.BuildVersionSuffix"/> is explicitly specified, gives the default <see cref="P:JetBrains.Util.JetSemanticVersion.PrereleaseMetadata">prerelease metadata</see> part of the semantic version which is to be used on the packages we produce during the build.</para>
              <para>On the build server, there's a setting for this value to either a prerelease suffix (eap, beta, rc) or release (an empty string). Locally, it should designate a custom build.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.PackageDefaultPrereleaseMetadata.PrereleaseMetadata">
            <summary>
              <para>Unless <see cref="T:JetBrains.Application.BuildScript.BuildVersionSuffix"/> is explicitly specified, gives the default <see cref="P:JetBrains.Util.JetSemanticVersion.PrereleaseMetadata">prerelease metadata</see> part of the semantic version which is to be used on the packages we produce during the build.</para>
              <para>On the build server, there's a setting for this value to either a prerelease suffix (eap, beta, rc) or release (an empty string). Locally, it should designate a custom build.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Application.BuildScript.PackageDefaultPrereleaseMetadata.DefaultForCustomBuilds">
            <summary>
            This applies to builds which have not been compiled on the build server (and thus received any specific, possibly empty for release, metadata).
            For example, local compilations and locally installed products.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.PreCompile.GeneratedMsbuild.DispositionAgainstCommonTargets">
            <summary>
            How to place this injection in relation with the standard language imports for this project (e.g. <c>Microsoft.CSharp.Targets</c>).
            The “<c>Before</c>” stuff can predefine scalar property values to be used for paths in the standard imports.
            The “<c>After</c>” stuff can inject into list property values at first/last position because the standard targets have already had their say.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.PreCompile.GeneratedMsbuild.GeneratedMsbuildCustomXml">
            <summary>
            Like other generated MSBuild items, allows to add custom MSBuild includes to all project files in the solution, but does not limit the text to specific MSbuild items.
            See base class doc for details.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.PreCompile.GeneratedMsbuild.GeneratedMsbuildElementBase">
            <summary>
            Allows to include pieces of an MSBuild script into each of the project files in the solution in a centralized manner.
            This means setting up properties with common project settings like outdir and optimization, stuffing assemblies, including tools from nuggets, etc.
            Each project in the solution (as part of the <c>LocalAutofixProjectFiles</c> procedure) gets the single import directive for the generated MSBuild file which receives all of these items. It gets written to disk either as part of the <see cref="T:JetBrains.Application.BuildScript.PreCompile.LocalPrepareWorkingCopy"/> or as a dependency of the compilation stage.
            Yield one such item per each project to be stuffed, filter by subplatform if needed.
            // TODO: when each subplatform is precompile-processed separately, these items would be effectively per-sp, so <see cref="F:JetBrains.Application.BuildScript.PreCompile.GeneratedMsbuild.GeneratedMsbuildElementBase.Subplatform"/> won't be needed.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.PreCompile.GeneratedMsbuild.GeneratedMsbuildElementBase.Condition">
            <summary>
            Optional condition.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.PreCompile.GeneratedMsbuild.GeneratedMsbuildElementBase.Disposition">
            <summary>
            How to place this injection in relation with the standard language imports for this project (e.g. <c>Microsoft.CSharp.Targets</c>).
            The “<c>Before</c>” stuff can predefine scalar property values to be used for paths in the standard imports.
            The “<c>After</c>” stuff can inject into list property values at first/last position because the standard targets have already had their say.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.PreCompile.GeneratedMsbuild.GeneratedMsbuildElementBase.Priority">
            <summary>
            Specifies ordering for inserting this element within the corresponding section (<see cref="F:JetBrains.Application.BuildScript.PreCompile.GeneratedMsbuild.GeneratedMsbuildElementBase.Disposition"/>). Zero is the dontcare level.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.PreCompile.GeneratedMsbuild.GeneratedMsbuildElementBase.ProjectInSubplatform">
            <summary>
            Path of the project to be stuffed, relative to the <see cref="F:JetBrains.Application.BuildScript.PreCompile.GeneratedMsbuild.GeneratedMsbuildElementBase.Subplatform"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.PreCompile.GeneratedMsbuild.GeneratedMsbuildElementBase.Subplatform">
            <summary>
            The subplatform to which the project to be stuffed belongs.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.PreCompile.GeneratedMsbuild.GeneratedMsbuildCustomXml.Id">
            <summary>
            Diagnostic identity of the custom section.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.PreCompile.GeneratedMsbuild.GeneratedMsbuildCustomXml.XmlDocumentFragment">
            <summary>
            A valid XML document fragment to be inserted into the project file.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.PreCompile.GeneratedMsbuild.GeneratedMsbuildImport">
            <summary>
            A pre-compile-time generated MSBuild Import directive.
            See base class doc for details.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.PreCompile.GeneratedMsbuild.GeneratedMsbuildImport.ImportTarget">
            <summary>
            The import target, relative to the project directory (as it will be written into the resulting generated file).
            </summary>
            <remarks>Here's no support for providing the import contents as a <see cref="T:JetBrains.Util.Storage.SimpleFileItem"/> because if you've got the contents in your hands rather than somewhere on disk in a tool Nuget package folder, then you'd better insert it as custom content right into the generated MSBuild imported file, for simplicity.</remarks>
        </member>
        <member name="T:JetBrains.Application.BuildScript.PreCompile.GeneratedMsbuild.GeneratedMsbuildMainImportedProject">
            <summary>
            The generated MSBuild project files to be injected into each of the solution's project files, built of all of the <see cref="T:JetBrains.Application.BuildScript.PreCompile.GeneratedMsbuild.GeneratedMsbuildElementBase"/> items.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.PreCompile.GeneratedMsbuild.GeneratedMsbuildMainImportedProject.File">
            <summary>
            The file content of the generated imported project.
            To be realized on disk in the project folder.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.PreCompile.GeneratedMsbuild.GeneratedMsbuildMainImportedProject.ItemsToRealize">
            <summary>
            Any items taking part in the generation which must also be realized relatively to the project folder (unless of empty content).
            This does not include the <see cref="F:JetBrains.Application.BuildScript.PreCompile.GeneratedMsbuild.GeneratedMsbuildMainImportedProject.File"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.PreCompile.GeneratedMsbuild.GeneratedMsbuildMainImportedProject.ProjectInSubplatform">
            <summary>
            Path of the project which is being stuffed, relative to the <see cref="F:JetBrains.Application.BuildScript.PreCompile.GeneratedMsbuild.GeneratedMsbuildMainImportedProject.Subplatform"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.PreCompile.GeneratedMsbuild.GeneratedMsbuildMainImportedProject.Subplatform">
            <summary>
            The subplatform to which the project to be stuffed belongs.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.PreCompile.GeneratedMsbuild.GeneratedMsbuildProperty">
            <summary>
            A pre-compile-time generated MSBuild Property.
            See base class doc for details.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.PreCompile.GeneratedMsbuild.GeneratedMsbuildProperty.PropertyName">
            <summary>
            Name of the MSBuild property.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.PreCompile.GeneratedMsbuild.GeneratedMsbuildProperty.PropertyValue">
            <summary>
            Value for the MSBuild property.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.PreCompile.GeneratedMsbuild.GeneratedMsbuildTaskItem">
            <summary>
            A pre-compile-time generated MSBuild Task Item.
            See base class doc for details.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.PreCompile.GeneratedMsbuild.GeneratedMsbuildTaskItem.File">
            <summary>
            This file's <see cref="T:JetBrains.Util.RelativePath"/> defines the task item's <see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Attributes.Include"/> text.
            If the file has non-empty content, it will be realized on disk per-project (and thus effectively included as a real disk file). Otherwise it's just a task item.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.PreCompile.GeneratedMsbuild.GeneratedMsbuildTaskItem.ItemGroupName">
            <summary>
            Item group name for the task item.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.PreCompile.GeneratedMsbuild.LocallyWrittenGeneratedMsbuildFile">
            <summary>
            A set of files from <see cref="T:JetBrains.Application.BuildScript.PreCompile.GeneratedMsbuild.GeneratedMsbuildMainImportedProject"/>, including the main generated project file, realized on disk for preparing the solution or compilation.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.PreCompile.GeneratedMsbuild.LocallyWrittenGeneratedMsbuildFile.File">
            <summary>
            The file content which were written.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.PreCompile.GeneratedMsbuild.LocallyWrittenGeneratedMsbuildFile.LocalPath">
            <summary>
            The path to which the file were written.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.PreCompile.GeneratedMsbuild.LocallyWrittenGeneratedMsbuildFile.ProjectInSubplatform">
            <summary>
            Path of the project which is being stuffed, relative to the <see cref="F:JetBrains.Application.BuildScript.PreCompile.GeneratedMsbuild.LocallyWrittenGeneratedMsbuildFile.Subplatform"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.PreCompile.GeneratedMsbuild.LocallyWrittenGeneratedMsbuildFile.Subplatform">
            <summary>
            The subplatform to which the project to be stuffed belongs.
            </summary>
        </member>
        <member name="M:JetBrains.Application.BuildScript.PreCompile.GeneratedMsbuild.LocallyWrittenGeneratedMsbuildFile.LocallyWriteItemsForAllProjects(JetBrains.Application.BuildScript.PreCompile.GeneratedMsbuild.GeneratedMsbuildMainImportedProject[],JetBrains.Application.BuildScript.ProductHomeDirArtifact,JetBrains.Util.ILogger)">
            <summary>
            Realizes items on disk.
            </summary>
        </member>
        <member name="M:JetBrains.Application.BuildScript.PreCompile.GeneratedMsbuild.LocallyWrittenGeneratedMsbuildFile.MountLocallyWrittenGeneratedCompileItems(JetBrains.Application.BuildScript.PreCompile.GeneratedMsbuild.LocallyWrittenGeneratedMsbuildFile[])">
            <summary>
            Locally write before compile.
            TODO: LocalInstall.
            // TODO: make compile write the stuff itself, for better isolation
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.PreCompile.LocalPrepareWorkingCopy">
            <summary>
            A service artifact for wiring related tasks to it.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.PreCompile.ToolPackages.InjectToolPackageArtifact">
            <summary>
            Requests that the tool package be injected by (a) requiring local restore of the tool Nuget package and (b) adding an MSBuild Import directive for it to all possible projects.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.PreCompile.ToolPackages.InjectToolPackageArtifact.FileToImportFromPackage">
            <summary>
            Rel path within the package (real, not effective) to be imported into MSBuild project files.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.PreCompile.ToolPackages.InjectToolPackageArtifact.PackageId">
            <summary>
            Nuget package with the tool.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.PreCompile.ToolPackages.InjectToolPackageArtifact.PackageVersion">
            <summary>
            Nuget package with the tool.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.ILocalTwoStageBuild">
            <summary>
            Helps with writing standard local two-stage builds, where the first stage just collects the packages (optionally, compiles), and the second stage does smth with those packages, like local install.
            The first stage is all set, and the second stage differs only by the requested package, which is the only parameter here.
            </summary>
        </member>
        <member name="M:JetBrains.Application.BuildScript.ILocalTwoStageBuild.RunTwoStage``1">
            <summary>
            </summary>
            <typeparam name="TObjective"></typeparam>
            <returns>If the objective is serializable, and one or more of them are produced during the second stage, returns these instances.</returns>
        </member>
        <member name="M:JetBrains.Application.BuildScript.ILocalTwoStageBuild.RunTwoStage(JetBrains.Build.Serialization.AssemblyQualifiedTypeName)">
            <summary>
            </summary>
            <returns>The output file artifacts produced during the build.</returns>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Solution.AllAssemblies">
            <summary>
            Basic API to all-assemblies lists.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Solution.AllAssembliesAccess">
            <summary>
            Caching and indexing of all-assemblies info.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Solution.AllAssembliesLocator.DefaultIntermediateOutputPathFolderName">
            <summary>
            The default name for the <see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Properties.IntermediateOutputPath"/> intermediate directory during the build, under Product Home Dir.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Solution.AllAssembliesLocator.DefaultProductBinariesDirFolderName">
            <summary>
            The default name for a ProductBinariesDir as a subfolder of the ProductHomeDir.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Solution.AllAssembliesLocator.JetMetadataInApplicationPackageExt">
            <summary>
            Package part extension for the jet package metadata objects embedded into a subplatform package.
            The part contains a structured storage with a <c>SerializedValuesResolver</c> holding the components.
            The other half of the part local name is the package ID (no version included, for easier cleanup when extracting), and the folder is the main content folder.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Solution.AllAssembliesLocator.ProductHomeDirEnvironmentVariableName">
            <summary>
            An explicit value for Product Home Dir when it has to be transferred to the callee via Environment Variables, e.g. when running NUnit tests on TeamCity in a sandboxed folder. Required for locating the test data. TODO: maybe pass the test data folder explicitly?
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Solution.AllAssembliesLocator.ProductHomeDirMarkerFile">
            <summary>
            Name of the marker file which must be present in the root folder of the product.
            Used for autodetection of the product home dir from any dir under it, e.g. with <see cref="M:JetBrains.Util.FileSystemUtil.GetDirectoryNameOfFileAbove(JetBrains.Util.FileSystemPath,System.String)"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Solution.AllAssembliesLocator.ProgramDatabasePackageIdAppendix">
            <summary>
            Add to the subplatform package ID (generated with <see cref="M:JetBrains.Application.BuildScript.Solution.AllAssembliesLocator.GetSubplatformPackageId(JetBrains.Application.BuildScript.Solution.SubplatformName,System.String)"/>) to get the ID of the Nuget package with the program database for that subplatform, separated with a dot.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Solution.AllAssembliesLocator.SubplatformRootDirStrongNameKeyPairFileName">
            <summary>
            The SNK file in the subplatform root dir (next to <see cref="F:JetBrains.Application.BuildScript.Solution.AllAssembliesLocator.SubplatformRootDirMarkerFileName"/>) which is used for strong-name-signing of all the assemblies.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Solution.AllAssembliesLocator.SubplatformStrongNameKeyFileName">
            <summary>
            The <c>.snk</c> file in the subplatform root directory which is used by subplatform's MSBuild-compiled projects for strong-name-signing its assemblies.
            </summary>
        </member>
        <member name="M:JetBrains.Application.BuildScript.Solution.AllAssembliesLocator.GetAllAssembliesOnLocallyInstalledBinariesFlat(JetBrains.Application.BuildScript.ProductBinariesDirArtifact)">
            <summary>
            Gets the list of subplatforms based on the locally-installed product binaries, as were extracted from the packages.
            </summary>
        </member>
        <member name="M:JetBrains.Application.BuildScript.Solution.AllAssembliesLocator.GetAllAssembliesOnSources(JetBrains.Util.FileSystemPath)">
            <summary>
            Gets the list of project files generating assemblies from all subplatforms of the product, and reads their expected assembly names.
            </summary>
        </member>
        <member name="M:JetBrains.Application.BuildScript.Solution.AllAssembliesLocator.GetProductHomeDirOnSources(JetBrains.Util.FileSystemPath)">
            <summary>
            Called on any folder within the source code tree of a product.
            Locates the product home dir by the marker file.
            </summary>
        </member>
        <member name="M:JetBrains.Application.BuildScript.Solution.AllAssembliesLocator.GetSubplatformOnSourcesFolders(JetBrains.Util.FileSystemPath)">
            <summary>
            Looks for subplatforms which are represented by source code folders under the product home dir.
            </summary>
        </member>
        <member name="M:JetBrains.Application.BuildScript.Solution.AllAssembliesLocator.GetSubplatformPackageId(JetBrains.Application.BuildScript.Solution.SubplatformName,System.String)">
            <summary>
            Calculates Package ID for a subplatform package.
            </summary>
        </member>
        <member name="M:JetBrains.Application.BuildScript.Solution.AllAssembliesLocator.GetSubplatformPackageId(JetBrains.Application.BuildScript.Solution.Subplatform)">
            <summary>
            Calculates Package ID for a subplatform package.
            </summary>
        </member>
        <member name="M:JetBrains.Application.BuildScript.Solution.AllAssembliesLocator.TryGetProductHomeDirOnSources(JetBrains.Util.FileSystemPath)">
            <summary>
            Called on any folder within the source code tree of a product.
            Locates the product home dir by the marker file.
            </summary>
        </member>
        <member name="M:JetBrains.Application.BuildScript.Solution.AllAssembliesLocator.FetchAssemblyNameAndOutputTypeFromFile(JetBrains.Util.FileSystemPath,JetBrains.Metadata.Utils.AssemblyNameInfo@,JetBrains.Application.BuildScript.Solution.OutputType@)">
            <summary>
              <para>A hack for ripping the assembly name and the ouput type from the project file.</para>
              <para>We're not spawning the whole MSBuild here, but just read the expected XML element. Should work for most our cases.</para>
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Solution.PackageOriginalProjects">
            <summary>
            Optional package metadata which specifies the project files from which the DLLs were originally built.
            Used for mapping project references into the binary DLL replacements.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Solution.PackageOriginalProjects.ProjectInSubplatformPath_AssemblyName">
            <summary>
            Lists project-in-subplatform — assembly name pairs.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Solution.ProjectAndAssembly.AssemblyName">
            <summary>
            Assembly name of the DLL compiled from this project.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Solution.ProjectAndAssembly.PossibleOutputType">
            <summary>
            Type of the output assembly.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Solution.ProjectAndAssembly.ProjectFileInSubplatform">
            <summary>
            Path of the project file from the root dir of its subplatform.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Solution.SubplatformInfo">
            <summary>
            The root object of the subplatform descriptor.
            </summary>
        </member>
        <member name="P:JetBrains.Application.BuildScript.Solution.SubplatformInfo.SubplatformReferences">
            <summary>
            Lists other subplatforms referenced by this subplatform.
            </summary>
        </member>
        <member name="P:JetBrains.Application.BuildScript.Solution.SubplatformInfo.VersionOverride">
            <summary>
            Optional. Manually overridden subplatform version number. By default you should leave this NULL to allow the wave-number-derived version to be used.
            Do not read directly unless you want the manual value only, use <see cref="M:JetBrains.Application.BuildScript.Solution.SubplatformEx.GetVersion(JetBrains.Application.BuildScript.Solution.Subplatform,JetBrains.Application.BuildScript.BuildVersionSuffix)"/> to get the version of a specific subplatform, which takes auto-substituted versions into account as well.
            If <c>NULL</c>, usages like <see cref="M:JetBrains.Application.BuildScript.Solution.SubplatformEx.GetVersion(JetBrains.Application.BuildScript.Solution.Subplatform,JetBrains.Application.BuildScript.BuildVersionSuffix)"/> will derive a value from the current wave number, <see cref="M:JetBrains.Util.WaveInfoEx.GetDefaultAssemblyVersion(JetBrains.Util.WaveInfo)"/>.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Solution.SubplatformOnPackage">
            <summary>
            A subplatform which has been created from an already-compiled application package, without access to the sources.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Solution.SubplatformOnPackage.ApplicationPackage">
            <summary>
            The product package of this subplatform.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Solution.SubplatformOnSources">
            <summary>
            A subplatform which has just been created from source code projects, by parsing out assembly names out of project files.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Solution.SubplatformOnSources.ProjectFiles">
            <summary>
            Project files. Paths are relative to the subplatform root folder.
            Partial info from <see cref="F:JetBrains.Application.BuildScript.Solution.SubplatformOnSources.ProjectFilesEx"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Solution.SubplatformOnSources.ProjectFilesEx">
            <summary>
            Project files and the assemblies they would produce.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.BuildEntryPointAttribute">
            <summary>
            Means the marked artifact should be suggested as a build entry point.
            // TODO: probably, a temporary solution.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.BuildVersionSuffix.Build">
            <summary>
            The third component of the full version number.
            (the first two components identify binary compatibility and are specified in the component being built, while the last two are merely incremental)
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.BuildVersionSuffix.PrereleaseMetadata">
            <summary>
            The “pre-release metadata” component of the semantic version spec, one after a hyphen.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.BuildVersionSuffix.Revision">
            <summary>
            The fourth component of the full version number.
            (the first two components identify binary compatibility and are specified in the component being built, while the last two are merely incremental)
            </summary>
        </member>
        <member name="M:JetBrains.Application.BuildScript.BuildVersionSuffix.DefaultBuildVersionSuffixForNow(JetBrains.Application.Components.Optional{JetBrains.Application.BuildScript.PackageDefaultPrereleaseMetadata},JetBrains.Application.Components.Optional{JetBrains.Application.BuildScript.IncrementalBuild},JetBrains.Util.ILogger)">
            <summary>
            Unless specifically provided, makes it from the current date-time.
            SPECIAL HANDLING for INCREMENTAL MDOE: the date-based versions are very rough when run locally, changing them often would prevent incrementality.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.CompileLevelEntryPoint">
            <summary>
            For linking as the after-compile stage.
            // TODO: probably, a temporary solution.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.SkipLocalCompilationArtifact">
            <summary>
            If this artifact is set to <c>True</c>, all of the compilation should be skipped in favor of reusing the already-compiled stuff in the bindir.
            This helps with the local scenario when you often want to do stuff like LocalRegister without rebuilding everything anew.
            Shan't be set to <c>True</c> on the server.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.SkipLocalCompilationArtifact.IsSkipCompileAll">
            <summary>
            If this artifact is set to <c>True</c>, all of the compilation should be skipped in favor of reusing the already-compiled stuff in the bindir.
            This helps with the local scenario when you often want to do stuff like LocalRegister without rebuilding everything anew.
            Shan't be set to <c>True</c> on the server.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Solution.SubplatformPlatformCoreShell">
            <summary>
            Gets the info on the Platform Core Shell subplatform, the center-most subplatform of all the infrastructure.
            NOTE: for other subplatforms, probably there'll be an auto-generated “Current Subplatform Name” class.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Solution.SubplatformProjectWrapper">
            <summary>
            Access wrapper for <see cref="F:JetBrains.Application.BuildScript.Solution.SubplatformProjectWrapper.ProjectAndAssembly"/> in <see cref="T:JetBrains.Application.BuildScript.Solution.SubplatformOnSources"/> in <see cref="F:JetBrains.Application.BuildScript.Solution.SubplatformProjectWrapper.AllAssembliesOnSources"/>.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Testing.TestDataHomeDirArtifact">
            <summary>
            A separate artifact to specify the home dir root for test data.
            This is to avoid mixing up with the regular home dir when we're running binaries-only builds with tests.
            Also, the test data home folder might quite differ from the regular home dir.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Res.CoreImages">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Res.CoreImages.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Res.CoreImages.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Res.CoreImages.ProductAboutBox">
            <summary>
              Looks up a localized resource of type System.Drawing.Bitmap.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Res.CoreImages.ProductIcon">
            <summary>
              Looks up a localized resource of type System.Drawing.Icon similar to (Icon).
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Solution.SubplatformReference">
            <summary>
              References another subplatform by its name, which is a relative path from the product root.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.SubplatformFileForPackaging">
            <summary>
            A file which will be put into the Subplatform Binaries Package of the specified subplatform, which is the primary compilation output for that subplatform.
            You should yield this artifact if you want to add something to the package being produced for the subplatform.
            </summary>
        </member>
        <member name="M:JetBrains.Application.ActivityTrackingNew.PermanentUserId.GetUniqueUserId">
            <summary>
            Gets permanent unique user Id. The Id is saved in Registry under HKCU\Software\JetBrains\Platform section. <br />
            The Id is used to idendify same user even after ReSharper (or another product) is reinstalled or downgraded.
            Please note that the Id is shared among all JetBrains applications intalled by the user.
            To make it sharable with Idea team it also resides in %appdata%\Roaming\JetBrains\PermanentUserId
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.HostEnvironmentZoneArtifact">
            <summary>
            Written into serialized host components.
            Defines the zone to run the host in.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Build.Nunit.IInvokeNunit">
            <summary>
            Can invoke NUnit tests on a certain DLL.
            Implementations exist using a physical local NUnit runner or a TC build runner (if running in a TC agent as a part of the build).
            </summary>
        </member>
        <member name="M:JetBrains.Application.BuildScript.ProductBinariesDirArtifact.#ctor(JetBrains.Application.BuildScript.ProductHomeDirArtifact,JetBrains.Application.Components.Optional{JetBrains.Application.BuildScript.ProductBinariesDirRelativeHintArtifact},JetBrains.Util.ILogger)">
            <summary>
            If the binaries dir is not given, defers it from the product home dir as a fallback.
            </summary>
        </member>
        <member name="M:JetBrains.Application.BuildScript.ProductNameAndVersionArtifact.#ctor(System.String,JetBrains.Application.BuildScript.Solution.SubplatformOnSources,JetBrains.Application.BuildScript.BuildVersionSuffix)">
            <summary>
            Takes company and version from subplatform.
            Requires <see cref="T:JetBrains.Application.BuildScript.Solution.SubplatformOnSources"/> not <see cref="T:JetBrains.Application.BuildScript.Solution.Subplatform"/> because the <see cref="T:JetBrains.Application.BuildScript.BuildVersionSuffix"/> is only validly available with the sources, otherwise it would be an autogenerated unrelated install-time item.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Build.Nunit.InvokeNunitInTeamCityBuild">
            <summary>
            TeamCity in-build version.
            Uses the TC-supplied launcher, so that it reported the live build stats to the server.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Solution.AllAssembliesOnEverything">
            <summary>
            Collects all-assemblies on sources and on packages.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Solution.AllAssembliesOnPackages">
            <summary>
            Just as <see cref="T:JetBrains.Application.BuildScript.Solution.AllAssemblies"/>, but specifically being created over already-compiled packages.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Solution.AllAssembliesOnSources">
            <summary>
            Just as <see cref="T:JetBrains.Application.BuildScript.Solution.AllAssemblies"/>, but specifically being created over source-code-presented assemblies.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Environment.ApplicationPackagesLocallyInstalled">
            <summary>
            Turns <see cref="T:JetBrains.Application.BuildScript.Application.IApplicationPackage"/> known for deployable packages into the runtime <see cref="T:JetBrains.Application.BuildScript.Application.IApplicationPackageLocallyInstalled"/> which also knows where the packages are installed.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Environment.FullPartCatalogSet">
            <summary>
            Holds the outermost catalog set for the <see cref="T:JetBrains.Application.Environment.JetEnvironment"/> class.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Environment.FullPartCatalogSet.CreateFromDiskFilesAndInstallResolver(JetBrains.DataFlow.Lifetime,System.Collections.Generic.ICollection{JetBrains.Metadata.Utils.AssemblyNameAndLocation},System.Collections.Generic.ICollection{JetBrains.Metadata.Utils.AssemblyNameAndLocation})">
            <summary>
            </summary>
            <param name="lifetime"></param>
            <param name="allassemblies">
              <para>Lists all of the product assemblies registered with this host.</para>
              <para>This generally includes all installed JB products and all static plugins.</para>
              <para>The <see cref="T:JetBrains.Application.Environment.FullPartCatalogSet"/> will be initially created on these, and other catalogsets will be a filtered-down subset of these assemblies.</para>
              <para>Lightweight plugins might be loaded dynamically and added to the part catalog set later, but major plugins go in this pack already.</para>
            </param>
            <param name="extras"></param>
        </member>
        <member name="M:JetBrains.Application.Environment.HostParameters.ConsoleLoggerMixin.PushToLogger(JetBrains.Util.ILogEventListener,JetBrains.Util.LoggingLevel)">
            <summary>
            Adds self to the logger, removes when this object is disposed of.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Environment.HostParameters.CustomComponentHostMixin">
            <summary>
            Adds custom object.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Environment.HostParameters.CustomComponentHostMixin.#ctor(System.Func{System.Object})">
            <summary>
            Adds a custom component to the host.
            Takes a functor instead of an object to discourage from executing code when writing the host chain, which usually has no loggers/reporters to handle the exception yet.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Environment.HostParameters.IHaveEnvironmentZoneHostMixin">
            <summary>
            Determines the environment zone (from the <see cref="T:JetBrains.Application.BuildScript.Application.Zones.IEnvironmentZone"/> family) to be used for running the app.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Environment.HostParameters.FullPartCatalogFromSerializedComponentsHostMixin">
            <summary>
            Makes a catalog based on app packages, as extracted from the SerializedValuesResolver which is embedded into the entry point.
            LEGACY: now we won't embed information on packages, just the Host Info and Environment Zone. The packages are collected  AD HOC based on the startup dir. This best fits with in-package EXEs, standalone tools, and ability to xcopy new plugins.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Environment.HostParameters.MakeAdHockProductPackageOnScatteredFilesHostMixin">
            <summary>
            When there's no serialized info to run the build, and we have not created packages to be extracted into the BIN folder (like we do for running tests), tries to make up a mock package for running the app from whatever DLLs can be located in the folder.
            This is a fallback scenario, use <see cref="T:JetBrains.Application.Environment.HostParameters.SerializedComponentsIntoEnvironmentContainerHostMixin"/> or <see cref="T:JetBrains.Application.Environment.HostParameters.CollectProductPackagesInDirectoryFlatHostMixin"/> whenever possible to run off the real packages.
            This scenario is to be used when you can't run the Local Register phase of the build (for example, when debugging the build itself;).
            </summary>
        </member>
        <member name="M:JetBrains.Application.Environment.HostParameters.MakeAdHockProductPackageOnScatteredFilesHostMixin.#ctor(JetBrains.Application.BuildScript.ProductBinariesDirArtifact,System.Predicate{JetBrains.Util.RelativePath})">
            <summary>
            </summary>
            <param name="productBinariesDirArtifact">The dir with scattered DLL and content files. Leave NULL to use the home directory of the currently-executing assembly (assuming others are by its side).</param>
            <param name="λFilter">Allows to run on a subset of the total set of files located in the folder. The default filter limits files to immediate children of the folder only.</param>
        </member>
        <member name="M:JetBrains.Application.Environment.HostParameters.MakeAdHockProductPackageOnScatteredFilesHostMixin.CollectScatteredDllFilesIntoApplicationPackage(JetBrains.Application.BuildScript.ProductBinariesDirArtifact,System.Predicate{JetBrains.Util.RelativePath})">
            <param name="productBinariesDirArtifact">The dir with scattered DLL and content files. Leave NULL to use the home directory of the currently-executing assembly (assuming others are by its side).</param>
            <param name="λFilter">Allows to run on a subset of the total set of files located in the folder. The default filter limits files to immediate children of the folder only.</param>
        </member>
        <member name="T:JetBrains.Application.Environment.HostParameters.MessagePumpMainLoopHostMixin">
            <summary>
            Runs message pump for the main product's message loop.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Environment.HostParameters.StdOutGreetingHostMixin">
            <summary>
            Writes text to StdOut on app startup. Useful for console apps.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Environment.HostParameters.StdOutGreetingHostMixin.#ctor(System.String,JetBrains.Application.Environment.HostParameters.HostInitLevels)">
            <summary>
            Pre-factored text. Use another overload if you got any code which might cause exceptions.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Environment.HostParameters.StdOutGreetingHostMixin.#ctor(System.Func{System.String},JetBrains.Application.Environment.HostParameters.HostInitLevels)">
            <summary>
            Defer-calculates the text. This allows for catching any possible exceptions in string building.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Environment.HostParameters.EnvironmentZoneHostMixin.ZoneAsPart">
            <summary>
            Gets the zone as <see cref="T:JetBrains.Application.BuildScript.Application.Zones.ZonePart"/> type, if it's already available at creating the object.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Environment.HostParameters.EnvironmentZoneHostMixin.ZoneAsRuntimeType">
            <summary>
            Gets the zone as a runtime type. The <see cref="T:JetBrains.Application.BuildScript.Application.Zones.ZonePart"/> will be created when this mixin is queried for the value because at that point the catalog set is available, and it's possible to look up the zone's PCType in a more efficient way.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Environment.HostParameters.CollectProductPackagesInDirectoryFlatNoCachingHostMixin">
            <summary>
            When there's no serialized info to run the build, but we have a set of locally-installed packages unpacked into a folder, collects the info on such packages for the app to run on these assemblies.
            Alternatively, the serialized info is submitted with <see cref="T:JetBrains.Application.Environment.HostParameters.SerializedComponentsIntoEnvironmentContainerHostMixin"/> directly as component implementations.
            This is the legacy no-caching version which builds the part catalog each time over the set of files available.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Environment.HostParameters.CollectProductPackagesInDirectoryFlatNoCachingHostMixin.#ctor(System.Lazy{JetBrains.Application.BuildScript.ProductBinariesDirArtifact},System.Func{JetBrains.Application.BuildScript.Solution.AllAssemblies,System.Collections.Generic.IList{JetBrains.Application.BuildScript.Solution.Subplatform}},System.Func{JetBrains.Application.BuildScript.Solution.AllAssembliesOnPackages,JetBrains.Application.BuildScript.Solution.AllAssembliesOnPackages})">
            <summary>
            </summary>
            <param name="productBinariesDirArtifact">The dir with extracted packages.</param>
            <param name="λFilter">Allows to run on a subset of the total set of packages located in the folder.</param>
            <param name="allAssembliesProcessor">Allows to modify set of packages found in the folder</param>
        </member>
        <member name="T:JetBrains.Application.Environment.HostParameters.DefaultApplicationHostMixin">
            <summary>
            Fills the default product info components, as required for running the application.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Environment.HostParameters.GuardAssertHostMixin">
            <summary>
            Asserts that the environment is started and stopped in a guarded context.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Environment.HostParameters.InitLoggerHostMixin.#ctor">
            <summary>
            Inits just to some logger.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Environment.HostParameters.WindowsApplicationHost">
            <summary>
            Base Windows application host init, which includes all of the kinds.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Environment.HostParameters.WindowsApplicationHost.OnPackagesInFlatFolder(JetBrains.Application.Environment.JetHostItems.Engine,System.Lazy{JetBrains.Application.BuildScript.ProductBinariesDirArtifact},System.Reflection.Assembly)">
            <summary>
              <para>Runs on a set of product packages as discovered in the actual Product Binaries Dir, extracted there in a flat manner.</para>
              <para>Applies appropriate caching for per-package components and the common part catalog.</para>
              <para>Starting with wave04, this is expected to be the main way of running the shell.</para>
            </summary>
            <param name="input"></param>
            <param name="productBinariesDirArtifact">The dir with extracted packages. Lazy, to ensure any exceptions in getting it are trapped.</param>
            <param name="minimalPackageSetFilter">
              <para>Filters subplatforms (=packages) whose DLLs are considered for caching and cataloging in this folder.</para>
              <para><c>NULL</c> means take em all.</para>
              <para>A specific value means that only the package which has this DLL and all of its referenced packages (transitively) should be taken.</para>
            </param>
        </member>
        <member name="T:JetBrains.Application.Environment.JetHost">
            <summary>
            API for spawning hosts.
            Start with the <see cref="P:JetBrains.Application.Environment.JetHost.New"/> property and proceed along the host creation chain with ext methods, until you can <see cref="M:JetBrains.Application.Environment.JetHostItems.CreateAndRun(JetBrains.Application.Environment.JetHostItems.Full)"/> with an ext method on the end of the chain.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Environment.JetHost.New">
            <summary>
            Starts the host creation chain.
            Call ext methods to proceed further by the chain.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Environment.HostParameters.HostInitLevels.Default">
            <summary>
            The “Don't care” choice. Also the default value of the enum.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Environment.HostParameters.HostInitLevels.BeforeDefault">
            <summary>
            A bit earlier than defaults.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Environment.HostParameters.HostInitLevels.HighPriority">
            <summary>
            High-priority tasks, but with all natives and fallback exception reporting already in charge.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Environment.HostParameters.HostInitLevels.Native">
            <summary>
            Initializing native stuff in the host, which must happen before major managed subsystems are loaded, like WPF / WinForms.
            Refrain from actions involving loading of large managed subsystems in steps prior to this.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Environment.HostParameters.HostInitLevels.PumpOutLeftovers">
            <summary>
            Initializes pumping out all of the leftover deferred actions on shutdown.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Environment.HostParameters.HostInitLevels.FallbackExceptionReporting">
            <summary>
            Installs the fallback exception reporter — a primitive one which makes early-in-startup exceptions known, before the real exception reporter gets installed.
            In interactive GUI hosts this is a simple message box.
            MUST NOT use any WinForms / WPF code, just native stuff. Nor anything else which might affect the <see cref="F:JetBrains.Application.Environment.HostParameters.HostInitLevels.Native"/> step.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Environment.HostParameters.HostInitLevels.AfterDefault">
            <summary>
            A bit later than defaults.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Environment.HostParameters.JetHostParametersCaller.FillHostInfoContainer(JetBrains.Application.Components.ComponentContainer,JetBrains.Application.Environment.EnvironmentPartCatalogSet)">
            <summary>
              <para>Add any additional information on the host here: VS Service Provider, main window, command line, etc.</para>
              <para>Environment components and product components will be chained into this container and will be getting this information.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Application.Environment.HostParameters.JetHostParametersCaller.GetFullPartCatalogSet(JetBrains.DataFlow.Lifetime)">
            <summary>
            The complete catalog set, as collected from the products currently known, plus their plugins and any parts introduced later. This is the origin of all the catalogsets in the component containers. It's not filtered yet, even by the environment.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Environment.HostParameters.HostInfoFromSerializedComponentsHostMixin">
            <summary>
            Registers the standard basic product info components, as extracted from the SerializedValuesResolver.
            Applies fallbacks.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Environment.HostParameters.SerializedComponentsIntoEnvironmentContainerHostMixin">
            <summary>
            Exposes all serialized components to the runtime.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Environment.HostParameters.PumpOutLeftoversHostMixin">
            <summary>
            Before final exceptions are logged, makes sure any deferred things are reported.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Environment.IJetHostEx.EntangleGuardedLifetime(JetBrains.DataFlow.Lifetime,System.String,JetBrains.Threading.ReentrancyGuard,System.Action{JetBrains.DataFlow.Lifetime})">
            <summary>
              <para>Defines a lifetime in a guarded context which will be terminated in a guarded context.</para>
              <para>Returns a lifetime definition whose termination should be initiated in an unguarded context.</para>
            </summary>
            <param name="lifetimeOuterUnguarded">An outer lifetime. MUST be terminated in an unguarded context.</param>
            <param name="sIdentity">Identifies all of the created lifetimes / guard contexts.</param>
            <param name="guard">The guard to use.</param>
            <param name="FWithGuardedLifetime">Executes guarded. The given lifetime will be terminated guarded.</param>
            <returns>A definition which you should terminated in an unguarded context.</returns>
        </member>
        <member name="M:JetBrains.Application.Environment.IJetHostEx.PumpOutLeftovers">
            <summary>
            Attempts to pump out all of the leftover deferred actions.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Environment.IJetHostEx.RunHostMessageLoop(JetBrains.Application.Components.IComponentContainer)">
            <summary>
              <para>Runs the standard message loop for interactive hosts.</para>
              <para>When the function exists, the host should shut down.</para>
            </summary>
            <returns>The final verdict which caused the host to stop running. Use it for determining the exit code.</returns>
        </member>
        <member name="T:JetBrains.Application.Environment.JetHostItems">
            <summary>
            Hides from <see cref="T:JetBrains.Application.Environment.JetHost"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Environment.JetHostItems.CreateAndRun(JetBrains.Application.Environment.JetHostItems.Full)">
            <summary>
            Terminates the host creation chain by running the host and returning the result after it exits.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Environment.JetHostItems.CustomAdd(JetBrains.Application.Environment.JetHostItems.Full,JetBrains.Application.Environment.HostParameters.IJetHostMixin)">
            <summary>
            Adds one more item to the host parameters (after the mandatory part of the chain is complete).
            </summary>
        </member>
        <member name="M:JetBrains.Application.Environment.JetHostItems.CustomRemove``1(JetBrains.Application.Environment.JetHostItems.Full)">
            <summary>
            Removes items by their base type from the host parameters (after the mandatory part of the chain is complete).
            Usually, to replace them with new items (see <see cref="M:JetBrains.Application.Environment.JetHostItems.CustomReplace``1(JetBrains.Application.Environment.JetHostItems.Full,JetBrains.Application.Environment.HostParameters.IJetHostMixin)"/>).
            </summary>
        </member>
        <member name="M:JetBrains.Application.Environment.JetHostItems.CustomReplace``1(JetBrains.Application.Environment.JetHostItems.Full,JetBrains.Application.Environment.HostParameters.IJetHostMixin)">
            <summary>
            Removes items by their base type from the host parameters and replaces with a new item (after the mandatory part of the chain is complete).
            </summary>
        </member>
        <member name="T:JetBrains.Application.Environment.JetHostItems.Empty">
            <summary>
            An item in the host creation chain.
            Adding more info proceeds to the next step in the chain.
            This is the first empty step.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Environment.JetHostItems.HostItems">
            <summary>
            Base class for the host creation chain.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Environment.JetHostItems.Engine">
            <summary>
            An item in the host creation chain.
            Adding more info proceeds to the next step in the chain.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Environment.JetHostItems.Full">
            <summary>
            An item in the host creation chain.
            Adding more info proceeds to the next step in the chain.
            This is the last full step.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Environment.JetHostItems.Packages">
            <summary>
            An item in the host creation chain.
            Adding more info proceeds to the next step in the chain.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Environment.JetHostItems.ProductInfo">
            <summary>
            An item in the host creation chain.
            Adding more info proceeds to the next step in the chain.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Environment.IZoneLicenseChecker">
            <summary>
            Environment-level component that provides list of <see cref="T:JetBrains.Application.BuildScript.Application.Zones.ZonePart"/> it has license for plus zone parts that do not require license and are used from the zones it enables.
            The component is signed with private key corresponding to public key of the zones it enables. 
            </summary>
        </member>
        <member name="P:JetBrains.Application.Environment.IZoneLicenseChecker.Signatures">
            <summary>
            Fully quilifed type name signed with private key corresponding to zones' public key. Empty if no license-requiring zone is enabled.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Environment.IProductCanBeStarted">
            <summary>
            <para>A handler which determines whether the particular product is allowed to be run.</para>
            <para>There are standard handlers for: license check, suspended state, timebomb, etc.</para>
            <para>Of all the registered handlers, they get asked in order of priority until any of the handler gives a negative reply, which yields a negative result and stops polling other handlers. Note that the reply is not a scalar but a live value which can later change. If all of the handlers give a positive reply, the product will be started.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Application.Environment.IProductCanBeStarted.CreateCanBeStarted(JetBrains.DataFlow.Lifetime)">
            <summary>
            <para>This method is called on your handler when the poll sequence reaches it (i.e. when all of the higher-priority handlers give an affirmative resolution).</para>
            <para>The <paramref name="lifetime"/> is the duration until polling your handler goes out of scope (i.e. either the whole setup is terminated or one of the higher-priority handlers changes its resolution to something non-affirmative). After the <paramref name="lifetime"/> is terminated, your resolution in the return value will be considered no more. If the poll sequence reaches your handler again, you'll get one more call with a new lifetime.</para>
            <para>The return value is your live verdict which you can change at any time within the <paramref name="lifetime"/>.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Application.Environment.IProductCanBeStarted.Priority">
            <summary>
            <para>The priority of your handler. See <see cref="T:JetBrains.Application.Environment.ProductCanBeStartedPriorityThresholds"/> for standard values.</para>
            <para>The lower the value, the sooner your handler gets asked.</para>
            </summary>
        </member>
        <member name="T:JetBrains.Application.Environment.ZoneLicenseAttribute">
            <summary>
            Use the attribute to mark payed zone (zone that requires valid license to be activated) with public key. 
            Public keys should be generated using LicenseGenerator tool. 
            Several keys are alowed. The zone is enabled if any of licensed <see cref="T:JetBrains.Application.License2.ILicensedEntity"/> provides corresponding signature.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Environment.PublicStaticIntMainAttribute">
            <summary>
            The core method for running an automated application.
            Its method is called after the Shell is started up, waited upon, and the application exits when the method exits, using its return as the process exit code.
            You can import components as method parameters.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Environment.JetEnvironmentAvailableZones">
            <summary>
            Lists the zones which are available in the environment assemblies.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Environment.JetEnvironmentAvailableZones.CreateFromEnvironmentModuleZoneAndStandardConfigs(JetBrains.Application.Environment.FullPartCatalogSet,JetBrains.Application.BuildScript.Application.Zones.ZonePart[])">
            <summary>
              <para>Creates the configuration object on the given host configurations, adding the well-known standard environment configurations, such as CLR version and CPU.</para>
              <para>On this early stage, the </para>
            </summary>
            <param name="catalog">The catalog for fetching configuration definitions.</param>
            <param name="zonesEnvironment">
              <para>Module zone which specifies the configuration against the <see cref="T:JetBrains.Application.BuildScript.Application.Zones.IEnvironmentZone"/> module zone axis.</para>
              <para>This will be combined with autodetected environment configurations from <see cref="M:JetBrains.Application.Environment.JetEnvironmentAvailableZones.GetStandardConfigsForCurrentRuntime(JetBrains.Application.Environment.FullPartCatalogSet)"/> to choose the environment components. </para>
              <para>Further configurations for running the Shell will be determined by environment components.</para>
            </param>
        </member>
        <member name="M:JetBrains.Application.Environment.JetEnvironmentAvailableZones.GetAllPossibleStandardConfigs(JetBrains.Application.Catalogs.PartCatalog)">
            <summary>
            Gets a union of standard configurations of all the possible environments.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Environment.JetEnvironmentAvailableZones.GetStandardConfigsForCurrentRuntime(JetBrains.Application.Environment.FullPartCatalogSet)">
            <summary>
            Gets the standard configurations for the current environment, like CLR version and CPU.
            </summary>
            <param name="catalog"></param>
        </member>
        <member name="M:JetBrains.Application.Environment.JetEnvironmentAvailableZones.GetCpuConfig(JetBrains.Application.Environment.FullPartCatalogSet)">
            <summary>
              <para>Gets the configuration of the CPU architecture of the current process (not the OS architecture nor physical CPU).</para>
              <para>Examples: <c>IntelCpu</c>, <c>Amd64Cpu</c>.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Application.Environment.JetEnvironmentAvailableZones.GetRuntimeConfig(JetBrains.Application.Environment.FullPartCatalogSet)">
            <summary>
            Gets the configuration of the current runtime (CLR version).
            </summary>
            <param name="catalogset"></param>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Application.Environment.ProductCanBeStartedResolution">
            <summary>
            The resolution part of the <see cref="T:JetBrains.Application.Environment.ProductCanBeStartedVerdict"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Environment.ProductCanBeStartedResolution.Affirmative">
            <summary>
            <para>Affirmative resolution: this handler doesn't object running the product.</para>
            <para>Next handlers will be asked if they also don't have any objections.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Environment.ProductCanBeStartedResolution.NegativeTemporary">
            <summary>
            <para>Negative resolution: this handler prohibits the product from being run.</para>
            <para>This is a veto, i.e. next handlers will not be polled.</para>
            <para>“Temporary” means that the handler is committed to resolve to either affirmative or negative-permanent state somewhen soon. An example is shutting down the product to immediately restart it with another licensing options. A standalone product should not be shutting down with such an active resolution. For a VS-integrated product, this is the same as a permanent negative resolution.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Environment.ProductCanBeStartedResolution.NegativePermanentGraceful">
            <summary>
            <para>Negative resolution: this handler prohibits the product from being run.</para>
            <para>This is a veto, i.e. next handlers will not be polled.</para>
            <para>“Permanent” means that a standalone product might shut down when it sees such a resolution. A VS-integrated product will just be deactivated.</para>
            <para>“Graceful” means this state is not unexpected. For example, closing the standalone application main window or suspending a VS-integrated product is a graceful shutdown.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Environment.ProductCanBeStartedResolution.NegativePermanentByError">
            <summary>
            <para>Negative resolution: this handler prohibits the product from being run.</para>
            <para>This is a veto, i.e. next handlers will not be polled.</para>
            <para>“Permanent” means that a standalone product might shut down when it sees such a resolution. A VS-integrated product will just be deactivated.</para>
            <para>“ByError” means this state is reached due to some problem like a failed startup or an invalid product license.</para>
            </summary>
        </member>
        <member name="T:JetBrains.Application.Environment.ProductCanBeStartedVerdict">
            <summary>
            The verdict of a single <see cref="T:JetBrains.Application.Environment.IProductCanBeStarted"/> handler.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Environment.ProductCanBeStartedVerdict.Resolution">
            <summary>
            The resolution (to make a decision on product).
            </summary>
        </member>
        <member name="F:JetBrains.Application.Environment.ProductCanBeStartedVerdict.Comment">
            <summary>
            Comment on the resolution. Optional.
            Highly recommended with non-positive resolutions.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Environment.ProductCanBeStartedVerdict.Affirmative(System.String)">
            <summary>
            <see cref="F:JetBrains.Application.Environment.ProductCanBeStartedResolution.Affirmative"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Application.Environment.ProductCanBeStartedVerdict.NegativeTemporary(System.String)">
            <summary>
            <see cref="F:JetBrains.Application.Environment.ProductCanBeStartedResolution.NegativeTemporary"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Environment.ProductCanBeStartedVerdict.NegativePermanentGraceful(System.String)">
            <summary>
            <see cref="F:JetBrains.Application.Environment.ProductCanBeStartedResolution.NegativePermanentGraceful"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Environment.ProductCanBeStartedVerdict.NegativePermanentByError(System.String)">
            <summary>
            <see cref="F:JetBrains.Application.Environment.ProductCanBeStartedResolution.NegativePermanentByError"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Environment.ProductCanBeStartedVerdictEx.IsAffirmative(JetBrains.Application.Environment.ProductCanBeStartedVerdict)">
            <summary>
            Gets whether the resolution is affirmative. <c>Null</c> is also considered affirmative because it's the <see cref="T:JetBrains.Application.ComposeVerdictWithPriority"/> return value for all-affirmative.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Environment.ProductCanBeStartedVerdictEx.SelectShouldStartShell(JetBrains.DataFlow.IProperty{JetBrains.Application.Environment.ProductCanBeStartedVerdict},JetBrains.DataFlow.Lifetime)">
            <summary>
            Gets whether the product shell should be started.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Environment.ProductCanBeStartedVerdictEx.ShouldStartShell(JetBrains.Application.Environment.ProductCanBeStartedVerdict)">
            <summary>
            Gets whether the product shell should be started.
            </summary>
            <remarks><c>Null</c> is also considered affirmative because it's the <see cref="T:JetBrains.Application.ComposeVerdictWithPriority"/> return value for all-affirmative.</remarks>
        </member>
        <member name="M:JetBrains.Application.Environment.ProductCanBeStartedVerdictEx.ShouldBeRunningStandaloneApplicationHost(JetBrains.Application.Environment.ProductCanBeStartedVerdict)">
            <summary>
            Gets whether the standalone application host (NOTE: this is not the product shell with components, but the host) should be still running.
            </summary>
            <remarks><c>Null</c> is also considered affirmative because it's the <see cref="T:JetBrains.Application.ComposeVerdictWithPriority"/> return value for all-affirmative.</remarks>
        </member>
        <member name="M:JetBrains.Application.Environment.ProductCanBeStartedVerdictEx.IsWithErrors(JetBrains.Application.Environment.ProductCanBeStartedVerdict)">
            <summary>
            Whether the overall application run is considered as failed.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Environment.ProductCanBeStartedVerdictEx.IsNegativePermanent(JetBrains.Application.Environment.ProductCanBeStartedVerdict)">
            <summary>
            Whether it's one of the permanent negative resolutions.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Environment.ApplicationShutdownRequests">
            <summary>
            Handles requests from code to shut down the application.
            If you detect a situation when the app should be shut down, e.g. the main window has been closed, or File|Exit has been invoked, or the automated application has completed its task, call this handler.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Environment.ApplicationShutdownRequests.ShutdownRequested(JetBrains.Application.Environment.ApplicationShutdownRequests.ShutdownErrorStatus)">
            <summary>
            Call this method if you would like the standalone application to shut down.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Environment.RunsPublicStaticIntMain">
            <summary>
            Looks for static methods with <see cref="T:JetBrains.Application.Environment.PublicStaticIntMainAttribute"/>.
            If found, executes them and shuts the app down.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Environment.TeamCityExceptionReporting.TeamCityExceptionReportService">
            <summary>
            Attaches to the exception reporter, dumps to TC.
            </summary>
        </member>
        <member name="M:JetBrains.Application.AssemblyInfoDatabase.IsBlessedAssembly(JetBrains.Util.FileSystemPath)">
            <summary>
            blessed means that this assembly will not be deleted, changed, etc. For instance - .net framework assemblies
            </summary>
            <param name="fileSystemPath"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Application.Build.ShellBasedBuiltInBuildEngineExtraction.CollectBuiltInEngineDlls(JetBrains.Application.Environment.ApplicationPackagesLocallyInstalled,JetBrains.Application.Components.Optional{JetBrains.Application.Environment.ShellPartCatalogSet})">
            <summary>
            DLLs required to run the builtin version of the engine.
            </summary>
            <param name="appPackages"></param>
            <param name="catalogset"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Application.Build.ShellBasedBuiltInBuildEngineExtraction.CollectBuiltInEngineDlls_AdHocScatteredPackage(JetBrains.Application.Components.Optional{JetBrains.Application.Environment.ShellPartCatalogSet})">
            <summary>
            We're running in fallback mode, off all DLLs in the folder.
            This is for hardcode bootstrapping only.
            In this case just trace all of the DLL refs from our DLL.
            </summary>
            <param name="catalogset"></param>
        </member>
        <member name="M:JetBrains.Application.changes.ChangeManagerEx.PushRegisterChangeProvider(JetBrains.Application.changes.ChangeManager,JetBrains.Application.changes.IChangeProvider)">
            <summary>
            Registers/unregisters change provider in the dispatching scheme.
            </summary>
        </member>
        <member name="M:JetBrains.Application.BuildScript.Application.Catalogs.PartCatalogZoneMapping.GetOrCreate(JetBrains.Application.Catalogs.PartCatalog)">
            <summary>
            Gets the zone mapping for a catalog.
            Reads a cached object, or creates a new one if missing yet.
            </summary>
        </member>
        <member name="M:JetBrains.Application.BuildScript.Application.Catalogs.PartCatalogZoneMapping.GetPartZones(JetBrains.Application.Catalogs.PartCatalogType)">
            <summary>
            For a type, gets either the list of module zones required for it (might be empty), or <c>NULL</c> if there're no <see cref="T:JetBrains.Application.ZoneMarker"/> wherever in its hierarchy, which makes it ineligible for instantiation.
            </summary>
        </member>
        <member name="M:JetBrains.Application.BuildScript.Application.Catalogs.PartCatalogZoneMapping.IsPartInZones(JetBrains.Application.Catalogs.PartCatalogType,System.Collections.Generic.JetHashSet{JetBrains.Application.BuildScript.Application.Zones.ZonePart},JetBrains.Application.BuildScript.Application.Catalogs.PartCatalogZoneMapping.CachedPartsPerZone)">
            <summary>
            Gets whether all zones marked over the given <paramref name="part" /> are among the <paramref name="activeModuleZoneValues" />.
            </summary>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Application.Catalogs.PartCatalogZoneMapping.AssemblyData">
            <summary>
            Declared zones within a single assembly.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Application.Catalogs.PartCatalogZoneMapping.AssemblyData.myMapFqnToZones">
            <summary>
            The trie path is the class fullname. There are nodes for classes and namespaces.
            Each node might have a list of zones applied to it.
            For a class, its effective zone list is the union of all lists on its node and its ancestors up to the root.
            </summary>
        </member>
        <member name="M:JetBrains.Application.BuildScript.Application.Catalogs.PartCatalogZoneMapping.AssemblyData.GetNameZones(JetBrains.Util.dataStructures.Sources.StringSource)">
            <summary>
            For a full name of a type, gets either the list of module zones required for it (might be empty), or <c>NULL</c> if there're no <see cref="T:JetBrains.Application.ZoneMarker"/> wherever in its hierarchy, which makes it ineligible for instantiation.
            </summary>
        </member>
        <member name="M:JetBrains.Application.BuildScript.Application.Catalogs.PartCatalogZoneMapping.AssemblyData.AddPartZones(JetBrains.Application.Catalogs.PartCatalogType)">
            <summary>
              <para>Looks if the class has the <see cref="T:JetBrains.Application.BuildScript.Application.Zones.ZoneMarkerAttribute"/>, which means the specific class, or the whole namespace is marked as belonging to that zone. See attr doc for details.</para>
            </summary>
        </member>
        <member name="T:JetBrains.Application.Install.InstallationData.EmptyTransformInstallationData">
            <summary>
            A placeholder build helper to ensure some helpers are always registered for the interface, and resolve succeeds for them.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Install.InstallationData.ITransformInstallationData">
            <summary>
            After all the installation data is collected as <see cref="T:JetBrains.Application.Install.InstallationData.InstallationDataOriginal"/>, applies transformations to it which cannot be implemented by populating the installation data in the regular additive manner. After all the transformation, the <see cref="T:JetBrains.Application.Install.InstallationData.InstallationDataFinal"/> is ready for execution.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Install.InstallationData.ITransformInstallationData.ApplyTransform(JetBrains.Application.Install.InstallationData.InstallationDataTransform)">
            <summary>
            Applies the transformation by modifying the installation data contents.
            Yield <c>Null</c> if you don't want to modify.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Install.InstallationData.ITransformInstallationData.Priority">
            <summary>
            Executed in ascending order.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Install.InstallationData.InstallationDataFinal">
            <summary>
            Installation data after all the transformations.
            To be used by installation data consumers.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Install.InstallationData.InstallationData">
            <summary>
            The root element of the product installation data.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Install.InstallationData.InstallationData.Folders">
            <summary>
            Gets the list of folders with files to install.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Install.InstallationData.InstallationData.SharedMsies">
            <summary>
            Msi-es with shared installation strategy.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Install.InstallationData.InstallationData.PostInstallExecutables">
            <summary>
            Local machine executables to run elevated on register and unregister.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Install.InstallationData.InstallationData.RegistryKeys">
            <summary>
            Gets the list of folders with files to install.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Install.InstallationData.InstallationData.RegistryValues">
            <summary>
            Gets the list of folders with files to install.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Install.InstallationData.InstallationData.MergeWith(JetBrains.Application.Install.InstallationData.InstallationData)">
            <summary>
            Merges the <paramref name="addon" /> installation data into the host's, and destroys the former.
            All of the collections are guaranteed to be non-Null
            </summary>
        </member>
        <member name="M:JetBrains.Application.Install.InstallationData.InstallationData.RemoveDuplicates">
            <summary>
            Checks for duplicate keys and values, removes, if any.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Install.InstallationData.InstallationDataBuildSteps.ApplyTransform(JetBrains.Application.Install.InstallationData.InstallationDataOriginal,JetBrains.Application.Install.InstallationData.ITransformInstallationData[],JetBrains.Util.ILogger)">
            <summary>
            After all the installation data is collected as <see cref="T:JetBrains.Application.Install.InstallationData.InstallationDataOriginal"/>, applies transformations to it which cannot be implemented by populating the installation data in the regular additive manner. After all the transformation, the <see cref="T:JetBrains.Application.Install.InstallationData.InstallationDataFinal"/> is ready for execution.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Install.InstallationData.InstallationDataOriginal">
            <summary>
            To be produced out of the original contributions. Used as input for the first transformation.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Install.InstallationData.InstallationDataOriginalPart">
            <summary>
            Produced by emitting build steps, or collected out of disjoint file/registry artifacts. Will be packed into the single <see cref="T:JetBrains.Application.Install.InstallationData.InstallationDataOriginal"/> for processing.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Install.InstallationData.InstallationDataTransform">
            <summary>
            Installation data in between the transformations.
            A special type to avoid mixup with the <see cref="T:JetBrains.Application.Install.InstallationData.InstallationDataOriginal"/> or <see cref="T:JetBrains.Application.Install.InstallationData.InstallationDataFinal"/> while within the <see cref="T:JetBrains.Application.Install.InstallationData.ITransformInstallationData"/> pipeline.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Install.InstallationData.TransformInstallationData">
            <summary>
            Temporary empty transformer to avoid failures on empty array injections.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Install.Launcher.CleanLauncherArtifact">
            <summary>
            The clean (not branded with any product, just as built) launcher executables.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Install.Launcher.LauncherArtifactBase.Configuration">
            <summary>
            Which CPU architecture, and is it for windows or console subsystem.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Install.Launcher.LauncherArtifactBase.Executable">
            <summary>
            The main executable of the launcher.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Install.Launcher.LauncherArtifactBase.ProgramDatabase">
            <summary>
            The launcher's PDB, if applicable.
            </summary>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Install.Launcher.LauncherSubsystem.Windows">
            <summary>
            Default.
            Parent process does not wait for it to exit.
            </summary>
            <remarks>Name must match the CPP project file constant value.</remarks>
        </member>
        <member name="F:JetBrains.Application.BuildScript.Install.Launcher.LauncherSubsystem.Console">
            <summary>
            Console mode.
            Console parent process waits for it to exit, and its console is reused.
            </summary>
            <remarks>Name must match the CPP project file constant value.</remarks>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Install.Launcher.StandaloneLauncherHostArtifact">
            <summary>
            Requests that a standalone host be installed.
            The entry point executable is created on the Local Install stage. It does not appear in the product packages and is only generated on the target deployment machine. Thus, it can hold the full host components with any localinstalltime-serialized info.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.Install.Launcher.StuffedLauncherArtifact">
            <summary>
            The ready launcher executables, branded with the product and stuffed with the serialized host components.
            </summary>
        </member>
        <member name="T:JetBrains.Application.BuildScript.SerializedHostComponentItemArtifact">
            <summary>
            Lists build artifact values which should be serialized during the Local Install to be then available at runtime as components.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Install.LocalInstaller">
            <summary>
            Performs local-system installations.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Install.LocalInstaller.InstallCore(JetBrains.Application.Install.InstallationData.InstallationDataFinal,JetBrains.Application.Install.RegistrationStage,JetBrains.Application.Install.LocalInstaller.LocalInstallerRegistryMacro[],JetBrains.Application.Install.LocalInstaller.ResolvedInstallationTargetDirRoot[],JetBrains.Util.ILogger,JetBrains.Application.BuildScript.Install.IsolationOptions,JetBrains.Application.Install.UninstallableFile[]@)">
            <summary>
            Performs the local installation of the given installation data by writing the Registry keys and copying the files.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Install.LocalInstaller.InstallFiles(System.Collections.Generic.IList{JetBrains.Application.Install.InstallationData.InstalledFolder},JetBrains.Application.Install.RegistrationStage,JetBrains.Util.ILogger,System.Func{JetBrains.Application.Install.InstallationData.InstallationTargetDirRoot,JetBrains.Util.FileSystemPath},JetBrains.Application.BuildScript.Install.IsolationOptions,System.Collections.Generic.List{JetBrains.Application.Install.UninstallableFile})">
            <summary>
            Copies or deletes the files.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Install.LocalInstaller.InstallRegistry(System.Collections.Generic.IList{JetBrains.Application.Install.InstallationData.InstalledRegistryKey},System.Collections.Generic.IList{JetBrains.Application.Install.InstallationData.InstalledRegistryValue},JetBrains.Application.Install.RegistrationStage,System.Collections.Generic.IDictionary{System.String,System.String},JetBrains.Application.BuildScript.Install.IsolationOptions,JetBrains.Util.ILogger)">
            <summary>
            Executes the registration/unregistration operations on the Registry keys.
            </summary>
            <param name="regkeys">The Registry to process.</param>
            <param name="regvalues">The Registry to process.</param>
            <param name="registrationStage">Processing type.</param>
            <param name="macros">The macros to substitute when processing the keys.</param>
            <param name="isolation"></param>
            <param name="logger"></param>
        </member>
        <member name="M:JetBrains.Application.Install.LocalInstaller.RegisterKey(JetBrains.Application.Install.InstallationData.InstalledRegistryKey,System.Collections.Generic.IDictionary{System.String,System.String},JetBrains.Application.BuildScript.Install.IsolationOptions,JetBrains.Util.ILogger)">
            <summary>
            Writes the key to the Registry.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Install.LocalInstaller.RegisterValue(JetBrains.Application.Install.InstallationData.InstalledRegistryValue,System.Collections.Generic.IDictionary{System.String,System.String},JetBrains.Application.BuildScript.Install.IsolationOptions,JetBrains.Util.ILogger)">
            <summary>
            Writes the value to the Registry.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Install.LocalInstaller.UnregisterKey(JetBrains.Application.Install.InstallationData.InstalledRegistryKey,System.Collections.Generic.IDictionary{System.String,System.String},JetBrains.Application.BuildScript.Install.IsolationOptions,JetBrains.Util.ILogger)">
            <summary>
            Deletes the key from the Registry.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Install.LocalInstaller.UnregisterValue(JetBrains.Application.Install.InstallationData.InstalledRegistryValue,System.Collections.Generic.IDictionary{System.String,System.String},JetBrains.Application.BuildScript.Install.IsolationOptions,JetBrains.Util.ILogger)">
            <summary>
            Deletes the value from the Registry.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Interop.NativeHook.DummyWindowsHookManager">
            <summary>
            Dummy <see cref="T:JetBrains.Application.Interop.NativeHook.IWindowsHookManager"/> implementation.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Interop.NativeHook.WindowsHookManager">
            <summary>
            Manages the windows hooks. Creates a native implementation wherever possible, or substitutes with a managed one when native not available.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Interop.NativeHook.IWindowsHookManager">
            <summary>
            Provides a set of methods to hook Windows messages in the current thread and notify the listeners of them.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Interop.NativeHook.IWindowsHookManager.AdviseWindowMessage(JetBrains.DataFlow.Lifetime,System.IntPtr,JetBrains.Interop.WinApi.WindowsMessages,System.Boolean,System.Action{JetBrains.Application.Interop.NativeHook.WindowsMessageEventArgs})">
            <summary>
            Advises specific or all Windows messages to specific or all windows in the current thread.
            </summary>
            <param name="lifetime">Lifetime.</param>
            <param name="window">Handle to the window, or <c>Null</c> for all the windows.</param>
            <param name="message">Windows message to listen to, or <c>0</c> for all the messages.</param>
            <param name="isDeferredProcessingAllowed">Is not implemented yet.</param>
            <param name="action">Message handler to be invoked.</param>
        </member>
        <member name="M:JetBrains.Application.Interop.NativeHook.IWindowsHookManager.AdviseWindowClassMessage(JetBrains.DataFlow.Lifetime,System.String,JetBrains.Interop.WinApi.WindowsMessages,System.Boolean,System.Action{JetBrains.Application.Interop.NativeHook.WindowsMessageEventArgs})">
            <summary>
            Advises specific or all Windows messages to all windows of a given window class in the current thread.
            </summary>
            <param name="lifetime">Lifetime.</param>
            <param name="className">Window class name to be advised.</param>
            <param name="message">Windows message to listen to, or <c>0</c> for all the messages.</param>
            <param name="isDeferredProcessingAllowed">Is not implemented yet.</param>
            <param name="action">Message handler to be invoked.</param>
        </member>
        <member name="M:JetBrains.Application.Interop.NativeHook.IWindowsHookManager.AdviseInputMessage(JetBrains.DataFlow.Lifetime,System.Action{JetBrains.Application.Interop.NativeHook.WindowsMessageEventArgs})">
            <summary>
            Advises all keyboard and mouse messages in the current thread.
            </summary>
            <param name="lifetime">Lifetime.</param>
            <param name="action">Message handler to be invoked.</param>
        </member>
        <member name="M:JetBrains.Application.Interop.NativeHook.IWindowsHookManager.AdviseApplicationActiveStateChange(JetBrains.DataFlow.Lifetime)">
            <summary>
            Advises application active state changes.
            </summary>
            <param name="lifetime">Lifetime</param>
            <returns>A boolean property that reflects the current application active state.</returns>
            <remarks>The behavior of the hook when focus goes to a window of another thread depends on implementation. 
            <para>The old managed implemetation is able to track the main thread only and reports application deactivation when the main thread loses the focus.</para>
            <para>The new unmanaged implementation monitors all threads of the process and reports deactivation when focus goes to another application.</para>
            </remarks>
        </member>
        <member name="M:JetBrains.Application.Interop.NativeHook.IWindowsHookManager.AdviseWindowScreenCoordinatesChange(JetBrains.DataFlow.Lifetime,System.IntPtr)">
            <summary>
            Advises screen coordinates changes of the specified window.
            </summary>
            <param name="lifetime">Lifetime.</param>
            <param name="window">Handle to the window to watch.</param>
            <returns>A property that reflects current window screen coordinates.
            <para>The hook does not control whether the window is alive or not. If the window is destroyed the property keeps its last value.</para>
            <para>When the lifetime is terminated, the property is set to an empty Rect.</para>
            </returns>
        </member>
        <member name="M:JetBrains.Application.Interop.NativeHook.IWindowsHookManager.AdviseWindowRootParentChange(JetBrains.DataFlow.Lifetime,System.IntPtr)">
            <summary>
            Advises root parent window changes of the specified window.
            </summary>
            <param name="lifetime">Lifetime.</param>
            <param name="window">Handle to the window to watch.</param>
            <returns>A property that reflects the current root parent window of the watched window.
            <para>When the window gets invalid (destroyed) or the lifetime is terminated, the property gets the <c>IntPtr.Zero</c> value.</para>
            </returns>
        </member>
        <member name="M:JetBrains.Application.Interop.NativeHook.IWindowsHookManager.StartMouseWheelRedirectingToHoveredWindow(JetBrains.DataFlow.Lifetime)">
            <summary>
            Fixes mouse wheel behavior so that the mouse wheel scrolls the hovered window instead of the fucused one.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Interop.NativeHook.IWindowsHookManager.AdviseForegroundIdle(JetBrains.DataFlow.Lifetime,System.Action)">
            <summary>
            Advises that the foreground thread is about to become idle.
            </summary>
            <param name="lifetime">Lifetime.</param>
            <param name="action">Action to be invoked.</param>
        </member>
        <member name="P:JetBrains.Application.Interop.NativeHook.IWindowsHookManager.Windows">
            <summary>
            A selector of the window and message to be hooked.
            </summary>
            <remarks>Usage:
             IWindowsHookManager hookman;
             hookman.Windows.All.Messages.All.Advise(lifetime, false, action);
             hookman.Windows.All.Messages[WM_msg].Advise(lifetime, false, action);
             hookman.Windows[wnd].Messages.All.Advise(lifetime, false, action);
             hookman.Windows[wnd].Messages[WM_msg].Advise(lifetime, false, action);
            </remarks>
        </member>
        <member name="F:JetBrains.Application.Interop.NativeHook.WindowsHookManager.NativeHooksDllName">
            <summary>
            Native Windows hook DLL name.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Interop.NativeHook.WindowsHookManager.myInstance">
            <summary>
            Instance (could be native or managed).
            </summary>
        </member>
        <member name="M:JetBrains.Application.Interop.NativeHook.WindowsHookManager.AdviseWindowMessage(JetBrains.DataFlow.Lifetime,System.IntPtr,JetBrains.Interop.WinApi.WindowsMessages,System.Boolean,System.Action{JetBrains.Application.Interop.NativeHook.WindowsMessageEventArgs})">
            <summary>
            Advises specific or all Windows messages to specific or all windows in the current thread.
            </summary>
            <param name="lifetime">Lifetime.</param>
            <param name="window">Handle to the window, or <c>Null</c> for all the windows.</param>
            <param name="message">Windows message to listen to, or <c>0</c> for all the messages.</param>
            <param name="isDeferredProcessingAllowed">Is not implemented yet.</param>
            <param name="action">Message handler to be invoked.</param>
        </member>
        <member name="M:JetBrains.Application.Interop.NativeHook.WindowsHookManager.AdviseWindowClassMessage(JetBrains.DataFlow.Lifetime,System.String,JetBrains.Interop.WinApi.WindowsMessages,System.Boolean,System.Action{JetBrains.Application.Interop.NativeHook.WindowsMessageEventArgs})">
            <summary>
            Advises specific or all Windows messages to all windows of a given window class in the current thread.
            </summary>
            <param name="lifetime">Lifetime.</param>
            <param name="className">Window class name to be advised.</param>
            <param name="message">Windows message to listen to, or <c>0</c> for all the messages.</param>
            <param name="isDeferredProcessingAllowed">Is not implemented yet.</param>
            <param name="action">Message handler to be invoked.</param>
        </member>
        <member name="M:JetBrains.Application.Interop.NativeHook.WindowsHookManager.AdviseInputMessage(JetBrains.DataFlow.Lifetime,System.Action{JetBrains.Application.Interop.NativeHook.WindowsMessageEventArgs})">
            <summary>
            Advises all keyboard and mouse messages in the current thread.
            </summary>
            <param name="lifetime">Lifetime.</param>
            <param name="action">Message handler to be invoked.</param>
        </member>
        <member name="M:JetBrains.Application.Interop.NativeHook.WindowsHookManager.AdviseApplicationActiveStateChange(JetBrains.DataFlow.Lifetime)">
            <summary>
            Advises application active state changes.
            </summary>
            <param name="lifetime">Lifetime</param>
            <returns>A boolean property that reflects the current application active state.</returns>
        </member>
        <member name="M:JetBrains.Application.Interop.NativeHook.WindowsHookManager.AdviseWindowScreenCoordinatesChange(JetBrains.DataFlow.Lifetime,System.IntPtr)">
            <summary>
            Advises screen coordinates changes of the specified window.
            </summary>
            <param name="lifetime">Lifetime.</param>
            <param name="window">Handle to the window to watch.</param>
            <returns>A property that reflects current window screen coordinates.</returns>
        </member>
        <member name="M:JetBrains.Application.Interop.NativeHook.WindowsHookManager.AdviseWindowRootParentChange(JetBrains.DataFlow.Lifetime,System.IntPtr)">
            <summary>
            Advises root parent window changes of the specified window.
            </summary>
            <param name="lifetime">Lifetime.</param>
            <param name="window">Handle to the window to watch.</param>
            <returns>A property that reflects the current root parent window of the watched window.</returns>
        </member>
        <member name="M:JetBrains.Application.Interop.NativeHook.WindowsHookManager.StartMouseWheelRedirectingToHoveredWindow(JetBrains.DataFlow.Lifetime)">
            <summary>
            Fixes mouse wheel behavior so that the mouse wheel scrolls the hovered window instead of the fucused one.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Interop.NativeHook.WindowsHookManager.AdviseForegroundIdle(JetBrains.DataFlow.Lifetime,System.Action)">
            <summary>
            Advises that the foreground thread is about to become idle.
            </summary>
            <param name="lifetime">Lifetime.</param>
            <param name="action">Event handler to be invoked.</param>
        </member>
        <member name="P:JetBrains.Application.Interop.NativeHook.WindowsHookManager.Instance">
            <summary>
            Gets the current instance of a WindowsHookManager.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Interop.NativeHook.WindowsHookManager.Windows">
            <summary>
            A selector of the window and message to be hooked.
            </summary>
        </member>
        <member name="T:JetBrains.Application.License2.Evaluation.EvaluationTracker">
            <summary>
            Use <see cref="P:JetBrains.Application.License2.Evaluation.EvaluationTracker.EntityUsedSignal"/> to report license entity usage on current date. 
            The signal is safe to be called numerous time during the same date.
            </summary>
        </member>
        <member name="M:JetBrains.Application.License2.ILicenseCheckResult.TryGetInfo(JetBrains.Application.License2.ILicensedEntity)">
            <summary>
            License check info if applicable
            </summary>
        </member>
        <member name="P:JetBrains.Application.License2.ILicenseCheckResult.AllowedEntities">
            <summary>
            Collection of entities the check for which is successful
            </summary>
        </member>
        <member name="P:JetBrains.Application.License2.ILicenseCheckResult.ResultChanged">
            <summary>
            Fired when result is changed, but AllowedEntities may remain intact. 
            I.e. one more checker allowed entity that is allowed already
            </summary>
        </member>
        <member name="P:JetBrains.Application.License2.ILicenseViewSubmodel.IsOn">
            <summary>
            Used to turn on/ off
            </summary>
        </member>
        <member name="P:JetBrains.Application.License2.ILicenseViewSubmodel.AllModel">
            <summary>
            Th compound model. We might remove it
            </summary>
        </member>
        <member name="P:JetBrains.Application.License2.ILicenseViewSubmodel.LicenseData">
            <summary>
            License data to store
            </summary>
        </member>
        <member name="M:JetBrains.Application.License2.ILicense2CheckComponent.ShowLicenseDialog(System.String)">
            <summary>
            Shows license dialog using handlers registered with <see cref="!:License2CheckComponent.RegisterShowLicenseDialogHandler.RegisterShowLicenseDialogHandler"/>
            </summary>
            <param name="reason">why the dialog is shown</param>
        </member>
        <member name="M:JetBrains.Application.License2.ILicense2CheckComponent.RegisterShowLicenseDialogHandler(JetBrains.DataFlow.Lifetime,System.Func{JetBrains.Application.License2.LicenseViewModel,System.String,System.Boolean},System.Func{JetBrains.Application.License2.LicenseViewModel,System.Boolean})">
            <summary>
            Register handler that will be called to show license dialog. 
            Normal reasons to show:
              1. when shell is started and there're changes in all/ allowed entities list comparing to previous product start
              2. allowed entities list is about to change when license goes off and similar
              3. user's request to show license information
            </summary>
            <param name="lifetime">Handler lifetime</param>
            <param name="handler">Callback to show dialog</param>
            <param name="forceShowDialog">Callback to decide whether license dialog is to be shown in spite of there is no change to the previous start</param>
        </member>
        <member name="M:JetBrains.Application.License2.ILicense2CheckComponent.WithLicenseViewModel(JetBrains.DataFlow.Lifetime,System.Action{JetBrains.Application.License2.LicenseViewModel})">
            <summary>
            Access current view model. Normally, the action is called syncronously, but the behaviour may change
            </summary>
            <param name="lifetime">Lifetime while the action still makes sense to execeute</param>
            <param name="action">Action to be executed over the <see cref="T:JetBrains.Application.License2.LicenseViewModel"/></param>
        </member>
        <member name="M:JetBrains.Application.License2.ILicense2CheckComponent.GetValidLicensePresentation">
            <summary>
            Returns information abould licensed entities
            </summary>
        </member>
        <member name="P:JetBrains.Application.License2.ILicense2CheckComponent.AllowedEntities">
            <summary>
            Collection of entitites licensed at the moment
            </summary>
        </member>
        <member name="P:JetBrains.Application.License2.ILicense2CheckComponent.LicenseViewModelSaved">
            <summary>
            Fired after license view model is persited. 
            </summary>
        </member>
        <member name="P:JetBrains.Application.License2.ILicenseData.LastRunAllEntities">
            <summary>
            Environment specific: List of entitites subject to license check last time the product is started in given environment.
            </summary>
        </member>
        <member name="P:JetBrains.Application.License2.ILicenseData.LastRunEnabledEntities">
            <summary>
            Environment specific: List of entitites that passed license check last time it was performed in given environment
            </summary>
        </member>
        <member name="T:JetBrains.Application.License2.ILicensedEntity">
            <summary>
            ILicensedEntity is an entity that represents a product if we use former terminology. The entity describes all the way it can be licensed and the zones it enables if properly licensed.
            If the product is free its <see cref="T:JetBrains.Application.License2.ILicensedEntity"/> should have the following property values 
            * <see cref="P:JetBrains.Application.License2.ILicensedEntity.Evaluation"/> is null 
            * <see cref="P:JetBrains.Application.License2.ILicensedEntity.UserLicense"/> is null 
            * <see cref="P:JetBrains.Application.License2.ILicensedEntity.LicenseServer"/> is empty
            * <see cref="P:JetBrains.Application.License2.ILicensedEntity.JetBrainsAccount"/> is empty
            If license to ReSharper Ultimate suits to the product make sure:
            * <see cref="P:JetBrains.Application.License2.ILicensedEntity.UserLicense"/>.<see cref="P:JetBrains.Application.License2.ISupportsUserLicense.UserLicenseCheckers"/> contains value <see cref="M:JetBrains.Application.License2.UserLicenseChecker.CreateForReSharperUltimate"/>
            * <see cref="P:JetBrains.Application.License2.ILicensedEntity.LicenseServer"/> contains value <see cref="M:JetBrains.Application.License2.LicenseServer.SupportsLicenseServer.CreateForReSharperUltimate"/>
            * <see cref="P:JetBrains.Application.License2.ILicensedEntity.JetBrainsAccount"/> contains value <see cref="M:JetBrains.Application.License2.SupportsJetBrainsAccount.CreateForReSharperUltimate"/>
            Zones marked with <see cref="T:JetBrains.Application.Environment.ZoneLicenseAttribute"/> must be allowed by any of <see cref="T:JetBrains.Application.License2.ILicensedEntity"/> running.
            The zones allowed are determined by <see cref="P:JetBrains.Application.Environment.IZoneLicenseChecker.Signatures"/> property. <see cref="M:JetBrains.Application.Environment.ZoneSignatureValidator.Encode(System.String,System.String,System.String)"/> or <see cref="M:JetBrains.Application.Environment.ZoneSignatureValidator.Encode``1(JetBrains.Application.Settings.ISettingsStore,System.Type[])"/> can be used to generate signature.
            If ReSharper is run in internal mode one may use action ReSharper | Internal | Zones | Copy Zone Signature to Clipboard as follows:
            * add zones public keys to <see cref="T:JetBrains.Application.Environment.ZoneLicenseCheckSettings"/>. Sample settings file may be found at \\msdc\resharper\Licensing\zoneKeys.DotSettings
            * in the .ctor create local variable of desired zone type (i.e. IUnitTestingZone z;)
            * put caret over zone type and execute action. The signature will be copied to clipboard. 
            Mark your licensed entity with <see cref="T:JetBrains.Application.License2.LicensedEntityIconsAttribute"/> to provide icons
            </summary>
        </member>
        <member name="P:JetBrains.Application.License2.ILicensedEntity.TechnicalName">
            <summary>
            Name of the entity used to store entity-related data. Should not be changed between product versions unless product differs
            </summary>
        </member>
        <member name="P:JetBrains.Application.License2.ILicensedEntity.PresentableName">
            <summary>
            Name of the entity used in presentations
            </summary>
        </member>
        <member name="P:JetBrains.Application.License2.ILicensedEntity.EntityVersion">
            <summary>
            Version of the entity. Since the entity more or less corresponds the product it is the product version
            </summary>
        </member>
        <member name="P:JetBrains.Application.License2.ILicensedEntity.EntityMarketingVersionString">
            <summary>
            Marketing Version of the entity. Corresponds to marketing version of a product.
            </summary>
        </member>
        <member name="T:JetBrains.Application.License2.ISupportsEvaluation">
            <summary>
            Implement the interface by the <see cref="T:JetBrains.Application.License2.ILicensedEntity"/> if the entity supports free evaluation.
            </summary>
        </member>
        <member name="P:JetBrains.Application.License2.ISupportsEvaluation.ProductGuid">
            <summary>
            Guid (with braces), that is used to store Date marker
            </summary>
        </member>
        <member name="P:JetBrains.Application.License2.ISupportsEvaluation.FreeTrialPeriod">
            <summary>
            Number of days, free trial period lasts
            </summary>
        </member>
        <member name="P:JetBrains.Application.License2.ISupportsEvaluation.FeedbackRequestPeriod">
            <summary>
            Number of free trial days, after which feedback is requested.
            Negative value means feedback is never requested.
            </summary>
        </member>
        <member name="P:JetBrains.Application.License2.ISupportsEvaluation.LeftDaysNotification">
            <summary>
            Identifies, when to start informing user that, his free trial
            period ends up 
            </summary>
        </member>
        <member name="P:JetBrains.Application.License2.ISupportsEvaluation.Mode">
            <summary>
            Identifies the way the entity considered used. 
            If the value is <see cref="F:JetBrains.Application.License2.EvaluationUsageMode.IMPLICITE_USAGE"/> every day corresponding <see cref="T:JetBrains.Application.License2.ILicensedEntity"/> is running will be count automatically.
            If <see cref="F:JetBrains.Application.License2.EvaluationUsageMode.EXPLICITE_USAGE"/> is used fire <see cref="P:JetBrains.Application.License2.Evaluation.EvaluationTracker.EntityUsedSignal"/> every time the entity is used. 
            </summary>
        </member>
        <member name="F:JetBrains.Application.License2.EvaluationUsageMode.IMPLICITE_USAGE">
            <summary>
            Every time the licensed entity is enabled it is considered used
            </summary>
        </member>
        <member name="F:JetBrains.Application.License2.EvaluationUsageMode.IMPLICITE_USAGE_EVERY_CALENDAR_DAY">
            <summary>
            Every time the licensed entity is enabled it is considered used for each day since last check 
            </summary>
        </member>
        <member name="F:JetBrains.Application.License2.EvaluationUsageMode.EXPLICITE_USAGE">
            <summary>
            The licensed entity is considered used if and only if the <see cref="P:JetBrains.Application.License2.Evaluation.EvaluationTracker.EntityUsedSignal"/> signal is fired. 
            Normally, the signal is fired from corresponsing actions
            </summary>
        </member>
        <member name="P:JetBrains.Application.License2.ISupportsLicensesWithSubscription.ProductBuiltDateUsedForSubscriptionCheck">
            <summary>
            When checking subscription license we need to verify product creation time against subscription period. 
            If we just use <see cref="!:IApplicationDescriptor.BuiltOn"/> there might be situation when version X.0 is eligible to use because issued within subscription period,
            but bugfix X.0.1 is issued when the period is over. To handle this the property is set to the date of X.0 release.
            Normally, TeamCity build parameter TC_DateTimeForSubscriptionCheck is used (<see cref="F:JetBrains.Application.Defines.DateTimeForSubscriptionCheck"/>).
            If subscription is not available one may return <see cref="F:System.DateTime.MaxValue"/>
            </summary>
        </member>
        <member name="T:JetBrains.Application.License2.ISupportsUserLicense">
            <summary>
            Implement the interface by the <see cref="T:JetBrains.Application.License2.ILicensedEntity"/> if the entity supports user licenses if form of user name/ license key.
            </summary>
        </member>
        <member name="M:JetBrains.Application.License2.ISupportsUserLicense.GetLicenseAgreement(JetBrains.Application.License.LicenseType)">
            <summary>
            License agreement in rich text. NULL if no license agreement is necessary to show when license is entered
            </summary>
        </member>
        <member name="P:JetBrains.Application.License2.ISupportsUserLicense.DoCheckLicenseReuseOverNetwork">
            <summary>
            Determines whether the product should check for multiple instances running simultaneousely over the network.
            </summary>
        </member>
        <member name="T:JetBrains.Application.License2.ISupportsLicenseServer">
            <summary>
            Implement the interface by the <see cref="T:JetBrains.Application.License2.ILicensedEntity"/> if the entity supports obtaining tickets from locally installed license server.
            </summary>
        </member>
        <member name="P:JetBrains.Application.License2.ISupportsLicenseServer.ProductFamily">
            <summary>
            JetBrains license server supports ProductFamily as guid without braces !!!
            </summary>
        </member>
        <member name="P:JetBrains.Application.License2.ISupportsLicenseServer.LicenseServerVersion">
            <summary>
            Version to request from license server. Normally it equals to product major version * 1000  (<see cref="F:JetBrains.Application.Defines.NumLicenseAppVersion"/>)
            If the product supports subscription only use version equal to buildDate.Year*10000 + buildDate.Month*100 + buildDate.Day.
            </summary>
        </member>
        <member name="P:JetBrains.Application.License2.ISupportsLicenseServer.LicenseServerEdition">
            <summary>
            Edition to request from license server. 
            </summary>
        </member>
        <member name="P:JetBrains.Application.License2.ISupportsLicenseServer.SendBuildDateAsVersionToOldServers">
            <summary>
            Return true if your product had subscription previously. In the case <see cref="P:JetBrains.Application.License2.ISupportsLicensesWithSubscription.ProductBuiltDateUsedForSubscriptionCheck"/> will be used to issue ticket 
            in case of old license server.
            </summary>
        </member>
        <member name="P:JetBrains.Application.License2.ISupportsJetBrainsAccount.ProductName">
            <summary>
            Product name used for presentation
            </summary>
        </member>
        <member name="P:JetBrains.Application.License2.ISupportsJetBrainsAccount.ProductCode">
            <summary>
            Product code to be requested from JetBrains license server
            </summary>
        </member>
        <member name="P:JetBrains.Application.License2.ISupportsJetBrainsAccount.ProductEdition">
            <summary>
            Product edition to be requested from JetBrains license server
            </summary>
        </member>
        <member name="P:JetBrains.Application.License2.ISupportsJetBrainsAccount.ProductVersion">
            <summary>
            Version to request from JetBrains license server. Normally it equals to product major version * 1000  (<see cref="F:JetBrains.Application.Defines.NumLicenseAppVersion"/>)
            If the product supports subscription only use version equal to buildDate.Year*10000 + buildDate.Month*100 + buildDate.Day.
            </summary>
        </member>
        <member name="M:JetBrains.Application.License2.UserLicenseChecker.CreateFor(System.String,System.String,System.Int32,System.DateTime,System.Func{JetBrains.Application.License.LicenseData,JetBrains.Application.License.LicenseCheckResult})">
            <summary>
            Default checker by product version and subscription
            </summary>
            <param name="publicKey">Product's public key</param>
            <param name="version">Product version in the form of (major*1000+minor*100). Normally, just major is used. Minor is used if and only if it is payed, which is not expected to happen under normal circumstances.</param>
            <param name="dateTimeForSubscriptionCheck">Date of the release build which is used for subscription check. Use <see cref="F:System.DateTime.MaxValue"/> if no subscription available.</param>
            <param name="additionalCheck">Additional check if necessary.</param>
            <returns>Default checker by product version and subscription</returns>
        </member>
        <member name="P:JetBrains.Application.License2.JBAccount.IJBAccountInfo.IsPrimary">
            <summary>
            Helper property used to distinguish current data from old
            </summary>
        </member>
        <member name="P:JetBrains.Application.License2.JBAccount.IJBAccountInfo.Account">
            <summary>
            JetBrains account used last time
            </summary>
        </member>
        <member name="P:JetBrains.Application.License2.JBAccount.IJBAccountInfo.UserId">
            <summary>
            User id corresponding to the account
            </summary>
        </member>
        <member name="P:JetBrains.Application.License2.JBAccount.IJBAccountInfo.UsedAssetIds">
            <summary>
            Asset ids used 
            </summary>
        </member>
        <member name="P:JetBrains.Application.License2.JBAccount.IJBAccountInfo.EncodedAssetDatas">
            <summary>
            Encoded data about all the assets available to the account
            </summary>
        </member>
        <member name="P:JetBrains.Application.License2.JBAccount.IJBAccountInfo.NextCheckTime">
            <summary>
            Time of the next check
            </summary>
        </member>
        <member name="P:JetBrains.Application.License2.JBAccount.IJBAccountInfo.ValidationDeadline">
            <summary>
            Time until which assets must be validate
            </summary>
        </member>
        <member name="M:JetBrains.Application.License2.JBAccount.JBAccountInfo.Sqeeze">
            <summary>
            Removes corrupt/ duplicated asset data
            </summary>
            <returns>Squeezed data or null if nothing to squeeze</returns>
        </member>
        <member name="T:JetBrains.Application.License2.JBAccount.JBAccountInfoPersister">
            <summary>
            Loads JetBrains account access information from registry corresponding to <see cref="!:ProductSettingsLocationFlag.AnyProductAnyVersion"/> 
            (HKEY_CURRENT_USER\Software\JetBrains\DotNet\vAny\JBAccount)
            </summary>
        </member>
        <member name="T:JetBrains.Application.License2.JBAccount.JBAccountSettingsPersister">
            <summary>
            Loads JetBrains account access information from registry corresponding to <see cref="!:ProductSettingsLocationFlag.AnyProductAnyVersion"/> 
            (HKEY_CURRENT_USER\Software\JetBrains\DotNet\vAny\JBAccountSettings)
            </summary>
        </member>
        <member name="M:JetBrains.Application.License2.JBAccount.JBAcountLicenseViewSubmodel.TryValidateAssetData(JetBrains.Application.License2.LicenseServerSupport.JBAccount.AssetData)">
            <summary>
            Validates asset data. 
            </summary>
            <param name="data">AssetData to validate</param>
            <returns>True if validation should continue. False on network error.</returns>
        </member>
        <member name="M:JetBrains.Application.License2.License2CheckComponent.ShowLicenseDialog(System.String)">
            <summary>
            Shows license dialog using handlers registered with <see cref="M:JetBrains.Application.License2.License2CheckComponent.RegisterShowLicenseDialogHandler(JetBrains.DataFlow.Lifetime,System.Func{JetBrains.Application.License2.LicenseViewModel,System.String,System.Boolean},System.Func{JetBrains.Application.License2.LicenseViewModel,System.Boolean})"/>
            </summary>
            <param name="reason">why the dialog is shown</param>
        </member>
        <member name="F:JetBrains.Application.License2.LicenseServerSupport.AbstractObtainTicketRequest`1.Version">
            <summary>
            Old license server version. In case of subscription must be year*10000 + month*100 + day.
            </summary>
        </member>
        <member name="F:JetBrains.Application.License2.LicenseServerSupport.AbstractObtainTicketRequest`1.VersionNumber">
            <summary>
            New license server data. VersionNumber = major * 1000
            </summary>
        </member>
        <member name="F:JetBrains.Application.License2.LicenseServerSupport.AbstractObtainTicketRequest`1.BuildDate">
            <summary>
            New license server data. Release date for subscription check in the form of year*10000 + month*100 + day
            </summary>
        </member>
        <member name="M:JetBrains.Application.License2.LicenseServerSupport.AbstractObtainTicketRequest`1.#ctor(System.Int32,System.DateTime,System.Boolean)">
            <summary>
            Helper constructor.
            </summary>
            <param name="version">Product version to send (Normally, major * 1000)</param>
            <param name="buildDate">Release build date to check subscription (y*10000 + m*100 + d)</param>
            <param name="sendBuildDateAsVersionToOldServers">Old license server compatibility. True if there was a subscription previously)</param>
        </member>
        <member name="M:JetBrains.Application.License2.LicenseServerSupport.AbstractObtainTicketRequest`1.#ctor(System.Int64,System.String,System.String,System.String,System.Int32,System.DateTime,System.Boolean)">
            <summary>
            Helper constructor.
            </summary>
            <param name="salt"></param>
            <param name="machineId"></param>
            <param name="hostName"></param>
            <param name="userName"></param>
            <param name="version">Product version to send (Normally, major * 1000)</param>
            <param name="buildDate">Release build date to check subscription (y*10000 + m*100 + d)</param>
            <param name="sendBuildDateAsVersionToOldServers">Old license server compatibility. True if there was a subscription previously)</param>
        </member>
        <member name="F:JetBrains.Application.License2.LicenseServerSupport.JBAccount.ExchangeKeyRequest.ProductCode">
            <summary>
            Product code is required by API but never used
            </summary>
        </member>
        <member name="F:JetBrains.Application.License2.LicenseServerSupport.JBAccount.ExchangeKeyRequest.OldLicenseKey">
            <summary>
            Old format license key (we do not need user name to lookup in database)
            </summary>
        </member>
        <member name="F:JetBrains.Application.License2.LicenseServerSupport.JBAccount.ExchangeKeyRequest.FirstName">
            <summary>
            Assignee's first name. Ignored if <see cref="F:JetBrains.Application.License2.LicenseServerSupport.JBAccount.ExchangeKeyRequest.OldLicenseKey"/> is personal
            </summary>
        </member>
        <member name="F:JetBrains.Application.License2.LicenseServerSupport.JBAccount.ExchangeKeyRequest.LastName">
            <summary>
            Assignee's last name. Ignored if <see cref="F:JetBrains.Application.License2.LicenseServerSupport.JBAccount.ExchangeKeyRequest.OldLicenseKey"/> is personal
            </summary>
        </member>
        <member name="F:JetBrains.Application.License2.LicenseServerSupport.JBAccount.ExchangeKeyRequest.Email">
            <summary>
            Assignee's email. Ignored if <see cref="F:JetBrains.Application.License2.LicenseServerSupport.JBAccount.ExchangeKeyRequest.OldLicenseKey"/> is personal
            </summary>
        </member>
        <member name="F:JetBrains.Application.License2.LicenseServerSupport.JBAccount.ExchangeKeyResponse.NewLicenseKey">
            <summary>
            New license key if exchange is applicable
            </summary>
        </member>
        <member name="F:JetBrains.Application.License2.LicenseServerSupport.JBAccount.ObtainLicenseRequest.UserId">
            <summary>
            User id obtained by JetBrains account credential check.
            </summary>
        </member>
        <member name="F:JetBrains.Application.License2.LicenseServerSupport.JBAccount.ObtainLicenseRequest.ProductCode">
            <summary>
            Product code as stated in products.json on a server
            </summary>
        </member>
        <member name="F:JetBrains.Application.License2.LicenseServerSupport.JBAccount.ObtainLicenseRequest.Edition">
            <summary>
            Not used actually
            </summary>
        </member>
        <member name="F:JetBrains.Application.License2.LicenseServerSupport.JBAccount.ObtainLicenseRequest.Version">
            <summary>
            Product version requested as major*1000+minor*100
            </summary>
        </member>
        <member name="F:JetBrains.Application.License2.LicenseServerSupport.JBAccount.ObtainLicenseRequest.BuildDate">
            <summary>
            Release date for subscription check in the form of year*10000 + month*100 + day
            </summary>
        </member>
        <member name="F:JetBrains.Application.License2.LicenseServerSupport.JBAccount.ObtainLicenseResponse.ValidationPeriod">
            <summary>
            Milliseconds to revalidate the license
            </summary>
        </member>
        <member name="F:JetBrains.Application.License2.LicenseServerSupport.JBAccount.ObtainLicenseResponse.ValidationDeadlinePeriod">
            <summary>
            Period in milliseconds to perform successful validation. If the period expires validation considered failed.
            </summary>
        </member>
        <member name="F:JetBrains.Application.License2.LicenseServerSupport.JBAccount.ValidateKeyRequest.ProductCode">
            <summary>
            Product code is required by API but never used
            </summary>
        </member>
        <member name="F:JetBrains.Application.License2.LicenseServerSupport.JBAccount.ValidateKeyRequest.LicenseKey">
            <summary>
            License Key entered by user. Licensee name is not necessary.
            </summary>
        </member>
        <member name="F:JetBrains.Application.License2.LicenseServerSupport.JBAccount.ValidateKeyRequest.LicenseHash">
            <summary>
            License hash for new keys. Used to check if regeneration is necessary.
            </summary>
        </member>
        <member name="F:JetBrains.Application.License2.LicenseServerSupport.JBAccount.ValidateKeyResponse.ValidationPeriod">
            <summary>
            Seconds to revalidate the license
            </summary>
        </member>
        <member name="F:JetBrains.Application.License2.LicenseServerSupport.JBAccount.ValidateKeyResponse.NewLicenseKey">
            <summary>
            New license key if changed.
            </summary>
        </member>
        <member name="F:JetBrains.Application.License2.LicenseServerSupport.JBAccount.ValidateLicenseRequest.UserId">
            <summary>
            User id obtained by JetBrains account credential check.
            </summary>
        </member>
        <member name="F:JetBrains.Application.License2.LicenseServerSupport.JBAccount.ValidateLicenseRequest.AssetId">
            <summary>
            Asset id to be validated
            </summary>
        </member>
        <member name="F:JetBrains.Application.License2.LicenseServerSupport.JBAccount.ValidateLicenseRequest.ProductCode">
            <summary>
            Product code as stated in products.json on a server
            </summary>
        </member>
        <member name="F:JetBrains.Application.License2.LicenseServerSupport.JBAccount.ValidateLicenseRequest.Edition">
            <summary>
            Not used actually
            </summary>
        </member>
        <member name="F:JetBrains.Application.License2.LicenseServerSupport.JBAccount.ValidateLicenseRequest.Version">
            <summary>
            Product version requested as major*1000+minor*100
            </summary>
        </member>
        <member name="F:JetBrains.Application.License2.LicenseServerSupport.JBAccount.ValidateLicenseRequest.BuildDate">
            <summary>
            Release date for subscription check in the form of year*10000 + month*100 + day
            </summary>
        </member>
        <member name="F:JetBrains.Application.License2.LicenseServerSupport.JBAccount.ValidateLicenseRequest.licenseHash">
            <summary>
            Hash of the license included in AssetData
            </summary>
        </member>
        <member name="F:JetBrains.Application.License2.LicenseServerSupport.JBAccount.ValidateLicenseResponse.ValidationPeriod">
            <summary>
            Milliseconds to revalidate the license
            </summary>
        </member>
        <member name="F:JetBrains.Application.License2.LicenseServerSupport.JBAccount.ValidateLicenseResponse.ValidationDeadlinePeriod">
            <summary>
            Period in milliseconds to perform successful validation. If the period expires validation considered failed.
            </summary>
        </member>
        <member name="F:JetBrains.Application.License2.LicenseServerSupport.JBAccount.ValidateLicenseResponse.NewEncodedAsset">
            <summary>
            New license key corresponding to the asset
            </summary>
        </member>
        <member name="T:JetBrains.Application.License2.LicenseServer.RegistryLicenseServerInfoPersister">
            <summary>
            Loads license server info from registry corresponding to <see cref="!:ProductSettingsLocationFlag.AnyProductAnyVersion"/> 
            (HKEY_CURRENT_USER\Software\JetBrains\DotNet\vAny\LicenseServer)
            </summary>
        </member>
        <member name="T:JetBrains.Application.License2.LicenseServer.RegistryLicenseServerSettingsPersister">
            <summary>
            Loads license server info from registry corresponding to <see cref="!:ProductSettingsLocationFlag.AnyProductAnyVersion"/> 
            (HKEY_CURRENT_USER\Software\JetBrains\DotNet\vAny\LicenseServerSettings)
            </summary>
        </member>
        <member name="P:JetBrains.Application.License2.LicenseViewModel.Name">
            <summary>
            Name of the model. Used to distinguish between current/ temporary etc.
            </summary>
        </member>
        <member name="P:JetBrains.Application.License2.LicenseViewModel.OriginalLicenseData">
            <summary>
            License data used when model is created.
            </summary>
        </member>
        <member name="P:JetBrains.Application.License2.LicenseViewModel.DataNeedsToBesSaved">
            <summary>
            Signal is fired when <see cref="!:Data"/> is changed. Used to save data when necessary.
            </summary>
        </member>
        <member name="P:JetBrains.Application.License2.LicenseViewModel.Entities">
            <summary>
            All licensed entities involved in license check process.
            TODO: who deals with entities that are not licensed if any?
            </summary>
        </member>
        <member name="P:JetBrains.Application.License2.LicenseViewModel.Submodels">
            <summary>
            Submodels responsible for certain aspects of licensing. I.e. evaluation period, user licenses etc.
            </summary>
        </member>
        <member name="P:JetBrains.Application.License2.LicenseViewModel.OverallStatus">
            <summary>
            Overall licensing status
            </summary>
        </member>
        <member name="M:JetBrains.Application.License2.NewLicenses.NewLicenseDataCache.GetOrCreateLicenseData(JetBrains.Application.License2.NewLicenses.NewLicenseData,JetBrains.Application.License2.ILicensedEntity)">
            <summary>
            Can be null if licensed entity does not support JBA
            </summary>
        </member>
        <member name="M:JetBrains.Application.License2.UserLicenses.INamedLicenseData.DescribeValidLicense">
            <summary>
            Overall description for presentation
            </summary>
        </member>
        <member name="P:JetBrains.Application.License2.UserLicenses.INamedLicenseData.LicenseName">
            <summary>
            Name of license for presentation
            </summary>
        </member>
        <member name="P:JetBrains.Application.License2.UserLicenses.INamedLicenseData.LicenseeName">
            <summary>
            To whom the license belogs. <see cref="P:JetBrains.Application.License.LicenseData.UserName"/> for old licenses.
            </summary>
        </member>
        <member name="P:JetBrains.Application.License2.UserLicenses.INamedLicenseData.AssigneeName">
            <summary>
            To whom the license is assigned. Should be ignored if empty of equals to <see cref="P:JetBrains.Application.License2.UserLicenses.INamedLicenseData.LicenseeName"/>
            </summary>
        </member>
        <member name="P:JetBrains.Application.License2.UserLicenses.INamedLicenseData.LicenseId">
            <summary>
            License identifier used for broadcasting. <see cref="P:JetBrains.Application.License.LicenseData.LicenseKey"/> for old license, <see cref="P:JetBrains.Application.License2.NewLicenses.NewLicenseData.LicenseId"/> for new one.
            </summary>
        </member>
        <member name="P:JetBrains.Application.License2.UserLicenses.INamedLicenseData.LicenseHash">
            <summary>
            License hash. <see cref="F:System.String.Empty"/> for old license, <see cref="P:JetBrains.Application.License2.NewLicenses.NewLicenseData.Hash"/> for new one.
            </summary>
        </member>
        <member name="P:JetBrains.Application.License2.UserLicenses.INamedLicenseData.LicenseRestrictions">
            <summary>
            License restrictions string.
            </summary>
        </member>
        <member name="P:JetBrains.Application.License2.UserLicenses.INamedLicenseData.ExpirationDate">
            <summary>
            Date of license expiration if ever. <see cref="P:JetBrains.Application.License.LicenseData.ExpirationDate"/> for old licenses.
            </summary>
        </member>
        <member name="P:JetBrains.Application.License2.UserLicenses.INamedLicenseData.CheckConcurrentUse">
            <summary>
            True if concurrent use is prohibited
            </summary>
        </member>
        <member name="P:JetBrains.Application.License2.UserLicenses.INamedLicenseData.Status">
            <summary>
            Get license status
            </summary>
        </member>
        <member name="P:JetBrains.Application.License2.UserLicenses.INamedLicenseData`1.LicenseData">
            <summary>
            Actual license data
            </summary>
        </member>
        <member name="T:JetBrains.Application.License2.UserLicenses.FileUserLicensePersister">
            <summary>
            Loads user license from files located in <see cref="!:ProductSettingsLocationFlag.AnyProductAnyVersion"/> folder
            Folder: C:\Users\qx\AppData\Roaming\JetBrains\DotNet\vAny
            File mask: *license*.txt
            </summary>
        </member>
        <member name="T:JetBrains.Application.License2.UserLicenses.RegistryUserLicensePersister">
            <summary>
            Loads user license from registry corresponding to <see cref="!:ProductSettingsLocationFlag.AnyProductAnyVersion"/> 
            (HKEY_CURRENT_USER\Software\JetBrains\DotNet\vAny\UserLicenses)
            </summary>
        </member>
        <member name="T:JetBrains.Application.License2.UserLicenses.RegistryUserLicenseSettingsPersister">
            <summary>
            Loads user license from registry corresponding to <see cref="!:ProductSettingsLocationFlag.AnyProductAnyVersion"/> 
            (HKEY_CURRENT_USER\Software\JetBrains\DotNet\vAny\UserLicenseSettings)
            </summary>
        </member>
        <member name="M:JetBrains.Application.License2.UserLicenses.UserLicenseViewSubmodel.CheckLicense(JetBrains.Application.License2.UserLicenses.UserLicense,JetBrains.Application.License2.ISupportsUserLicense)">
            <summary>
            Returns 
              - NULL if license failed to decode.
              - data of first successful check
              - data of first failed check if no successful 
            </summary>
        </member>
        <member name="M:JetBrains.Application.License2.UserLicenses.UserLicenseViewSubmodel.CheckLicense(JetBrains.Application.License2.UserLicenses.UserLicense,JetBrains.Application.License2.ILicensedEntity)">
            <summary>
            Returns 
              - NULL if license failed to decode.
              - data of first successful check
              - data of first failed check if no successful 
            </summary>
        </member>
        <member name="M:JetBrains.Application.License2.Util.AssetUtil.DescribeValidAsset(System.String,System.String,System.DateTime,System.DateTime)">
            <summary>
            Returns presentable asset (manually entered user licese or asset obtained from JetBrains account) description.
            </summary>
            <param name="licensee">Licensee name</param>
            <param name="licenseRestrictions">License restrictions if any (i.e "for non-commercial development only")</param>
            <param name="subscriptionEndDate">End of maintainence subscription. When no subcription use <see cref="F:System.DateTime.MinValue"/></param>
            <param name="expirationDate">End of license. Use <see cref="F:System.DateTime.MaxValue"/> for endless assets</param>
            <returns>Presentable asset description</returns>
        </member>
        <member name="M:JetBrains.Application.platforms.IFrameworkDetectionHelper.GetNetFrameworkDirectory(System.Version)">
            <summary>
            Returns .NET framework directory, usually under .NET Frameworks install root
            </summary>
        </member>
        <member name="M:JetBrains.Application.platforms.NetCoreProvider.GetMscorlibSubstituentPath(JetBrains.Application.platforms.PlatformInfo)">
            <summary>
            Assembly with all predefined types. i.e. System.Runtime (for 4.5.1, 4.5.0).
            </summary>
        </member>
        <member name="P:JetBrains.Application.platforms.PlatformManager.GacPath">
            <summary>
            Path to GAC.
            </summary>
        </member>
        <member name="P:JetBrains.Application.platforms.PlatformManager.Gac40Path">
            <summary>
            Path to GAC 4.0.
            </summary>
        </member>
        <member name="M:JetBrains.Application.ShellComponentAttribute.#ctor(JetBrains.Application.Lifecycle,JetBrains.Application.Creation,JetBrains.Application.Access)">
            <summary>
            Note: all of the params are not used yet, but should be set up on all newly-created components to later enable deferred/lazy loading.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.IHaveDefaultSettings">
            <summary>
            If you got default settings to be always preloaded into the Settings Store, you can expose by implementing this interface.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Settings.IHaveDefaultSettings.Name">
            <summary>
            The name for the mounting point which will be mounting your settings stream into the settings store.
            </summary>
        </member>
        <member name="T:JetBrains.Application.AdjustSystemTraceListeners">
            <summary>
            Remove default trace listener (with msgboxes on exceptions).
            Add own listener to intercept problems on callstacks where our code (any) is present, and submit to exception reporting.
            </summary>
        </member>
        <member name="T:JetBrains.Application.AssertShellLocksAreGuarded">
            <summary>
            Prevents <see cref="T:JetBrains.Threading.Invocator"/> reentrancy when a lock is taken (temporary).
            Asserts that any primary-thread lock is guarded by <see cref="T:JetBrains.Threading.Invocator"/>.
            </summary>
        </member>
        <member name="T:JetBrains.Application.HostCulture">
            <summary>
            WTF
            </summary>
        </member>
        <member name="P:JetBrains.Application.HostCulture.Culture">
            <summary>
            WTF
            </summary>
        </member>
        <member name="T:JetBrains.Application.Threading.ContentModelReadWriteLock">
            <summary>
            Implements the housekeeping logic around <see cref="T:JetBrains.Util.Concurrency.ReentrantWriterPreferenceReadWriteLock"/> for the needs of full <see cref="T:JetBrains.Application.IShellLocks"/> functionality.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Threading.ContentModelReadWriteLock.Debug_LongWait_Threshold">
            <summary>
            The threshold, in milliseconds, for telling long waits. Any wait above this is "long", and is reported.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Threading.ContentModelReadWriteLock.myAfterWriteLockReleased">
            <summary>
            Fires after the Writer Lock is released in any thread. Fires on that same thread.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Threading.ContentModelReadWriteLock.myBeforeAcquiringReadLock">
            <summary>
            Fires after the Writer Lock is released in any thread. Fires on that same thread.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Threading.ContentModelReadWriteLock.myDispatcher">
            <summary>
            Identifies the primary thread (for the Write Lock affinity).
            Attaches to the thread it's created on.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Threading.ContentModelReadWriteLock.myRWLock">
            <summary>
            Core implementation of the RW locks.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Threading.ContentModelReadWriteLock.myThreadWithGrantedWriteAccess">
            <summary>
            Normally, only the primary thread can take Write Lock at any time, and this is <c>Null</c>.
            If non-<c>Null</c>, then this right is temporarily granted to another thread.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.ContentModelReadWriteLock.AcquireReadLock">
            <summary>
             Fetches read lock - the lock which is used to control read-access to ReSharper data (such as PSI, documents, etc.) and
             is obtained by threads that perform read-operations.
            </summary>
            <remarks>
             Read lock cannot be acquired when the write lock is acquired by another thread and execution will be blocked until the write lock is released.
             You do not need to acquire read lock in the UI thread (since write operations cannot be performed in any thread different from the UI thread).
             Use <see cref="M:JetBrains.Application.Threading.ContentModelReadWriteLock.ReleaseReadLock"/> method to release read lock.
            <b>NOTE:</b> the best way to hold read lock for a block of code is to use <see cref="!:JetBrains.ReSharper.Resources.Shell.Shell.ReadLockCookie"></see>
            </remarks>
            <seealso cref="!:JetBrains.ReSharper.Resources.Shell.Shell.ReadLockCookie"/>
            <seealso cref="M:JetBrains.Application.Threading.ContentModelReadWriteLock.ReleaseReadLock"/>
        </member>
        <member name="M:JetBrains.Application.Threading.ContentModelReadWriteLock.AcquireWriteLock">
            <summary>
            Fetches write lock - the lock which is used to control write-access to ReSharper data (such as PSI, documents, etc.) and
            is obtained by threads that perform write-operations.
            </summary>
            <remarks>
            Write lock cannot be acquired when the read lock is acquired by another thread and execution will be blocked until the read lock is released.
            Acquiring of the write lock is allowed only in the UI thread (and so you cannot perform any write operations from non-UI thread).
            Note that you do not have to obtain the write lock explicitly in most of cases. All low-level write methods (such as PSI or document modifications)
            obtain write lock automatically. You may need to obtain write lock if your subsystem (similar to PSI or documents) has its own data to be modified in write operations only.
            Use <see cref="M:JetBrains.Application.Threading.ContentModelReadWriteLock.ReleaseWriteLock"/> method to release write lock.
            <b>NOTE:</b> the best way to hold write lock for a block of code is to use <see cref="!:JetBrains.ReSharper.Resources.Shell.Shell.Shell.WriteLockCookie"></see>
            </remarks>
            <seealso cref="!:JetBrains.ReSharper.Resources.Shell.Shell.Shell.WriteLockCookie"/>
            <seealso cref="M:JetBrains.Application.Threading.ContentModelReadWriteLock.ReleaseWriteLock"/>
        </member>
        <member name="M:JetBrains.Application.Threading.ContentModelReadWriteLock.GrantWriteAccess(System.Threading.Thread)">
            <summary>
            Grants write access rights to the specified secondary thread. This function can only be called from the
            primary UI thread. The typical situation in which it can be useful is when a time-consuming
            write operation needs to be performed. It is supposed that during this operation the UI thread
            is blocked (by e.g. a modal window). Only one thread can be granted write access at time.
            </summary>
            <seealso cref="M:JetBrains.Application.Threading.ContentModelReadWriteLock.RevokeWriteAccess(System.Threading.Thread)"/>
            <param name="thread">Thread to grant write access to</param>
        </member>
        <member name="M:JetBrains.Application.Threading.ContentModelReadWriteLock.ReleaseReadLock">
            <summary>
             Releases read lock.
             For more information about read lock see <see cref="M:JetBrains.Application.Threading.ContentModelReadWriteLock.AcquireReadLock"/>.
            </summary>
            <seealso cref="M:JetBrains.Application.Threading.ContentModelReadWriteLock.AcquireReadLock"/>
        </member>
        <member name="M:JetBrains.Application.Threading.ContentModelReadWriteLock.ReleaseWriteLock">
            <summary>
             Releases write lock.
             For more information about write lock see <see cref="M:JetBrains.Application.Threading.ContentModelReadWriteLock.AcquireWriteLock"/>.
            </summary>
            <seealso cref="M:JetBrains.Application.Threading.ContentModelReadWriteLock.AcquireWriteLock"/>
        </member>
        <member name="M:JetBrains.Application.Threading.ContentModelReadWriteLock.RevokeWriteAccess(System.Threading.Thread)">
            <summary>
            Revokes write access from the thread that has been granted write access.
            </summary>
            <seealso cref="M:JetBrains.Application.Threading.ContentModelReadWriteLock.GrantWriteAccess(System.Threading.Thread)"/>
            <param name="thread">Thread to revoke write access from</param>
        </member>
        <member name="M:JetBrains.Application.Threading.ContentModelReadWriteLock.Debug_LongWait_AfterWaitForReadLock">
            <summary>
            Called after we have completed waiting for the write lock.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.ContentModelReadWriteLock.Debug_LongWait_AfterWaitForWriteLock">
            <summary>
            Called after we have completed waiting for the write lock.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.ContentModelReadWriteLock.Debug_LongWait_BeforeReleaseReadLock">
            <summary>
            Read lock is about to be released, check if we kept someone waiting for a write lock.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.ContentModelReadWriteLock.Debug_LongWait_BeforeReleaseWriteLock">
            <summary>
            Read lock is about to be released, check if we kept someone waiting for a write lock.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.ContentModelReadWriteLock.Debug_LongWait_BeforeWaitForReadLock">
            <summary>
            Called before we start waiting for the lock, to enter the long-wait-tracking-mode.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.ContentModelReadWriteLock.Debug_LongWait_BeforeWaitForWriteLock">
            <summary>
            Called before we start waiting for the lock, to enter the long-wait-tracking-mode.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Threading.ContentModelReadWriteLock.AfterWriteLockReleased">
            <summary>
            Fires after the Writer Lock is released in any thread. Fires on that same thread.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Threading.ContentModelReadWriteLock.IsReadAccessAllowed">
            <summary>
            True if read access is allowed in the current thread.
            </summary>
            <seealso cref="M:JetBrains.Application.Threading.ContentModelReadWriteLock.AcquireReadLock"/>
            <seealso cref="M:JetBrains.Application.IShellLocksEx.AssertReadAccessAllowed(JetBrains.Application.IShellLocks)"/>
        </member>
        <member name="P:JetBrains.Application.Threading.ContentModelReadWriteLock.IsReadLockHeld">
            <summary>
            Indicates that the current thread owns the read lock
            </summary>
        </member>
        <member name="P:JetBrains.Application.Threading.ContentModelReadWriteLock.IsWriteAccessAllowed">
            <summary>
            True if write access is allowed in the current thread.
            </summary>
            <seealso cref="M:JetBrains.Application.Threading.ContentModelReadWriteLock.AcquireWriteLock"/>
            <seealso cref="M:JetBrains.Application.IShellLocksEx.AssertWriteAccessAllowed(JetBrains.Application.IShellLocks)"/>
        </member>
        <member name="P:JetBrains.Application.Threading.ContentModelReadWriteLock.IsWriteLockHeld">
            <summary>
            Indicates that the current thread owns the write lock
            </summary>
        </member>
        <member name="P:JetBrains.Application.Threading.ContentModelReadWriteLock.IsWriteLockRequested">
            <summary>
            Indicates that any thread requests for write lock, but not yet granted
            </summary>
        </member>
        <member name="E:JetBrains.Application.Threading.ContentModelReadWriteLock.AfterReadLockReleased">
            <summary>
            Fires after the Read Lock is released in any thread. Fires on that same thread.
            </summary>
        </member>
        <member name="E:JetBrains.Application.Threading.ContentModelReadWriteLock.BeforeAcquiringReadLock">
            <summary>
            Event which is raised before read lock is acquired.
            </summary>
            <seealso>AcquireReadLock</seealso>
        </member>
        <member name="E:JetBrains.Application.Threading.ContentModelReadWriteLock.BeforeAcquiringWriteLock">
            <summary>
            Event which is raised before write lock is acquired.
            This event can be used by background operations which need to stop/pause to allow write operation to execute.
            </summary>
            <seealso>AcquireWriteLock</seealso>
        </member>
        <member name="T:JetBrains.Application.IShellLocks">
            <summary>
            Expands basic threading constructs with the Reader-Writer pessimistic locking which protects the content model stuff, such as Documents, Project Model, PSI, and so on.
            </summary>
        </member>
        <member name="T:JetBrains.Threading.IThreading">
            <summary>
            Exposes threading tasks of the application.
            </summary>
        </member>
        <member name="P:JetBrains.Threading.IThreading.Dispatcher">
            <summary>
              <para>Gets the <see cref="T:JetBrains.Threading.JetDispatcher"/> of the home thread of this instance.</para>
              <para>If you get <see cref="T:JetBrains.Threading.IThreading">the threading object</see> imported into a component, then this is the primary thread of your component container.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Threading.IThreading.GroupingEvents">
            <summary>
              <para>A host that creates grouping events to be executed on the home thread of this instance (optionally, under protection of the <see cref="P:JetBrains.Threading.IThreading.ReentrancyGuard"/>).</para>
              <para>If you get <see cref="T:JetBrains.Threading.IThreading">the threading object</see> imported into a component, then this is the primary thread of your component container.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Threading.IThreading.IsRecurringActivityAllowed">
            <summary>
            Gets or sets whether the application is currently active (and background activities are allowed).
            Used to suspend recurring actions execution when inactive.
            </summary>
        </member>
        <member name="P:JetBrains.Threading.IThreading.ReentrancyGuard">
            <summary>
              <para>Gets the <see cref="P:JetBrains.Threading.IThreading.ReentrancyGuard"/> of the home thread of this instance.</para>
              <para>If you get <see cref="T:JetBrains.Threading.IThreading">the threading object</see> imported into a component, then this is the primary thread of your component container.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Threading.IThreading.Tasks">
            <summary>
            Gets the .NET Async Tasks API for executing tasks asynchronously on either background or main thread, optionally with guarding and content access locks.
            </summary>
        </member>
        <member name="P:JetBrains.Threading.IThreading.ThreadManager">
            <summary>
            Gets the scheduler for running background tasks on other threads.
            </summary>
        </member>
        <member name="P:JetBrains.Threading.IThreading.TimedActions">
            <summary>
              <para>Schedules one-time and recurring actions to be executed on the home thread of this instance, optionally under protection of the <see cref="P:JetBrains.Threading.IThreading.ReentrancyGuard"/>.</para>
              <para>If you get <see cref="T:JetBrains.Threading.IThreading">the threading object</see> imported into a component, then this is the primary thread of your component container.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Application.IShellLocks.ContentModelLocks">
            <summary>
            The Reader-Writer pessimistic locking which protects the content model stuff, such as Documents, Project Model, PSI, and so on.
            </summary>
        </member>
        <member name="M:JetBrains.Application.IShellLocksEx.AllowNestedExecutionAndReleaseLocks(JetBrains.Application.IShellLocks,System.String,System.Action)">
            <summary>
            When executed under a reentrancy guard, lifts the guard and releases all of the locks, ie constructs a clean state.
            Must be executed on the primaty thread.
            </summary>
            <param name="thіs"></param>
            <param name="name">Name for the <see cref="P:JetBrains.Threading.Invocator.ReentrancyGuard"/> lifting.</param>
            <param name="F">The action to be executed in the clean state.</param>
        </member>
        <member name="M:JetBrains.Application.IShellLocksEx.ExecuteOrQueueReadLock(JetBrains.Application.IShellLocks,System.String,System.Action)">
            <summary>
            <para>Executes an action on the <see cref="T:JetBrains.Threading.JetDispatcher">primary thread</see> in a <see cref="T:JetBrains.Threading.ReentrancyGuard">guarded context</see>.</para>
            <para>If called on a foreign thread, executes the action asynchronously, like <see cref="M:JetBrains.Threading.IThreadingEx.Queue(JetBrains.Threading.IThreading,JetBrains.DataFlow.Lifetime,System.String,System.Action)"/>.</para>
            <para>If called on the guarded thread, checks for reentrancy. If there are no guarded executions on the stack yet, executes the action immediately and synchronously. Otherwise, postpones the action for asynchronous execution, like <see cref="M:JetBrains.Threading.IThreadingEx.Queue(JetBrains.Threading.IThreading,JetBrains.DataFlow.Lifetime,System.String,System.Action)"/> does.</para>
            <para>Takes a read lock.</para>
            </summary>
            <param name="thіs"></param>
            <param name="name">The name for the task.</param>
            <param name="F">The action to execute. Exceptions will be trapped.</param>
            <returns><c>True</c> if executed immediately, <c>False</c> if queued (<see cref="M:JetBrains.Threading.ReentrancyGuard.TryExecute(System.String,System.Action)"/>-compatible behavior).</returns>
        </member>
        <member name="M:JetBrains.Application.IShellLocksEx.ExecuteOrQueueReadLockEx(JetBrains.Application.IShellLocks,System.String,System.Action)">
            <summary>
            <para>Executes an action on the <see cref="T:JetBrains.Threading.JetDispatcher">primary thread</see> in a <see cref="T:JetBrains.Threading.ReentrancyGuard">guarded context</see>.</para>
            <para>If called on a foreign thread, executes the action asynchronously, like <see cref="M:JetBrains.Threading.IThreadingEx.Queue(JetBrains.Threading.IThreading,JetBrains.DataFlow.Lifetime,System.String,System.Action)"/>.</para>
            <para>If called on the guarded thread, checks for reentrancy. If there are no guarded executions on the stack yet, executes the action immediately and synchronously. Otherwise, postpones the action for asynchronous execution, like <see cref="M:JetBrains.Threading.IThreadingEx.Queue(JetBrains.Threading.IThreading,JetBrains.DataFlow.Lifetime,System.String,System.Action)"/> does.</para>
            <para>Takes a read lock.</para>
            <para>If Async behavior is prohibited, like in test environment, always executes synchronously.</para>
            </summary>
            <param name="thіs"></param>
            <param name="name">The name for the task.</param>
            <param name="F">The action to execute. Exceptions will be trapped.</param>
            <returns><c>True</c> if executed immediately, <c>False</c> if queued (<see cref="M:JetBrains.Threading.ReentrancyGuard.TryExecute(System.String,System.Action)"/>-compatible behavior).</returns>
        </member>
        <member name="M:JetBrains.Application.IShellLocksEx.ExecuteOrQueueReadLock(JetBrains.Application.IShellLocks,JetBrains.DataFlow.Lifetime,System.String,System.Action)">
            <summary>
            <para>Executes an action on the <see cref="T:JetBrains.Threading.JetDispatcher">primary thread</see> in a <see cref="T:JetBrains.Threading.ReentrancyGuard">guarded context</see>.</para>
            <para>If called on a foreign thread, executes the action asynchronously, like <see cref="M:JetBrains.Threading.IThreadingEx.Queue(JetBrains.Threading.IThreading,JetBrains.DataFlow.Lifetime,System.String,System.Action)"/>.</para>
            <para>If called on the guarded thread, checks for reentrancy. If there are no guarded executions on the stack yet, executes the action immediately and synchronously. Otherwise, postpones the action for asynchronous execution, like <see cref="M:JetBrains.Threading.IThreadingEx.Queue(JetBrains.Threading.IThreading,JetBrains.DataFlow.Lifetime,System.String,System.Action)"/> does.</para>
            <para>Takes a read lock.</para>
            </summary>
            <param name="thіs"></param>
            <param name="lifetime"></param>
            <param name="name">The name for the task.</param>
            <param name="F">The action to execute. Exceptions will be trapped.</param>
            <returns><c>True</c> if executed immediately, <c>False</c> if queued (<see cref="M:JetBrains.Threading.ReentrancyGuard.TryExecute(System.String,System.Action)"/>-compatible behavior).</returns>
        </member>
        <member name="M:JetBrains.Application.IShellLocksEx.ExecuteOrQueueReadLockEx(JetBrains.Application.IShellLocks,JetBrains.DataFlow.Lifetime,System.String,System.Action)">
            <summary>
            <para>Executes an action on the <see cref="T:JetBrains.Threading.JetDispatcher">primary thread</see> in a <see cref="T:JetBrains.Threading.ReentrancyGuard">guarded context</see>.</para>
            <para>If called on a foreign thread, executes the action asynchronously, like <see cref="M:JetBrains.Threading.IThreadingEx.Queue(JetBrains.Threading.IThreading,JetBrains.DataFlow.Lifetime,System.String,System.Action)"/>.</para>
            <para>If called on the guarded thread, checks for reentrancy. If there are no guarded executions on the stack yet, executes the action immediately and synchronously. Otherwise, postpones the action for asynchronous execution, like <see cref="M:JetBrains.Threading.IThreadingEx.Queue(JetBrains.Threading.IThreading,JetBrains.DataFlow.Lifetime,System.String,System.Action)"/> does.</para>
            <para>Takes a read lock.</para>
            <para>If Async behavior is prohibited, like in test environment, always executes synchronously.</para>
            </summary>
            <param name="thіs"></param>
            <param name="lifetime"></param>
            <param name="name">The name for the task.</param>
            <param name="F">The action to execute. Exceptions will be trapped.</param>
            <returns><c>True</c> if executed immediately, <c>False</c> if queued (<see cref="M:JetBrains.Threading.ReentrancyGuard.TryExecute(System.String,System.Action)"/>-compatible behavior).</returns>
        </member>
        <member name="M:JetBrains.Application.IShellLocksEx.QueueReadLock(JetBrains.Application.IShellLocks,System.String,System.Action)">
            <summary>
            <para>Queues the action to execute asynchronously on the <see cref="T:JetBrains.Threading.JetDispatcher">primary thread</see> in a <see cref="T:JetBrains.Threading.ReentrancyGuard">guarded context</see>, as soon as possible. Free-threaded.</para>
            <para>The reentrancy between guarded actions is prevented.</para>
            <para>Takes a read lock.</para>
            </summary>
            <param name="thіs"></param>
            <param name="name">The name for the task.</param>
            <param name="F">The action to execute. Exceptions will be trapped.</param>
        </member>
        <member name="M:JetBrains.Application.IShellLocksEx.QueueReadLock(JetBrains.Application.IShellLocks,JetBrains.DataFlow.Lifetime,System.String,System.Action)">
            <summary>
            <para>Queues the action to execute asynchronously on the <see cref="T:JetBrains.Threading.JetDispatcher">primary thread</see> in a <see cref="T:JetBrains.Threading.ReentrancyGuard">guarded context</see>, as soon as possible. Free-threaded.</para>
            <para>The reentrancy between guarded actions is prevented.</para>
            <para>Takes a read lock.</para>
            </summary>
            <param name="thіs"></param>
            <param name="lifetime"></param>
            <param name="name">The name for the task.</param>
            <param name="F">The action to execute. Exceptions will be trapped.</param>
        </member>
        <member name="M:JetBrains.Application.IShellLocksEx.AssertReadAccessAllowed(JetBrains.Application.IShellLocks)">
            <summary>
            Checks whether read lock is acquired and issues an internal assertion if it's not true.
            Useful method to be inserted in data access methods to ensure correct use of locks.
            </summary>
        </member>
        <member name="M:JetBrains.Application.IShellLocksEx.AssertWriteAccessAllowed(JetBrains.Application.IShellLocks)">
            <summary>
            Checks whether write lock is acquired and issues an internal assertion if it's not true.
            Useful method to be inserted in data modification methods to ensure correct use of locks.
            </summary>
        </member>
        <member name="M:JetBrains.Application.IShellLocksEx.HideReadLocks(JetBrains.Application.IShellLocks,JetBrains.DataFlow.Lifetime)">
            <summary>
            Hides all of the read locks taken by the current thread, and returns them back on dispose.
            Used by wait-for-caches kind functions to allow write locks on the other thread.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.IThreadingEx.LogAssertGuarded(JetBrains.Threading.IThreading)">
            <summary>
            <para>Checks that the activity is executed on the proper thread and is being guarded from reentrancy.</para>
            <para>Does not break execution, just logs the failure — the common case of the failure is adding new guard-checks, in which case the features could go on functioning “as before” without breaking execution, but logging the failure.</para>
            </summary>
            <param name="thіs"></param>
        </member>
        <member name="M:JetBrains.Threading.IThreadingEx.ExecuteOrQueue(JetBrains.Threading.IThreading,System.String,System.Action)">
            <summary>
            <para>Executes an action on the <see cref="P:JetBrains.Threading.IThreading.Dispatcher">primary thread</see> in a <see cref="T:JetBrains.Threading.ReentrancyGuard">guarded context</see>.</para>
            <para>If called on a foreign thread, executes the action asynchronously, like <see cref="M:JetBrains.Threading.IThreadingEx.Queue(JetBrains.Threading.IThreading,JetBrains.DataFlow.Lifetime,System.String,System.Action)"/>.</para>
            <para>If called on the guarded thread, checks for reentrancy. If there are no guarded executions on the stack yet, executes the action immediately and synchronously, like <see cref="M:JetBrains.Threading.ReentrancyGuard.Execute(System.String,System.Action)"/>. Otherwise, postpones the action for asynchronous execution, like <see cref="M:JetBrains.Threading.IThreadingEx.Queue(JetBrains.Threading.IThreading,JetBrains.DataFlow.Lifetime,System.String,System.Action)"/> does.</para>
            </summary>
            <param name="thіs"></param>
            <param name="name">The name for the task.</param>
            <param name="action">The action to execute. Exceptions will be trapped.</param>
            <returns><c>True</c> if executed immediately, <c>False</c> if queued (<see cref="M:JetBrains.Threading.ReentrancyGuard.TryExecute(System.String,System.Action)"/>-compatible behavior).</returns>
        </member>
        <member name="M:JetBrains.Threading.IThreadingEx.ExecuteOrQueueEx(JetBrains.Threading.IThreading,System.String,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)">
            <summary>
            <para>Executes an action on the <see cref="P:JetBrains.Threading.IThreading.Dispatcher">primary thread</see> in a <see cref="T:JetBrains.Threading.ReentrancyGuard">guarded context</see>.</para>
            <para>If called on a foreign thread, executes the action asynchronously, like <see cref="M:JetBrains.Threading.IThreadingEx.Queue(JetBrains.Threading.IThreading,JetBrains.DataFlow.Lifetime,System.String,System.Action)"/>.</para>
            <para>If called on the guarded thread, checks for reentrancy. If there are no guarded executions on the stack yet, executes the action immediately and synchronously, like <see cref="M:JetBrains.Threading.ReentrancyGuard.Execute(System.String,System.Action)"/>. Otherwise, postpones the action for asynchronous execution, like <see cref="M:JetBrains.Threading.IThreadingEx.Queue(JetBrains.Threading.IThreading,JetBrains.DataFlow.Lifetime,System.String,System.Action)"/> does.</para>
            <para>If Async behavior is prohibited, like in test environment, always executes synchronously.</para>
            </summary>
            <param name="thіs"></param>
            <param name="name">The name for the task.</param>
            <param name="action">The action to execute. Exceptions will be trapped.</param>
            <param name="getPriority"></param>
            <returns><c>True</c> if executed immediately, <c>False</c> if queued (<see cref="M:JetBrains.Threading.ReentrancyGuard.TryExecute(System.String,System.Action)"/>-compatible behavior).</returns>
        </member>
        <member name="M:JetBrains.Threading.IThreadingEx.ExecuteOrQueue(JetBrains.Threading.IThreading,JetBrains.DataFlow.Lifetime,System.String,System.Action)">
            <summary>
            <para>Executes an action on the <see cref="P:JetBrains.Threading.IThreading.Dispatcher">primary thread</see> in a <see cref="T:JetBrains.Threading.ReentrancyGuard">guarded context</see>.</para>
            <para>If called on a foreign thread, executes the action asynchronously, like <see cref="M:JetBrains.Threading.IThreadingEx.Queue(JetBrains.Threading.IThreading,JetBrains.DataFlow.Lifetime,System.String,System.Action)"/>.</para>
            <para>If called on the guarded thread, checks for reentrancy. If there are no guarded executions on the stack yet, executes the action immediately and synchronously, like <see cref="M:JetBrains.Threading.ReentrancyGuard.Execute(System.String,System.Action)"/>. Otherwise, postpones the action for asynchronous execution, like <see cref="M:JetBrains.Threading.IThreadingEx.Queue(JetBrains.Threading.IThreading,JetBrains.DataFlow.Lifetime,System.String,System.Action)"/> does.</para>
            </summary>
            <param name="thіs"></param>
            <param name="lifetime"></param>
            <param name="name">The name for the task.</param>
            <param name="action">The action to execute. Exceptions will be trapped.</param>
            <returns><c>True</c> if executed immediately, <c>False</c> if queued (<see cref="M:JetBrains.Threading.ReentrancyGuard.TryExecute(System.String,System.Action)"/>-compatible behavior).</returns>
        </member>
        <member name="M:JetBrains.Threading.IThreadingEx.ExecuteOrQueueEx(JetBrains.Threading.IThreading,JetBrains.DataFlow.Lifetime,System.String,System.Action)">
            <summary>
            <para>Executes an action on the <see cref="P:JetBrains.Threading.IThreading.Dispatcher">primary thread</see> in a <see cref="T:JetBrains.Threading.ReentrancyGuard">guarded context</see>.</para>
            <para>If called on a foreign thread, executes the action asynchronously, like <see cref="M:JetBrains.Threading.IThreadingEx.Queue(JetBrains.Threading.IThreading,JetBrains.DataFlow.Lifetime,System.String,System.Action)"/>.</para>
            <para>If called on the guarded thread, checks for reentrancy. If there are no guarded executions on the stack yet, executes the action immediately and synchronously, like <see cref="M:JetBrains.Threading.ReentrancyGuard.Execute(System.String,System.Action)"/>. Otherwise, postpones the action for asynchronous execution, like <see cref="M:JetBrains.Threading.IThreadingEx.Queue(JetBrains.Threading.IThreading,JetBrains.DataFlow.Lifetime,System.String,System.Action)"/> does.</para>
            <para>If Async behavior is prohibited, like in test environment, always executes synchronously.</para>
            </summary>
            <param name="thіs"></param>
            <param name="lifetime"></param>
            <param name="name">The name for the task.</param>
            <param name="action">The action to execute. Exceptions will be trapped.</param>
            <returns><c>True</c> if executed immediately, <c>False</c> if queued (<see cref="M:JetBrains.Threading.ReentrancyGuard.TryExecute(System.String,System.Action)"/>-compatible behavior).</returns>
        </member>
        <member name="M:JetBrains.Threading.IThreadingEx.Queue(JetBrains.Threading.IThreading,JetBrains.DataFlow.Lifetime,System.String,System.Action)">
            <summary>
            <para>Queues the action to execute asynchronously on the <see cref="P:JetBrains.Threading.IThreading.Dispatcher">primary thread</see> in a <see cref="T:JetBrains.Threading.ReentrancyGuard">guarded context</see>, as soon as possible. Reclaims the queuing and cancels the action from executing when the lifetime ends.</para>
            <para>The reentrancy between guarded actions is prevented.</para>
            </summary>
            <param name="thіs"></param>
            <param name="lifetime"></param>
            <param name="name">The name for the task.</param>
            <param name="F">The action to execute. Exceptions will be trapped.</param>
            <returns>You may optionally dispose of the return value to prevent the action from executing later.</returns>
        </member>
        <member name="M:JetBrains.Threading.IThreadingEx.Queue(JetBrains.Threading.IThreading,System.String,System.Action)">
            <summary>
            <para>Queues the action to execute asynchronously on the <see cref="P:JetBrains.Threading.IThreading.Dispatcher">primary thread</see> in a <see cref="T:JetBrains.Threading.ReentrancyGuard">guarded context</see>, as soon as possible. Free-threaded.</para>
            <para>The reentrancy between guarded actions is prevented.</para>
            </summary>
            <param name="thіs"></param>
            <param name="name">The name for the task.</param>
            <param name="action">The action to execute. Exceptions will be trapped.</param>
        </member>
        <member name="M:JetBrains.Threading.IThreadingEx.QueueAt(JetBrains.Threading.IThreading,System.String,System.TimeSpan,System.Action)">
            <summary>
            <para>Queues the action to execute once on the <see cref="P:JetBrains.Threading.IThreading.Dispatcher">primary thread</see> in a <see cref="T:JetBrains.Threading.ReentrancyGuard">guarded context</see> when the timeout elapses.</para>
            <para>Returns a token that cancels the action execution. The token disposal is optional.</para>
            <para>A <see cref="T:JetBrains.Threading.ReentrancyGuard"/> is preventing reentrancy between the actions.</para>
            </summary>
            <param name="thіs"></param>
            <param name="name">The name for the task.</param>
            <param name="action">The action to execute. Exceptions will be trapped.</param>
            <param name="interval">A non-negative time interval.</param>
        </member>
        <member name="M:JetBrains.Threading.IThreadingEx.QueueAt(JetBrains.Threading.IThreading,JetBrains.DataFlow.Lifetime,System.String,System.TimeSpan,System.Action)">
            <summary>
            <para>Queues the action to execute once on the <see cref="P:JetBrains.Threading.IThreading.Dispatcher">primary thread</see> in a <see cref="T:JetBrains.Threading.ReentrancyGuard">guarded context</see> when the timeout elapses.</para>
            <para>A <see cref="T:JetBrains.Threading.ReentrancyGuard"/> is preventing reentrancy among the actions.</para>
            </summary>
            <param name="thіs"></param>
            <param name="lifetime">Limiting lifetime. If the lifetime ends before the action is executed, the execution is canceled.</param>
            <param name="name">The name for the task.</param>
            <param name="action">The action to execute. Exceptions will be trapped.</param>
            <param name="interval">A non-negative time interval.</param>
        </member>
        <member name="M:JetBrains.Threading.IThreadingEx.QueueAt_NoReentrancyGuarding(JetBrains.Threading.IThreading,JetBrains.DataFlow.Lifetime,System.String,System.TimeSpan,System.Action)">
            <summary>
            <para>Queues the action to execute once on the <see cref="P:JetBrains.Threading.IThreading.Dispatcher">primary thread</see> when the timeout elapses.</para>
            <para>The action does not use <see cref="T:JetBrains.Threading.ReentrancyGuard"/> to execute.</para>
            </summary>
            <param name="thіs"></param>
            <param name="lifetime">Limiting lifetime. If the lifetime ends before the action is executed, the execution is canceled.</param>
            <param name="name">The name for the task.</param>
            <param name="action">The action to execute. Exceptions will be trapped.</param>
            <param name="interval">A non-negative time interval.</param>
        </member>
        <member name="M:JetBrains.Threading.IThreadingEx.CreateGroupingEvent(JetBrains.Threading.IThreading,JetBrains.DataFlow.Lifetime,System.String,System.TimeSpan,System.Action)">
            <summary>
            <para>Creates and registers an event that groups multiple incoming signals within a time span and issues only one outgoing signal for them.</para>
            <para>This allows to accommodate for external events firing at a high rate and execute the handler only when their activity suspends.</para>
            <para>The object is thread-safe: the incoming event may fire on any thread, the outgoing activity always happens on the <see cref="P:JetBrains.Threading.IThreading.Dispatcher">primary thread</see> in a <see cref="T:JetBrains.Threading.ReentrancyGuard">guarded context</see>.</para>
            <para>This function is free-threaded.</para>
            </summary>
            <param name="thіs"></param>
            <param name="lifetime">Limiting lifetime. If the lifetime ends before the action is executed, the execution is canceled.</param>
            <param name="name">A name to identify the event.</param>
            <param name="interval">The grouping interval. The incoming events are grouped until there's a pause of the <paramref name="interval"/> length, and after that the outgoing event is fired. The interval must be not above <see cref="F:JetBrains.Threading.GroupingEvent.MaxInterval"/>.</param>
            <param name="action">Optional. The action for the outgoing event. This action will be executed on the primary thread and under the <see cref="T:JetBrains.Threading.ReentrancyGuard"/>. If you omit this action, advise the <see cref="P:JetBrains.Threading.GroupingEvent.Outgoing"/> event on the return value.</param>
            <returns>The event on which the incoming events can be fired. Must be disposed of.</returns>
        </member>
        <member name="M:JetBrains.Threading.IThreadingEx.QueueRecurring(JetBrains.Threading.IThreading,System.String,System.TimeSpan,System.Action)">
            <summary>
            <para>Queues the action to execute asynchronously on the <see cref="P:JetBrains.Threading.IThreading.Dispatcher">primary thread</see> in a <see cref="T:JetBrains.Threading.ReentrancyGuard">guarded context</see> at recurring intervals. Can be used on the primary thread only.</para>
            <para>Returns a token that cancels the recurring action execution. This token must be eventually disposed of.</para>
            <para>When the application gets inactive, the action is executed once, and then suspends until the application gets activated again.</para>
            <para>A <see cref="T:JetBrains.Threading.ReentrancyGuard"/> is preventing reentrancy between the actions.</para>
            </summary>
            <param name="thіs"></param>
            <param name="name">The name for the task.</param>
            <param name="action">The action to execute. Exceptions will be trapped.</param>
            <param name="interval">A non-negative time interval.</param>
        </member>
        <member name="M:JetBrains.Threading.IThreadingEx.QueueRecurring(JetBrains.Threading.IThreading,JetBrains.DataFlow.Lifetime,System.String,System.TimeSpan,System.Action)">
            <summary>
            <para>Queues the action to execute asynchronously on the <see cref="P:JetBrains.Threading.IThreading.Dispatcher">primary thread</see> in a <see cref="T:JetBrains.Threading.ReentrancyGuard">guarded context</see> at recurring intervals. Can be used on the primary thread only.</para>
            <para>Returns a token that cancels the recurring action execution. This token must be eventually disposed of.</para>
            <para>When the application gets inactive, the action is executed once, and then suspends until the application gets activated again.</para>
            <para>A <see cref="T:JetBrains.Threading.ReentrancyGuard"/> is preventing reentrancy between the actions.</para>
            </summary>
            <param name="thіs"></param>
            <param name="lifetime">Limiting lifetime. If the lifetime ends before the action is executed, the execution is canceled.</param>
            <param name="name">The name for the task.</param>
            <param name="action">The action to execute. Exceptions will be trapped.</param>
            <param name="interval">A non-negative time interval.</param>
        </member>
        <member name="M:JetBrains.Threading.IThreadingEx.ExecuteOrQueueWhenNotGuarded(JetBrains.Threading.IThreading,JetBrains.DataFlow.Lifetime,System.String,System.Action)">
            <summary>
            Executes the activity at the moment when there's no <see cref="T:JetBrains.Threading.ReentrancyGuard"/> running.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.IThreadingEx.AssertMainThread(JetBrains.Threading.IThreading)">
            <summary>
            Throw an exception if calling thread is not associated with threading's dispatcher.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Threading.Tasks.JetDispatcherTaskScheduler">
            <summary>
            Allows to schedule async tasks execution on a Dispatcher thread.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Threading.Tasks.ReentrancyGuardTaskScheduler">
            <summary>
            Allows to schedule async tasks execution on the Reentrancy Guard.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.ReentrancyGuardTaskScheduler.#ctor(JetBrains.Threading.ReentrancyGuard,JetBrains.Application.Threading.ContentModelReadWriteLock)">
            <summary>
            Sets up the scheduler for the given guard.
            </summary>
            <param name="guard">The guard instance, also defines the target STA thread.</param>
            <param name="rwlocks">Optional. Takes reader lock on with the given object, if supplied.</param>
        </member>
        <member name="T:JetBrains.Application.CommandProcessing.ICommandProcessor">
            <summary>
            Command processor that performs undoable actions.
            </summary>
        </member>
        <member name="P:JetBrains.Application.CommandProcessing.ICommandProcessor.IsExecutingCommand">
            <summary>
            Gets whether the command processor is executing at least one command.
            </summary>
        </member>
        <member name="P:JetBrains.Application.CommandProcessing.ICommandProcessor.CurrentCommand">
            <summary>
            The outermost command of the command processor. Opening nested commands does not affect this property.
            </summary>
        </member>
        <member name="P:JetBrains.Application.CommandProcessing.ICommandProcessor.CurrentBatchChangeName">
            <summary>
            If in a batch change (<see cref="M:JetBrains.Application.CommandProcessing.ICommandProcessor.BeginBatchTextChange(JetBrains.DataFlow.Lifetime,System.String)"/>), bears the batch change name. Otherwise, <c>Null</c>.
            </summary>
        </member>
        <member name="F:JetBrains.Application.CommandProcessing.StandaloneCommandProcessor.myCurrentBatchChangeName">
            <summary>
            If in a batch change (<see cref="M:JetBrains.Application.CommandProcessing.ICommandProcessor.BeginBatchTextChange(JetBrains.DataFlow.Lifetime,System.String)"/>), bears the batch change name. Otherwise, <c>Null</c>.
            </summary>
        </member>
        <member name="P:JetBrains.Application.CommandProcessing.StandaloneCommandProcessor.JetBrains#Application#CommandProcessing#ICommandProcessor#CurrentBatchChangeName">
            <summary>
            If in a batch change (<see cref="M:JetBrains.Application.CommandProcessing.ICommandProcessor.BeginBatchTextChange(JetBrains.DataFlow.Lifetime,System.String)"/>), bears the batch change name. Otherwise, <c>Null</c>.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Environment.Components.IAnyProductSettingsLocation.GetSettingsRelativePath(JetBrains.Application.BuildScript.ApplicationHostDetails)">
            <summary>
            Gets the suffix that forms the <see cref="M:JetBrains.Application.Environment.Components.AnyProductSettingsLocation.GetSettingsRegistryKey(JetBrains.Application.BuildScript.ApplicationHostDetails)"/>, <see cref="M:JetBrains.Application.Environment.Components.AnyProductSettingsLocation.GetUserSettingsDir(JetBrains.Application.BuildScript.HostFolderLifetime,JetBrains.Application.BuildScript.ApplicationHostDetails)"/>.
            The template must not include location-specific parts (ie “Software” for registry or “AppData” for folder), as they should be concatenated by consumers.
            There should be no leading or trailing slashes.
            </summary>
            <param name="details"></param>
        </member>
        <member name="M:JetBrains.Application.Environment.Components.IAnyProductSettingsLocation.GetSettingsRegistryKey(JetBrains.Application.BuildScript.ApplicationHostDetails)">
            <summary>
            Gets the path to the product's Registry key.
            </summary>
            <param name="detail"></param>
        </member>
        <member name="M:JetBrains.Application.Environment.Components.IAnyProductSettingsLocation.GetUserSettingsDir(JetBrains.Application.BuildScript.HostFolderLifetime,JetBrains.Application.BuildScript.ApplicationHostDetails)">
            <summary>
            Gets the location of the settings folders used by the product (product-specific or not).
            Creates the directory if missing.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Environment.Components.IAnyProductSettingsLocation.GetSettingsPathSuffix(System.String,System.Version,System.Collections.Generic.IList{JetBrains.Util.JetTuple{System.String,System.String}})">
            <summary>
            The main implementation method for getting the settings directories for all products, per-product, product-specific, etc.
            </summary>
            <param name="nameProduct">Product short name, if the settings should be per-product. <c>NULL</c> or <c>""</c> for all-product settings location.</param>
            <param name="version">
            <para>If non-<c>NULL</c> and <paramref name="nameProduct"/> is specified, produces version-specific product settings.</para>
            <para>If non-<c>NULL</c> and <paramref name="nameProduct"/> is not specified, produces versioned all-products settings location.</para>
            <para>If <c>NULL</c>, produces version-invariant location (either all-products or product-specific).</para>
            </param>
            <param name="additionalParameters">
            <para>Allows to further differentiate locations by product or environment flavors, for example Visual Studio hives, as used to be up to R# 5.</para>
            <para>Each pair in the list is the name and the value of the additional parameter. Visual Studio 9.0 specific folder for the main Visual Studio hive has it as <c>("vs", "9.0")</c>.</para>
            <para>A subfolder will be created for every additional parameter, in the exact order as they're given here.</para>
            <para><c>NULL</c> or an empty list means there're no additional parameters.</para>
            <para>In this class, the default value for additional parameters is provided by the <see cref="!:GetSettingsPathSuffixAdditionalParameters"/> function (overridden by specific environments, like Visual Studio).</para>
            </param>
            <returns>Relative path to the directory (might not exist yet) from <c>%APPDATA%</c>, Registry <c>Software</c> key, etc.</returns>
            <remarks>
            <para>General rules for forming the suffix:</para>
            <para>• Folder with the company name. Always present.</para>
            <para>• Folder for the product, or the special “All Products” folder name (<see cref="F:JetBrains.Application.Environment.Components.AnyProductSettingsLocation.AllProductsFolderName"/>) if getting an all-products location.</para>
            <para>• Folder for the version (as “v”{Major}{Minor}), or the special v∀ string (<see cref="F:JetBrains.Application.Environment.Components.AnyProductSettingsLocation.AnyVersionString"/>) if getting an all-versions location.</para>
            <para>• One folder per each additional parameter (parameter name and value concatenated).</para>
            <para>The overall scheme looks like this: <c>{CompanyName}/{ProductName}/v{Version}[/vs{VsVersion}{VsRootSuffix}]</c>.</para>
            </remarks>
        </member>
        <member name="T:JetBrains.Application.Environment.Components.AnyProductSettingsLocation">
            <summary>
            Component for providing environment-defined settings location of products (VS, non-VS, etc).
            </summary>
        </member>
        <member name="M:JetBrains.Application.Environment.Components.AnyProductSettingsLocation.GetSettingsRelativePath(JetBrains.Application.BuildScript.ApplicationHostDetails)">
            <summary>
            Gets the suffix that forms the <see cref="M:JetBrains.Application.Environment.Components.AnyProductSettingsLocation.GetSettingsRegistryKey(JetBrains.Application.BuildScript.ApplicationHostDetails)"/>, <see cref="M:JetBrains.Application.Environment.Components.AnyProductSettingsLocation.GetUserSettingsDir(JetBrains.Application.BuildScript.HostFolderLifetime,JetBrains.Application.BuildScript.ApplicationHostDetails)"/>.
            The template must not include location-specific parts (ie “Software” for registry or “AppData” for folder), as they should be concatenated by consumers.
            There should be no leading or trailing slashes.
            </summary>
            <param name="details"></param>
        </member>
        <member name="M:JetBrains.Application.Environment.Components.AnyProductSettingsLocation.GetSettingsRegistryKey(JetBrains.Application.BuildScript.ApplicationHostDetails)">
            <summary>
            Gets the path to the product's Registry key.
            </summary>
            <param name="detail"></param>
        </member>
        <member name="F:JetBrains.Application.Environment.Components.AnyProductSettingsLocation.ProductRegistryKeyPrefix_Software">
            <summary>
            Registry prefix which forms the Registry key when combined with the <see cref="M:JetBrains.Application.Environment.Components.AnyProductSettingsLocation.GetSettingsPathSuffix(System.String,System.Version,System.Collections.Generic.IList{JetBrains.Util.JetTuple{System.String,System.String}})"/> suffix.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Environment.Components.AnyProductSettingsLocation.GetUserSettingsDir(JetBrains.Application.BuildScript.HostFolderLifetime,JetBrains.Application.BuildScript.ApplicationHostDetails)">
            <summary>
            Gets the location of the settings folders used by the product (product-specific or not).
            Creates the directory if missing.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Environment.Components.AnyProductSettingsLocation.GetSettingsPathSuffix(System.String,System.Version,System.Collections.Generic.IList{JetBrains.Util.JetTuple{System.String,System.String}})">
            <summary>
            The main implementation method for getting the settings directories for all products, per-product, product-specific, etc.
            </summary>
            <param name="nameProduct">Product short name, if the settings should be per-product. <c>NULL</c> or <c>""</c> for all-product settings location.</param>
            <param name="version">
            <para>If non-<c>NULL</c> and <paramref name="nameProduct"/> is specified, produces version-specific product settings.</para>
            <para>If non-<c>NULL</c> and <paramref name="nameProduct"/> is not specified, produces versioned all-products settings location.</para>
            <para>If <c>NULL</c>, produces version-invariant location (either all-products or product-specific).</para>
            </param>
            <param name="additionalParameters">
            <para>Allows to further differentiate locations by product or environment flavors, for example Visual Studio hives, as used to be up to R# 5.</para>
            <para>Each pair in the list is the name and the value of the additional parameter. Visual Studio 9.0 specific folder for the main Visual Studio hive has it as <c>("vs", "9.0")</c>.</para>
            <para>A subfolder will be created for every additional parameter, in the exact order as they're given here.</para>
            <para><c>NULL</c> or an empty list means there're no additional parameters.</para>
            <para>In this class, the default value for additional parameters is provided by the <see cref="!:GetSettingsPathSuffixAdditionalParameters"/> function (overridden by specific environments, like Visual Studio).</para>
            </param>
            <returns>Relative path to the directory (might not exist yet) from <c>%APPDATA%</c>, Registry <c>Software</c> key, etc.</returns>
            <remarks>
            <para>General rules for forming the suffix:</para>
            <para>• Folder with the company name. Always present.</para>
            <para>• Folder for the product, or the special “All Products” folder name (<see cref="F:JetBrains.Application.Environment.Components.AnyProductSettingsLocation.AllProductsFolderName"/>) if getting an all-products location.</para>
            <para>• Folder for the version (as “v”{Major}{Minor}), or the special v∀ string (<see cref="F:JetBrains.Application.Environment.Components.AnyProductSettingsLocation.AnyVersionString"/>) if getting an all-versions location.</para>
            <para>• One folder per each additional parameter (parameter name and value concatenated).</para>
            <para>The overall scheme looks like this: <c>{CompanyName}/{ProductName}/v{Version}[/vs{VsVersion}{VsRootSuffix}]</c>.</para>
            </remarks>
        </member>
        <member name="F:JetBrains.Application.Environment.Components.AnyProductSettingsLocation.AllProductsFolderName">
            <summary>
            When making an all-products folder location (e.g. with <see cref="M:JetBrains.Application.Environment.Components.AnyProductSettingsLocation.GetSettingsPathSuffix(System.String,System.Version,System.Collections.Generic.IList{JetBrains.Util.JetTuple{System.String,System.String}})"/>), used in place of the product name.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Environment.Components.AnyProductSettingsLocation.AnyVersionString">
            <summary>
            Used in place of the version-named folder when getting a version-invariant location (e.g. with <see cref="M:JetBrains.Application.Environment.Components.AnyProductSettingsLocation.GetSettingsPathSuffix(System.String,System.Version,System.Collections.Generic.IList{JetBrains.Util.JetTuple{System.String,System.String}})"/>).
            </summary>
        </member>
        <member name="M:JetBrains.Application.Environment.Components.AnyProductSettingsLocation.GetLegacyUserSettingsRoamingLegacyDirs(System.String)">
            <summary>
            Gets the list of legacy user-settings dirs (coming from previous product version), actually found on the local system, sorted in descending priority order.
            That means something like R# v2.5, which was in use even before platform v5 and compatibles, so it's double-legacy by now.
            The second part of the tuple is the product version of the legacy settings file.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Environment.Components.AnyProductSettingsLocation.GetLegacyUserSettingsXmlPath(JetBrains.Application.IApplicationHost)">
            <summary>
            Full path to the User Settings (<see cref="F:JetBrains.Application.Configuration.XmlExternalizationScope.UserSettings"/>) XML file we save. Platform v5 and below.
            Overridden in some of the DotTrace subproducts.
            </summary>
            <param name="product"></param>
        </member>
        <member name="M:JetBrains.Application.Environment.Components.AnyProductSettingsLocation.GetLegacyWorkspaceXmlPath(JetBrains.Application.IApplicationHost)">
            <summary>
            Full path to the Workspace Settings (<see cref="F:JetBrains.Application.Configuration.XmlExternalizationScope.WorkspaceSettings"/>) XML file we save.
            Overridden in some of the DotTrace subproducts.
            </summary>
            <param name="product"></param>
        </member>
        <member name="M:JetBrains.Application.Environment.Components.AnyProductSettingsLocation.GetInstallDir(JetBrains.Application.IApplicationHost)">
            <summary>
            Gets the directory in which the product assemblies are located.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Communication.InternetSettings">
            <summary>
            A settings node under <see cref="T:JetBrains.Application.Settings.EnvironmentSettings"/>. Root for internet-related settings.
            </summary>
        </member>
        <member name="T:JetBrains.Application.ComposeVerdictWithPriority">
            <summary>
            Has a list of tellers ordered by priority. Polls them for a verdict (live) until one of them returns a negative value. Determines whether all of the tellers have a positive verdict, or which is the one and only negative verdict.
            </summary>
        </member>
        <member name="M:JetBrains.Application.ComposeVerdictWithPriority.Create``1(JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.CollectionEvents{JetBrains.Application.ComposeVerdictWithPriority.VerdictTeller{``0}})">
            <summary>
            Takes a list of tellers ordered by priority. Polls them for a verdict (live) until one of them returns a negative value. Determines whether all of the tellers have a positive verdict, or which is the one and only negative verdict.
            Returns a property which is either <c>Null</c> when there're no tellers with a negative verdict, or contains the one and only negative verdict (remaining tellers are not polled when a negative verdict is encountered).
            </summary>
        </member>
        <member name="M:JetBrains.Application.ComposeVerdictWithPriority.UpdateActiveTellers``1(JetBrains.DataFlow.Lifetime,System.Collections.Generic.List{JetBrains.Application.ComposeVerdictWithPriority.ActiveTeller{``0}},JetBrains.DataFlow.IProperty{``0})">
            <summary>
            Apply invariants to the active state of the tellers, then update the property.
            </summary>
            <param name="lifetimeComponent"></param>
            <param name="tellers"></param>
            <param name="propComposite"></param>
        </member>
        <member name="T:JetBrains.Application.IProductCommandLine">
            <summary>
            Command line of the product. Usually created over the host command line, whose keys are then stripped of the prefix identifying the product.
            </summary>
        </member>
        <member name="P:JetBrains.Application.ICommandLine.Keys">
            <summary>
            Array of defined keys: “/Key[=Value]”.
            </summary> 
        </member>
        <member name="P:JetBrains.Application.ICommandLine.NonKeyedParameters">
            <summary>
            Strings that do not start with “/” and do not belong to the previous string with a “/”.
            </summary> 
        </member>
        <member name="P:JetBrains.Application.ICommandLine.Parameters">
            <summary>
            <para>Gets all of the command line parameters, <see cref="P:JetBrains.Application.ICommandLine.Keys"/> and <see cref="P:JetBrains.Application.ICommandLine.NonKeyedParameters"/> together, in order of appearance.</para>
            <para>If a standalone application implements the singleton mode, command line parameters from attempted new instances get added to this list of the original instance.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Application.ICommandLine.StartupDirectory">
            <summary>
            The startup directory of the application. Can be used to restore full paths from relative paths passed to the command line parameters.
            // TODO: handle the case when sending cmdline keys to the second instance of the application.
            </summary>
            <remarks>
            You should not be using <see cref="M:JetBrains.Util.FileSystemUtil.GetCurrentDirectory"/> (or even worse <see cref="!:Environment.CurrentDirectory"/> for that task because the current directory of the process might change at runtime (e.g. by open-file-dialog), and the command line arguments should always be interpreted against the current directory at the time the process were started.
            </remarks>
        </member>
        <member name="M:JetBrains.Application.IProductCommandLine.MakeFullCommandLineKeyName(System.String)">
            <summary>
            <para>Gets the string to be passed on the command line to this host so that the command line of this product would have the key named <paramref name="sShortKeyName"/> defined.</para>
            <para>If this product is not the default product of the host, the product name will be added to the short key name (to distinguish between keys addressed to different products). The environment (for example, Visual Studio non-default hive) might also add decorations to the key name.</para>
            <para>For example, let's consider a key with short name of “<c>SelfDestruction</c>” that belongs to the product named “<c>Kalabash</c>”, currently running in a non-default Visual Studio hive with root suffix “<c>Exp</c>”. This method is given the short key name “<c>Kalabash</c>”, and yields the full ready-for-VS-command-line “<c>Kalabash.SelfDestruction.Exp</c>” key name.</para>
            <para>In non-VS or VS default hive, there is no root suffix. If the product is also the default product of the host (not applicable to VS), the resulting full name will just be the short key name.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Application.IProductCommandLine.KeyPrefix">
            <summary>
            Gets the prefix of the command line keys in the host command line.
            To parse the whole host command line into the command lines for each of the products, they're filtered by the prefix (usually, <c>"ProductName."</c>), and the prefix is removed from keys.
            </summary>
        </member>
        <member name="P:JetBrains.Application.IProductCommandLine.IsKeyPrefixOptional">
            <summary>
            If there's a default product in the host, its command line keys could optionally be specified without the <see cref="P:JetBrains.Application.IProductCommandLine.KeyPrefix"/>.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Environment.IJetHost">
            <summary>
            Represents the environment-specific host that can load our products and make them running.
            For example, there's a VS-host (single per products that share the same shell, ideally one per VS if versions are close), Tests host, etc.
            The host creates the shared environment, into which products can be loaded (by advertising <see cref="!:IApplicationDescriptor"/> to its known products list).
            </summary>
        </member>
        <member name="P:JetBrains.Application.Environment.IJetHost.Environment">
            <summary>
            The environment, which creates and hosts environment-level components.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Environment.Components.InternalModeProductZoneActivator">
            <summary>
            Provides environment config for internal/public modes.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Environment.IActivate`1">
            <summary>
              <para> Meta-interface defines zones which should be activated for shell container.</para>
              <para> Use with <see cref="T:JetBrains.Application.Environment.ZoneActivatorAttribute"/>.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Application.Environment.IActivate`1.ActivatorEnabled">
            <summary>
            Support for conditional activation.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Environment.Components.InternalModeProductZoneActivator.OverrideInternalModeOnNextStart">
            <summary>
            If assigned by somebody, explicitly specifies the internal mode for next shell start, regardless of the cmdline.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Environment.JetEnvironment">
            <summary>
            The instance of the application environment.
            The host application (VS, standalone exe, etc) creates one environment, then loads the products into it.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Environment.JetEnvironment.#ctor(JetBrains.DataFlow.Lifetime,JetBrains.Application.Environment.HostParameters.JetHostParametersCaller)">
            <summary>
            Creates the environment and defines its lifetime.
            </summary>
            <param name="lifetime"></param>
            <param name="host">Defines the environment to be created: the set of assemblies with components, the configuration, additional runtime components, stuff to be created before composing the env container, and so on.</param>
        </member>
        <member name="F:JetBrains.Application.Environment.JetEnvironment.ActiveEnvironmentZones">
            <summary>
            Configuration of this environment.
            Defined by the host when the environment is created.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Environment.JetEnvironment.Container">
            <summary>
            Gets the environment component container.
            It is fully composed upon leaving the class ctor, and until the lifetime ends.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Environment.JetEnvironment.EnvironmentPartCatalogSet">
            <summary>
            Catalog set for the environment components, as narrowed down from <see cref="F:JetBrains.Application.Environment.JetEnvironment.FullPartCatalogSet"/> by applying the environment configuration filter to the parts. Do not modify.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Environment.JetEnvironment.FullPartCatalogSet">
            <summary>
            The complete catalog set, as collected from the products currently known, plus their plugins and any parts introduced later. This is the origin of all the catalogsets in the component containers. It's not filtered yet, even by the environment.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Environment.JetEnvironment.CreateDontRun(JetBrains.DataFlow.Lifetime,JetBrains.Application.Environment.HostParameters.JetHostParameters)">
            <summary>
            A special method for non-continuous hosts, like the tests host, in which creation and destruction must be carried out on different stacks.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Environment.ProductCanBeStartedPriorityThresholds.EnvironmentReady">
            <summary>
            On this level, should check if the env is fully initialized for starting the product (and calling other checkers).
            Eg in VS this is when VS' Shell gets into the non-zombied state.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Environment.ProductCanBeStartedPriorityThresholds.UserSuspend">
            <summary>
            On this level, should check for any user-induced deactivations of the product.
            Eg in VS it's when user suspends a product.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Environment.ProductCanBeStartedPriorityThresholds.Licensing">
            <summary>
            On this level, check for a license.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Environment.Helpers.ProductConfigurationsEx.GetInternalMode(JetBrains.Application.Environment.RunsProducts.ProductConfigurations)">
            <summary>
            Gets whether Internal mode is present among product configurations.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Environment.Helpers.ProductConfigurationsEx.IsInternalMode(JetBrains.Application.Environment.RunsProducts.ProductConfigurations)">
            <summary>
            Gets whether Internal mode is present among product configurations.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Environment.Components.ProductSettingsLocation">
            <summary>
            Component for providing environment-defined settings location of products (VS, non-VS, etc).
            Specializes <see cref="T:JetBrains.Application.Environment.Components.AnyProductSettingsLocation"/> with a specific product.
            If you'd like to override the behavior in your product, you should rather override the utility class <see cref="T:JetBrains.Application.Environment.Components.AnyProductSettingsLocation"/>, because it provides impl for this class and some more.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Environment.Components.ProductSettingsLocation.GetUserSettingsNonRoamingDir(JetBrains.Application.BuildScript.ApplicationHostDetails)">
            <summary>
            Gets the full path to the computer-local per-user folder that stores the product settings.
            This folder should be used for storing large or easily-re-generated files, like type index caches.
            </summary>
            <param name="details"></param>
        </member>
        <member name="M:JetBrains.Application.Environment.Components.ProductSettingsLocation.GetUserSettingsRoamingDir(JetBrains.Application.BuildScript.ApplicationHostDetails)">
            <summary>
            Gets the full path to the network-roaming per-user folder that stores the product settings.
            This folder should be used for storing small and non-re-generatable files only.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Environment.Components.ProductSettingsLocation.GetProductRegistryKey(JetBrains.Application.BuildScript.ApplicationHostDetails)">
            <summary>
            Gets the path to the product's Registry key.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Environment.Components.ProductSettingsLocation.InstallDir">
            <summary>
            Gets the directory in which the product assemblies are located.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Environment.ReportsProductsAllowedToRun">
            <summary>
            For each given product, monitors its <see cref="T:JetBrains.Application.Environment.IProductCanBeStarted"/> validators, and reports to <see cref="T:JetBrains.Application.Environment.RunsProducts"/> when the product can be started.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Environment.ReportsProductsAllowedToRun.ProductCanBeStartedVerdict">
            <summary>
            Whether the product Shell is allowed to run right now (Success means it can be started or continue running; Failure means it cannot be started or has to be shut down if already running; Permanent means that a standalone host should also be terminated).
            </summary>
        </member>
        <member name="M:JetBrains.Application.Environment.ReportsProductsAllowedToRun.Init_ComposeProperty(JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.ICollectionEvents{JetBrains.Application.Environment.IProductCanBeStarted},JetBrains.Threading.IThreading)">
            <summary>
            Composes the state of all the <see cref="T:JetBrains.Application.Environment.IProductCanBeStarted"/>, by priority.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Environment.Components.ReportUnhandledExceptions">
            <summary>
            Catches as many unhandled exceptions as possible, reports them, and prevents them from crashing the whole environment.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Environment.RunningProducts">
            <summary>
            When the Shell container is started, allows to get it on the environment level.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Environment.RunsProducts">
            <summary>
            Watches if the product is allowed to run (<see cref="T:JetBrains.Application.Environment.ReportsProductsAllowedToRun"/>).
            If yes, starts the Shell container.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Environment.RunsProducts.FilterPartCatalogSetByModuleZones(JetBrains.DataFlow.Lifetime,JetBrains.Application.Catalogs.IPartCatalogSet,JetBrains.Application.Catalogs.IPartCatalogSet,System.Collections.Generic.JetHashSet{JetBrains.Application.BuildScript.Application.Zones.ZonePart},JetBrains.DataFlow.StandardPreconditions.ReadonlyToken)">
            <summary>
            Applies product configuration to narrow down the parts set in the catalog set. Live within the lifetime (applies to new catalogs in the set also).
            </summary>
        </member>
        <member name="M:JetBrains.Application.Environment.RunsProducts.RunProduct(JetBrains.DataFlow.Lifetime,JetBrains.Application.Environment.JetEnvironment,JetBrains.Application.Environment.JetEnvironmentZones,JetBrains.Application.Environment.RunningProducts,JetBrains.Application.Environment.ZoneUserPreferenceChecker,JetBrains.Application.Environment.TimebombZoneFilter,JetBrains.Application.Environment.ZoneLicenseChecker,JetBrains.Application.Components.IInitializationStrategyProvider,JetBrains.DataFlow.IProperty{System.Collections.Generic.ICollection{JetBrains.Application.BuildScript.Application.Zones.ZonePart}},JetBrains.Util.ILogger)">
            <summary>
            Runs the product. The lifetime start and end must be guarded &amp; locked.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Environment.RunsProducts.TimebombedZones">
            <summary>
            Gets the zones which would normally be running in Shell but have been suppressed by timebombing of their package, or dependency package, or because of timebombing of their activator's package.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Environment.RunsProducts.ProductConfigurations">
            <summary>
            Gives out the configurations the product is running in.
            Published as a product-specific component on the Shell-level.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Access.None">
            <summary>
            Worker component.
            Importing to other components not supported.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Access.PrimaryThread">
            <summary>
            Can be retrieved on the primary thread only.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Access.AnyThread">
            <summary>
            Can be retrieved on any thread.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Creation.PrimaryThread">
            <summary>
            Must be created on primary thread only.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Creation.AnyThread">
            <summary>
            Can be created on any thread (demand/deferred).
            </summary>
        </member>
        <member name="F:JetBrains.Application.Lifecycle.Container">
            <summary>
            Created ASAP (when composing container), destroyed when destroying container.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Lifecycle.DemandReclaimable">
            <summary>
            Created on-demand, could be reclaimed and re-created.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Lifecycle.OneCall">
            <summary>
            Created when someone needs it, can be destroyed right after use.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Lifecycle.Demand">
            <summary>
            Created on-demand, destroyed ALAP when destroying container.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Lifecycle.Deferred">
            <summary>
            Created automatically (or on demand), but a bit later, to save CPU on component startup; destroyed when destroying container. 
            Access threading policy must be same or narrower as creation threading policy.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Environment.Components.SuspendResume">
            <summary>
            Manages Suspend/Resume functionality for the product.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Environment.Components.SuspendResume.IsSuspended">
            <summary>
            Gets whether the product is currently in the suspended state.
            If you change the property value, or call one of the appropriate methods on this class, the product will be suspended or resumed.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Environment.Components.SuspendResume.Init_CommandLine(JetBrains.Application.IProductCommandLine)">
            <summary>
            Applies the command line key values to <see cref="F:JetBrains.Application.Environment.Components.SuspendResume.IsSuspended"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Environment.Components.SuspendResume.Init_Registry(JetBrains.DataFlow.Lifetime,JetBrains.Application.Environment.Components.ProductSettingsLocation)">
            <summary>
            Supports persisting the suspended state in the Registry.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Environment.Components.SuspendResume.CmdLineResume">
            <summary>
            The product gets into the resumed state on startup
            </summary>
        </member>
        <member name="F:JetBrains.Application.Environment.Components.SuspendResume.CmdLineResume.KeyName">
            <summary>
            Causes the package to start in the resumed stage.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Environment.Components.SuspendResume.CmdLineSuspend">
            <summary>
            The product gets into the suspended state on startup.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Environment.Components.SuspendResume.CmdLineSuspend.KeyName">
            <summary>
            Causes the package to start in the suspended stage.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Environment.Components.SuspendResumeProductCanBeStarted">
            <summary>
            Allows the product to start only if it's not suspended.
            </summary>
        </member>
        <member name="T:JetBrains.Application.ComponentModel.ShellFeaturePartsContainer">
            <summary>
            Container for getting ALL (not only leaf) applicable components
            </summary>
        </member>
        <member name="T:JetBrains.Application.Configuration.ISaveSettings">
            <summary>
            An interface for a component that has some settings and they should be saved whenever all of the application settings are being saved.
            // TODO: rework when we have a mature settings model.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Configuration.ISaveSettings.LoadSettings">
            <summary>
            <para>Tells the component container to reload the settings from the persistent media, deserialize them from the bag, and apply them to the components.</para>
            <para>If a particular component has not been initialized yet, it will be called for <see cref="!:IXmlExternalizable.ReadFromXml"/> / <see cref="M:JetBrains.Application.Configuration.IXmlUpgradable.UpgradeFromXml(System.Xml.XmlElement,System.Version)"/> before its <see cref="!:IComponent.Init"/>. Otherwise, those xml-related methods will be called on it for the second and so on time.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Application.Configuration.ISaveSettings.SaveSettings">
            <summary>
            <para>Tells the component container that it's about time to query the components of their settings, serialize them to the bag, and write that to the persistent media.</para>
            <para>You must make sure this method is called on component containers in the end of the session. The component container will never save settings on its own.</para>
            </summary>
        </member>
        <member name="T:JetBrains.Application.Configuration.IXmlConfigurable">
            <summary>
            The interface which is used to mark components as requiring initialization from configuration file which ships with the product.
            Used for components which have complex initial configuration which is better to keep in external files rather than in code.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Configuration.IXmlConfigurable.ConfigureFromXml(System.Xml.XmlElement)">
            <summary>
            Called on the component by the component container before its <see cref="!:IComponent.Init"/>
            and <see cref="!:IXmlExternalizable.ReadFromXml"/> to load the XML Configuration from the resource
            in the component implementation assembly, the name of the resource specified in the
            <see cref="T:JetBrains.Application.Configuration.XmlConfigurableAttribute"/> on the component implementation.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Configuration.IXmlReadable.ReadFromXml(System.Xml.XmlElement)">
            <summary>
            <para>This method is called on the component to populate it with default or loaded settings, unless the component implements <see cref="T:JetBrains.Application.Configuration.IXmlUpgradable"/> and returns <c>True</c> from its handler.</para>
            <para>The element is taken from the settings file, if available.</para>
            <para>If not, and there are settings files from the older versions, and the component does not implement <see cref="T:JetBrains.Application.Configuration.IXmlUpgradable"/>, this method is called with the old settings.</para>
            <para>Otherwise, this method is called with an empty element or a <c>Null</c> value.</para>
            <para>For the first time, this method is called right before component's init.</para>
            <para>The settings-reading protocol might be executed more than once thru the component lifetime.</para>
            </summary>
            <param name="element"></param>
        </member>
        <member name="M:JetBrains.Application.Configuration.IXmlWritable.WriteToXml(System.Xml.XmlElement)">
            <summary>
            Called when the component should serialize its settings into the XML presentation, for saving into the settings file.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Configuration.IXmlRegistrable">
            <summary>
            Interface for classes that support registration in Windows Registry
            </summary>
        </member>
        <member name="T:JetBrains.Application.Configuration.IXmlUpgradable">
            <summary>
            If a previous User Settings version is found, and the component implements this interface, it's called with this interface instead of the regular Externalizable.
            Otherwise, the old settings will be passed into the regular interface.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Configuration.IXmlUpgradable.UpgradeFromXml(System.Xml.XmlElement,System.Version)">
            <summary>
            <para>Called with component's settings taken from the older version of the settings file, for each of the <see cref="P:JetBrains.Application.Configuration.IXmlUpgradable.LegacyTagNames"/> (even if some of the handlers return <c>True</c>).</para>
            <para><see cref="!:IXmlExternalizable.ReadFromXml"/> will not be called if any of the calls returns <c>True</c>.</para>
            <para>The settings-reading protocol might be executed more than once thru the component lifetime.</para>
            </summary>
            <param name="element">An XML element with component settings, taken from the settings file.</param>
            <param name="version">Version of the product that supposedly produced the legacy settings file we're upgrading from, or an empty <see cref="T:System.Version"/> instance if those are not known.</param>
            <returns>Whether the component has upgraded. Its normal <see cref="!:IXmlExternalizable.ReadFromXml"/> will not be called if that is the case.</returns>
        </member>
        <member name="P:JetBrains.Application.Configuration.IXmlUpgradable.LegacyTagNames">
            <summary>
            Element names for the component under which it used to be known in the old settings files.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Configuration.SettingsComponentBase">
            <summary>
            A component container with XML serialization capabilities for the component settings.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Configuration.SettingsComponentBase.myXmlSettingsBag">
            <summary>
            This stores the settings after they're read from the storage and before they're loaded by the components, and before they're written back to the storage. 
            </summary>
        </member>
        <member name="F:JetBrains.Application.Configuration.SettingsComponentBase.myVersionUpgradingFrom">
            <summary>
            Whenever an older version of the settings file is found to be upgraded, set to the version of the product that supposedly produced that file.
            Otherwise, <c>Null</c>, which means that the upgrade should not be called.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Configuration.SettingsComponentBase.myXmlDocumentSettings">
            <summary>
            A dummy XML document for creating XML elements for component settings. When settings are deserialized, set to their XML document.
            It's not important which XmlDoc to use, we'd just like to minimize their number.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Configuration.SettingsComponentBase.OnLoadSettingsXmlBag(System.Action{System.Xml.XmlDocument,JetBrains.Application.Configuration.XmlExternalizationScope})">
            <summary>
            <para>Invoked by the base implementation when it's time to load the XML Settings Bag from the permanent storage. </para>
            <para>This logic (like, choosing the file) must be implemented by the inheritor. The inheritor might look for legacy settings files from previous versions if the normal settings file is missing and set <see cref="M:JetBrains.Application.Configuration.SettingsComponentBase.ShouldUpgradeSettings(System.Version)"/> to use them with <see cref="T:JetBrains.Application.Configuration.IXmlUpgradable"/> components.</para>
            <para>Call <see paramref="funcDeserializeXmlBag"/> to submit the XML representation of the settings for a particular scope (see <see cref="M:JetBrains.Application.Configuration.SettingsComponentBase.DeserializeXmlBag(System.Xml.XmlDocument,JetBrains.Application.Configuration.XmlExternalizationScope)"/> for details).</para>
            </summary>
        </member>
        <member name="M:JetBrains.Application.Configuration.SettingsComponentBase.ComponentReadFromXmlBag_TrySettingsElement(JetBrains.Application.Configuration.IXmlReadable,JetBrains.Application.Configuration.XmlExternalizationScope,System.String)">
            <summary>
            There were no upgrade, but there's a valid settings element, and it will be applied.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Configuration.SettingsComponentBase.ComponentReadFromXmlBag_TryUpgrade(JetBrains.Application.Configuration.IXmlReadable,JetBrains.Application.Configuration.XmlExternalizationScope)">
            <summary>
            If in upgrade mode, see for upgrade data for this component.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Configuration.SettingsComponentBase.DeserializeXmlBag(System.Xml.XmlDocument,JetBrains.Application.Configuration.XmlExternalizationScope)">
            <summary>
            Reads from an XML document and stores into the XML Bag.
            Collects the entries for the <see cref="F:JetBrains.Application.Configuration.SettingsComponentBase.myXmlSettingsBag"/> map from the <paramref name="document"/>.
            The scope is given by <paramref name="scope"/>, and the name comes from the XML tag names.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Configuration.SettingsComponentBase.LoadSettings(JetBrains.Application.Configuration.IXmlReadable,JetBrains.Application.Configuration.XmlExternalizationScope,System.String)">
            <summary>
            Overrides the base init-component to perform XML-related ops.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Configuration.SettingsComponentBase.LoadSettingsWithXmlExternalizationUtil(System.Object,JetBrains.Application.Configuration.XmlExternalizationScope,System.String)">
            <summary>
            Uses <see cref="M:JetBrains.Application.Configuration.XmlExternalizationUtil.ReadFromXml(System.Xml.XmlElement,System.Object)"/> and <see cref="M:JetBrains.Application.Configuration.XmlExternalizationUtil.WriteToXml(System.Xml.XmlElement,System.Object)"/> as the default implementation of <see cref="!:IXmlExternalizable"/> over <paramref name="target"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Configuration.SettingsComponentBase.Init">
            <returns>True if loaded anything, false otherwise </returns>
        </member>
        <member name="P:JetBrains.Application.Configuration.SettingsComponentBase.ValidXmlExternalizationScopes">
            <summary>
            Override this property to provide a list of scopes that are valid for components in this container.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Configuration.WorkspaceSettingsTable">
            <summary>
            Contains global settings of objects that do not have components to store settings in
            </summary>
        </member>
        <member name="P:JetBrains.Application.Configuration.SettingsTableBase.BoolProperties">
            <summary>
            Gets the boolean properties.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Configuration.SettingsTableBase.IntProperties">
            <summary>
            Gets the integer properties.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Configuration.SettingsTableBase.StringProperties">
            <summary>
            Gets the string properties.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Configuration.SettingsTableBase.PropertiesCollection`1">
            <summary>
            Represent the properties collection.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Configuration.SettingsTableBase.PropertiesCollection`1.Add(JetBrains.DataFlow.IProperty{`0})">
            <summary>
            Adds an item to the <see cref="T:System.Collections.Generic.ICollection`1"></see>.
            </summary>
            
            <param name="item">The object to add to the <see cref="T:System.Collections.Generic.ICollection`1"></see>.</param>
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1"></see> is read-only.</exception>
        </member>
        <member name="M:JetBrains.Application.Configuration.SettingsTableBase.PropertiesCollection`1.Clear">
            <summary>
            Removes all items from the <see cref="T:System.Collections.Generic.ICollection`1"></see>.
            </summary>
            
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1"></see> is read-only. </exception>
        </member>
        <member name="M:JetBrains.Application.Configuration.SettingsTableBase.PropertiesCollection`1.Contains(JetBrains.DataFlow.IProperty{`0})">
            <summary>
            Determines whether the <see cref="T:System.Collections.Generic.ICollection`1"></see> contains a specific value.
            </summary>
            
            <returns>
            true if item is found in the <see cref="T:System.Collections.Generic.ICollection`1"></see>; otherwise, false.
            </returns>
            
            <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.ICollection`1"></see>.</param>
        </member>
        <member name="M:JetBrains.Application.Configuration.SettingsTableBase.PropertiesCollection`1.CopyTo(JetBrains.DataFlow.IProperty{`0}[],System.Int32)">
            <summary>
            Copies the elements of the <see cref="T:System.Collections.Generic.ICollection`1"></see> to an <see cref="T:System.Array"></see>, starting at a particular <see cref="T:System.Array"></see> index.
            </summary>
            
            <param name="array">The one-dimensional <see cref="T:System.Array"></see> that is the destination of the elements copied from <see cref="T:System.Collections.Generic.ICollection`1"></see>. The <see cref="T:System.Array"></see> must have zero-based indexing.</param>
            <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">arrayIndex is less than 0.</exception>
            <exception cref="T:System.ArgumentNullException">array is null.</exception>
            <exception cref="T:System.ArgumentException">array is multidimensional.-or-arrayIndex is equal to or greater than the length of array.-or-The number of elements in the source <see cref="T:System.Collections.Generic.ICollection`1"></see> is greater than the available space from arrayIndex to the end of the destination array.-or-Type T cannot be cast automatically to the type of the destination array.</exception>
        </member>
        <member name="M:JetBrains.Application.Configuration.SettingsTableBase.PropertiesCollection`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            
            <returns>
            An <see cref="T:System.Collections.IEnumerator"></see> object that can be used to iterate through the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.Application.Configuration.SettingsTableBase.PropertiesCollection`1.Remove(JetBrains.DataFlow.IProperty{`0})">
            <summary>
            Removes the first occurrence of a specific object from the <see cref="T:System.Collections.Generic.ICollection`1"></see>.
            </summary>
            
            <returns>
            true if item was successfully removed from the <see cref="T:System.Collections.Generic.ICollection`1"></see>; otherwise, false. This method also returns false if item is not found in the original <see cref="T:System.Collections.Generic.ICollection`1"></see>.
            </returns>
            
            <param name="item">The object to remove from the <see cref="T:System.Collections.Generic.ICollection`1"></see>.</param>
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1"></see> is read-only.</exception>
        </member>
        <member name="M:JetBrains.Application.Configuration.SettingsTableBase.PropertiesCollection`1.System#Collections#Generic#IEnumerable{JetBrains#DataFlow#IProperty{TValue}}#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"></see> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:JetBrains.Application.Configuration.SettingsTableBase.PropertiesCollection`1.System#Collections#Generic#IEnumerable{System#Collections#Generic#KeyValuePair{System#String@JetBrains#DataFlow#IProperty{TValue}}}#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"></see> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="P:JetBrains.Application.Configuration.SettingsTableBase.PropertiesCollection`1.Item(System.String)">
            <summary>
            Gets a property by its name.
            Creates a new one if missing.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Configuration.SettingsTableBase.PropertiesCollection`1.Item(System.String,`0)">
            <summary>
            Gets a property by its name.
            Creates a new one if missing.
            The second parameter is the default value for the case the property does not yet exist.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Configuration.SettingsTableBase.PropertiesCollection`1.Count">
            <summary>
            Gets the number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1"></see>.
            </summary>
            
            <returns>
            The number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1"></see>.
            </returns>
            
        </member>
        <member name="P:JetBrains.Application.Configuration.SettingsTableBase.PropertiesCollection`1.IsReadOnly">
            <summary>
            Gets a value indicating whether the <see cref="T:System.Collections.Generic.ICollection`1"></see> is read-only.
            </summary>
            
            <returns>
            true if the <see cref="T:System.Collections.Generic.ICollection`1"></see> is read-only; otherwise, false.
            </returns>
            
        </member>
        <member name="T:JetBrains.Application.Configuration.XmlConfigurableAttribute">
            <summary>
            Allows to mark a type as XML Configurable. 
            Call to <see cref="M:JetBrains.Application.Configuration.XmlConfigurableHelper.InitializeComponent_XmlConfigurable(JetBrains.Application.Configuration.IXmlConfigurable)"/> to configure.  
            <see cref="M:JetBrains.Application.Configuration.IXmlConfigurable.ConfigureFromXml(System.Xml.XmlElement)"/> is used to fill instance with data.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Configuration.XmlConfigurableAttribute.#ctor(System.String)">
            <param name="configurationResourceName">
            Name of the embedded resource in either the component's assembly or the product's <see cref="!:IApplicationDescriptor.ConfigurationAssembly"/> that contains the XML to be passed into the component's <see cref="M:JetBrains.Application.Configuration.IXmlConfigurable.ConfigureFromXml(System.Xml.XmlElement)"/> before its <see cref="!:IComponent.Init"/>.
            </param>
        </member>
        <member name="P:JetBrains.Application.Configuration.XmlConfigurableAttribute.ConfigurationResourceName">
            <summary>
            Name of the embedded resource in either the component's assembly or the product's <see cref="!:IApplicationDescriptor.ConfigurationAssembly"/> that contains the XML to be passed into the component's <see cref="M:JetBrains.Application.Configuration.IXmlConfigurable.ConfigureFromXml(System.Xml.XmlElement)"/> before its <see cref="!:IComponent.Init"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Configuration.XmlConfigurableHelper.InitializeComponent_XmlConfigurable(JetBrains.Application.Configuration.IXmlConfigurable)">
            <summary>
            For an XML-configurable component, loads its config and applies to the component.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Configuration.XmlExternalizableAttribute">
            <summary>
            Use this attribute to mark those fields and properties of a class that should be serialized to XML.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Configuration.XmlExternalizableAttribute.DefaultValue">
            <summary>
            <para>The default value for this entry. You do not need to initialize the field itself in the inline initializer or the constructor. Instead, you MUST set this to the desired initial value, for serialization to work consistently.</para>
            <para>The possible values are:</para>
            <para>• <c>Null</c>,.which means the default value for the <see cref="T:System.Type"/> of the field (<c>Null</c> for reference types and zero memory for value types).</para>
            <para>• Some value of the same type as the <see cref="T:System.Type"/> of the field, or a value type convertible to it.</para>
            <para>• An invariant string representation of a value that cannot be presented inline in the attribute ctor. value of the same type as the <see cref="T:System.Type"/> of the field, or a value type convertible to it. The appropriate <see cref="T:System.ComponentModel.TypeConverter"/> is used for reading the value.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Application.Configuration.XmlExternalizableAttribute.SettingName">
            <summary>
            Use this property to specify settings name used in the xml, if different from the property (field) name.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Configuration.XmlExternalizableAttribute.UseXmlSerializer">
            <summary>
            Gets or sets whether the XML Serializer should be used for serializing the value of this field.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Configuration.XmlExternalizationScope">
            <summary>
            Defines the scopes for the externalizable components.
            The define the sets of isolated components that are serialized to separate storages.
            You may use one of the base values, or introduce your own ones as integers, as the string representations are never used.
            The scopes are normally not persisted, because they define a settings storage on serialization and are defined by the storage on deserialization.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Configuration.XmlExternalizationScope.Any">
            <summary>
            Don't return from components.
            Means that, when filtering, all the scopes should be allowed.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Configuration.XmlExternalizationScope.Local">
            <summary>
            Locally-stored settings of a project or a solution.
            They're not intended to be shared in the team or added to the SCC.
            Typically, they're persisted in a “.resharper.user” file.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Configuration.XmlExternalizationScope.Shared">
            <summary>
            Team-shared settings of a project or a solution.
            They're intended to be added to the SCC.
            Typically, they're persisted in a “.resharper” file.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Configuration.XmlExternalizationScope.UserSettings">
            <summary>
            User settings of the product.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Configuration.XmlExternalizationScope.WorkspaceSettings">
            <summary>
            Workspace settings of the product.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Configuration.GlobalSettingsTable">
            <summary>
            Contains global settings of objects that do not have components to store settings in
            </summary>
        </member>
        <member name="T:JetBrains.Application.Configuration.XmlExternalizationUtil">
            <summary>
            Utility class to externalize values of fields and properties of given instance via reflection.
            Helpful for implementing <see cref="T:JetBrains.Application.Configuration.IXmlReadable"/> and <see cref="T:JetBrains.Application.Configuration.IXmlWritable"/> interface.
            Values of all fields and properties marked with <see cref="T:JetBrains.Application.Configuration.XmlExternalizableAttribute"/> are saved/restored.
            The following value types are supported: <see cref="T:System.Boolean"/>, <see cref="T:System.Int32"/>, <see cref="T:System.Int64"/>, <see cref="T:System.String"/>, <see cref="T:System.Enum"/>s, <see cref="T:System.DateTime"/>s and one-dimensional arrays of the above types (as well as arrays of arrays).
            </summary>
        </member>
        <member name="F:JetBrains.Application.Configuration.XmlExternalizationUtil.XmlIsNullAttrName">
            <summary>
            Controls the element nullity in the new serialization behavior.
            New behavior: elements with non-empty content are not-null values, and IsNull attribute must be present on elements with empty content to tell apart Null and empty string serialization (or empty arrays).
            Old behavior: if the IsNull attr is missing on an empty-content element, a self-closed tag is considered Null, and an opening+closing pair is considered an empty string.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Configuration.XmlExternalizationUtil.XmlExternalizableElementName">
            <summary>
            Name of the root element of the settings we write.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Configuration.XmlExternalizationUtil.XmlStreamElementName">
            <summary>
            Name of the <see cref="M:JetBrains.Application.Configuration.XmlExternalizationUtil.WriteStreamToXml(System.Xml.XmlElement,System.Action{System.Xml.XmlWriter})"/> / <see cref="M:JetBrains.Application.Configuration.XmlExternalizationUtil.ReadStreamFromXml(System.Xml.XmlElement,System.Action{System.Xml.XmlReader})"/> root element.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Configuration.XmlExternalizationUtil.ApplyDefaults(System.Object)">
            <summary>
            Enumerates the XML-externalizable fields of the <paramref name="externalizable"/> object and sets them to the default values, if such are given in the <see cref="P:JetBrains.Application.Configuration.XmlExternalizableAttribute.DefaultValue"/> property.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Configuration.XmlExternalizationUtil.ApplyDefaults(System.Object,System.Object)">
            <summary>
            Enumerates the XML-externalizable fields of the <paramref name="externalizable"/> object and sets them to the default values, if such are given in the <see cref="P:JetBrains.Application.Configuration.XmlExternalizableAttribute.DefaultValue"/> property.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Configuration.XmlExternalizationUtil.ReadStreamElementsFromXml(System.Xml.XmlElement,System.Action{System.Xml.XmlReader})">
            <summary>
            XML Serial access to the CDATA element content.
            Called on each top-level element under the stream root element.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Configuration.XmlExternalizationUtil.ReadStreamFromXml(System.Xml.XmlElement,System.Action{System.Xml.XmlReader})">
            <summary>
            XML Serial access to the CDATA element content.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Configuration.XmlExternalizationUtil.WriteStreamToXml(System.Xml.XmlElement,System.Action{System.Xml.XmlWriter})">
            <summary>
            XML Serial access to the CDATA element content.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Configuration.XmlExternalizationUtil.GetExternalizableMembers(System.Object)">
            <summary>
            Gets the members supported for XML Externalization.
            That is, fields or properties with the <see cref="T:JetBrains.Application.Configuration.XmlExternalizableAttribute"/> attribute.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Configuration.XmlExternalizationUtil.ReadFromXml_FillMembersWithValues_Value(System.Xml.XmlReader,System.Type)">
            <summary>
            Reads a value from the reader, returns either that value of type <paramref name="type"/>, or <c>Null</c>.
            </summary>
            <param name="reader">XML Reader positioned at the element whose value should be parsed.</param>
            <param name="type">Expected value type.</param>
        </member>
        <member name="M:JetBrains.Application.Configuration.XmlExternalizationUtil.ReadFromXml_FillMembersWithValues_Value(System.Xml.XmlElement,System.Type)">
            <summary>
            Reads the value, returns it if available, or <see cref="F:System.Convert.DBNull"/> otherwise.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Configuration.XmlExternalizationUtil.ReadFromXml_FillMembersWithValues_ValueXmlSerializer(System.Xml.XmlReader,JetBrains.Application.Configuration.XmlExternalizationUtil.ExternalizableMember)">
            <summary>
            Value deserialization for the <see cref="P:JetBrains.Application.Configuration.XmlExternalizableAttribute.UseXmlSerializer"/> case.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Configuration.XmlExternalizationUtil.ExternalizableMember.GetMemberType">
            <summary>
            Gets the type of the member values.
            Supports fields and properties of a CLR and <see cref="T:JetBrains.DataFlow.IProperty`1"/> type.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Configuration.XmlExternalizationUtil.ExternalizableMember.GetMemberValue(System.Object)">
            <summary>
            Retrieves a value of the member.
            Supports fields and properties of a CLR and <see cref="T:JetBrains.DataFlow.IProperty`1"/> type.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Configuration.XmlExternalizationUtil.ExternalizableMember.GetMemberValueRaw">
            <summary>
            Retrieves a value of the member in a raw manner.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Configuration.XmlExternalizationUtil.ExternalizableMember.HasDefaultValue">
            <summary>
            Gets whether there's a default value specified for the member in its <see cref="P:JetBrains.Application.Configuration.XmlExternalizationUtil.ExternalizableMember.Attribute"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Configuration.XmlExternalizationUtil.ExternalizableMember.ParseDefaultValue">
            <summary>
            Analyses and parses the default value, as given by the <see cref="P:JetBrains.Application.Configuration.XmlExternalizationUtil.ExternalizableMember.Attribute"/>-&gt;<see cref="P:JetBrains.Application.Configuration.XmlExternalizableAttribute.DefaultValue"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Configuration.XmlExternalizationUtil.ExternalizableMember.SetMemberValue(System.Object,System.Object)">
            <summary>
            Assigns a value to the member.
            Supports fields and properties of a CLR and <see cref="T:JetBrains.DataFlow.IProperty`1"/> type.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Configuration.XmlExternalizationUtil.ExternalizableMember.SetMemberValueRaw(System.Object)">
            <summary>
            Sets the value of the member in a raw manner.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Configuration.XmlExternalizationUtil.ExternalizableMember.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />.
            </summary>
            <returns>
            true if the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />; otherwise, false.
            </returns>
            <param name="obj">The <see cref="T:System.Object" /> to compare with the current <see cref="T:System.Object" />. </param>
            <exception cref="T:System.NullReferenceException">The <paramref name="obj" /> parameter is null.</exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.Application.Configuration.XmlExternalizationUtil.ExternalizableMember.GetHashCode">
            <summary>
            Serves as a hash function for a particular type. 
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object" />.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.Application.Configuration.XmlExternalizationUtil.ExternalizableMember.CompareTo(JetBrains.Application.Configuration.XmlExternalizationUtil.ExternalizableMember)">
            <summary>
            Compares the current object with another object of the same type.
            </summary>
            <returns>
            A 32-bit signed integer that indicates the relative order of the objects being compared. The return value has the following meanings: Value Meaning Less than zero This object is less than the <paramref name="other" /> parameter.Zero This object is equal to <paramref name="other" />. Greater than zero This object is greater than <paramref name="other" />. 
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:JetBrains.Application.Configuration.XmlExternalizationUtil.ExternalizableMember.Equals(JetBrains.Application.Configuration.XmlExternalizationUtil.ExternalizableMember)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="P:JetBrains.Application.Configuration.XmlExternalizationUtil.ExternalizableMember.UserValue">
            <summary>
            The value read from the member, or the value to be written to the member. Temporary storage. Not operated by this class, read and written by external consumers.
            Initially, <see cref="F:System.Convert.DBNull"/>.
            </summary>
        </member>
        <member name="T:JetBrains.Application.DataContext.IDataConstant">
            <summary>
            Identifies a piece of data that could be requested from an <see cref="T:JetBrains.Application.DataContext.IDataContext"/>.
            </summary>
        </member>
        <member name="P:JetBrains.Application.DataContext.IDataConstant.Id">
            <summary>
            Gets the unique ID of this data constant instance.
            </summary>
        </member>
        <member name="P:JetBrains.Application.DataContext.IDataConstant.Type">
            <summary>
            Gets the type of the constant. Somewhen soon enough this is likely to become the identity of the constant.
            </summary>
        </member>
        <member name="M:JetBrains.Application.DataContext.DataConstant`1.ToString">
            <summary>
            Returns a <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </summary>
            
            <returns>
            A <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:JetBrains.Application.DataContext.DataContext">
            <summary>
            <para>The Action Manager's implementation of IDataContext.</para>
            <para>If you'd like to create your own data context, use one of the <see cref="T:JetBrains.Application.DataContext.DataContexts"/> methods (import <see cref="T:JetBrains.Application.DataContext.DataContexts"/>). With it, you can add any rules or constants on your own, and create the data context on a specific control or point, or without any local context (the default global context).</para>
            <para>In the rare case when you need entirely your own datacontext without standard data rules, implement <see cref="T:JetBrains.Application.DataContext.IDataContext"/> directly.</para>
            </summary>
        </member>
        <member name="T:JetBrains.Application.DataContext.IDataContext">
            <summary>
            The context, passed to Action.
            Must be used immediately ONLY, within the same <see cref="T:JetBrains.Threading.ReentrancyGuard"/> execution session.
            If you're deferring the execution, extract these parameters and store in your own structures.
            </summary>
        </member>
        <member name="F:JetBrains.Application.DataContext.DataContext.myDataConstantsInUse_Constant">
            <summary>
            Recursion prevention.
            </summary>
        </member>
        <member name="M:JetBrains.Application.DataContext.DataContext.#ctor(JetBrains.DataFlow.Lifetime,System.Collections.Generic.IEnumerable{JetBrains.Application.DataContext.IDataRule},JetBrains.Util.OneToListMap{JetBrains.Application.DataContext.IDataConstant,JetBrains.Application.DataContext.IDataRule})">
            <summary>
            <para>Creates the data context.</para>
            <para>If you'd like to create your own data context, use one of the <see cref="T:JetBrains.Application.DataContext.DataContexts"/> methods (import <see cref="T:JetBrains.Application.DataContext.DataContexts"/>). With it, you can add any rules or constants on your own, and create the data context on a specific control or point, or without any local context (the default global context).</para>
            <para>From all the rules lists (plain and pre-sorted), rules are picked first by priority, then (within the same priority, which is usually the case because nearly all the rules have the default priority) — first from the plain list in order of appearance, then from the sorted list. The precedence of the plain list comes from the fact that it's usually the context-specific one (from focused control or moused control etc), while the pre-sorted list is the global list of the Action Manager.</para>
            </summary>
            <param name="lifetime">Limiting lifetime.</param>
            <param name="datarulesPlain">Optional. The plain list of data rules for the context.</param>
            <param name="datarulesSorted">Optional. As Action Manager has a large persistent list of data rules, they're given in a way that they're pre-tossed by constant and pre-sorted by priority for each constant.</param>
        </member>
        <member name="F:JetBrains.Application.DataContext.DataContext.Thread">
            <summary>
            Thread affinity.
            </summary>
        </member>
        <member name="F:JetBrains.Application.DataContext.DataContext.myDebugInstanceId">
            <summary>
            For diagnostyx.
            </summary>
        </member>
        <member name="M:JetBrains.Application.DataContext.DataContext.CachedValues_ToDictionarySlow">
            <summary>
            For exception diag only, might be as slow as you'd like.
            </summary>
            <returns></returns>
        </member>
        <member name="F:JetBrains.Application.DataContext.DataContext.Evaluator.myDebugInstanceId">
            <summary>
            For diagnostyx.
            </summary>
        </member>
        <member name="F:JetBrains.Application.DataContext.DataContext.Evaluator.IsEmpty">
            <summary>
            Gets if there're no rules at all in this datacontext.
            </summary>
        </member>
        <member name="M:JetBrains.Application.DataContext.DataContext.Evaluator.#ctor(System.Collections.Generic.IEnumerable{JetBrains.Application.DataContext.IDataRule},JetBrains.Util.OneToListMap{JetBrains.Application.DataContext.IDataConstant,JetBrains.Application.DataContext.IDataRule},System.String)">
            <summary>
            From all the rules lists (plain and pre-sorted), rules are picked first by priority, then (within the same priority, which is usually the case because nearly all the rules have the default priority) — first from the plain list in order of appearance, then from the sorted list. The precedence of the plain list comes from the fact that it's usually the context-specific one (from focused control or moused control etc), while the pre-sorted list is the global list of the Action Manager.
            </summary>
            <param name="datarulesPlain">Optional. The plain list of data rules for the context.</param>
            <param name="datarulesSorted">Optional. As Action Manager has a large persistent list of data rules, they're given in a way that they're pre-tossed by constant and pre-sorted by priority for each constant.</param>
            <param name="debugInstanceId"></param>
        </member>
        <member name="M:JetBrains.Application.DataContext.DataContext.Evaluator.TryEvaluateDataRules(JetBrains.Application.DataContext.IDataConstant,JetBrains.Application.DataContext.IDataContext)">
            <summary>
            Tries to get the constant value by evaluating all of the data rules in both lists.
            </summary>
        </member>
        <member name="M:JetBrains.Application.DataContext.DataContexts.RegisterDataRule``1(JetBrains.DataFlow.Lifetime,System.String,JetBrains.Application.DataContext.DataConstant{``0},System.Func{JetBrains.Application.DataContext.IDataContext,``0})">
            <summary>
            Registers a data rule that will apply to data contexts created by this object.
            </summary>
            <typeparam name="TValue"></typeparam>
            <param name="lifetime"></param>
            <param name="name">Required for debugging data constant values inference. Allows to track the rule supplying the questionable constant value.</param>
            <param name="constant">The rule knows how to produce this constant out of some other constants or the environment.</param>
            <param name="FRule"></param>
        </member>
        <member name="M:JetBrains.Application.DataContext.DataContexts.RegisterDataRule(JetBrains.DataFlow.Lifetime,JetBrains.Application.DataContext.IDataRule)">
            <summary>
            Registers a data rule that will apply to data contexts created by this object.
            </summary>
            <param name="lifetime"></param>
            <param name="rule"></param>
        </member>
        <member name="M:JetBrains.Application.DataContext.DataContexts.CreateOnActiveControl(JetBrains.DataFlow.Lifetime,System.Collections.Generic.IEnumerable{JetBrains.Application.DataContext.IDataRule})">
            <summary>
            Gets the data context for executing the actions in the control that currently has user input focus.
            </summary>
            <param name="lifetime"></param>
            <param name="datarulesAdditional">Manually-supplied additional data rules. Takes precedence over any other data rules (of the same priority).</param>
        </member>
        <member name="M:JetBrains.Application.DataContext.DataContexts.CreateOnSelection(JetBrains.DataFlow.Lifetime,System.Collections.Generic.IEnumerable{JetBrains.Application.DataContext.IDataRule})">
            <summary>
            <para>Gets the data context for executing the actions based on the given data rules.</para>
            <para>Note that the focused control is not used for collecting data rules in this overload, but application-wide selection context (like VS selected hierarchy item as current project file, text control, document, etc) still contributes to the context.</para>
            <para>Registered data rules are also enabled with this context.</para>
            </summary>
            <param name="lifetime"></param>
            <param name="datarulesAdditional">Manually-supplied additional data rules. Takes precedence over any other data rules (of the same priority).</param>
        </member>
        <member name="M:JetBrains.Application.DataContext.DataContexts.CreateOnApplicationWideState(JetBrains.DataFlow.Lifetime,System.Collections.Generic.IEnumerable{JetBrains.Application.DataContext.IDataRule})">
            <summary>
            <para>Gets the data context for the current application-wide state.</para>
            <para>Note that the focused control is not used for collecting data rules in this overload, and application-wide selection context is not used either(like VS selected hierarchy item as current project file, text control, document, etc). Only application-wide state like currently opened solution takes effect.</para>
            <para>Registered data rules are also enabled with this context.</para>
            </summary>
            <param name="lifetime"></param>
            <param name="datarulesAdditional">Manually-supplied additional data rules. Takes precedence over any other data rules (of the same priority).</param>
        </member>
        <member name="M:JetBrains.Application.DataContext.DataContexts.CreateWithDataRules(JetBrains.DataFlow.Lifetime,System.Collections.Generic.IEnumerable{JetBrains.Application.DataContext.IDataRule})">
            <summary>
            <para>Gets the data context for executing the actions based on the given data rules.</para>
            <para>Note that no selection/application context is used for collecting data rules in this overload. Only transformation data rules should be applied.</para>
            <para>This method is different from creating a <see cref="T:JetBrains.Application.DataContext.DataContext"/> explicitly on these providers because <see cref="M:JetBrains.Application.DataContext.DataContexts.RegisterDataRule``1(JetBrains.DataFlow.Lifetime,System.String,JetBrains.Application.DataContext.DataConstant{``0},System.Func{JetBrains.Application.DataContext.IDataContext,``0})">registered data rules</see> are added to the data rules pool (with a lower priority than your manually-supplied list).</para>
            </summary>
            <param name="lifetime"></param>
            <param name="datarulesAdditional">Manually-supplied additional data rules. Takes precedence over any other data rules (of the same priority).</param>
        </member>
        <member name="M:JetBrains.Application.DataContext.DataContexts.CreateWithoutDataRules(JetBrains.DataFlow.Lifetime,System.Collections.Generic.IEnumerable{JetBrains.Application.DataContext.IDataRule})">
            <summary>
            Gets the data context for executing the actions based on the given data rules.
            Note that the focused control is not used for collecting data rules in this overload.
            The registered data rules are not taking part in this data context.
            </summary>
            <param name="lifetime"></param>
            <param name="datarulesAdditional">Manually-supplied additional data rules. Takes precedence over any other data rules (of the same priority).</param>
        </member>
        <member name="M:JetBrains.Application.DataContext.DataContexts.CreateAtScreenPoint(JetBrains.DataFlow.Lifetime,System.Windows.Point,System.Collections.Generic.IEnumerable{JetBrains.Application.DataContext.IDataRule})">
            <summary>
            Gets the data context for executing the actions in the given screen location.
            Basically, this is <see cref="M:JetBrains.Application.DataContext.DataContexts.CreateOnControl(JetBrains.DataFlow.Lifetime,JetBrains.UI.CrossFramework.EitherControl,System.Collections.Generic.IEnumerable{JetBrains.Application.DataContext.IDataRule})">the context for the UI control</see> at the given screen location.
            </summary>
            <param name="lifetime"></param>
            <param name="ptScreen">Point, in screen coordinates.</param>
            <param name="datarulesAdditional">Manually-supplied additional data rules. Takes precedence over any other data rules (of the same priority).</param>
        </member>
        <member name="M:JetBrains.Application.DataContext.DataContexts.CreateOnControl(JetBrains.DataFlow.Lifetime,JetBrains.UI.CrossFramework.EitherControl,System.Collections.Generic.IEnumerable{JetBrains.Application.DataContext.IDataRule})">
            <summary>
            Gets the data context for executing actions within the given control.
            </summary>
            <param name="lifetime"></param>
            <param name="control">The control of either kind.</param>
            <param name="datarulesAdditional">Manually-supplied additional data rules. Takes precedence over any other data rules (of the same priority).</param>
        </member>
        <member name="M:JetBrains.Application.DataContext.DataContexts.CloneWithAdditionalDataRules(JetBrains.DataFlow.Lifetime,JetBrains.Application.DataContext.IDataContext,System.Collections.Generic.IEnumerable{JetBrains.Application.DataContext.IDataRule})">
            <summary>
            Clones the existing data context and extends it with additional given data rules.    
            The registered data rules are not taking part in this data context.
            </summary>
            <param name="lifetime"></param>
            <param name="dataContext">Original data context</param>
            <param name="datarulesAdditional">Manually-supplied additional data rules. Takes precedence over any other data rules (of the same priority).</param>
        </member>
        <member name="P:JetBrains.Application.DataContext.DataContexts.FindDataRules">
            <summary>
            Exposes the aggregator of registered data rule finders.
            </summary>
        </member>
        <member name="P:JetBrains.Application.DataContext.DataContexts.Empty">
            <summary>
            A data context that knows no data constants at all.
            </summary>
        </member>
        <member name="F:JetBrains.Application.DataContext.DataConstants.ScreenPoint">
            <summary>
            A point, in screen coordinates.
            Available if the context has been created from a screen point: <see cref="M:JetBrains.Application.DataContext.DataContexts.CreateAtScreenPoint(JetBrains.DataFlow.Lifetime,System.Windows.Point,System.Collections.Generic.IEnumerable{JetBrains.Application.DataContext.IDataRule})"/> (or if published by some data provider).
            </summary>
        </member>
        <member name="F:JetBrains.Application.DataContext.DataConstants.CurrentSelectionContext">
            <summary>
            <para>Presence of this data constant in the data context means that you would like to refine the context to all the possibly known details of the current selection, like current document, file, text control, caret position in the text control, selected text, and so on.</para>
            <para>All of the data rules providing context info should be doing this in inference from this constant instead of supplying the data out of nothing.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.DataContext.DataConstants.ApplicationContext">
            <summary>
            <para>Presence of this data constant in the data context means that you would like to refine the context to the current global state of the application, which is more or less permanent and does not depend on selected window/document etc. Global features not bound to selection (like Memory Usage Indicator for instance) might be using this context for their actions and settings binding. In VS-based products, this normally includes the solution object, because a solution defines the VS context (and you must switch the state with an explicit Open/Close Solution Action to alter this context), but does not include projects because the current project changes with selection. In DotTrace with one-process-per-snapshot, this might be the snapshot.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.DataContext.DataConstants.ComponentContainerForFactoring">
            <summary>
            Gets the component container which is best for factoring object belonging to this context.
            </summary>
        </member>
        <member name="T:JetBrains.Application.DataContext.ExportFindDataRulesAttribute">
            <summary>
            Attribute for <see cref="T:JetBrains.Application.DataContext.IFindDataRules"/> impls.
            </summary>
        </member>
        <member name="F:JetBrains.Application.DataContext.ExportFindDataRulesAttribute.Priority">
            <summary>
            The higher the priority, the sooner the finder is asked (and can promote its own result in precedence of the others).
            </summary>
        </member>
        <member name="T:JetBrains.Application.DataContext.FindDataRules">
            <summary>
            Takes <see cref="T:JetBrains.Application.DataContext.IFindDataRules"/>, prioritizes, and runs queries on them.
            </summary>
        </member>
        <member name="M:JetBrains.Application.DataContext.IDataContextEx.ToPropertyBag(JetBrains.Application.DataContext.IDataContext,JetBrains.Application.DataContext.IDataConstant[])">
            <summary>
            Creates a new property bag with a snapshot of this data context.
            </summary>
        </member>
        <member name="M:JetBrains.Application.DataContext.IDataContextEx.GetRawData(JetBrains.Application.DataContext.IDataContext,JetBrains.Application.DataContext.IDataConstant)">
            <summary>
            Creates a new property bag with a snapshot of this data context.
            </summary>
        </member>
        <member name="M:JetBrains.Application.DataContext.IDataContextEx.ToPropertyId(JetBrains.Application.DataContext.IDataConstant)">
            <summary>
            Creates a property ID identified by a data constant.
            We convert it to a generic <see cref="T:JetBrains.Application.DataContext.DataConstant`1"/> type, and then instantiate <see cref="T:JetBrains.Application.DataContext.DataConstantPropertyId`1"/> for the same <c>T</c>.
            </summary>
        </member>
        <member name="M:JetBrains.Application.DataContext.IDataContextEx.ToPropertyId``1(JetBrains.Application.DataContext.DataConstant{``0})">
            <summary>
            Creates a property ID identified by a data constant.
            </summary>
        </member>
        <member name="T:JetBrains.Application.DataContext.IDataRuleProvider">
            <summary>
            The Windows Forms specific way of providing ui-context-spefific <see cref="T:JetBrains.Application.DataContext.IDataRule"/>s on UI controls.
            </summary>
        </member>
        <member name="T:JetBrains.Application.DataContext.IDataRule">
            <summary>
            A data rule that is the internal mechanism of the default <see cref="!:IActionManager"/>'s implementation of <see cref="T:JetBrains.Application.DataContext.IDataContext"/> for evaluating values of constants. When a constant is requested from the data context, it's evaluated transitively by a chain of rules where the first rule in the chain uses no inputs and just tells the value (e.g. current text control from the environment), and other rules transform it to get the desired data constant out of it (e.g. document from the current text control).
            </summary>
        </member>
        <member name="M:JetBrains.Application.DataContext.IDataRule.Evaluate(JetBrains.Application.DataContext.IDataContext)">
            <summary>
            Attempts to evaluate the data rule.
            </summary>
            <param name="context">The data context from which the data rule could optionally get any other constants to calculate the rule result upon.</param>
            <returns>
            <para>Returns the value if it could be calculated. The possible return values are:</para>
            <para>(1) A valid value, if the rule was evaluated successfully. No rules would be further evaluated. The value must be of type specified by <see cref="P:JetBrains.Application.DataContext.IDataRule.OutputType"/>.</para>
            <para>(2) A <c>Null</c> value if this rule has insufficient information for evaluation, such as a "text control selection from text control" when no text control could be taken from data context. The remaining rules will be evaluated in this case.</para>
            <para>(3) The <see cref="F:System.Reflection.Missing.Value">VT_ERROR/DISP_E_PARAMNOTFOUND</see> value, which means that the rule knows and understands this context and usually can produce a result, but right now (with current user selection etc) cannot yield a value. In this case rules with larger priority values will not be processed, and <c>Null</c> will be returned from the data context for this constant, unless some of the remaining rules of the same priority provides a value. Evaluation of the remaining rules of the same priority is not prevented because their relative order is not well defined.</para>
            </returns>
        </member>
        <member name="P:JetBrains.Application.DataContext.IDataRule.Name">
            <summary>
            Semantic name of the rule. Crucial for debugging data constants inference.
            </summary>
        </member>
        <member name="P:JetBrains.Application.DataContext.IDataRule.OutputType">
            <summary>
            The output type of the rule.
            </summary>
        </member>
        <member name="P:JetBrains.Application.DataContext.IDataRule.Priority">
            <summary>
            <para>The rule priority. The lower the priority, the earlier the rule gets chance to contribute. Evaluation stops after some rule yields a valid value.</para>
            <para>The order of execution for rules of the same priority is undefined in most cases. However, as rules are collected from UI context by bubbling out of the active our mouse-hit control, rules of the control closer to the bubbling origin would be preferred.</para>
            <para>See <see cref="T:JetBrains.Application.DataContext.DataRulePriorityClasses"/> for typical values. As you create a rule with <see cref="T:JetBrains.Application.DataContext.DataRule`1"/> class or one of the helper methods, it gets the default priority of <see cref="F:JetBrains.Application.DataContext.DataRulePriorityClasses.Default"/>.</para>
            </summary>
        </member>
        <member name="T:JetBrains.Application.DataContext.DataRule`1">
            <summary>
            The default data rule implementation with default priority.
            </summary>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:JetBrains.Application.DataContext.DataRule`1.#ctor(System.String,JetBrains.Application.DataContext.DataConstant{`0},`0)">
            <summary>
            Creates a constant data rule (no evaluation involved).
            </summary>
        </member>
        <member name="M:JetBrains.Application.DataContext.DataRule`1.#ctor(System.String,JetBrains.Application.DataContext.DataConstant{`0},System.Func{JetBrains.Application.DataContext.IDataContext,`0})">
            <summary>
            <para>Creates a data rule that evaluates a function, possibly requesting other constants from the data context transitively.</para>
            <para>Out of the <see cref="M:JetBrains.Application.DataContext.IDataRule.Evaluate(JetBrains.Application.DataContext.IDataContext)"/> return type variations supports <c>Null</c> and a meaningful value. For the usually-available-but-now-missing value, see another overload.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Application.DataContext.DataRule`1.#ctor(System.String,JetBrains.Application.DataContext.DataConstant{`0},System.Func{JetBrains.Application.DataContext.IDataContext,JetBrains.Util.JetTuple{`0,System.Boolean}})">
            <summary>
            <para>Creates a data rule that evaluates a function, possibly requesting other constants from the data context transitively.</para>
            <para>Unlike the other overload, supports all of the <see cref="M:JetBrains.Application.DataContext.IDataRule.Evaluate(JetBrains.Application.DataContext.IDataContext)"/> return type variations. The boolean in the tuple means whether the value would usually be available in this context. Your function could return the following tuple combinations:</para>
            <para>(1) {meaningful-value, True}: evaluation succeeded.</para>
            <para>(2) {Null, True}: evaluation recognized the context and usually would return smth, but right now there is no value available. See <see cref="M:JetBrains.Application.DataContext.IDataRule.Evaluate(JetBrains.Application.DataContext.IDataContext)"/> for further details.</para>
            <para>(3) {Null, False}: evaluation has no idea as of what to return. See <see cref="M:JetBrains.Application.DataContext.IDataRule.Evaluate(JetBrains.Application.DataContext.IDataContext)"/> for further details.</para>
            </summary>
        </member>
        <member name="T:JetBrains.Application.DataContext.DataRule`1.DesperateDataRule">
            <summary>
            The last-chance data rule to be called only even no other data rules for this constant could yield a result.
            </summary>
        </member>
        <member name="T:JetBrains.Application.DataContext.DataRules">
            <summary>
            Helper class for creating lists of data rules.
            </summary>
        </member>
        <member name="M:JetBrains.Application.DataContext.DataRules.AddRule``1(System.String,JetBrains.Application.DataContext.DataConstant{``0},System.Func{JetBrains.Application.DataContext.IDataContext,``0})">
            <summary>
            Starts a new list of data rules.
            </summary>
        </member>
        <member name="M:JetBrains.Application.DataContext.DataRules.AddRule``1(System.String,JetBrains.Application.DataContext.DataConstant{``0},``0)">
            <summary>
            Starts a new list of data rules.
            </summary>
        </member>
        <member name="M:JetBrains.Application.DataContext.DataRules.AddRule``1(System.Collections.Generic.IList{JetBrains.Application.DataContext.IDataRule},System.String,JetBrains.Application.DataContext.DataConstant{``0},System.Func{JetBrains.Application.DataContext.IDataContext,``0})">
            <summary>
            Adds another rule to the rules list. Modifies the original list. Fluent.
            </summary>
        </member>
        <member name="M:JetBrains.Application.DataContext.DataRules.AddRule``1(System.Collections.Generic.IList{JetBrains.Application.DataContext.IDataRule},System.String,JetBrains.Application.DataContext.DataConstant{``0},``0)">
            <summary>
            Adds another rule to the rules list. Modifies the original list. Fluent.
            </summary>
        </member>
        <member name="T:JetBrains.Application.DataContext.DataRulePriorityClasses">
            <summary>
            Sample priority classes for data rules.
            </summary>
        </member>
        <member name="F:JetBrains.Application.DataContext.DataRulePriorityClasses.Default">
            <summary>
            Default priority. Most of data rules be at this level.
            </summary>
        </member>
        <member name="F:JetBrains.Application.DataContext.DataRulePriorityClasses.Ambient">
            <summary>
            Ambient data rules taking context from the environment. For example, Visual Studio selected hierarchy item is turned into a project model element. Would not be called if any of the product rules are able to provide a value for the constant.
            </summary>
        </member>
        <member name="F:JetBrains.Application.DataContext.DataRulePriorityClasses.Desperate">
            <summary>
            Last-chance data rules providing an arguebly useful value in case it couldn't be inferred from normal rules or host environment. For example, if there're no declared elements available, use the project model element to expose it as a "declared path" to make it searchable etc.
            </summary>
        </member>
        <member name="T:JetBrains.Application.DataContext.AmbientSelectionDataRule`1">
            <summary>
            <para>Overrides the data rule priority to make it a last-chance-fallback to getting the current selection of the application environment (eg VS).</para>
            <para>This rule is only active when a Data Context with current selection is requested (<see cref="F:JetBrains.Application.DataContext.DataConstants.CurrentSelectionContext"/>) is present in the data context.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Application.DataContext.AmbientSelectionDataRule`1.#ctor(System.String,JetBrains.Application.DataContext.DataConstant{`0},System.Func{JetBrains.Application.DataContext.IDataContext,`0})">
            <summary>
            Overrides the data rule priority to make it a last-chance-fallback to application environment (eg VS).
            </summary>
            <param name="name">Rule name for rules inference problems diagnostics.</param>
            <param name="dataconstant">Output data constant of the rule.</param>
            <param name="FTryEvaluate">Rule function.</param>
        </member>
        <member name="T:JetBrains.Application.DataContext.AmbientSelectionMainThreadDataRule`1">
            <summary>
            <para>Overrides the data rule priority to make it a last-chance-fallback to getting the current selection of the application environment (eg VS).</para>
            <para>Is deactivated on background threads. Use this when calling into VS APIs which are primary-thread-only.</para>
            <para>This rule is only active when a Data Context with current selection is requested (<see cref="F:JetBrains.Application.DataContext.DataConstants.CurrentSelectionContext"/>) is present in the data context.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Application.DataContext.AmbientSelectionMainThreadDataRule`1.#ctor(System.String,JetBrains.Application.DataContext.DataConstant{`0},JetBrains.Threading.IThreading,System.Func{JetBrains.Application.DataContext.IDataContext,`0})">
            <summary>
            Overrides the data rule priority to make it a last-chance-fallback to application environment (eg VS).
            </summary>
            <param name="name">Rule name for rules inference problems diagnostics.</param>
            <param name="dataconstant">Output data constant of the rule.</param>
            <param name="mainthread">Identifies the main thread to which this rule affines.</param>
            <param name="FTryEvaluate">Rule function.</param>
        </member>
        <member name="T:JetBrains.Application.DataContext.AmbientApplicationDataRule`1">
            <summary>
            <para>Overrides the data rule priority to make it a last-chance-fallback to getting the non-selection-dependent state of the application environment (eg VS). See <see cref="F:JetBrains.Application.DataContext.DataConstants.ApplicationContext"/> for details.</para>
            <para>This rule is only active when a Data Context with current selection is requested (<see cref="F:JetBrains.Application.DataContext.DataConstants.ApplicationContext"/>) is present in the data context.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Application.DataContext.AmbientApplicationDataRule`1.#ctor(System.String,JetBrains.Application.DataContext.DataConstant{`0},System.Func{JetBrains.Application.DataContext.IDataContext,`0})">
            <summary>
            Overrides the data rule priority to make it a last-chance-fallback to application environment (eg VS).
            </summary>
            <param name="name">Rule name for rules inference problems diagnostics.</param>
            <param name="dataconstant">Output data constant of the rule.</param>
            <param name="FTryEvaluate">Rule function.</param>
        </member>
        <member name="T:JetBrains.Application.DataContext.AmbientApplicationOrSelectionDataRule`1">
            <summary>
            <para>Operates as a combination of <see cref="T:JetBrains.Application.DataContext.AmbientApplicationDataRule`1"/> and <see cref="T:JetBrains.Application.DataContext.AmbientSelectionDataRule`1"/>, which means that this rule is active when either selection or ambient information is requested (any of the <see cref="F:JetBrains.Application.DataContext.DataConstants.ApplicationContext"/> or <see cref="F:JetBrains.Application.DataContext.DataConstants.CurrentSelectionContext"/> constants is present). See documentation on the abovementioned rule kinds for details.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Application.DataContext.AmbientApplicationOrSelectionDataRule`1.#ctor(System.String,JetBrains.Application.DataContext.DataConstant{`0},System.Func{JetBrains.Application.DataContext.IDataContext,`0})">
            <summary>
            Overrides the data rule priority to make it a last-chance-fallback to application environment (eg VS).
            </summary>
            <param name="name">Rule name for rules inference problems diagnostics.</param>
            <param name="dataconstant">Output data constant of the rule.</param>
            <param name="FTryEvaluate">Rule function.</param>
        </member>
        <member name="T:JetBrains.Application.DataContext.IFindDataRules">
            <summary>
            An entity to look for an <see cref="T:JetBrains.Application.DataContext.IDataRuleProvider"/> based on the current cursor position or current UI control.
            </summary>
            <seealso cref="T:JetBrains.Application.DataContext.ExportFindDataRulesAttribute"/>.
        </member>
        <member name="M:JetBrains.Application.DataContext.IFindDataRules.FindActiveDataRules">
            <summary>
            Gets the data provider for the control that currently has user input focus.
            </summary>
        </member>
        <member name="M:JetBrains.Application.DataContext.IFindDataRules.FindDataRulesAtPoint(System.Windows.Point)">
            <summary>
            Gets the data provider for the control that is located at the given screen point.
            </summary>
        </member>
        <member name="M:JetBrains.Application.DataContext.IFindDataRules.FindDataRulesInControl(JetBrains.UI.CrossFramework.EitherControl)">
            <summary>
            Gets the data provider for the given control.
            </summary>
        </member>
        <member name="P:JetBrains.Application.ExceptionReport.ExceptionStorageLocator.StoresExceptions">
            <summary>
              Returns true if this storage is meant to store exceptions. Otherwise returns false.
            </summary>
        </member>
        <member name="T:JetBrains.Application.ExceptionReport.ManagedThreadNameExceptionReportDataProvider">
            <summary>
            Adds managed thread name to the submitted exception data.
            </summary>
        </member>
        <member name="M:JetBrains.Application.ExceptionReport.PersistableExceptionData.AddExternalDataLine(System.Exception,System.String)">
            <summary>
              Adds to the <see cref="P:JetBrains.Application.ExceptionReport.PersistableExceptionData.HeaderText"/> .
            </summary>
        </member>
        <member name="P:JetBrains.Application.ExceptionReport.PersistableExceptionData.HeaderText">
            <summary>
              Additional text in the header, just before the full stack traces of the exception. Might contain environmental info, build description, etc. Most of the technical data must be added to the exception data itself, with <see cref="M:JetBrains.Util.ExceptionEx.AddData``1(``0,System.String,System.Func{System.Object})"/> inside your implementation of <see cref="M:JetBrains.Application.ExceptionReport.IExceptionReportDataProvider.ProvideExceptionData(System.Exception)"/> . It will appear in the detailed stack traces among the data field of the outermost exception. If you'd like your data get into the header text, call <see cref="M:JetBrains.Application.ExceptionReport.PersistableExceptionData.AddExternalDataLine(System.Exception,System.String)"/> inside your implementation of <see cref="M:JetBrains.Application.ExceptionReport.IExceptionReportDataProvider.ProvideExceptionData(System.Exception)"/> . Use sparingly.
            </summary>
        </member>
        <member name="T:JetBrains.Application.ExceptionReport.SccRevisionExceptionReportDataProviderEnv">
            <summary>
              <para>Exposes the SCC revision of the codebase off which the host package was built. Lists packages which contain the activated env zones.</para>
              <para>The About Box has detailed info on all packages' revisions.</para>
            </summary>
        </member>
        <member name="T:JetBrains.Application.ExceptionReport.BuildDescriptionExceptionReportDataProvider">
            <summary>
            Product configurations (includes env, CLR, edition, internal mode, etc).
            </summary>
        </member>
        <member name="T:JetBrains.Application.CommandLineParameter">
            <summary>
            One parsed parameter of the command line.
            </summary>
        </member>
        <member name="F:JetBrains.Application.CommandLineParameter.Key">
            <summary>
            The key to the command line parameter. <c>Null</c> or <c>""</c> on a non-keyed parameter.
            </summary>
        </member>
        <member name="F:JetBrains.Application.CommandLineParameter.Value">
            <summary>
            The command line parameter value. <c>Null</c> or <c>""</c> on a command line key without a value.
            </summary>
        </member>
        <member name="T:JetBrains.Application.IHostCommandLine">
            <summary>
            Command line of the host, which includes both product-shared keys and all keys that belong to each product.
            In VS, created over the VS command line object. In standalone, created over a string array.
            </summary>
        </member>
        <member name="M:JetBrains.Application.IHostCommandLine.MakeFullCommandLineKeyName(System.String)">
            <summary>
              <para>Gets the string to be passed on the command line to this host so that the product-specific command lines would get <paramref name="sKeyWithProductDecoration"/> for parsing.</para>
              <para>For calling from <see cref="T:JetBrains.Application.IProductCommandLine"/>s to serve their <see cref="M:JetBrains.Application.IProductCommandLine.MakeFullCommandLineKeyName(System.String)"/> requests.</para>
              <para>For example, let's consider a non-default Visual Studio hive with root suffix “<c>Exp</c>”, a key with short name of “<c>SelfDestruction</c>”, for the product named “<c>Kalabash</c>”. This method is given the product-decorated “<c>Kalabash.SelfDestruction</c>” key name (formed from the short name by some <see cref="T:JetBrains.Application.IProductCommandLine"/>), and yields the full ready-for-VS-command-line “<c>Kalabash.SelfDestruction.Exp</c>” key name.</para>
              <para>In non-VS or VS default hive, returns the original string. If the product is also the default product of the host (not applicable to VS), the resulting full name will just be the short key name.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Application.IHostCommandLine.IsProductDecorationRequiredOnKeys">
            <summary>
            See doc on <see cref="M:JetBrains.Application.IHostCommandLine.MakeFullCommandLineKeyName(System.String)"/>. <c>True</c> in VS, <c>False</c> otherwise.
            </summary>
        </member>
        <member name="M:JetBrains.Application.IHostCommandLineEx.IsKeyDefinedInAnyProduct(JetBrains.Application.IHostCommandLine,System.String,System.Boolean)">
            <summary>
            Checks if the key is defined in any product loaded in this host.
            </summary>
        </member>
        <member name="T:JetBrains.Application.ProductCommandLine">
            <summary>
            Implements the command line of the product over a host command line.
            Selects those keys that have the prefix of a specific product (or no prefix at all, for host-default product).
            </summary>
        </member>
        <member name="M:JetBrains.Application.ProductCommandLine.#ctor(JetBrains.DataFlow.Lifetime,JetBrains.Application.IHostCommandLine,System.String,System.Boolean)">
            <summary>
            Init.
            </summary>
            <param name="lifetime"> </param>
            <param name="cmdlHost">Host command line to filter and strip key names.</param>
            <param name="sProductPrefix">Prefix of the product (dot not included). Keys with this prefix (followed by a dot) are attributed to the current product and given out. Case-sensitivity flags of the command line request also applies to the prefix.</param>
            <param name="isKeyPrefixOptional">If the host has a default product, then keys without prefix are also attributed to that product. An example is a standalone application (eg DotTrace).</param>
        </member>
        <member name="T:JetBrains.Application.Install.InstallationData.InstalledFileAccessControl">
            <summary>
            <para>Allows to modify ACLs when installing a file.</para>
            <para>This info is written to <see cref="F:JetBrains.Application.Install.InstallationData.InstalledFile.Metadata"/> field on an <see cref="T:JetBrains.Application.Install.InstallationData.InstalledFile"/>.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Install.InstallationData.InstalledFileAccessControl.AccessControl">
            <summary>
            <see cref="F:JetBrains.Application.Install.InstallationData.InstalledFile.Metadata"/> entry key for files that should have ACLs specifically modified upon deployment.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Install.InstallationData.InstalledFileAccessControl.AccessControlEntry.IsContinueOnError">
            <summary>
            Proceed with the installation if this ACL fails to set.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Install.InstallationData.InstalledFileAccessControl.AccessControlEntry.MinOsVersion">
            <summary>
            Only applies to OS versions of this and newer. <c>Null</c> for no limit.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Install.InstallationData.InstalledFileAccessControl.AccessControlEntry.Subject">
            <summary>
            SID or username for which to modify ACLs with this entry.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Install.InstallationData.InstalledFileAccessControl.AccessControlEntry.AddPermissions">
            <summary>
            Access rights to assign.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Install.InstallationData.InstalledFileAccessControl.SidOrUsername">
            <summary>
            Subject of the entry 
            </summary>
        </member>
        <member name="T:JetBrains.Application.Install.InstallationData.InstalledReplaceTextInFile">
            <summary>
              <para>An advanced installation task which alters the contents of an installed file on the target system.</para>
              <para>It takes a regular installed file as a source, reads its text, applies the transformation, and writes to the new location on the target system.</para>
            </summary>
        </member>
        <member name="T:JetBrains.Application.Install.InstallationData.InstalledFileItemBase">
            <summary>
            Base class for all of the files installed to the target system by the Installation Data items.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Install.InstallationData.InstalledFileItemBase.#ctor(System.String)">
            <summary>
            Sets the name of the file item on the target filesystem.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Install.InstallationData.InstalledFileItemBase.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />.
            </summary>
            <returns>
            true if the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />; otherwise, false.
            </returns>
            <param name="obj">The <see cref="T:System.Object" /> to compare with the current <see cref="T:System.Object" />. </param>
            <exception cref="T:System.NullReferenceException">The <paramref name="obj" /> parameter is null.</exception>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.Application.Install.InstallationData.InstalledFileItemBase.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object" />.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.Application.Install.InstallationData.InstalledFileItemBase.System#IComparable{JetBrains#Application#Install#InstallationData#InstalledFileItemBase}#CompareTo(JetBrains.Application.Install.InstallationData.InstalledFileItemBase)">
            <summary>
            Compares the current object with another object of the same type.
            </summary>
            <returns>
            A 32-bit signed integer that indicates the relative order of the objects being compared. The return value has the following meanings: Value Meaning Less than zero This object is less than the <paramref name="other" /> parameter.Zero This object is equal to <paramref name="other" />. Greater than zero This object is greater than <paramref name="other" />.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:JetBrains.Application.Install.InstallationData.InstalledFileItemBase.Equals(JetBrains.Application.Install.InstallationData.InstalledFileItemBase)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="P:JetBrains.Application.Install.InstallationData.InstalledFileItemBase.TargetName">
            <summary>
            The local name of the file on the target system. If left empty, will be the same as the source name. Must be left empty if the source name matches more than one file.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Install.InstallationData.InstalledReplaceTextInFile.Encoding">
            <summary>
            Specifies the file text encoding.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Install.InstallationData.InstalledReplaceTextInFile.OriginalDir">
            <summary>
            Relative path from the root folder to the folder on the target file system in which the original file for patching the text is residing.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Install.InstallationData.InstalledReplaceTextInFile.OriginalName">
            <summary>
            Local name of the original file for patching the text (under <see cref="P:JetBrains.Application.Install.InstallationData.InstalledReplaceTextInFile.OriginalDir"/>).
            </summary>
        </member>
        <member name="P:JetBrains.Application.Install.InstallationData.InstalledReplaceTextInFile.OriginalRoot">
            <summary>
            Root folder on the target file system in which the original file for patching the text is residing.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Install.InstallationData.InstalledReplaceTextInFile.StandardMacros">
            <summary>
            Standard macros which could be used in files when replacing their text.
            The string representation of the macro is <c>$()</c>-surrounded text representation of the enumeration member name.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Install.InstallDirInstaller">
            <summary>
            Writes the InstallDir to the Registry. Works for VS shells.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Install.InstallerAttributeBase.VsVersionAffinity">
            <summary>
            Specifies whether this installation is interested in the VS version, and how.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Install.InstallFromReferencesDirectoryAttribute.#ctor(System.String,JetBrains.Application.Install.InstallationData.InstallationTargetDirRoot,System.String,System.String,JetBrains.Application.Install.InstallFromReferencesDirectoryAttribute.Recursive,System.Boolean)">
            <summary>
            Adds one or more arbitrary files to the installation.
            </summary>
            <param name="targetroot">Base folder on the installation site.</param>
            <param name="sTargetRelativeDir">Relative path from the base folder on the installation site.</param>
            <param name="sSourceRelativeDir">Relative path from the base folder on the compilation site.</param>
            <param name="id">The unique identifier for this installation entry.</param>
            <param name="recursive">Process all subfolders recursively, or not.</param>
            <param name="allowEmpty">Allow source fodler to be empty</param>
        </member>
        <member name="P:JetBrains.Application.Install.InstallFromReferencesDirectoryAttribute.Id">
            <summary>
            The unique identifier for this installation entry.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Install.InstallFromReferencesDirectoryAttribute.TargetRoot">
            <summary>
            Base folder on the installation site.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Install.InstallFromReferencesDirectoryAttribute.TargetRelativeDir">
            <summary>
            Relative path from the base folder on the installation site.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Install.InstallFromReferencesDirectoryAttribute.SourceRelativeDir">
            <summary>
            <para>Relative path from the base folder on the compilation site.</para>
            <para>It's always relative to the references directory of the current module.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Application.Install.InstallFromReferencesDirectoryAttribute.IsRecursive">
            <summary>
            Process all subfolders recursively, or not.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Install.InstallFromReferencesDirectoryAttribute.AllowEmpty">
            <summary>
            Allow source folder to be empty. By default, an empty folder-to-be-installed is an error.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Install.StaticInstallerAttribute">
            <summary>
            An attribute to mark the classes that called once to perform attribute-independent installation.
            The class must implement the <see cref="T:JetBrains.Application.Install.ITypeAttributeInstaller"/> interface.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Install.StaticInstallerAttribute.#ctor(JetBrains.Application.Install.InstallerVsVersionAffinity)">
            <summary>
            Creates the attribute.
            </summary>
            <param name="vsversionaffinity">Specifies the affinity of this installer to the VS version, see enum member summaries for details.</param>
        </member>
        <member name="T:JetBrains.Application.Install.TypeAttributeInstallerAttribute">
            <summary>
            An attribute to mark the classes that process the installation data written in the form of type attributes of type <see cref="P:JetBrains.Application.Install.TypeAttributeInstallerAttribute.AttributeToInstall"/> during registration and unregistration.
            The class must implement the <see cref="T:JetBrains.Application.Install.ITypeAttributeInstaller"/> interface.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Install.TypeAttributeInstallerAttribute.#ctor(System.Type,JetBrains.Application.Install.InstallerVsVersionAffinity)">
            <summary>
            Creates the attribute.
            </summary>
            <param name="typeAttributeToInstall">Type of the attribute for which the class marked by <see cref="T:JetBrains.Application.Install.TypeAttributeInstallerAttribute"/> should be invoked to process the installation</param>
            <param name="vsversionaffinity">Specifies the affinity of this installer to the VS version, see enum member summaries for details.</param>
        </member>
        <member name="P:JetBrains.Application.Install.TypeAttributeInstallerAttribute.AttributeToInstall">
            <summary>
            Gets the type of the attribute for which the class marked by <see cref="T:JetBrains.Application.Install.AssemblyAttributeInstallerAttribute"/> should be invoked to process the installation.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Interop.NativeHook.HookedMessageSelector">
            <summary>
            The per-window collection of all the available messages.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Interop.NativeHook.IHookedMessageSelector">
            <summary>
            The per-window selector of all the available messages.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Interop.NativeHook.IHookedMessageSelector.All">
            <summary>
            Gets a virtual message that corresponds to all the messages received by the window specified.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Interop.NativeHook.IHookedMessageSelector.Item(JetBrains.Interop.WinApi.WindowsMessages)">
            <summary>
            Gets a particluar message on a particular window.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Interop.NativeHook.HookedMessageSelector.All">
            <summary>
            Gets a virtual message that corresponds to all the messages received by the window specified.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Interop.NativeHook.HookedMessageSelector.Item(JetBrains.Interop.WinApi.WindowsMessages)">
            <summary>
            Gets a particluar message on a particular window.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Interop.NativeHook.HookedMessageSelector.Window">
            <summary>
            Gets the window whose messages are being accessed via this collection.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Interop.NativeHook.HookedWindow">
            <summary>
            A reference to a window to be hooked.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Interop.NativeHook.IHookedWindow">
            <summary>
            A reference to a window to be hooked.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Interop.NativeHook.IHookedWindow.Messages">
            <summary>
            Gets a selector of messages available for the window.
            To subscribe to or unsubscribe from an event, pick the message you're interested in from this collection.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Interop.NativeHook.HookedWindow.Messages">
            <summary>
            Gets the collection of messages available for this window.
            To subscribe to or unsubscribe from an event, pick the message you're interested in from this collection.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Interop.NativeHook.HookedWindow.Owner">
            <summary>
            The hooking manager.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Interop.NativeHook.HookedWindow.Handle">
            <summary>
            A handle to the current window.
            <c>Null</c> means “all the windows of the process”.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Interop.NativeHook.HookedWindowAndMessage">
            <summary>
            A particular message of a particular window that could be subscribed to.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Interop.NativeHook.IHookedWindowAndMessage">
            <summary>
            A particular message of a particular window that could be subscribed to.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Interop.NativeHook.IHookedWindowAndMessage.Advise(JetBrains.DataFlow.Lifetime,System.Boolean,System.Action{JetBrains.Application.Interop.NativeHook.WindowsMessageEventArgs})">
            <summary>
            Advises an event that fires after the message described by the <see cref="P:JetBrains.Application.Interop.NativeHook.IHookedWindowAndMessage.Code"/> is processed by the <see cref="P:JetBrains.Application.Interop.NativeHook.IHookedWindowAndMessage.Window"/>.
            </summary>
            <param name="lifetime">A hook lifetime.</param>
            <param name="isDeferredProcessingAllowed">Allows to notify the handler outside the hook callback function. Executing managed .NET code over the hook function might be undesired at times.</param>
            <param name="action">Message handler to be invoked.</param>
        </member>
        <member name="P:JetBrains.Application.Interop.NativeHook.IHookedWindowAndMessage.Code">
            <summary>
            Gets the WINAPI code of the message.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Interop.NativeHook.IHookedWindowAndMessage.Window">
            <summary>
            Gets the window whose message this is.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Interop.NativeHook.HookedWindowAndMessage.Advise(JetBrains.DataFlow.Lifetime,System.Boolean,System.Action{JetBrains.Application.Interop.NativeHook.WindowsMessageEventArgs})">
            <summary>
            Advises an event that fires after the message described by the <see cref="P:JetBrains.Application.Interop.NativeHook.HookedWindowAndMessage.Code"/> is processed by the <see cref="P:JetBrains.Application.Interop.NativeHook.HookedWindowAndMessage.Window"/>.
            </summary>
            <param name="lifetime">Lifetime.</param>
            <param name="isDeferredProcessingAllowed">Not implemented yet.</param>
            <param name="action">Message handler to be invoked.</param>
        </member>
        <member name="P:JetBrains.Application.Interop.NativeHook.HookedWindowAndMessage.Owner">
            <summary>
            Gets the owning hooker.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Interop.NativeHook.HookedWindowAndMessage.Code">
            <summary>
            Gets the WINAPI code of this message.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Interop.NativeHook.HookedWindowAndMessage.Window">
            <summary>
            Gets the window whose message this is.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Interop.NativeHook.HookedWindowSelector">
            <summary>
            A selector of a window to be hooked.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Interop.NativeHook.IHookedWindowSelector">
            <summary>
            A selector of a window to be hooked.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Interop.NativeHook.IHookedWindowSelector.All">
            <summary>
            Gets a virtual window that captures the messages for all the windows in the thread.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Interop.NativeHook.IHookedWindowSelector.Item(System.Windows.Forms.IWin32Window)">
            <summary>
            Gets a window.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Interop.NativeHook.IHookedWindowSelector.Item(System.IntPtr)">
            <summary>
            Gets a window by its handle.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Interop.NativeHook.IHookedWindowSelector.Item(System.Void*)">
            <summary>
            Gets a window by its handle.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Interop.NativeHook.HookedWindowSelector.All">
            <summary>
            Gets a virtual window that captures the messages for all the windows in the process.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Interop.NativeHook.HookedWindowSelector.Item(System.IntPtr)">
            <summary>
            Gets a window from the collection by its handle.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Interop.NativeHook.HookedWindowSelector.Item(System.Windows.Forms.IWin32Window)">
            <summary>
            Gets a window from the collection.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Interop.NativeHook.HookedWindowSelector.Item(System.Void*)">
            <summary>
            Gets a window from the collection by its handle.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Interop.NativeHook.HookEventArgs">
            <summary>
            Event arguments for the <see cref="T:JetBrains.Application.Interop.NativeHook.WindowsHook"/> notification.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Interop.NativeHook.HookEventArgs.GetCwpRetStruct">
            <summary>
            Gets the hook data as a <see cref="T:JetBrains.Interop.WinApi.CWPRETSTRUCT"/>. Valid for some messages only. Valid within the hook callback only. LIVE, do not modify unless that's intentional.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Interop.NativeHook.HookEventArgs.GetCwpStruct">
            <summary>
            Gets the hook data as a <see cref="T:JetBrains.Interop.WinApi.CWPSTRUCT"/>. Valid for some messages only. Valid within the hook callback only. LIVE, do not modify unless that's intentional.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Interop.NativeHook.HookEventArgs.GetMouseHookStruct">
            <summary>
            Gets the hook data as a <see cref="T:JetBrains.Interop.WinApi.MOUSEHOOKSTRUCT"/>. Valid for some messages only. Valid within the hook callback only. LIVE, do not modify unless that's intentional.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Interop.NativeHook.HookEventArgs.GetMsgStruct">
            <summary>
            Gets the hook data as a <see cref="T:JetBrains.Interop.WinApi.MSG"/>. Valid for some messages only. Valid within the hook callback only. LIVE, do not modify unless that's intentional.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Interop.NativeHook.HookEventArgs.GetMsLlHookStruct">
            <summary>
            Gets the hook data as a <see cref="T:JetBrains.Interop.WinApi.MSLLHOOKSTRUCT"/>. Valid for some messages only. Valid within the hook callback only. LIVE, do not modify unless that's intentional.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Interop.NativeHook.ComImport.IWindowMessageSink">
            <summary>
            This interface is used in JetNativeHooks.dll.
            Must be synchronized with NativeHooks.IDL.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Interop.NativeHook.ComImport.INativeHookHandler">
            <summary>
            This interface is implemeted in JetNativeHooks.dll.
            Do not modify it unless NativeHooks.IDL is changed.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Interop.NativeHook.ComImport.NativeHookHandler">
            <summary>
            Coclass for DLLs implementing the hook handler.
            </summary>
            <remarks>
            This object is exposed in JetNativeHooks.dll.
            Do not modify it unless NativeHooks.IDL is changed.
            </remarks>
        </member>
        <member name="T:JetBrains.Application.Interop.NativeHook.ManagedWindowsHookManager">
            <summary>
            Hooks to all the windows messages in the main thread and notifies the listeners of them.
            </summary>
            <remarks>
            We have to listen to both WH_CALLWNDPROCRET and WH_GETMESSAGE hooks because they return nonintersecting subsets of messages.
            </remarks>
        </member>
        <member name="F:JetBrains.Application.Interop.NativeHook.ManagedWindowsHookManager.myCwpRetHook">
            <summary>
            The object that winds up the WH_CALLWNDPROCRET Windows hook.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Interop.NativeHook.ManagedWindowsHookManager.myGetMsgHook">
            <summary>
            The object that winds up the WH_GETMESSAGE Windows hook.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Interop.NativeHook.ManagedWindowsHookManager.myHookEntries">
            <summary>
            The quick-lookup map of windows &amp; messages to handlers.
            <c>Null</c> window handle and <c>0</c> message are wildcards.
            Maps: HWND -> (MSG -> (entry)).
            </summary>
        </member>
        <member name="F:JetBrains.Application.Interop.NativeHook.ManagedWindowsHookManager.myClassHandlers">
            <summary>
            Maps: Window class -> Message -> Handler
            </summary>
        </member>
        <member name="F:JetBrains.Application.Interop.NativeHook.ManagedWindowsHookManager.myForegroundIdleHook">
            <summary>
            The object that winds up the WH_FOREGROUNDIDLE Windows hook.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Interop.NativeHook.ManagedWindowsHookManager.Dump(System.Xml.XmlWriter)">
            <summary>
            Dumps the object.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Interop.NativeHook.ManagedWindowsHookManager.RemoveAll(System.Object)">
            <summary>
            Removes all the event subscriptions by the <paramref name="owner"/> object.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Interop.NativeHook.ManagedWindowsHookManager.AdviseWindowMessageInternal(JetBrains.DataFlow.Lifetime,System.Void*,JetBrains.Interop.WinApi.WindowsMessages,System.Action{JetBrains.Application.Interop.NativeHook.WindowsMessageEventArgs})">
            <summary>
            Internal implemetation of <see cref="M:JetBrains.Application.Interop.NativeHook.IWindowsHookManager.AdviseWindowMessage(JetBrains.DataFlow.Lifetime,System.IntPtr,JetBrains.Interop.WinApi.WindowsMessages,System.Boolean,System.Action{JetBrains.Application.Interop.NativeHook.WindowsMessageEventArgs})"/> method.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Interop.NativeHook.ManagedWindowsHookManager.AddRemoveMessageHandler(System.Void*,JetBrains.Interop.WinApi.WindowsMessages,System.Action{JetBrains.Application.Interop.NativeHook.WindowsMessageEventArgs},System.Delegate,System.Boolean,JetBrains.DataFlow.AddRemove)">
            <summary>
            Implements adding/removing the message handler to the map, possibly, with its children.
            </summary>
            <param name="window">Handle to the window, or <c>Null</c> for all the windows.</param>
            <param name="message">Message to listen to, or <c>0</c> for all the messages.</param>
            <param name="action">The handler to be invoked.</param>
            <param name="handlerOriginal">The external handler that will be used to unsubscribe from this event.</param>
            <param name="includeparents">Whether to listen to parent windows also, illegal if <paramref name="window"/> is <c>Null</c>.</param>
            <param name="addremove">Whether to add or remove.</param>
        </member>
        <member name="M:JetBrains.Application.Interop.NativeHook.ManagedWindowsHookManager.AddRemoveHookEntry(JetBrains.Application.Interop.NativeHook.ManagedWindowsHookManager.WindowsMessageHookEntry,JetBrains.DataFlow.AddRemove)">
            <summary>
            The raw adder-remover of the <paramref name="entry"/> to the <see cref="F:JetBrains.Application.Interop.NativeHook.ManagedWindowsHookManager.myHookEntries"/> map.
            </summary>
            <param name="entry">The entry to add/remove, specifies all the keys of the map and the value.</param>
            <param name="addremove">Whether to add or remove.</param>
        </member>
        <member name="M:JetBrains.Application.Interop.NativeHook.ManagedWindowsHookManager.AddRemoveClassMessageHandler(System.String,JetBrains.Interop.WinApi.WindowsMessages,System.Action{JetBrains.Application.Interop.NativeHook.WindowsMessageEventArgs},JetBrains.DataFlow.AddRemove)">
            <summary>
            Adds/removes window class message handlers to/from map.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Interop.NativeHook.ManagedWindowsHookManager.EnumAllEntries">
            <summary>
            Gets the all-entries enumerator.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Interop.NativeHook.ManagedWindowsHookManager.HookUnhook">
            <summary>
            Either hooks or unhooks the underlying WinAPI hook, depending on whether there are any clients in the map.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Interop.NativeHook.ManagedWindowsHookManager.HookUnhookForegroundIdle">
            <summary>
            Either hooks or unhooks the WH_FOREGROUNDIDLE hook, depending on whether there are any clients.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Interop.NativeHook.ManagedWindowsHookManager.OnHookedMessage(System.Object,JetBrains.Application.Interop.NativeHook.WindowsMessageEventArgs)">
            <summary>
            The hook has caught some message, call the listeners.
            Should return <c>True</c> so that the chained callers would succeed in processing the message.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Interop.NativeHook.ManagedWindowsHookManager.RemoveAll">
            <summary>
            Removes all the hooks.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Interop.NativeHook.ManagedWindowsHookManager.JetBrains#Application#Interop#NativeHook#IWindowsHookManager#AdviseWindowMessage(JetBrains.DataFlow.Lifetime,System.IntPtr,JetBrains.Interop.WinApi.WindowsMessages,System.Boolean,System.Action{JetBrains.Application.Interop.NativeHook.WindowsMessageEventArgs})">
            <summary>
            NOTE: isDeferredProcessingAllowed ignored by this implementation
            </summary>
        </member>
        <member name="M:JetBrains.Application.Interop.NativeHook.ManagedWindowsHookManager.JetBrains#Application#Interop#NativeHook#IWindowsHookManager#AdviseWindowClassMessage(JetBrains.DataFlow.Lifetime,System.String,JetBrains.Interop.WinApi.WindowsMessages,System.Boolean,System.Action{JetBrains.Application.Interop.NativeHook.WindowsMessageEventArgs})">
            <summary>
            NOTE: isDeferredProcessingAllowed ignored by this implementation
            </summary>
        </member>
        <member name="M:JetBrains.Application.Interop.NativeHook.ManagedWindowsHookManager.ToString">
            <summary>
            Returns a <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </summary>
            
            <returns>
            A <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:JetBrains.Application.Interop.NativeHook.ManagedWindowsHookManager.Dispatcher">
            <summary>
            Identifies the owning thread.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Interop.NativeHook.ManagedWindowsHookManager.JetBrains#Application#Interop#NativeHook#IWindowsHookManager#Windows">
            <summary>
            A selector of the window and message to be hooked.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Interop.NativeHook.ManagedWindowsHookManager.WindowsMessageHookEntry">
            <summary>
            An entrty in the hooks list.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Interop.NativeHook.ManagedWindowsHookManager.WindowsMessageHookEntry.#ctor(System.IntPtr,System.IntPtr,JetBrains.Interop.WinApi.WindowsMessages,System.Action{JetBrains.Application.Interop.NativeHook.WindowsMessageEventArgs},System.Delegate)">
            <summary>
            Inits all the fields of the instance, see corresponding attributes for comments.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Interop.NativeHook.ManagedWindowsHookManager.WindowsMessageHookEntry.Dump(System.Xml.XmlWriter)">
            <summary>
            Dumps the entry.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Interop.NativeHook.ManagedWindowsHookManager.WindowsMessageHookEntry.Handler">
            <summary>
            Handler to be invoked on capture.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Interop.NativeHook.ManagedWindowsHookManager.WindowsMessageHookEntry.Message">
            <summary>
            Code of the message to capture.
            <c>0</c> is a wildcard.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Interop.NativeHook.ManagedWindowsHookManager.WindowsMessageHookEntry.OriginalHandler">
            <summary>
            Gets the handler that the external user passed in when subscribing to the event.
            Needed to look up all the events from a particular user in case it bulk-unsubscribes.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Interop.NativeHook.ManagedWindowsHookManager.WindowsMessageHookEntry.OriginalTarget">
            <summary>
            The original window, as specified by the client when subscribing, a child of <see cref="P:JetBrains.Application.Interop.NativeHook.ManagedWindowsHookManager.WindowsMessageHookEntry.Target"/>. Not listened by this hook entry.
            It's rather a mark that the hook entry has been added in order to listen all the parents of the <see cref="P:JetBrains.Application.Interop.NativeHook.ManagedWindowsHookManager.WindowsMessageHookEntry.OriginalTarget"/> window.
            Needed to remove all of such entries when unsubscribing.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Interop.NativeHook.ManagedWindowsHookManager.WindowsMessageHookEntry.Target">
            <summary>
            The target window that should be spied in response to this hook entry.
            <c>Null</c> is a wildcard.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Interop.NativeHook.NativeWindowsHookManager">
            <summary>
            Wraps <see cref="T:JetBrains.Application.Interop.NativeHook.ComImport.INativeHookHandler"/>'s direct hooking features into the <see cref="T:JetBrains.Application.Interop.NativeHook.IWindowsHookManager"/> interface.
            </summary>
            
        </member>
        <member name="F:JetBrains.Application.Interop.NativeHook.NativeWindowsHookManager.myNativeHooks">
            <summary>
            Native Wondows hook implementation.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Interop.NativeHook.NativeWindowsHookManager.Dispatcher">
            <summary>
            Identifies the owning thread.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Interop.NativeHook.NativeWindowsHookManager.JetBrains#Application#Interop#NativeHook#IWindowsHookManager#Windows">
            <summary>
            A selector of the window and message to be hooked.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Interop.NativeHook.WindowsHook">
            <summary>
            Implements hooking to local and global windows messages by the means of <see cref="M:JetBrains.Interop.WinApi.User32Dll.SetWindowsHookExW(System.Int32,JetBrains.Interop.WinApi.Functions.HOOKPROC,System.Void*,System.UInt32)"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Interop.NativeHook.WindowsHook.myHookEventHandler">
            <summary>
            External handler for the hook events.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Interop.NativeHook.WindowsHook.myHookHandle">
            <summary>
            Handle to the hook, assigned by <see cref="M:JetBrains.Interop.WinApi.User32Dll.SetWindowsHookExW(System.Int32,JetBrains.Interop.WinApi.Functions.HOOKPROC,System.Void*,System.UInt32)"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Interop.NativeHook.WindowsHook.myHookType">
            <summary>
            Hook code.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Interop.NativeHook.WindowsHook.#ctor(JetBrains.Interop.WinApi.Constants.HookType,JetBrains.Application.Interop.NativeHook.WindowsHook.HookEventHandler)">
            <summary>
            Hooks the given event-handler to the messages specified by the code.
            </summary>
            <param name="code">Code for the messages to hook.</param>
            <param name="handler">External event handler.</param>
        </member>
        <member name="M:JetBrains.Application.Interop.NativeHook.WindowsHook.#ctor(JetBrains.Interop.WinApi.Constants.HookType,JetBrains.Application.Interop.NativeHook.WindowsHook.HookEventHandler,JetBrains.Interop.WinApi.Functions.HOOKPROC)">
            <summary>
            An internal constructor.
            </summary>
            <param name="code">Code for the messages to hook.</param>
            <param name="handler">External event handler, <c>Null</c> for none.</param>
            <param name="callback">Internal WinAPI hook handler, <c>Null</c> to use the stock one that notifies the <paramref name="handler"/>.</param>
        </member>
        <member name="M:JetBrains.Application.Interop.NativeHook.WindowsHook.IsGlobalHook(JetBrains.Interop.WinApi.Constants.HookType)">
            <summary>
            Determines whether the hook is a global scope only hook and needs a HINSTANCE specified etc when hooking.
            All the other hooks could be set either as a global or a per-thread.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Interop.NativeHook.WindowsHook.Release">
            <summary>
            Uninstall the hook.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Interop.NativeHook.WindowsHook.HookEventHandler">
            <summary>
            event-like delegate for the external hook event handlers.
            </summary>
            <returns>Whether to call next handlers in the chain (<c>True</c>), or drop the request at this point (<c>False</c>).</returns>
        </member>
        <member name="T:JetBrains.Application.Interop.NativeHook.WindowsMessageEventArgs">
            <summary>
            Arguments for the <see cref="T:JetBrains.Application.Interop.NativeHook.IWindowsHookManager"/>-emitted messages.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Interop.NativeHook.WindowsMessageEventArgs.WindowsHook">
            <summary>
            Gets the windows message hooks manager you're subscribed to.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Interop.NativeHook.WindowsMessageEventArgs.HWnd">
            <summary>
            Gets the handle to the window that is receiving the message.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Interop.NativeHook.WindowsMessageEventArgs.Message">
            <summary>
            Gets the message ID.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Interop.NativeHook.WindowsMessageEventArgs.WParam">
            <summary>
            Gets the "WORD" parameter.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Interop.NativeHook.WindowsMessageEventArgs.LParam">
            <summary>
            Gets the "LONG" parameter.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Interop.NativeHook.WindowsMessageEventArgs.LResult">
            <summary>
            Gets or sets the message result.
            Applicable for the WH_CALLWNDPROCRET hook only. For other hook types always IntPtr.Zero.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Interop.NativeHook.WindowsMessageEventArgs.Location">
            <summary>
            The cursor position, in screen coordinates, when the message was posted.
            WH_GETMESSAGE hook returns this value, for other hook types we get it using GetCursorInfo().
            </summary>
        </member>
        <member name="P:JetBrains.Application.Interop.NativeHook.WindowsMessageEventArgs.WindowHandle">
            <summary>
            Gets the safe handle to the window that is receiving the message.
            </summary>
        </member>
        <member name="T:JetBrains.Application.License.LicenseSupportBase">
            <summary>
            Simple implementation of license support that fetches all the possible data from product <see cref="T:JetBrains.Application.Defines"/>
            </summary>
        </member>
        <member name="M:JetBrains.Application.License.ILicenseSupport.CreateLicenseData(System.String,System.String,System.String)">
            <summary>
            Creates license data using licenseKey, userName and company name. If only one type of licenses is acceptable,
            normally returns new LicenseData(...). Otherwise some additional processing should take place
            </summary>
        </member>
        <member name="M:JetBrains.Application.License.ILicenseSupport.GetLicenseAgreement(JetBrains.Application.License.LicenseType)">
            <summary>
            License agreement in rich text. NULL if no license agreement is necessary
            </summary>
        </member>
        <member name="M:JetBrains.Application.License.ILicenseSupport.DecodeProductEdition(System.String,JetBrains.Application.IApplicationHost)">
            <summary>
            Detect edition by asset's product code
            </summary>
            <param name="productCode">Product code from asset returned by ObtainLicenseResponse</param>
            <param name="descriptor"></param>
            <returns>Product edition decoded</returns>
        </member>
        <member name="P:JetBrains.Application.License.ILicenseSupport.ProductGuid">
            <summary>
            Guid (with braces), that is used to store Date marker
            </summary>
        </member>
        <member name="P:JetBrains.Application.License.ILicenseSupport.FreeTrialPeriod">
            <summary>
            Number of days, free trial period lasts
            </summary>
        </member>
        <member name="P:JetBrains.Application.License.ILicenseSupport.FeedbackRequestPeriod">
            <summary>
            Number of free trial days, after which feedback is requested.
            Negative value means feedback is never requested.
            </summary>
        </member>
        <member name="P:JetBrains.Application.License.ILicenseSupport.LeftDaysNotification">
            <summary>
            Identifies, when to start informing user that, his free trial
            period ends up 
            </summary>
        </member>
        <member name="P:JetBrains.Application.License.ILicenseSupport.ProductBuiltDateUsedForSubscriptionCheck">
            <summary>
            When checking subscription license we need to verify product creation time against subscription period. 
            If we just use <see cref="!:IApplicationDescriptor.BuiltOn"/> there might be situation when version X.0 is eligible to use because issued within subscription period,
            but bugfix X.0.1 is issued when the period is over. To handle this the property is set to the date of X.0 release.
            Normally, TeamCity build parameter TC_DateTimeForSubscriptionCheck is used (<see cref="F:JetBrains.Application.Defines.DateTimeForSubscriptionCheck"/>).
            If subscription is not available one may return <see cref="F:System.DateTime.MaxValue"/>
            </summary>
        </member>
        <member name="P:JetBrains.Application.License.ILicenseSupport.BuyUrl">
            <summary>
            Gets the URL that takes to the “Buy Product” page.
            </summary>
        </member>
        <member name="P:JetBrains.Application.License.ILicenseSupport.DoCheckLicenseReuseOverNetwork">
            <summary>
            Determines whether the product should check for multiple instances running simultaneousely over the network.
            </summary>
        </member>
        <member name="P:JetBrains.Application.License.ILicenseSupport.ProductFamily">
            <summary>
            JetBrains license server supports ProductFamily as guid without braces !!!
            </summary>
        </member>
        <member name="P:JetBrains.Application.License.ILicenseSupport.Version">
            <summary>
            Version to request from license server. Normally it equals to product major version * 1000  (<see cref="F:JetBrains.Application.Defines.NumLicenseAppVersion"/>)
            If the product supports subscription only use version equal to buildDate.Year*10000 + buildDate.Month*100 + buildDate.Day.
            </summary>
        </member>
        <member name="P:JetBrains.Application.License.ILicenseSupport.SendBuildDateAsVersionToOldServers">
            <summary>
            Return true if your product had subscription previously. In the case <see cref="P:JetBrains.Application.License.ILicenseSupport.ProductBuiltDateUsedForSubscriptionCheck"/> will be used to issue ticket 
            in case of old license server.
            </summary>
        </member>
        <member name="P:JetBrains.Application.License.ILicenseSupport.JBProductCode">
            <summary>
            Product code withod edition. In case of ReSharper it should be RS.
            </summary>
        </member>
        <member name="M:JetBrains.Application.PerformanceTracking.IPerformanceTracking.PopResults">
            <summary>
            Returns results and clears stored results.
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Application.PerformanceTracking.IPerformanceTracking.RecordValue(System.String,System.Double)">
            <summary>
            Record value to TC build statistics
            </summary>
            <param name="actionId"></param>
            <param name="value"></param>
        </member>
        <member name="M:JetBrains.Application.PerformanceTracking.IPerformanceTracking.TrackActionRunDuration(System.String,System.Action)">
            <summary>
            Runs action and records its duration
            </summary>
            <param name="actionId"></param>
            <param name="action"></param>
        </member>
        <member name="M:JetBrains.Application.PersistentMap.PersistentDbHelpers.ThrowDbExceptionIfNeccessary(System.Byte*,System.Byte*)">
            <summary>
            Throws DB exception and optionally free memory
            </summary>
            <param name="errmsg"></param>
            <param name="memoryToFree"></param>
        </member>
        <member name="M:JetBrains.Application.PersistentMap.PersistentSortedMapEx.ToOptimized``2(JetBrains.Application.PersistentMap.OptimizedPersistentSortedMap{``0,``1},JetBrains.DataFlow.Lifetime,System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            special overload to prevent double optimization. fails always (not to run too fast).
            </summary>
        </member>
        <member name="M:JetBrains.Application.PersistentMap.LevelDbMap`2.Remove(`0)">
            <summary>    
            
            </summary>
            <param name="key"></param>
            <returns>Always returns True</returns>
        </member>
        <member name="T:JetBrains.Application.PersistentMap.OptimizedPersistentSortedMap`2">
            <summary>
            Only one map per DB table is supported. No cache coherency!
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="P:JetBrains.Application.PersistentMap.OptimizedPersistentSortedMap`2.UseCachingEnumerator">
            <summary>
            When set to true enumerating through the values will try to get current value from cache if it is presented, otherwise current value will be obtained from underlying storage
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Extentions.ISettingsCache.GetData``1(JetBrains.DataFlow.Lifetime,JetBrains.Application.Settings.Extentions.ICachedSettingsReader{``0},System.Action{``0})">
            <summary>
            Data is cached by reader instance equality
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.InternKeyPathComponent.Interned">
            <summary>
            Interns string contents of the path components.
            Being a concurrent dictionary, needs no additional locking.
            Maps any key to the interned version.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.Storage.SettingsStorageHiero">
            <summary>
            An implementation of the settings storage which natively operates on key-path-components and stores them along their hierarchy, in a tree structure.
            Its load &amp; save are externally driven in terms of entries (serialization formats are not this object's responsibility).
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.Storage.ISettingsStorageSerializable">
            <summary>
            A contract to require both interfaces.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.Storage.ISettingsStorage">
            <summary>
            Interface to the key-value settings storage (representing a physical storage on disk or a file from the Web).
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.ISettingsStorage.Get(JetBrains.Application.Settings.Storage.KeyPathComponents,JetBrains.Application.Settings.Storage.ISettingsStorageTransactionContext)">
            <summary>
            Tries to get the value of the key. 
            </summary>
            <param name="key">Key.</param>
            <param name="transaction"></param>
            <returns>Either a value of one of the predefined types (<see cref="T:JetBrains.Application.Settings.Storage.SettingsStorageHelpers.StorageValueTypeId"/>), or <c>Null</c> if the value for this key is not set.</returns>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.ISettingsStorage.Set(JetBrains.Application.Settings.Storage.KeyPathComponents,System.Object,JetBrains.Application.Settings.Storage.ISettingsStorageTransactionContext)">
            <summary>
            Sets or resets the value of the key.
            </summary>
            <param name="key">Key.</param>
            <param name="value">Either a value of one of the predefined types (<see cref="T:JetBrains.Application.Settings.Storage.SettingsStorageHelpers.StorageValueTypeId"/>) to assign, or <c>Null</c> to reset the value of the given key.</param>
            <param name="transaction"></param>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.ISettingsStorage.AdviseChange(JetBrains.DataFlow.Lifetime,System.Action{JetBrains.Application.Settings.Storage.SettingsStorageChangeArgs},JetBrains.Application.Settings.Storage.ISettingsStorageTransactionContext)">
            <summary>
            Advises changes to the stored values.
            A change happens both when setting a new value thru <see cref="M:JetBrains.Application.Settings.Storage.ISettingsStorage.Set(JetBrains.Application.Settings.Storage.KeyPathComponents,System.Object,JetBrains.Application.Settings.Storage.ISettingsStorageTransactionContext)"/> and when synchronizing to external changes to the disk storage.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.ISettingsStorage.Enum(JetBrains.Application.Settings.Storage.KeyPathComponents,System.Int32,System.Action{JetBrains.Application.Settings.Storage.KeyPathComponents,System.Object},JetBrains.Application.Settings.Storage.ISettingsStorageTransactionContext)">
            <summary>
            Enumerates keys and values in the storage.
            The lock is held throughout the whole enumeration process, so you should minimize your callback activities as much as possible.
            </summary>
            <param name="root">The root key from which the enumeration should start. Its children or subtree will be enumerated. To enumerate the whole storage, pass in an empty (but non-<c>Null</c>) key path list here. This function MIGHT modify the key path list in the <paramref name="root"/> on each step by appending the child/ancestor key path components to it. The path prefix which you pass in is never modified though. Upon function exit, the original value is restored.</param>
            <param name="nTakeChildLevelOnly">If nonzero, ancestors of the specified level will be enumerated (such keys whose key path is the <paramref name="root"/> plus one <paramref name="nTakeChildLevelOnly"/> components). If <c>0</c>, the whole subtree will be enumerated, which includes the <paramref name="root"/> itself (if there's a value for it in the storage), and any ancestors (to whom <paramref name="root"/> path is a prefix).</param>
            <param name="FCallback">Your callback which is invoked on every iteration for each key-value pair encountered in the enumeration.
            The callback parameters are the key and non-<c>Null</c> value of the item. Note that the implementation MIGHT reuse the path you passed in as <paramref name="root"/> to be modified on each iteration to point to the current key path. You should not be performing lengthy operations or calling the storage recursively within this callback because the storage lock is held during the whole operation.</param>
            <param name="transaction"></param>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.ISettingsStorage.AttachToTransaction(JetBrains.DataFlow.Lifetime,JetBrains.Application.Settings.Storage.ISettingsStorageTransactionContext,JetBrains.Application.Settings.Storage.ISettingsStorageTransactionContext)">
            <summary>
            Makes sure this storage is attached to the specific transaction.
            This method only guarantees that read-repeatable within the transaction will not see any data written to the storage after this point.
            </summary>
            <param name="lifetime"></param>
            <param name="transactionToAttach">Transaction context in which this storage should work in transactional fashion.</param>
            <param name="transactionOuter">The current transaction context, if we're opening a nested transaction.</param>
            <returns>Transaction data of this storage.</returns>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.ISettingsStorage.EraseSubtree(JetBrains.Application.Settings.Storage.KeyPathComponents,JetBrains.Application.Settings.Storage.ISettingsStorageTransactionContext)">
            <summary>
            Erases the given key, as well as its whole subtree.
            Pass in an empty list of key components to erase the whole storage contents.
            </summary>
            <param name="root"></param>
            <param name="transaction"></param>
        </member>
        <member name="P:JetBrains.Application.Settings.Storage.ISettingsStorage.Name">
            <summary>
            Gets the user-friendly storage name. This is used for telling storages apart in the mount points list
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.Storage.Persistence.ISettingsStorageEntriesSerialization">
            <summary>
            The basic serialization interface for the default storage implementation.
            Works right on in-memory representation of the storage entries.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.Persistence.ISettingsStorageSerializationCommon.GetInMemoryChangesDiffCopy">
            <summary>
            Gets the list of entries changed in-memory (<c>Null</c> value means it should be reset).
            Used mostly for diagnostics needs.
            Creates a copy of the dictionary (so use sparingly), because the actual dictionary access is lock-protected.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Settings.Storage.Persistence.ISettingsStorageSerializationCommon.Name">
            <summary>
            Gets the user-friendly storage name. This is used for telling storages apart in the mount points list
            </summary>
        </member>
        <member name="P:JetBrains.Application.Settings.Storage.Persistence.ISettingsStorageSerializationCommon.IsDirty">
            <summary>
            Gets whether the storage has any dirty (in-memory) changes pending for save. Free-threaded.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Settings.Storage.Persistence.ISettingsStorageSerializationCommon.IsEmpty">
            <summary>
            Gets if there're no entries in the storage. This includes both entries-from-stream and dirty entries.
            This allows for optimized behavior if we've got nothing to save.
            Yields <c>Null</c> when it's a bit too expensive to calculate the result.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.Persistence.ISettingsStorageEntriesSerialization.Load(JetBrains.Application.Settings.Storage.SettingsStorageLoadFlag,System.Func{System.Collections.Generic.Dictionary{System.String,System.Object}})">
            <summary>
            Loads entries into the storage.
            If the storage has any in-memory changes, they remain intact.
            </summary>
            <param name="flag"></param>
            <param name="FReadEntries">Storage calls this function when it needs to read the entries. This makes sure it sets any applicable locks around the read operation.</param>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.Persistence.ISettingsStorageEntriesSerialization.Save(System.Func{System.Collections.Generic.Dictionary{System.String,System.Object},System.Boolean})">
            <summary>
            Saves the entries from the storage.
            </summary>
            <param name="FSave">Storage calls this function on the exact entries to be saved. The return value indicates whether the save succeeds (if the storage can assume in-memory diff applied).</param>
        </member>
        <member name="T:JetBrains.Application.Settings.Storage.Persistence.ISettingsStorageEntriesSerializationCached">
            <summary>
            Adds caching capabilities to storage serialization.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.Persistence.ISettingsStorageEntriesSerializationCached.FirstTimeLoadFromCache(System.Func{System.Collections.Generic.Dictionary{System.String,System.Object}},System.IO.BinaryReader)">
            <summary>
            This method takes precedence over <see cref="M:JetBrains.Application.Settings.Storage.Persistence.ISettingsStorageEntriesSerialization.Load(JetBrains.Application.Settings.Storage.SettingsStorageLoadFlag,System.Func{System.Collections.Generic.Dictionary{System.String,System.Object}})"/>. If you provided data on previous <see cref="M:JetBrains.Application.Settings.Storage.Persistence.ISettingsStorageEntriesSerializationCached.SaveToCache(System.Func{System.Collections.Generic.Dictionary{System.String,System.Object},System.Boolean},System.IO.BinaryWriter)"/>, and it's still up-to-date, you'll have a chance to load from the cached data instead of parsing the XML anew.
            If you implement this method and your called understands the interface and there's cache data available, on the first-load you'll be called for this method instead of <see cref="M:JetBrains.Application.Settings.Storage.Persistence.ISettingsStorageEntriesSerialization.Load(JetBrains.Application.Settings.Storage.SettingsStorageLoadFlag,System.Func{System.Collections.Generic.Dictionary{System.String,System.Object}})"/>. If you cannot read the binary cache data, fallback to reading <see cref="!:FReadEntries"/>.
            The caller might always call <see cref="M:JetBrains.Application.Settings.Storage.Persistence.ISettingsStorageEntriesSerialization.Load(JetBrains.Application.Settings.Storage.SettingsStorageLoadFlag,System.Func{System.Collections.Generic.Dictionary{System.String,System.Object}})"/> instead.
            If you throw an exception out of this method, caller assumes reading the cache did not succeed and calls into <see cref="M:JetBrains.Application.Settings.Storage.Persistence.ISettingsStorageEntriesSerialization.Load(JetBrains.Application.Settings.Storage.SettingsStorageLoadFlag,System.Func{System.Collections.Generic.Dictionary{System.String,System.Object}})"/>.
            </summary>
            <returns>If were loaded OK. If not, then the caller assumes <see cref="M:JetBrains.Application.Settings.Storage.Persistence.ISettingsStorageEntriesSerialization.Load(JetBrains.Application.Settings.Storage.SettingsStorageLoadFlag,System.Func{System.Collections.Generic.Dictionary{System.String,System.Object}})"/> has to be called, and that the binary cache file is corrupt and has to be deleted.</returns>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.Persistence.ISettingsStorageEntriesSerializationCached.SaveToCache(System.Func{System.Collections.Generic.Dictionary{System.String,System.Object},System.Boolean},System.IO.BinaryWriter)">
            <summary>
            This method supercedes the regular <see cref="M:JetBrains.Application.Settings.Storage.Persistence.ISettingsStorageEntriesSerialization.Save(System.Func{System.Collections.Generic.Dictionary{System.String,System.Object},System.Boolean})"/>. If you implement this method, and your caller understands the interface, you'll be called into this method and not into <see cref="M:JetBrains.Application.Settings.Storage.Persistence.ISettingsStorageEntriesSerialization.Save(System.Func{System.Collections.Generic.Dictionary{System.String,System.Object},System.Boolean})"/>.
            </summary>
            <param name="FSaveEntries">As in <see cref="M:JetBrains.Application.Settings.Storage.Persistence.ISettingsStorageEntriesSerialization.Save(System.Func{System.Collections.Generic.Dictionary{System.String,System.Object},System.Boolean})"/>. You must provide entries to this function.</param>
            <param name="writer">Specific to this method. Fast-save a binary cache presentation of your state in your own format so that to get it into <see cref="M:JetBrains.Application.Settings.Storage.Persistence.ISettingsStorageEntriesSerializationCached.FirstTimeLoadFromCache(System.Func{System.Collections.Generic.Dictionary{System.String,System.Object}},System.IO.BinaryReader)"/>.</param>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.SettingsStorageHiero.myChangeSinks">
            <summary>
            The object is for keying, to correctly process the case when the same action is added twice under different lifetimes. This might happen as we're sharing the same sinklist among all transactions.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.SettingsStorageHiero.myHierarchy">
            <summary>
            Root node in the hierarchical structure which stores all the data.
            The nodes are trie-like, by key path components.
            This root is a fake node (empty component value) with list of actual roots.
            RW-locked with <see cref="F:JetBrains.Application.Settings.Storage.SettingsStorageHiero.Hierarchy.LockHierarchy"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.SettingsStorageHiero.myInterned">
            <summary>
            Interns string contents of the path components.
            Being a concurrent dictionary, needs no additional locking.
            Maps any key to the interned version.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.SettingsStorageHiero.myLockChangeSinksWrite">
            <summary>
            Locks the <see cref="F:JetBrains.Application.Settings.Storage.SettingsStorageHiero.myChangeSinks"/> array modification.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.SettingsStorageHiero.myLockSerialization">
            <summary>
            Held while a save or load process is in progress to avoid runnnig one more in parallel.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.SettingsStorageHiero.CommitDiffToStream(System.Collections.Generic.Dictionary{JetBrains.Application.Settings.Storage.KeyPathComponents,System.Object},System.Collections.Generic.Dictionary{JetBrains.Application.Settings.Storage.KeyPathComponents,System.Object})">
            <summary>
              <para>Commits the diffs dictionary to the main dictionary, respecting recorded adds and removes.</para>
              <para>Normally is non-throwing.</para>
            </summary>
            <param name="main">Main dictionary. Will be overwritten by commit with changes from <paramref name="diff" />.</param>
            <param name="diff">Might be <c>Null</c> if there's no diff yet.</param>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.SettingsStorageHiero.BinarySerialization.Writer.WriteComponentPathDelta(JetBrains.Application.Settings.Storage.KeyPathComponents,JetBrains.Application.Settings.Storage.KeyPathComponents)">
            <summary>
            Updates <paramref name="componentsWriting"/> to match <paramref name="componentsNext"/>. Adds the operations to <see cref="F:JetBrains.Application.Settings.Storage.SettingsStorageHiero.BinarySerialization.Writer.myWriter"/>.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.Storage.SettingsStorageHiero.HNode">
            <summary>
            A node in the hierarchy tree.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.SettingsStorageHiero.HNode.#ctor(JetBrains.Application.Settings.Storage.KeyPathComponent)">
            <summary>
            A non-root node .ctor, component must be specified.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.SettingsStorageHiero.HNode.#ctor">
            <summary>
            Root node ctor, does not take a component.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.SettingsStorageHiero.HNode.Children">
            <summary>
            Child nodes.
            Operations: lookup by component (most often), enum, add/remove.
            Null until first filled. Currently never deleted back to Null.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.SettingsStorageHiero.HNode.Component">
            <summary>
            The key path component of this node.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.SettingsStorageHiero.HNode.IsFrozen">
            <summary>
            As a tree structure, the nodes trie can operate in the Copy-on-Write mode.
            This is useful for sharing the parts of the tree between transactions, without the need to always clone the whole tree.
            Frozen nodes are readonly forever and might be used for free-threaded reading regardless of the locks taken.
            The frozen state must always propagate to the bottom, and lifting the frozen state requires cloning the nodes up to the top.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.SettingsStorageHiero.HNode.ValueInMemoryDiff">
            <summary>
            The value of this node which is in effect.
            If there're any in-memory changes to this node which have not been saved, it's different from <see cref="F:JetBrains.Application.Settings.Storage.SettingsStorageHiero.HNode.ValueInStream"/> until the next save.
            If the storage is not dirty, it's the same as <see cref="F:JetBrains.Application.Settings.Storage.SettingsStorageHiero.HNode.ValueInStream"/>.
            All read/write APIs are operating with this value.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.SettingsStorageHiero.HNode.ValueInStream">
            <summary>
            Value of this node, as present in the serialization backend.
            <see cref="F:JetBrains.Application.Settings.Storage.SettingsStorageHiero.HNode.ValueInMemoryDiff"/> takes precedence.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.SettingsStorageHiero.HNode.CreateRootNode">
            <summary>
            Creates the root node (does not have a component specified).
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.SettingsStorageHiero.HNode.CloneCow">
            <summary>
            Does Copy-On-Write on the node. Re-mounts its children AS IS.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.SettingsStorageHiero.HNode.GetOrCreateChildren">
            <summary>
            Creates <see cref="F:JetBrains.Application.Settings.Storage.SettingsStorageHiero.HNode.Children"/> if missing, with the correct comparer.
            </summary>
            <returns></returns>
        </member>
        <member name="P:JetBrains.Application.Settings.Storage.SettingsStorageHiero.HNode.IsEmpty">
            <summary>
            Gets if this node is totally empty (no value or children).
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.SettingsStorageHiero.Hierarchy.LockHierarchy">
            <summary>
            Protects this hierarchy.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.SettingsStorageHiero.Hierarchy.RootNode">
            <summary>
            The root node of the hierarchy.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.SettingsStorageHiero.Hierarchy.SetCore(JetBrains.Application.Settings.Storage.KeyPathComponents,System.Object,JetBrains.Application.Settings.Storage.SettingsStorageHiero.Hierarchy.SetWhat,JetBrains.Application.Settings.Storage.SettingsStorageHiero.Hierarchy.Lock)">
            <summary>
            Implements the write.
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <param name="what"></param>
            <param name="locking"></param>
            <returns>Whether the effective value has changed.</returns>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.SettingsStorageHiero.Hierarchy.WalkWithCow(JetBrains.Application.Settings.Storage.SettingsStorageHiero.Hierarchy.Lock,System.Func{JetBrains.Application.Settings.Storage.KeyPathComponents,JetBrains.Application.Settings.Storage.SettingsStorageHiero.HNode,JetBrains.Application.Settings.Storage.SettingsStorageHiero.Hierarchy.WalkState})">
            <summary>
            Walks the nodes tree in a way which supports copy-on-write when needed.
            Your function is called on every descendant node, DFS.
            If you see that you should change the node, and the node is readonly, yield <see cref="F:JetBrains.Application.Settings.Storage.SettingsStorageHiero.Hierarchy.WalkState.CowNeeded"/> from the function. You'll be called once again on the writable clone of the node.
            If you make the node empty, it will be removed from the tree for you automatically.
            Note that you might be called more than once for some nodes (if we're retracing after making smth writable).
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.SettingsStorageHiero.Hierarchy.WalkWithCow(JetBrains.Application.Settings.Storage.KeyPathComponents,JetBrains.Application.Settings.Storage.SettingsStorageHiero.Hierarchy.Lock,System.Func{JetBrains.Application.Settings.Storage.KeyPathComponents,JetBrains.Application.Settings.Storage.SettingsStorageHiero.HNode,JetBrains.Application.Settings.Storage.SettingsStorageHiero.Hierarchy.WalkState})">
            <summary>
            Walks the nodes tree in a way which supports copy-on-write when needed.
            Your function is called on every descendant node, DFS.
            If you see that you should change the node, and the node is readonly, yield <see cref="F:JetBrains.Application.Settings.Storage.SettingsStorageHiero.Hierarchy.WalkState.CowNeeded"/> from the function. You'll be called once again on the writable clone of the node.
            If you make the node empty, it will be removed from the tree for you automatically.
            Note that you might be called more than once for some nodes (if we're retracing after making smth writable).
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.SettingsStorageHiero.Hierarchy.WalkWithCow(JetBrains.Application.Settings.Storage.KeyPathComponents,JetBrains.Application.Settings.Storage.SettingsStorageHiero.HNode,System.Collections.Generic.List{JetBrains.Application.Settings.Storage.SettingsStorageHiero.HNode},System.Func{JetBrains.Application.Settings.Storage.KeyPathComponents,JetBrains.Application.Settings.Storage.SettingsStorageHiero.HNode,JetBrains.Application.Settings.Storage.SettingsStorageHiero.Hierarchy.WalkState})">
            <summary>
            Walks the nodes tree in a way which supports copy-on-write when needed.
            Your function is called on every descendant node, DFS.
            If you see that you should change the node, and the node is readonly, yield <see cref="F:JetBrains.Application.Settings.Storage.SettingsStorageHiero.Hierarchy.WalkState.CowNeeded"/> from the function. You'll be called once again on the writable clone of the node.
            If you make the node empty, it will be removed from the tree for you automatically.
            Note that you might be called more than once for some nodes (if we're retracing after making smth writable).
            </summary>
            <param name="components">Key path of the current node, to call into the user callback. Modifiable.</param>
            <param name="node">Node to start the walk from (inclusive).</param>
            <param name="cache">Operations cache.</param>
            <param name="FWithNode">Your handling function.</param>
            <returns>If called from the rootmost node, always will be OK (as it's always writable). Otherwise, you must</returns>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.SettingsStorageHiero.Hierarchy.SetCore_AssertValidValueType(JetBrains.Application.Settings.Storage.KeyPathComponents,System.Object@)">
            <summary>
            We're limiting the set of value types which can be held in the storage, this method checks if the limit is obeyed.
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.SettingsStorageHiero.Hierarchy.WalkState.CowNeeded">
            <summary>
            When returned from a call, means “make my node writable and call once more with the same parameters”.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.Storage.ISettingsStorageTransactionData">
            <summary>
            An interface for settings storage transaction to talk to the storage in its transaction.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.ISettingsStorageTransactionData.Commit">
            <summary>
            Commits all of the in-transaction modifications.
            The transaction remains operable until its lifetime terminates.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.ISettingsStorageTransactionData.Revert">
            <summary>
            Reverts all of the in-transaction modifications.
            The transaction remains operable until its lifetime terminates.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Settings.Storage.ISettingsStorageTransactionData.Storage">
            <summary>
            <para>Gets the storage this transaction has been created for.</para>
            <para>Note that even though new <see cref="T:JetBrains.Application.Settings.Storage.ISettingsStorage"/> objects might be created to server the transaction, this is always the same object as the out-of-all-transactions storage.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.SettingsStorageHiero.TransactionData.InTransactionHierarchy">
            <summary>
            The transaction is currently implemented as one more storage which actually implements all reading &amp; writing. That's it.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.SettingsStorageHiero.TransactionData.OutOfTransactionStorage">
            <summary>
            The same storage, but outside all transaction. That's the interface which the outer world uses for accessing the storage.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.SettingsStorageHiero.TransactionData.OuterTransactionHierarchy">
            <summary>
            In case of nested transaction, the nearest outer storage (storage from the parent transaction). Otherwise, <see cref="F:JetBrains.Application.Settings.Storage.SettingsStorageHiero.TransactionData.OutOfTransactionStorage"/>.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.Storage.SettingsStorageHybrid">
            <summary>
            An implementation of the settings storage which natively operates on key-path-components and stores them in a flat hashtable, adding a trie for hierarchical lookup. The trie is employed used for child-enumerating needs, but has to be maintained by all write-operations.
            Its load &amp; save are externally driven in terms of entries (serialization formats are not this object's responsibility).
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.SettingsStorageHybrid.myFHierarchicalKeyPathComponentGetComponent">
            <summary>
            Cached binary search lookup delegate.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.SettingsStorageHybrid.myDiffToStream">
            <summary>
              <para><see cref="F:JetBrains.Application.Settings.Storage.SettingsStorageHybrid.myEntriesInStream"/> diff: what should be applied to the settings storage on save to ensure merging of the conflicts.</para>
              <para>Protected with <see cref="F:JetBrains.Application.Settings.Storage.SettingsStorageHybrid.myLockDiffToStream"/>.</para>
              <para>Set to <c>Null</c> when empty to enabled lock-free checks for the “no-dirty” state.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.SettingsStorageHybrid.myEntriesInStream">
            <summary>
              <para>The settings storage entries, as read from the persistent storage.</para>
              <para>Maps keys to values.</para>
              <para>In-memory changes are stored in <see cref="F:JetBrains.Application.Settings.Storage.SettingsStorageHybrid.myDiffToStream"/> until persisted to the storage.</para>
              <para>Protected with the <see cref="F:JetBrains.Application.Settings.Storage.SettingsStorageHybrid.myLockEntriesInStream"/>.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.SettingsStorageHybrid.myHierarchyRoot">
            <summary>
            Root node in the hierarchical structure which enables child enumeration on key paths.
            This root is a fake node (empty component value) with list of actual roots.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.SettingsStorageHybrid.myInterned">
            <summary>
            Interns string contents of the path components.
            Locked with <see cref="F:JetBrains.Application.Settings.Storage.SettingsStorageHybrid.myLockDiffToStream"/> (rational: we write-access diff-to-stream more often than entries-in-stream, and we do not need interneds apart from writing anyting =&gt; better reuse that lock).
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.SettingsStorageHybrid.myLockHierarchy">
            <summary>
            Locks access to the <see cref="F:JetBrains.Application.Settings.Storage.SettingsStorageHybrid.myHierarchyRoot"/> structure. It does not take parts in regular reads, so it's not RW-optimized.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.SettingsStorageHybrid.myLockSerialization">
            <summary>
            Held while a save or load process is in progress to avoid runnnig one more in parallel.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.SettingsStorageHybrid.CommitDiffToStream(System.Collections.Generic.Dictionary{JetBrains.Application.Settings.Storage.KeyPathComponents,System.Object},System.Collections.Generic.Dictionary{JetBrains.Application.Settings.Storage.KeyPathComponents,System.Object})">
            <summary>
              <para>Commits the diffs dictionary to the main dictionary, respecting recorded adds and removes.</para>
              <para>Normally is non-throwing.</para>
            </summary>
            <param name="main">Main dictionary. Will be overwritten by commit with changes from <paramref name="diff" />.</param>
            <param name="diff">Might be <c>Null</c> if there's no diff yet.</param>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.SettingsStorageHybrid.GetOrCreateHierarchyRoot">
            <summary>
            Gets the hierarchy root, if there's an up-to-date version available.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.SettingsStorageHybrid.HierarchyAddKey(JetBrains.Application.Settings.Storage.KeyPathComponents)">
            <summary>
            Ensures the key exists in the hierarchy. Requires an outer lock.
            </summary>
            <param name="components"></param>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.SettingsStorageHybrid.HierarchyRemoveKey(JetBrains.Application.Settings.Storage.KeyPathComponents)">
            <summary>
            Ensures the key does not exist in the hierarchy. Requires an outer lock.
            </summary>
            <param name="components"></param>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.SettingsStorageHybrid.OnUpdateHierarchy(JetBrains.Application.Settings.Storage.SettingsStorageChangeArgs)">
            <summary>
            Some settings have changed in the dictionary storage.
            Update the hierarchy to stay in sync.
            Note that this happens out of the dictionary storage lock, so the hierarchy state is out of sync at times.
            The consideration is that in absence of external synchronization we're not able to observe the difference in clients, and concurrent changes are not a problem because in this handler we'd be always updating hierarchy to the up-to-date
            </summary>
            <param name="args"></param>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.SettingsStorageHybrid.SetBatchWithDiffWriteLocked(System.Collections.Generic.ICollection{System.Collections.Generic.KeyValuePair{JetBrains.Application.Settings.Storage.KeyPathComponents,System.Object}},System.Collections.Generic.List{JetBrains.Application.Settings.Storage.KeyPathComponents})">
            <summary>
            Does a batch-set to the out-of-transaction storage when committing a transaction.
            Writer lock on diff-to-stream must be held by the caller.
            </summary>
            <param name="items">Transaction changes to apply.</param>
            <param name="keysChanged">Keys which were changed by the batch-change must be written here.</param>
        </member>
        <member name="T:JetBrains.Application.Settings.Storage.SettingsStorageHybrid.HierarchicalKeyPathComponent">
            <summary>
            A node in the tree which maintains the keys hierarchy to speed up children enumerations.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.SettingsStorageHybrid.HierarchicalKeyPathComponent.IsDefined">
            <summary>
            True on nodes which are terminal in some key path component paths.
            False if the node is there just for holding some children, but does not correspond to any actual nodes in the dictionary storage.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.SettingsStorageHybrid.TransactionData.InTransactionStorage">
            <summary>
            The transaction is currently implemented as one more storage which actually implements all reading &amp; writing. That's it.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.SettingsStorageHybrid.TransactionData.OutOfTransactionStorage">
            <summary>
            The same storage, but outside all transaction. That's the interface which the outer world uses for accessing the storage.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.SettingsStorageHybrid.TransactionData.OuterTransactionStorage">
            <summary>
            In case of nested transaction, the nearest outer storage (storage from the parent transaction). Otherwise, <see cref="F:JetBrains.Application.Settings.Storage.SettingsStorageHybrid.TransactionData.OutOfTransactionStorage"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.SettingsStorageFactory.CreateStorage(JetBrains.DataFlow.Lifetime,System.String,JetBrains.Util.ILogger,JetBrains.Application.Settings.Storage.InternKeyPathComponent)">
            <summary>
            Creates the currently-preferred impl of the storage.
            </summary>
            <param name="lifetime"></param>
            <param name="name"></param>
            <param name="logger"></param>
            <param name="interned"></param>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Application.Settings.Storage.SettingsStorageFlat">
            <summary>
            An implementation of the settings storage which natively operates on key-path-components and stores them in a flat hashtable.
            Its load &amp; save are externally driven in terms of entries (serialization formats are not this object's responsibility).
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.SettingsStorageFlat.myDiffToStream">
            <summary>
            <para><see cref="F:JetBrains.Application.Settings.Storage.SettingsStorageFlat.myEntriesInStream"/> diff: what should be applied to the settings storage on save to ensure merging of the conflicts.</para>
            <para>Protected with <see cref="F:JetBrains.Application.Settings.Storage.SettingsStorageFlat.myLockDiffToStream"/>.</para>
            <para>Set to <c>Null</c> when empty to enabled lock-free checks for the “no-dirty” state.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.SettingsStorageFlat.myEntriesInStream">
            <summary>
            <para>The settings storage entries, as read from the persistent storage.</para>
            <para>Maps keys to values.</para>
            <para>In-memory changes are stored in <see cref="F:JetBrains.Application.Settings.Storage.SettingsStorageFlat.myDiffToStream"/> until persisted to the storage.</para>
            <para>Protected with the <see cref="F:JetBrains.Application.Settings.Storage.SettingsStorageFlat.myLockEntriesInStream"/>.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.SettingsStorageFlat.myLockSerialization">
            <summary>
            Held while a save or load process is in progress to avoid running one more in parallel.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.SettingsStorageFlat.myInterned">
            <summary>
            Interns string contents of the path components.
            Locked with <see cref="F:JetBrains.Application.Settings.Storage.SettingsStorageFlat.myLockDiffToStream"/> (rational: we write-access diff-to-stream more often than entries-in-stream, and we do not need interneds apart from writing anyting =&gt; better reuse that lock).
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.SettingsStorageFlat.myCacheChildLevel2Enumerations">
            <summary>
            <para>Caches enumeration of level-2 children (Enum() with nTakeChildLevelOnly=2, which is a common case for enumerating settings store indexed keys/entries).</para>
            <para>Locked with <see cref="F:JetBrains.Application.Settings.Storage.SettingsStorageFlat.myLockCacheChildLevel2Enumerations"/>.</para>
            <para>Invalidated by any write to the second level or any massive change to storage, filled by Enum() when it encounters a cache miss.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.SettingsStorageFlat.myLockCacheChildLevel2Enumerations">
            <summary>
            Locks access to the dictionary only, its member classes have their own locking.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.SettingsStorageFlat.CommitDiffToStream(System.Collections.Generic.Dictionary{JetBrains.Application.Settings.Storage.KeyPathComponents,System.Object},System.Collections.Generic.Dictionary{JetBrains.Application.Settings.Storage.KeyPathComponents,System.Object})">
            <summary>
            <para>Commits the diffs dictionary to the main dictionary, respecting recorded adds and removes.</para>
            <para>Normally is non-throwing.</para>
            </summary>
            <param name="main">Main dictionary. Will be overwritten by commit with changes from <paramref name="diff"/>.</param>
            <param name="diff">Might be <c>Null</c> if there's no diff yet.</param>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.SettingsStorageFlat.SetBatchWithDiffWriteLocked(System.Collections.Generic.ICollection{System.Collections.Generic.KeyValuePair{JetBrains.Application.Settings.Storage.KeyPathComponents,System.Object}},System.Collections.Generic.List{JetBrains.Application.Settings.Storage.KeyPathComponents})">
            <summary>
            Does a batch-set to the out-of-transaction storage when committing a transaction.
            Writer lock on diff-to-stream must be held by the caller.
            </summary>
            <param name="items">Transaction changes to apply.</param>
            <param name="keysChanged">Keys which were changed by the batch-change must be written here.</param>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.SettingsStorageFlat.TransactionData.InTransactionStorage">
            <summary>
            The transaction is currently implemented as one more storage which actually implements all reading &amp; writing. That's it.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.SettingsStorageFlat.TransactionData.OuterTransactionStorage">
            <summary>
            In case of nested transaction, the nearest outer storage (storage from the parent transaction). Otherwise, <see cref="F:JetBrains.Application.Settings.Storage.SettingsStorageFlat.TransactionData.OutOfTransactionStorage"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.SettingsStorageFlat.TransactionData.OutOfTransactionStorage">
            <summary>
            The same storage, but outside all transaction. That's the interface which the outer world uses for accessing the storage.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.Storage.SettingsStorageLoadFlag">
            <summary>
            When storage is loaded from the external source, varies its behavior.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.SettingsStorageLoadFlag.FirstTime">
            <summary>
            The storage contents is dropped, no events are fired for newly-loaded items.
            Good for first-time loading of the storage.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.SettingsStorageLoadFlag.SecondTime">
            <summary>
            Applies diff from the source, fires all of the events appropriate.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.Storage.DefaultFileStorages.GlobalPerProductStorage">
            <summary>
            User settings: the storage serving the Global context, specific to the current product.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.Storage.FileSettingsStorageProviderBase">
            <summary>
            Helper class for registering a single file-based storage and a single mounting point with the Settings Store.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.FileSettingsStorageProviderBase.XmlFileStorage">
            <summary>
            The file-based storage (along with serialization) created by this component. Its <see cref="F:JetBrains.Application.Settings.Storage.Persistence.XmlFileSettingsStorage.Storage"/> property is promoted to the <see cref="T:JetBrains.Application.Settings.Store.Implementation.SettingsStore"/> under the <see cref="F:JetBrains.Application.Settings.Storage.FileSettingsStorageProviderBase.MountPoint"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.FileSettingsStorageProviderBase.MountPoint">
            <summary>
            The mounting point for the storage created by this component and promoted to the <see cref="T:JetBrains.Application.Settings.Store.Implementation.SettingsStore"/>.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.Storage.DefaultFileStorages.GlobalSettings">
            <summary>
            Helpers for working with global settings layers (per-product and all-products).
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.DefaultFileStorages.GlobalSettings.ProductGlobalLayerId">
            <summary>
            <para>Identifies the This-Product-Global-Settings <see cref="T:JetBrains.Application.Settings.UserInterface.UserFriendlySettingsLayer">user-friendly settings layer</see>.</para>
            <para>To get the layer, obtain or create a <see cref="T:JetBrains.Application.Settings.UserInterface.UserFriendlySettingsLayers"/> instance and ask it for the layer by its ID.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.DefaultFileStorages.GlobalSettings.BindForWritingToAllProducts">
            <summary>
            Binds <see cref="T:JetBrains.Application.Settings.Store.Implementation.SettingsStore"/> to the application-wide context so that writes were SmartSaved to the All-Products Settings layer (affecting any higher-priority writable layers if they contain conflicting values).
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.DefaultFileStorages.GlobalSettings.BindForSmartWritingToReadonlyContext(JetBrains.Application.Settings.ISettingsStore,JetBrains.Application.Settings.ISettingsStorageMountPoint,JetBrains.Application.Settings.ContextRange)">
            <summary>
            Helper function for binding to a smart-save context which turns the specified readonly mount into a writable one and specifies it as the last-wide-context-mount (which means that no writes will go to lower-priority layers, and higher-priority layers will be updated to agree to the setting being written).
            </summary>
            <param name="store"></param>
            <param name="mountReadonly"></param>
            <param name="contextrangeWithReadonlyMount"></param>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Application.Settings.Storage.ContentSubstring">
            <summary>
            Packs character ranges in string content of a <see cref="T:JetBrains.Application.Settings.Storage.KeyPathComponent"/> into a single DWORD.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.ContentSubstring.RawOffset">
            <summary>
            Offset of content.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.ContentSubstring.RawLengthPlus1">
            <summary>
            Length of content, plus <c>1</c>, if defined.
            If <c>0</c>, then the content length is unlimied (take up to the end). This is the default value in the structure.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.ContentSubstring.RawValue">
            <summary>
            The union of offset and length.
            <c>0</c> means the substring is not limited and the content should be taken as the whole string.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Settings.Storage.ContentSubstring.IsWhole">
            <summary>
            Whether the whole content should be taken.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Settings.Storage.ContentSubstring.Whole">
            <summary>
            Gets a content substring for getting whole content.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.Storage.KeyPathComponent">
            <summary>
            A single entry in the storage key path contained in <see cref="T:JetBrains.Application.Settings.Storage.KeyPathComponents"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.KeyPathComponent.Content">
            <summary>
            String content providing the path component as a substring.
            If <c>Null</c>, then this object is in an uninitialized state (semantically <c>Null</c>).
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.KeyPathComponent.ContentSubstring">
            <summary>
            Defines which substring of the <see cref="F:JetBrains.Application.Settings.Storage.KeyPathComponent.Content"/> should be used.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.KeyPathComponent.ContentPrefix">
            <summary>
            Optional character prefix of the path component, prepended to the substring of <see cref="F:JetBrains.Application.Settings.Storage.KeyPathComponent.Content"/>.
            <c>0</c> for no prefix.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.KeyPathComponent.EqualityComparer">
            <summary>
            A generic equality comparer. Use it with data structures if you would like to avoid boxing on any comparer operation.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.KeyPathComponent.GetPathComponentSlow">
            <summary>
            Renders the content substring and the prefix as a string. Might do substrings and concatenation, so is possibly slow.
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.KeyPathComponent.Write(System.Text.StringBuilder)">
            <summary>
            Writes self into a stringbuilder. Does not create any intermediate strings, but writing to a stringbuilder is not too good in mem/perf anyway.
            </summary>
            <param name="sb"></param>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.KeyPathComponent.AsNormalized(JetBrains.Application.Settings.Storage.KeyPathComponent)">
            <summary>
            Normalizes the component for interning, so that the optimal representation of the component were stored.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.Storage.KeyPathComponents">
            <summary>
            A list of <see cref="T:JetBrains.Application.Settings.Storage.KeyPathComponent"/> objects which constitute a settings storage key path.
            The path is operated as splitted into <see cref="F:JetBrains.Application.Settings.Storage.KeyPathComponents.PathSeparatorChar"/>-splitted components because in most use cases it's composed from such components based on the context of access.
            When path originates as components, this allows to avoid concatenating strings for lookup.
            When path originates as a whole string, the components are pointing into character ranges within that string instead of actually creating substrings, so this scenario does not have memory penalty anyway.
            This class is a typed wrapper for a list of components.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.KeyPathComponents.Components">
            <summary>
            The list of components. Might be <c>Null</c> when this struct is just created, so take care.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.KeyPathComponents.Parse(System.String)">
            <summary>
            Parses a set of components over a string.
            There is always at least one component.
            Leading and trailing slashes are ignored, any other slashes separate components, even if zero-length.
            Components are pointing into character ranges within <paramref name="s"/> instead of creating substrings.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.KeyPathComponents.ParseInterned(System.String,JetBrains.Util.DataStructures.ChunkHashSet{JetBrains.Application.Settings.Storage.KeyPathComponent})">
            <summary>
            Parses a set of components over a string following some invariants: certain chars are prefetched into prefix, and the strings are interned.
            There is always at least one component.
            Leading and trailing slashes are ignored, any other slashes separate components, even if zero-length.
            Components are created over individual strings, which are interned.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.KeyPathComponents.RenderToStringSlow(System.Boolean)">
            <summary>
            The reverse to <see cref="M:JetBrains.Application.Settings.Storage.KeyPathComponents.Parse(System.String)"/>, should not be using in practice because it actually writes everything into a string-builder.
            Leading slash is an option, trailing slash is never added.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.KeyPathComponents.Intern(JetBrains.Util.DataStructures.ChunkHashSet{JetBrains.Application.Settings.Storage.KeyPathComponent})">
            <summary>
            Interns strings in all path components.
            </summary>
            <param name="interneds"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.KeyPathComponents.Clone">
            <summary>
            Even though this wrapper is a structure (to save on allocating an object), the list of path components inside is a reference object, so it will be shared when this value is passed along.
            If you'd like to persist the value you have received, you have to clone the list.
            </summary>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Application.Settings.Storage.Substring">
            <summary>
            A structure which adds one DWORD to the string pointer to identify a substring within a string without acyually producing the truncated string.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.Substring.CommitToString">
            <summary>
            Applies offset and length to get the substring.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.Storage.Persistence.FileSettingsStorageBehavior">
            <summary>
            Modifies behavior of the settings storages on the filesystem.
            The fully-functional implementation to use with real storages.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.Storage.Persistence.IFileSettingsStorageBehavior">
            <summary>
            Modifies behavior of the settings storages on the filesystem.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.Persistence.IFileSettingsStorageBehavior.QueryEditFile(JetBrains.Util.FileSystemPath)">
            <summary>
              <para>Request environment (like integrated SCC in the VS) if the file can be modified.</para>
              <para>Can only be called on the main thread.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Application.Settings.Storage.Persistence.IFileSettingsStorageBehavior.DiskOperationSuppression">
            <summary>
            Add a token here to prevent file settings storages from being loaded from disk.
            This also suppresses save because saving a non-loaded storage would destroy the data.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Settings.Storage.Persistence.IFileSettingsStorageBehavior.IsDiskOperationAllowed">
            <summary>
            You should not be loading from disk or saving to disk if this is <c>False</c>.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Settings.Storage.Persistence.IFileSettingsStorageBehavior.IsSaveToDiskAllowed">
            <summary>
            You should not be saving to disk if this is <c>False</c>. Note that when <see cref="P:JetBrains.Application.Settings.Storage.Persistence.IFileSettingsStorageBehavior.IsDiskOperationAllowed"/> gets <c>False</c>, this property also gets <c>False</c> automatically.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Settings.Storage.Persistence.IFileSettingsStorageBehavior.Logger">
            <summary>
            All settings-related logging should go into this logger.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Settings.Storage.Persistence.IFileSettingsStorageBehavior.SaveToDiskSuppression">
            <summary>
            Add a token here to prevent file settings storages from being saved to disk.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.Persistence.FileSettingsStorageBehavior.QueryEditFile(JetBrains.Util.FileSystemPath)">
            <summary>
              <para>Request environment (like integrated SCC in the VS) if the file can be modified.</para>
              <para>Can only be called on the main thread.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Application.Settings.Storage.Persistence.FileSettingsStorageBehavior.DiskOperationSuppression">
            <summary>
            Add a token here to prevent file settings storages from being loaded from disk.
            This also suppresses save because saving a non-loaded storage would destroy the data.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Settings.Storage.Persistence.FileSettingsStorageBehavior.IsDiskOperationAllowed">
            <summary>
            You should not be loading from disk or saving to disk if this is <c>False</c>.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Settings.Storage.Persistence.FileSettingsStorageBehavior.IsSaveToDiskAllowed">
            <summary>
            You should not be saving to disk if this is <c>False</c>. Note that when <see cref="P:JetBrains.Application.Settings.Storage.Persistence.FileSettingsStorageBehavior.IsDiskOperationAllowed"/> gets <c>False</c>, this property also gets <c>False</c> automatically.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Settings.Storage.Persistence.FileSettingsStorageBehavior.Logger">
            <summary>
            All settings-related logging should go into this logger.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Settings.Storage.Persistence.FileSettingsStorageBehavior.SaveToDiskSuppression">
            <summary>
            Add a token here to prevent file settings storages from being saved to disk.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.Storage.ISettingsStorageTransactionContext">
            <summary>
            <para>Denotes a transaction opened over a group of <see cref="T:JetBrains.Application.Settings.Storage.ISettingsStorage"/> objects.</para>
            <para>To create a new transaction, you create an instance of this interface and add storages to it (or access storages passing them the new context, which also adds them to the transaction).</para> 
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.ISettingsStorageTransactionContext.AttachStorages(System.Collections.Generic.IEnumerable{JetBrains.Application.Settings.Storage.ISettingsStorage})">
            <summary>
            <para>Adds storages to the transaction. It's OK to pass storages which are already in this transaction, or to pass the same storage multiple times.</para>
            <para>Calling storage APIs with this transaction context without adding them to the transaction first is also OK, but in such a case the read-repeatable isolation starts working upon the fist call. Invoking this method on all the storages of interest begins read-repeatable on them.</para>
            </summary>
            <param name="storages"></param>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.ISettingsStorageTransactionContext.RevertAllStorages">
            <summary>
            Reverts all of the in-transaction modifications.
            The transaction remains operable until its lifetime terminates.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.ISettingsStorageTransactionContext.CommitAllStorages">
            <summary>
            Commits all of the in-transaction modifications.
            The transaction remains operable until its lifetime terminates.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.ISettingsStorageTransactionContext.GetTransactionData``1(JetBrains.Application.Settings.Storage.ISettingsStorage)">
            <summary>
            Helper method for the storages themselves. Gives them the per-storage-per-transaction data associated with this transaction.
            </summary>
            <typeparam name="TData"></typeparam>
            <param name="storage"></param>
            <returns></returns>
        </member>
        <member name="P:JetBrains.Application.Settings.Storage.ISettingsStorageTransactionContext.Name">
            <summary>
            A name to tell transactions apart.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.Storage.SettingsStorageProvidersCollection">
            <summary>
            <para>Normally, you should export <see cref="T:JetBrains.Application.Settings.IProvider`1"/> interfaces of <see cref="T:JetBrains.Application.Settings.Storage.ISettingsStorage"/> and <see cref="T:JetBrains.Application.Settings.ISettingsStorageMountPoint"/> on your component so that they became available to the Settings Store.</para>
            <para>In case this is undesirable, those storages and mounts can be added to the items collections on this class to be exposed on behalf of this class.</para>
            </summary>
            <remarks>Currently, this is the only way to expose storages/mounts from child containers (like Solution/Project) to the shell-level container, because child containers won't be traversed for interfaces.</remarks>
        </member>
        <member name="P:JetBrains.Application.Settings.Storage.SettingsStorageProvidersCollection.Storages">
            <summary>
            Live collection of storages. Exposed to the shell-level component container.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Settings.Storage.SettingsStorageProvidersCollection.MountPoints">
            <summary>
            Live collection of mounting points. Exposed to the shell-level component container.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.Storage.SettingsStorageTransactionContext">
            <summary>
            Default implementation for <see cref="T:JetBrains.Application.Settings.Storage.ISettingsStorageTransactionContext"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.SettingsStorageTransactionContext.#ctor(JetBrains.DataFlow.Lifetime,System.String,JetBrains.Application.Settings.Storage.ISettingsStorageTransactionContext,JetBrains.Util.ILogger)">
            <summary>
            Creates a new empty transaction context without storages in it. You may call <see cref="M:JetBrains.Application.Settings.Storage.ISettingsStorageTransactionContext.AttachStorages(System.Collections.Generic.IEnumerable{JetBrains.Application.Settings.Storage.ISettingsStorage})"/> then (see method documentation).
            </summary>
            <param name="lifetime">Transaction lifetime. All of the uncommitted changes will be reverted. It's not necessary to call <see cref="M:JetBrains.Application.Settings.Storage.ISettingsStorageTransactionContext.RevertAllStorages"/> explicitly.</param>
            <param name="name"><see cref="P:JetBrains.Application.Settings.Storage.ISettingsStorageTransactionContext.Name"/>.</param>
            <param name="transactionOuter">If this is a nested transaction, identifies the outer transaction.</param>
            <param name="logger"></param>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.SettingsStorageTransactionContext.myMapStorageToTransactionData">
            <summary>
            Copy-on-write, so has lock-free read access.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.SettingsStorageHelpers.AssertValidLocalName(System.String)">
            <summary>
            The storage key string (full name) is a slash-separated list of local names. Each local name must comply with the identified rules (Ll,Lu,Lt,Lo,Lm,Nd,Pc).
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.SettingsStorageHelpers.IsValidLocalName(System.String,JetBrains.Util.OnError)">
            <summary>
            The storage key string (full name) is a slash-separated list of local names. Each local name must comply with the identified rules (Ll,Lu,Lt,Lo,Lm,Nd,Pc).
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.SettingsStorageHelpers.ValueEquals(System.Object,System.Object)">
            <summary>
              <para>Value “equals” to take possible byte arrays into account.</para>
              <para>Possible raw storage value types include a few primitive POD types, strings, and byte arrays. The latter need some special Equals handling.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.SettingsStorageHelpers.ResolveAutoSerializer(JetBrains.Application.Settings.SettingsStoreSerializerType,JetBrains.Util.dataStructures.Sources.StringSource)">
            <summary>
            If the serializer choice (<paramref name="serializer"/>) is <see cref="F:JetBrains.Application.Settings.SettingsStoreSerializerType.Auto"/>, picks a specific serializer based on the actual value type (<paramref name="sTypeFullName"/>). Otherwise, returns the serializer choice AS IS.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.SettingsStorageHelpers.GetSettingsStorageSerializedType(JetBrains.Util.dataStructures.Sources.StringSource,JetBrains.Application.Settings.SettingsStoreSerializerType)">
            <summary>
            <para>Gets the type by which this entry would be represented in the settings key-value storage.</para>
            <para>The settings store only supports primitive types; complex ones are serialized, and their storage type depends on the particular serializer used.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.SettingsStorageHelpers.CoerceEntryDefaultValueToRuntimeType(System.Object,System.Type,JetBrains.Util.ILogger)">
            <summary>
            <para>When a value has to be specified on an attribute, its type is limited to primitive types. Also, the primitive types might not match if an integer is specified where a floating-point type is expected.</para>
            <para>Conversion logic: basically, it's the <see cref="M:JetBrains.Extension.TypeEx.CoercePrimitiveValueToType(System.Object,System.Type,JetBrains.Util.ILogger)"/>, but with the addition that the default value for a string is <c>""</c> instead of <c>NULL</c> (because generally settings entries only store non-<c>NULL</c> values).</para>
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.SettingsStorageHelpers.GetStorageDefaultValue(JetBrains.Application.Settings.Storage.SettingsStorageHelpers.StorageValueTypeId)">
            <summary>
            Gets an object with a default non-<c>Null</c> value for the given storage type (e.g. it'd be an empty string and an empty blob instead of <c>Null</c>s).
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.Logging.ISettingsLogger">
            <summary>
            <para>Gets the logger to be used within the Settings subsystem.</para>
            <para>Assertions and algorithm consistency failures are reported to the central logging system immediately, while the outer-world and user-data exceptions are considered nonfatal and somewhat not quite unexpected in the real life, so they're stored for reading on request.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Application.Settings.Logging.ISettingsLogger.Logger">
            <summary>
            <para>Gets the logger to be used within the Settings subsystem.</para>
            <para>Assertions and algorithm consistency failures are reported to the central logging system immediately, while the outer-world and user-data exceptions are considered nonfatal and somewhat not quite unexpected in the real life, so they're stored for reading on request.</para>
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.Logging.SettingsLogging">
            <summary>
            Intercepts all of the exceptions in the Settings subsystem and treats them specially.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Settings.Logging.SettingsLogging.CollectedSettingsExceptions">
            <summary>
            <para>Gets the logger which is collecting outer-world failures in exceptions (like invalid data file format). </para>
            <para>Note that, unlike <see cref="P:JetBrains.Application.Settings.Logging.ISettingsLogger.Logger"/>, this member is not overridable. If an inheritor is replacing the logger, its exceptions will not be tracked by this object.</para>
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.Logging.WrapLoggerForSettings">
            <summary>
            When you're passing your own logger to the Settings subsystem, wraps it and exposes as the proper interface.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.Storage.Persistence.IFileSettingsStorageBehaviorProvider">
            <summary>
            Allows to publish behavior flag from your component instead of adding them to <see cref="T:JetBrains.Application.Settings.Storage.Persistence.FileSettingsStorageBehavior"/>. This way, your class is implicitly imported into <see cref="T:JetBrains.Application.Settings.Storage.Persistence.FileSettingsStorageBehavior"/> rather than the other way, which guarantees that all other clients of <see cref="T:JetBrains.Application.Settings.Storage.Persistence.FileSettingsStorageBehavior"/> get your all-time suppressions from the very beginning.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.Persistence.IFileSettingsStorageBehaviorProvider.Bind(JetBrains.DataFlow.Lifetime,JetBrains.Application.Settings.Storage.Persistence.IFileSettingsStorageBehavior)">
            <summary>
            Do the modifications to the behavior in this method, or remember the value to manipulate further on your state changes.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.Persistence.IFileSettingsStorageBehaviorProvider.QueryEditFile(JetBrains.Util.FileSystemPath)">
            <summary>
              <para>Request environment (like integrated SCC in the VS) if the file can be modified.</para>
              <para>Can only be called on the main thread.</para>
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.Storage.Persistence.MockFileSettingsStorageBehavior">
            <summary>
            Special implementation for simple one-time storages.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.Storage.Persistence.SettingsStorageBinaryCache">
            <summary>
            Helps with binary caching of the XML settings storages content.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.Persistence.SettingsStorageBinaryCache.CreateWriterOnStream(System.IO.Stream)">
            <summary>
            Creates a writer with all of the parameters (e.g. encoding must match when reading and writing).
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.Persistence.SettingsStorageBinaryCache.TryGetCachedStorageReader(JetBrains.Application.Settings.Storage.Persistence.SettingsStorageBinaryCache.StorageCacheIdentity,JetBrains.Util.ILogger)">
            <summary>
            On the first load, try reading the cached binary representation of the settings file, if exists.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.Persistence.SettingsStorageBinaryCache.CleanupCachedStorage(JetBrains.Application.Settings.Storage.Persistence.SettingsStorageBinaryCache.StorageCacheIdentity,JetBrains.Util.ILogger)">
            <summary>
            Deletes the storage disk file once the caller finds it necessary.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.Persistence.SettingsStorageBinaryCache.StorageCacheIdentity.CreateFromFileProperty(JetBrains.DataFlow.IProperty{JetBrains.Util.FileSystemPath},JetBrains.Util.ILogger)">
            <summary>
            Same as <see cref="M:JetBrains.Application.Settings.Storage.Persistence.SettingsStorageBinaryCache.StorageCacheIdentity.TryCreateFromFile(JetBrains.Util.FileSystemPath,JetBrains.Util.ILogger)"/>, but for a long-run.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.Storage.Persistence.SettingsStorageXmlStreamSerializationWithBinaryCaching">
            <summary>
            Operates over <see cref="T:JetBrains.Application.Settings.Storage.Persistence.ISettingsStorageEntriesSerialization"/> (whose serialization works on entries' in-memory representation). Uses <see cref="T:JetBrains.Application.Settings.Storage.Persistence.EntriesReader"/> and <see cref="T:JetBrains.Application.Settings.Storage.Persistence.EntriesWriter"/> to convert it into XML serialization over the given stream.
            Supports the binary cache to avoid re-parsing the XML stream on each run, if the storage implements <see cref="T:JetBrains.Application.Settings.Storage.Persistence.ISettingsStorageEntriesSerializationCached"/>.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.Storage.Persistence.SettingsStorageXmlStreamSerializationWithBinaryCaching.LoadResult">
            <summary>
            Reports results of the <see cref="M:JetBrains.Application.Settings.Storage.Persistence.SettingsStorageXmlStreamSerializationWithBinaryCaching.Load(JetBrains.Application.Settings.Storage.SettingsStorageLoadFlag,System.Action{System.Action{System.IO.Stream}},JetBrains.Application.Settings.Storage.Persistence.SettingsStorageBinaryCache.StorageCacheIdentity,JetBrains.Util.ILogger)"/> function.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.Persistence.SettingsStorageXmlStreamSerializationWithBinaryCaching.LoadResult.LoadSource">
            <summary>
            Where the loaded data came from.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.Storage.Persistence.SettingsStorageXmlStreamSerializationWithBinaryCaching.LoadSource">
            <summary>
            Where the loaded data came from.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.Persistence.SettingsStorageXmlStreamSerializationWithBinaryCaching.LoadSource.None">
            <summary>
            There was no data (e.g. XML file did not exist on disk).
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.Persistence.SettingsStorageXmlStreamSerializationWithBinaryCaching.LoadSource.XmlStream">
            <summary>
            Parsed the XML stream.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.Persistence.SettingsStorageXmlStreamSerializationWithBinaryCaching.LoadSource.BinaryCache">
            <summary>
            Got an up-to-date binary cache for the source and executed treebuilding off it.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.Persistence.SettingsStorageXmlStreamSerializationWithBinaryCaching.SaveResult.EntriesWriterResult">
            <summary>
            Gets the result of writing the XML form of the storage.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.Persistence.SettingsStorageXmlStreamSerializationWithBinaryCaching.SaveResult.FlushBinaryCache">
            <summary>
            Call to flush the binary cache (when the identity is already known, which only happens after the XML stream is saved successfully to disk and gets its final timestamp and file length, but the lock is not released yet).
            </summary>
        </member>
        <member name="T:JetBrains.Application.src.Settings.ContextBoundSettingsStore">
            <summary>
            <para>Provides access to the <see cref="P:JetBrains.Application.src.Settings.ContextBoundSettingsStore.SettingsStore"/> in terms of <see cref="T:JetBrains.Application.Settings.SettingsEntry"/>/<see cref="T:JetBrains.Application.Settings.SettingsKey"/> API idioms, and in a specific context (global, per-solution, etc).</para>
            <para>Read operations consider settings coming from all of the “parent” contexts (for example, solution context includes global settings).</para>
            <para>Write operations would always contribute to the shallowest context possible. In most cases you should use the SmartSave feature through the <see cref="!:IBiContextBoundSettingsStore"/> interface.</para>
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.IContextBoundSettingsStore">
            <summary>
            Operates the same <see cref="T:JetBrains.Application.Settings.SettingsEntry"/>/<see cref="T:JetBrains.Application.Settings.SettingsKey"/> API idioms as <see cref="P:JetBrains.Application.Settings.IContextBoundSettingsStore.SettingsStore"/>, but is bound to the specific context (which is defined by <see cref="T:JetBrains.Application.Settings.Store.Implementation.SettingsStorageOnMountPoints"/> with specific mounts selected).
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.IContextBoundSettingsStore.GetValue(JetBrains.Application.Settings.SettingsScalarEntry,System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object})">
            <summary>
            <para>Gets the value of a non-indexed settings entry.</para>
            <para>Note that you will always get a meaningful value (the entry default value), even if the entry value has not been set, or if the entry parent key does not exist (if there's no instance for such indexed key index). If you're reading entries of an indexed key or its ancestors, verify that key instance exists first.</para>
            </summary>
            <param name="entry">The settigs entry whose value is to be read.</param>
            <param name="keyIndices">If this entry is parented by one or more indexed keys, the indices to those keys. It is an error to have an index omitted for an indexed key.</param>
            <returns>The value, as set in the highest-priority storage which is not restricted for overriding. The settings entry default value otherwise (<c>Null</c> if not available).</returns>
        </member>
        <member name="M:JetBrains.Application.Settings.IContextBoundSettingsStore.GetValues(System.Collections.Generic.IList{JetBrains.Application.Settings.SettingsScalarEntry},System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object})">
            <summary>
            Executes <see cref="M:JetBrains.Application.Settings.IContextBoundSettingsStore.GetValue(JetBrains.Application.Settings.SettingsScalarEntry,System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object})"/> for a series of entries in a row, which has performance benefits over getting them one by one.
            All of the entries must belong to the same key.
            For all details, see <see cref="M:JetBrains.Application.Settings.IContextBoundSettingsStore.GetValue(JetBrains.Application.Settings.SettingsScalarEntry,System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object})"/>.
            </summary>
            <param name="entries">Entries of the single key.</param>
            <param name="keyIndices">If this entry is parented by one or more indexed keys, the indices to those keys. It is an error to have an index omitted for an indexed key.</param>
            <returns>An array of values of the same length as <see cref="!:entries"/> where each value corresponds to the entry at the same index. See <see cref="M:JetBrains.Application.Settings.IContextBoundSettingsStore.GetValue(JetBrains.Application.Settings.SettingsScalarEntry,System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object})"/> for details on the entry values returned.</returns>
        </member>
        <member name="M:JetBrains.Application.Settings.IContextBoundSettingsStore.SetValue(JetBrains.Application.Settings.SettingsScalarEntry,System.Object,System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object})">
            <summary>
            <para>Sets the value of a non-indexed settings entry.</para>
            </summary>
            <param name="entry">The settigs entry whose value is to be written.</param>
            <param name="value">The value to be written. Must be of the CLR type specified in the settings entry.</param>
            <param name="keyIndices">If this entry is parented by one or more indexed keys, the indices to those keys. It is an error to have an index omitted for an indexed key.</param>
        </member>
        <member name="M:JetBrains.Application.Settings.IContextBoundSettingsStore.ResetValue(JetBrains.Application.Settings.SettingsScalarEntry,System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object})">
            <summary>
            <para>Resets the value of a non-indexed settings entry in the highest-priority storage. It will have the value in the next storage or the entry default value.</para>
            </summary>
            <param name="entry">The settigs entry whose value is to be read.</param>
            <param name="keyIndices">If this entry is parented by one or more indexed keys, the indices to those keys. It is an error to have an index omitted for an indexed key.</param>
        </member>
        <member name="M:JetBrains.Application.Settings.IContextBoundSettingsStore.GetIndexedValue(JetBrains.Application.Settings.SettingsIndexedEntry,System.Object,System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object})">
            <summary>
            <para>Gets the value of an indexed settings entry.</para>
            </summary>
            <param name="entry">The settigs entry, the value of whose indexed instance is to be read.</param>
            <param name="entryIndex">An index to the indexed entry instance.</param>
            <param name="keyIndices">If this entry is parented by one or more indexed keys, the indices to those keys. It is an error to have an index omitted for an indexed key.</param>
            <returns>The value, as set in the highest-priority storage which is not restricted for overriding. The settings entry default value otherwise (<c>Null</c> if not available).</returns>
        </member>
        <member name="M:JetBrains.Application.Settings.IContextBoundSettingsStore.SetIndexedValue(JetBrains.Application.Settings.SettingsIndexedEntry,System.Object,System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object},System.Object)">
            <summary>
            <para>Sets the value of an indexed settings entry.</para>
            </summary>
            <param name="entry">The settigs entry, the value of whose indexed instance is to be written.</param>
            <param name="entryIndex">An index to the indexed entry instance.</param>
            <param name="keyIndices">If this entry is parented by one or more indexed keys, the indices to those keys. It is an error to have an index omitted for an indexed key.</param>
            <param name="value">The value to be written. Must be of the CLR type specified in the settings entry.</param>
        </member>
        <member name="M:JetBrains.Application.Settings.IContextBoundSettingsStore.RemoveIndexedValue(JetBrains.Application.Settings.SettingsIndexedEntry,System.Object,System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object})">
            <summary>
            <para>Removes the value of an indexed settings entry.</para>
            </summary>
            <param name="entry">The settigs entry, whose indexed instance is to be removed.</param>
            <param name="entryIndex">An index to the indexed entry instance.</param>
            <param name="keyIndices">If this entry is parented by one or more indexed keys, the indices to those keys. It is an error to have an index omitted for an indexed key.</param>
        </member>
        <member name="M:JetBrains.Application.Settings.IContextBoundSettingsStore.CreateIndexedKey(JetBrains.Application.Settings.SettingsIndexedKey,System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object})">
            <summary>
            <para>Ensures that the instance of an indexed key is marked as created in the highest-priority storage of the current context.</para>
            <para>This accounts for these two basic scenarios:</para>
            <para>• Create an instance of the key which has all of its entries in their default values (without setting any entries on the key).</para>
            <para>• Mark an instance of an indexed key inherited from a lower-priority storage as defined in this higher-priority storage so that it were available even when the lower-priority storage is removed.</para>
            <para>In most other cases, like when you're setting entries on an indexed key, the indexed key instance will be reported as existing in the current combination of layers (the existence status might be coming from a lower-priority storage).</para>
            </summary>
            <param name="key">Indexed settings key to create an instance of.</param>
            <param name="keyIndices">An index to the <paramref name="key"/> to be created, as well as indices to any parent indexed keys of <paramref name="key"/>.</param>
        </member>
        <member name="M:JetBrains.Application.Settings.IContextBoundSettingsStore.DeleteIndexedKey(JetBrains.Application.Settings.SettingsIndexedKey,System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object})">
            <summary>
            <para>Ensures that the instance of an indexed key does not exist anymore in the current layered context.</para>
            <para>All data for this key index is wiped from the highest-priority storage.</para>
            <para>If the key still remains defined because of some lower-priority storage, a special revocation flag is written to the highest-priority storage.</para>
            </summary>
            <param name="key">Indexed settings key to delete an instance of.</param>
            <param name="keyIndices">An index to the <paramref name="key"/> to be deleted, as well as indices to any parent indexed keys of <paramref name="key"/>.</param>
        </member>
        <member name="M:JetBrains.Application.Settings.IContextBoundSettingsStore.IsIndexedKeyDefined(JetBrains.Application.Settings.SettingsKey,System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object})">
            <summary>
            <para>Gets whether the instance of an indexed key for particular index is defined in the current layered context.</para>
            <para>Also checks all possible parent indexed keys of this key, and their indices in <paramref name="keyIndices"/>.</para>
            <para>It is valid to pass in a non-indexed key as <paramref name="key"/>, in which case its indexed ancestor keys will be checked. If there are none, the key is always assumed as defined.</para>
            </summary>
            <param name="key">Indexed settings key to check. Might be a non-indexed key iteself to check its possible indexed parents.</param>
            <param name="keyIndices">An index to the <paramref name="key"/> to be deleted, as well as indices to any parent indexed keys of <paramref name="key"/>. Note that this can be <c>Null</c> if you're testing an arbitrary settings key without checking if it's indexed or not first.</param>
        </member>
        <member name="M:JetBrains.Application.Settings.IContextBoundSettingsStore.GetSnapshot(JetBrains.Application.Settings.SettingsKey,System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object})">
            <summary>
            Gets the snapshot of the Settings Store content in a form of Settings Key and Settings Entry instances.
            </summary>
            <param name="keyRoot">Optional. If <c>Null</c>, the whole store available in this context is dumped. If non-<c>Null</c>, only those values under the given schema key are included.</param>
            <param name="keyIndices">Optional. Indices to <paramref name="keyRoot"/>, if it's specified.</param>
            <returns>Delta with extracted settings store values.</returns>
        </member>
        <member name="M:JetBrains.Application.Settings.IContextBoundSettingsStore.EnumIndexedValues(JetBrains.Application.Settings.SettingsIndexedEntry,System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object})">
            <summary>Enumerates all of the indices of the defined entry indexed value instances, and those values.</summary>
            <param name="entry">Identifies the indexed entry.</param>
            <param name="keyIndices">If this entry is parented by one or more indexed keys, the indices to those keys. It is an error to have an index omitted for an indexed key.</param>
            <returns>An enumeration of the index objects. The CLR type of these objects is defined by the settings entry declaration.</returns>
        </member>
        <member name="M:JetBrains.Application.Settings.IContextBoundSettingsStore.EnumIndexedKey(JetBrains.Application.Settings.SettingsIndexedKey,System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object},System.Boolean)">
            <summary>
            <para>Gives out all of the indexed key indices currently present in the store.</para>
            <para>Note that checking <see cref="M:JetBrains.Application.Settings.IContextBoundSettingsStore.IsIndexedKeyDefined(JetBrains.Application.Settings.SettingsKey,System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object})"/> by some of these indices might actually return <c>False</c> due to:</para> 
            <para>• Multithreaded access to the setings store.</para>
            </summary>
            <param name="key">Identifies the indexed key.</param>
            <param name="parentKeyIndices">If this key is parented by one or more indexed keys, the indices to those keys. It is an error to have an index omitted for an indexed key. Note that this should not include the index to the <paramref name="key"/> itself because its possible indices are to be enumerated, but it's not an error if it's present.</param>
            <param name="isIgnoringKeyIsDefined"></param>
            <returns>An enumeration of the index objects. The CLR type of these objects is defined in the settings key attribute.</returns>
        </member>
        <member name="P:JetBrains.Application.Settings.IContextBoundSettingsStore.InvolvedMountPoints">
            <summary>
            Enumerates the mount points which take part in this context.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Settings.IContextBoundSettingsStore.IsIgnoringReadonlyFlag">
            <summary>
            Set to <c>True</c> to write to just any mounts, without looking for one which is <see cref="P:JetBrains.Application.Settings.ISettingsStorageMountPoint.Flags"/>.
            The default is <c>False</c>.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Settings.IContextBoundSettingsStore.SettingsStore">
            <summary>
            Gets the parent Settings Store which has been bound to the context.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Settings.IContextBoundSettingsStore.Schema">
            <summary>
            Gets the Settings Schema of the parent settings store.
            </summary>
        </member>
        <member name="M:JetBrains.Application.src.Settings.ContextBoundSettingsStore.#ctor(JetBrains.DataFlow.Lifetime,JetBrains.Application.Settings.Store.Implementation.SettingsStorageOnMountPoints,JetBrains.Application.Settings.ISettingsStore,JetBrains.Application.Settings.Storage.ISettingsStorageTransactionContext)">
            <summary>
            Ctor.
            </summary>
            <param name="lifetimeLimit">This is not the lifetime of this object. It's rather a limiting lifetime to check that we're not operational after it terminates.</param>
            <param name="storageLayered">Mounts selected for the current context.</param>
            <param name="store">Parent settings store.</param>
            <param name="transaction"></param>
        </member>
        <member name="M:JetBrains.Application.src.Settings.ContextBoundSettingsStore.GetValue(JetBrains.Application.Settings.SettingsScalarEntry,System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object})">
            <summary>
            <para>Gets the value of a non-indexed settings entry.</para>
            <para>Note that you will always get a meaningful value (the entry default value), even if the entry value has not been set, or if the entry parent key does not exist (if there's no instance for such indexed key index). If you're reading entries of an indexed key or its ancestors, verify that key instance exists first.</para>
            </summary>
            <param name="entry">The settigs entry whose value is to be read.</param>
            <param name="keyIndices">If this entry is parented by one or more indexed keys, the indices to those keys. It is an error to have an index omitted for an indexed key.</param>
            <returns>The value, as set in the highest-priority storage which is not restricted for overriding. The settings entry default value otherwise (<c>Null</c> if not available).</returns>
        </member>
        <member name="M:JetBrains.Application.src.Settings.ContextBoundSettingsStore.SetValue(JetBrains.Application.Settings.SettingsScalarEntry,System.Object,System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object})">
            <summary>
            <para>Sets the value of a non-indexed settings entry.</para>
            </summary>
            <param name="entry">The settigs entry whose value is to be written.</param>
            <param name="value">The value to be written. Must be of the CLR type specified in the settings entry.</param>
            <param name="keyIndices">If this entry is parented by one or more indexed keys, the indices to those keys. It is an error to have an index omitted for an indexed key.</param>
        </member>
        <member name="M:JetBrains.Application.src.Settings.ContextBoundSettingsStore.ResetValue(JetBrains.Application.Settings.SettingsScalarEntry,System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object})">
            <summary>
            <para>Resets the value of a non-indexed settings entry in the highest-priority storage. It will have the value in the next storage or the entry default value.</para>
            </summary>
            <param name="entry">The settigs entry whose value is to be read.</param>
            <param name="keyIndices">If this entry is parented by one or more indexed keys, the indices to those keys. It is an error to have an index omitted for an indexed key.</param>
        </member>
        <member name="M:JetBrains.Application.src.Settings.ContextBoundSettingsStore.GetIndexedValue(JetBrains.Application.Settings.SettingsIndexedEntry,System.Object,System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object})">
            <summary>
            <para>Gets the value of an indexed settings entry.</para>
            </summary>
            <param name="entry">The settigs entry, the value of whose indexed instance is to be read.</param>
            <param name="entryIndex">An index to the indexed entry instance.</param>
            <param name="keyIndices">If this entry is parented by one or more indexed keys, the indices to those keys. It is an error to have an index omitted for an indexed key.</param>
            <returns>The value, as set in the highest-priority storage which is not restricted for overriding. The settings entry default value otherwise (<c>Null</c> if not available).</returns>
        </member>
        <member name="M:JetBrains.Application.src.Settings.ContextBoundSettingsStore.SetIndexedValue(JetBrains.Application.Settings.SettingsIndexedEntry,System.Object,System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object},System.Object)">
            <summary>
            <para>Sets the value of an indexed settings entry.</para>
            </summary>
            <param name="entry">The settigs entry, the value of whose indexed instance is to be written.</param>
            <param name="entryIndex">An index to the indexed entry instance.</param>
            <param name="keyIndices">If this entry is parented by one or more indexed keys, the indices to those keys. It is an error to have an index omitted for an indexed key.</param>
            <param name="value">The value to be written. Must be of the CLR type specified in the settings entry.</param>
        </member>
        <member name="M:JetBrains.Application.src.Settings.ContextBoundSettingsStore.RemoveIndexedValue(JetBrains.Application.Settings.SettingsIndexedEntry,System.Object,System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object})">
            <summary>
            <para>Removes the value of an indexed settings entry.</para>
            </summary>
            <param name="entry">The settigs entry, whose indexed instance is to be removed.</param>
            <param name="entryIndex">An index to the indexed entry instance.</param>
            <param name="keyIndices">If this entry is parented by one or more indexed keys, the indices to those keys. It is an error to have an index omitted for an indexed key.</param>
        </member>
        <member name="M:JetBrains.Application.src.Settings.ContextBoundSettingsStore.EnumEntryIndices(JetBrains.Application.Settings.SettingsIndexedEntry,System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object})">
            <summary>
            <para>Gives out all of the indexed entry indices currently present in the store.</para>
            <para>Note that reading indexed entry values by some of these indices might actually return <c>Null</c> due to:</para> 
            <para>• Multithreaded access to the setings store.</para>
            <para>• Some technical info leftovers present in the store under this index, but not the actual value.</para>
            <para>• The entry indexed value is set in a base layer and then removed in a higher-priority layer, in which case the removal technical entry will report the index as present, but the actual value will be missing.</para>
            </summary>
            <param name="entry">Identifies the indexed entry.</param>
            <param name="keyIndices">If this entry is parented by one or more indexed keys, the indices to those keys. It is an error to have an index omitted for an indexed key.</param>
            <returns>An enumeration of the index objects. The CLR type of these objects is defined by the settings entry declaration.</returns>
        </member>
        <member name="M:JetBrains.Application.src.Settings.ContextBoundSettingsStore.EnumKeyIndices(JetBrains.Application.Settings.SettingsIndexedKey,System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object})">
            <summary>
            <para>Gives out all of the indexed key indices currently present in the store.</para>
            <para>Note that checking <see cref="M:JetBrains.Application.src.Settings.ContextBoundSettingsStore.IsIndexedKeyDefined(JetBrains.Application.Settings.SettingsKey,System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object})"/> by some of these indices might actually return <c>False</c> due to:</para> 
            <para>• Multithreaded access to the setings store.</para>
            <para>• Some technical info leftovers present in the store under this index, but not the actual value.</para>
            <para>• The key indexed instance is defined in a base layer and then removed in a higher-priority layer, in which case the removal technical record will report the index as present, but the actual key instance will be missing.</para>
            <para>• You're enumerating indices to an indexed key which is a descendant of another indexed key instance which is not defined itself.</para>
            </summary>
            <param name="key">Identifies the indexed key.</param>
            <param name="parentKeyIndices">If this key is parented by one or more indexed keys, the indices to those keys. It is an error to have an index omitted for an indexed key. Note that this should not include the index to the <paramref name="key"/> itself because its possible indices are to be enumerated, but it's not an error if it's present.</param>
            <returns>An enumeration of the index objects. The CLR type of these objects is defined in the settings key attribute.</returns>
        </member>
        <member name="M:JetBrains.Application.src.Settings.ContextBoundSettingsStore.CreateIndexedKey(JetBrains.Application.Settings.SettingsIndexedKey,System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object})">
            <summary>
            <para>Ensures that the instance of an indexed key is marked as created in the highest-priority storage of the current context.</para>
            <para>This accounts for these two basic scenarios:</para>
            <para>• Create an instance of the key which has all of its entries in their default values (without setting any entries on the key).</para>
            <para>• Mark an instance of an indexed key inherited from a lower-priority storage as defined in this higher-priority storage so that it were available even when the lower-priority storage is removed.</para>
            <para>In most other cases, like when you're setting entries on an indexed key, the indexed key instance will be reported as existing in the current combination of layers (the existence status might be coming from a lower-priority storage).</para>
            </summary>
            <param name="key">Indexed settings key to create an instance of.</param>
            <param name="keyIndices">An index to the <paramref name="key"/> to be created, as well as indices to any parent indexed keys of <paramref name="key"/>.</param>
        </member>
        <member name="M:JetBrains.Application.src.Settings.ContextBoundSettingsStore.DeleteIndexedKey(JetBrains.Application.Settings.SettingsIndexedKey,System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object})">
            <summary>
            <para>Ensures that the instance of an indexed key does not exist anymore in the current layered context.</para>
            <para>All data for this key index is wiped from the highest-priority storage.</para>
            <para>If the key still remains defined because of some lower-priority storage, a special revocation flag is written to the highest-priority storage.</para>
            </summary>
            <param name="key">Indexed settings key to delete an instance of.</param>
            <param name="keyIndices">An index to the <paramref name="key"/> to be deleted, as well as indices to any parent indexed keys of <paramref name="key"/>.</param>
        </member>
        <member name="M:JetBrains.Application.src.Settings.ContextBoundSettingsStore.IsIndexedKeyDefined(JetBrains.Application.Settings.SettingsKey,System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object})">
            <summary>
            <para>Gets whether the instance of an indexed key for particular index is defined in the current layered context.</para>
            <para>Also checks all possible parent indexed keys of this key, and their indices in <paramref name="keyIndices"/>.</para>
            <para>It is valid to pass in a non-indexed key as <paramref name="key"/>, in which case its indexed ancestor keys will be checked. If there are none, the key is always assumed as defined.</para>
            </summary>
            <param name="key">Indexed settings key to check. Might be a non-indexed key iteself to check its possible indexed parents.</param>
            <param name="keyIndices">An index to the <paramref name="key"/> to be deleted, as well as indices to any parent indexed keys of <paramref name="key"/>. Note that this can be <c>Null</c> if you're testing an arbitrary settings key without checking if it's indexed or not first.</param>
        </member>
        <member name="T:JetBrains.Application.src.Settings.ContextBoundSettingsStore.IndexedEntryAccess">
            <summary>
            Algorithms for indexed entry/key operations.
            </summary>
        </member>
        <member name="M:JetBrains.Application.src.Settings.ContextBoundSettingsStore.IndexedEntryAccess.EnumChildIndicesSerialized(System.String,JetBrains.Application.Settings.Store.Implementation.SettingsStorageOnMountPoints,JetBrains.Application.Settings.Storage.ISettingsStorageTransactionContext)">
            <summary>
            Helper for enumerating mapping keys of map-entry or mapped-key.
            Given the storage key of the mapping, parses out the serialized values of the mapping keys (queries for child keys, strips off '=', removes duplicates).
            </summary>
        </member>
        <member name="M:JetBrains.Application.src.Settings.ContextBoundSettingsStore.IndexedEntryAccess.GetIndexedEntryValue(JetBrains.Application.Settings.SettingsIndexedEntry,JetBrains.Application.Settings.Store.Implementation.SettingsStorageOnMountPoints,JetBrains.Application.src.Settings.ContextBoundSettingsStore.IndexedEntryAccess.StorageKeyPrefixForIndexedValueAttrs,JetBrains.Application.Settings.Storage.ISettingsStorageTransactionContext,JetBrains.Util.IExceptionThrowingLogger)">
            <summary>
            Indexed entry value reader (gets come storage key info precached).
            Supports indexed entry values removal in higher-priority layers.
            </summary>
        </member>
        <member name="M:JetBrains.Application.src.Settings.ContextBoundSettingsStore.IndexedEntryAccess.SetIndexedValue(JetBrains.Application.Settings.SettingsIndexedEntry,System.Object,System.Object,JetBrains.Application.Settings.Store.Implementation.SettingsStorageOnMountPoints,System.Boolean,JetBrains.Application.src.Settings.ContextBoundSettingsStore.IndexedEntryAccess.StorageKeyPrefixForIndexedValueAttrs,System.Boolean,JetBrains.Application.Settings.Storage.ISettingsStorageTransactionContext)">
            <summary>
            Indexed entry value writer (gets come storage key info precached).
            Supports indexed entry values removal in higher-priority layers.
            </summary>
        </member>
        <member name="M:JetBrains.Application.src.Settings.ContextBoundSettingsStore.IndexedEntryAccess.RemoveIndexedValue(JetBrains.Application.Settings.SettingsIndexedEntry,System.Object,JetBrains.Application.Settings.Store.Implementation.SettingsStorageOnMountPoints,JetBrains.Application.src.Settings.ContextBoundSettingsStore.IndexedEntryAccess.StorageKeyPrefixForIndexedValueAttrs,System.Boolean,JetBrains.Application.Settings.Storage.ISettingsStorageTransactionContext,JetBrains.Util.IExceptionThrowingLogger)">
            <summary>
            Indexed entry instance eraser (gets come storage key info precached).
            Supports indexed entry values removal in higher-priority layers.
            </summary>
        </member>
        <member name="T:JetBrains.Application.src.Settings.ContextBoundSettingsStore.IndexedEntryAccess.StorageKeyPrefixForIndexedValueAttrs">
            <summary>
            Prepares the storage key prefix for addressing settings storage attributes of an indexed entry.
            This includes path to the entry storage key plus serialized index in the special format plus an at sign which begins the attribute local name.
            </summary>
        </member>
        <member name="F:JetBrains.Application.src.Settings.ContextBoundSettingsStore.IndexedEntryAccess.StorageKeyPrefixForIndexedValueAttrs.Prefix">
            <summary>
            Append attribute name => you got storage key to attribute on an indexed entry instance.
            </summary>
        </member>
        <member name="M:JetBrains.Application.src.Settings.ContextBoundSettingsStore.IndexedEntryAccess.StorageKeyPrefixForIndexedValueAttrs.#ctor(JetBrains.Application.Settings.SettingsIndexedEntry,System.Object,System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object})">
            <summary>
            Prepares the storage key prefix for addressing settings storage attributes of an indexed entry.
            This includes path to the entry storage key plus serialized index in the special format plus an at sign which begins the attribute local name.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.IIndexedEntry`2.SnapshotAndFreeze">
            <summary>
            Prefetches all indexed values from the store (=snapshot) and stops reading from the actual store (=freeze).
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Store.IndexedEntry`2.myStore">
            <summary>
            Non-<c>Null</c> when live, <c>Null</c>ed when we get snapshot&amp;frozen.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Store.IndexedEntry`2.mySnapshot">
            <summary>
            <c>Null</c> until we do a snapshot.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.IndexedEntry`2.SnapshotAndFreeze">
            <summary>
            Prefetches all indexed values from the store (=snapshot) and stops reading from the actual store (=freeze).
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.ISettingsOptimization">
            <summary>
            Attaches key getting/setting to the instance of this object to enable caching of some data required for speedup.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.ISettingsOptimization.GetKey(JetBrains.Application.Settings.IContextBoundSettingsStore,JetBrains.Application.Settings.SettingsKey,System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object})">
            <summary>
            <para>Gets the values of all of the settings key's entries and returns them in a settings key class.</para>
            <para>This is always non-<c>Null</c> for a simple (non-indexed) key whose parents are also all simple. If there's no data on that key in the storage, default values will be returned for all of its entries.</para>
            <para>For an indexed key, or a key with an indexed ancestor, this will be <c>Null</c> if no instance is defined for the particular index value specified in <see cref="!:keyIndices"/>.</para>
            </summary>
            <param name="store"></param>
            <param name="key">The settigs key to be read.</param>
            <param name="keyIndices">If this key is parented by one or more indexed keys or is indexed itself, the indices to those keys. It is an error to have an index omitted for an indexed key.</param>
            <returns>An instance of the key class with non-indeexed entries read with <see cref="M:JetBrains.Application.Settings.IContextBoundSettingsStore.GetValue(JetBrains.Application.Settings.SettingsScalarEntry,System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object})"/> and indexed entries exposed as with <see cref="M:JetBrains.Application.Settings.SettingsStoreEx.CreateIndexedEntryAccess(JetBrains.Application.Settings.IContextBoundSettingsStore,JetBrains.Application.Settings.SettingsIndexedEntry,System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object},JetBrains.Util.ILogger)"/>.</returns>
        </member>
        <member name="M:JetBrains.Application.Settings.ISettingsOptimization.SetKey(JetBrains.Application.Settings.IContextBoundSettingsStore,JetBrains.Application.Settings.SettingsKey,System.Object,System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object})">
            <summary>
            <para> Stores the values of all of the settings key's scalar entries.</para>
            <para> It's semantic is equivalent to calling <see cref="M:JetBrains.Application.Settings.IContextBoundSettingsStore.SetValue(JetBrains.Application.Settings.SettingsScalarEntry,System.Object,System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object})"/> for each scalar entry of the key. </para>
            <param name="key">The settigs key to be written.</param>
            <param name="value">The value to be written. Must be of the CLR type specified in the settings entry</param>
            <param name="keyIndices">If <paramref name="key"/> is indexed itself or is parented by one or more indexed keys, the indices to those keys. It is an error to have an index omitted for an indexed key.</param>
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.ISettingsStorageMountPointEx.MountGetObsolete(JetBrains.Application.Settings.ISettingsStorageMountPoint,System.String,JetBrains.Application.Settings.Storage.ISettingsStorageTransactionContext)">
            <summary>
            Accesses the mounted settings storage taking its mounting path into account.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.ISettingsStorageMountPointEx.MountGetRaw(JetBrains.Application.Settings.ISettingsStorageMountPoint,JetBrains.Application.Settings.Storage.KeyPathComponents,JetBrains.Application.Settings.Storage.ISettingsStorageTransactionContext,JetBrains.Util.ILogger)">
            <summary>
            Accesses the mounted settings storage taking its mounting path into account.
            <paramref name="keyPathComponentsWithEmptySlot"/> must be specifically prepared for calling this method.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.ISettingsStorageMountPointEx.MountGetSlow(JetBrains.Application.Settings.ISettingsStorageMountPoint,JetBrains.Application.Settings.Storage.KeyPathComponents,JetBrains.Application.Settings.Storage.ISettingsStorageTransactionContext,JetBrains.Util.ILogger)">
            <summary>
            Accesses the mounted settings storage taking its mounting path into account.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.ISettingsStorageMountPointEx.MountSetObsolete(JetBrains.Application.Settings.ISettingsStorageMountPoint,System.String,System.Object,JetBrains.Application.Settings.Storage.ISettingsStorageTransactionContext)">
            <summary>
            Accesses the mounted settings storage taking its mounting path into account.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.ISettingsStorageMountPointEx.MountSetRaw(JetBrains.Application.Settings.ISettingsStorageMountPoint,JetBrains.Application.Settings.Storage.KeyPathComponents,System.Object,JetBrains.Application.Settings.Storage.ISettingsStorageTransactionContext,JetBrains.Util.ILogger)">
            <summary>
            Accesses the mounted settings storage taking its mounting path into account.
            <paramref name="keyPathComponentsWithEmptySlot"/> must be specifically prepared for calling this method.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.ISettingsStorageMountPointEx.MountEraseRaw(JetBrains.Application.Settings.ISettingsStorageMountPoint,JetBrains.Application.Settings.Storage.KeyPathComponents,JetBrains.Application.Settings.Storage.ISettingsStorageTransactionContext,JetBrains.Util.ILogger)">
            <summary>
            Accesses the mounted settings storage taking its mounting path into account.
            <paramref name="keyPathComponentsWithEmptySlot"/> must be specifically prepared for calling this method.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.ISettingsStorageMountPointEx.MountSetSlow(JetBrains.Application.Settings.ISettingsStorageMountPoint,JetBrains.Application.Settings.Storage.KeyPathComponents,System.Object,JetBrains.Application.Settings.Storage.ISettingsStorageTransactionContext,JetBrains.Util.ILogger)">
            <summary>
            Accesses the mounted settings storage taking its mounting path into account.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.ISettingsStorageMountPointEx.MountEnumKeysObsolete(JetBrains.Application.Settings.ISettingsStorageMountPoint,System.String,JetBrains.Application.Settings.Storage.ISettingsStorageTransactionContext)">
            <summary>
            Accesses the mounted settings storage taking its mounting path into account.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.ISettingsStorageMountPointEx.MountEnumRaw(JetBrains.Application.Settings.ISettingsStorageMountPoint,JetBrains.Application.Settings.Storage.KeyPathComponents,System.Int32,System.Action{JetBrains.Application.Settings.Storage.KeyPathComponents,System.Object},JetBrains.Application.Settings.Storage.ISettingsStorageTransactionContext,JetBrains.Util.ILogger)">
            <summary>
            Accesses the mounted settings storage taking its mounting path into account.
            NOTE: for enumerating the whole mount, your key path must contain exactly the first NULL component
            NOTE: the key MIGHT contain mountpaht in the first component when your callback is invoked.
            <paramref name="keyPathComponentsWithEmptySlot"/> must be specifically prepared for calling this method.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.ISettingsStorageMountPointEx.MountEnumSlow(JetBrains.Application.Settings.ISettingsStorageMountPoint,JetBrains.Application.Settings.Storage.KeyPathComponents,System.Int32,System.Action{JetBrains.Application.Settings.Storage.KeyPathComponents,System.Object},JetBrains.Application.Settings.Storage.ISettingsStorageTransactionContext,JetBrains.Util.ILogger)">
            <summary>
            Accesses the mounted settings storage taking its mounting path into account.
            NOTE: for enumerating the whole mount, your key path must contain exactly the first NULL component
            NOTE: the key MIGHT contain mountpaht in the first component when your callback is invoked.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.ISettingsStorageMountPointEx.MountCopyTo(JetBrains.Application.Settings.ISettingsStorageMountPoint,JetBrains.Application.Settings.ISettingsStorageMountPoint,JetBrains.Application.Settings.Storage.ISettingsStorageTransactionContext,JetBrains.Application.Settings.Storage.ISettingsStorageTransactionContext,JetBrains.Util.ILogger,System.String)">
            <summary>
            Copies the contents of the mounting point as raw storage physical data (the part of the storage mounted under this mount point).
            </summary>
            <param name="transactionTarget"></param>
            <param name="logger"></param>
            <param name="sRootKey">Optional. If only a part of the mounting point's contents should be copied, specifies the root key of the data to copy. If <c>Null</c> or an empty string, the whole storage under the mounting path will be copied.</param>
            <param name="thіs"></param>
            <param name="target"></param>
            <param name="transactionThis"></param>
        </member>
        <member name="M:JetBrains.Application.Settings.ISettingsStorageMountPointEx.MountErase(JetBrains.Application.Settings.ISettingsStorageMountPoint,JetBrains.Application.Settings.Storage.ISettingsStorageTransactionContext,JetBrains.Util.ILogger)">
            <summary>
            Erases all of the storage contents under the mounting point.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.ISettingsStorageMountPointEx.MountEraseSubtreeSlow(JetBrains.Application.Settings.ISettingsStorageMountPoint,JetBrains.Application.Settings.Storage.KeyPathComponents,JetBrains.Application.Settings.Storage.ISettingsStorageTransactionContext,JetBrains.Util.ILogger)">
            <summary>
            Erases all of the storage contents under the mounting point.
            </summary>
            <param name="mount"></param>
            <param name="keyPathComponentsExact">NULL or empty to erase the whole mounted content. A specific path to erase all the content under it.</param>
            <param name="transaction"></param>
            <param name="logger"></param>
        </member>
        <member name="M:JetBrains.Application.Settings.ISettingsStorageMountPointEx.MountEraseSubtreeRaw(JetBrains.Application.Settings.ISettingsStorageMountPoint,JetBrains.Application.Settings.Storage.KeyPathComponents,JetBrains.Application.Settings.Storage.ISettingsStorageTransactionContext,JetBrains.Util.ILogger)">
            <summary>
            Erases all of the storage contents under the mounting point.
            </summary>
            <param name="mount"></param>
            <param name="keyPathComponentsWithEmptySlot">Empty (but for the placeholder) to erase the whole mounted content. A specific path to erase all the content under it.</param>
            <param name="transaction"></param>
            <param name="logger"></param>
        </member>
        <member name="T:JetBrains.Application.Settings.ListWithoutPrefix`1">
            <summary>
            Wraps the list so that it appears as if missing one first item.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.ListWithPrefix`1">
            <summary>
            Wraps the list so that it appears as if having one extra first item.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.SettingsOptimization.DoMeSlowly">
            <summary>
            <para>Gets the dummy implementation which does not do any optimizations.</para>
            <para>This is a placeholder. In performance-critical real-life uses, import <see cref="T:JetBrains.Application.Settings.ISettingsOptimization"/> from your container and use this instance in place of this parameter.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.SettingsOptimization.OptimizeDefault">
            <summary>
            Gets the default static optimization cache.
            It is still preferrable to import the optimization as a component.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.SettingsStoreChangeArgsEx_Visit.VisitContext">
            <summary>
            Pass params thru hierarchy in a special class to save stack space when recursing.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.SettingsStoreEx.ResetValue``2(JetBrains.Application.Settings.IContextBoundSettingsStore,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object})">
            <summary>
            Resets the value in the most concrete store of the given context.
            The local value in the store will be removed. A value from one of the underlying stores, if any, will be used. If none, the default value will be used.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.SettingsStoreEx.ResetValue``1(JetBrains.Application.Settings.ISettingsStore,JetBrains.Application.DataContext.IDataContext,System.Linq.Expressions.Expression{System.Func{``0,System.Object}},System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object})">
            <summary>
            Resets the value in the most concrete store of the given context.
            The local value in the store will be removed. A value from one of the underlying stores, if any, will be used. If none, the default value will be used.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.SettingsStoreEx.ResetValue``1(JetBrains.Application.Settings.ISettingsStore,System.Func{JetBrains.DataFlow.Lifetime,JetBrains.Application.DataContext.DataContexts,JetBrains.Application.DataContext.IDataContext},System.Linq.Expressions.Expression{System.Func{``0,System.Object}},System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object})">
            <summary>
            Resets the value in the most concrete store of the given context.
            The local value in the store will be removed. A value from one of the underlying stores, if any, will be used. If none, the default value will be used.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.SettingsStoreEx.ResetValue(JetBrains.Application.Settings.ISettingsStore,JetBrains.Application.DataContext.IDataContext,JetBrains.Application.Settings.SettingsScalarEntry,System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object})">
            <summary>
            Resets the value in the most concrete store of the given context.
            The local value in the store will be removed. A value from one of the underlying stores, if any, will be used. If none, the default value will be used.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.SettingsStoreEx.CreateIndexedEntryAccess(JetBrains.Application.Settings.IContextBoundSettingsStore,JetBrains.Application.Settings.SettingsIndexedEntry,System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object},JetBrains.Util.ILogger)">
            <summary>
            Creates a dictionary-like object for reading indexed entry values by index.
            </summary>
            <param name="thіs"></param>
            <param name="entry">The settigs entry, the value of whose indexed instance is to be read.</param>
            <param name="keyIndices">If this entry is parented by one or more indexed keys, the indices to those keys. It is an error to have an index omitted for an indexed key.</param>
            <param name="logger"></param>
            <returns>An <see cref="T:JetBrains.Application.Settings.Store.IIndexedEntry`2"/> object.</returns>
        </member>
        <member name="M:JetBrains.Application.Settings.SettingsStoreEx.BoundToContextForTemporaryChanges(JetBrains.Application.Settings.ISettingsStore,JetBrains.DataFlow.Lifetime,JetBrains.Application.DataContext.IDataContext,JetBrains.Application.Settings.Storage.InternKeyPathComponent)">
            <summary>
            Creates Settings store binded to the provided context and adds extra mount point with highest priority for handling write operations.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.SettingsStoreEx.CreateIndexedKey``1(JetBrains.Application.Settings.IContextBoundSettingsStore,System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object})">
            <summary>
            <para>Ensures that the instance of an indexed key is marked as created in the highest-priority storage of the current context.</para>
            <para>This accounts for these two basic scenarios:</para>
            <para>• Create an instance of the key which has all of its entries in their default values (without setting any entries on the key).</para>
            <para>• Mark an instance of an indexed key inherited from a lower-priority storage as defined in this higher-priority storage so that it were available even when the lower-priority storage is removed.</para>
            <para>In most other cases, like when you're setting entries on an indexed key, the indexed key instance will be reported as existing in the current combination of layers (the existence status might be coming from a lower-priority storage).</para>
            </summary>
            <param name="thіs"></param>
            <param name="keyIndices">An index to the key to be created, as well as indices to any parent indexed keys of that key.</param>
        </member>
        <member name="M:JetBrains.Application.Settings.SettingsStoreEx.IsIndexedKeyDefined``1(JetBrains.Application.Settings.IContextBoundSettingsStore,System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object})">
            <summary>
            <para>Checks whether the instance of an indexed key is marked as created in any mounted storage of the current context.</para>
            </summary>
            <param name="thіs"></param>
            <param name="keyIndices">An index to the key to be checked, as well as indices to any parent indexed keys of that key.</param>
        </member>
        <member name="M:JetBrains.Application.Settings.SettingsStoreEx.GetValueLive``2(JetBrains.Application.Settings.ISettingsStore,JetBrains.DataFlow.Lifetime,System.Func{JetBrains.DataFlow.Lifetime,JetBrains.Application.DataContext.DataContexts,JetBrains.Application.DataContext.IDataContext},System.Linq.Expressions.Expression{System.Func{``0,``1}},JetBrains.Threading.IThreading)">
            <summary>
            Gets the live value of the setting in the given context.
            </summary>
            <typeparam name="TEntryMemberType">Value type.</typeparam>
            <typeparam name="TKeyClass">Settings key class owning the settings entry.</typeparam>
            <param name="thіs"></param>
            <param name="lifetime">Duration.</param>
            <param name="FDataContext">Identifies the context in which the retained-state value should be maintained. As the data context is lifetime-bound and expires on guard release, needs a function to produce the context at need. This function is guaranteed to be called on the primary thread under a guard.</param>
            <param name="lambdaexpression">The entry whose value is to be monitored.</param>
            <param name="threading"></param>
            <returns>A property that changes live as the setting changes.</returns>
        </member>
        <member name="M:JetBrains.Application.Settings.SettingsStoreEx.GetValueLive``1(JetBrains.Application.Settings.ISettingsStore,JetBrains.DataFlow.Lifetime,System.Func{JetBrains.DataFlow.Lifetime,JetBrains.Application.DataContext.DataContexts,JetBrains.Application.DataContext.IDataContext},JetBrains.Application.Settings.SettingsScalarEntry,JetBrains.Threading.IThreading)">
            <summary>
            Gets the live value of the setting in the given context.
            </summary>
            <typeparam name="TEntryMemberType">Value type.</typeparam>
            <param name="thіs"></param>
            <param name="lifetime">Duration.</param>
            <param name="FDataContext">Identifies the context in which the retained-state value should be maintained. As the data context is lifetime-bound and expires on guard release, needs a function to produce the context at need. This function is guaranteed to be called on the primary thread under a guard.</param>
            <param name="entry">The entry whose value is to be monitored.</param>
            <param name="threading"></param>
            <returns>A property that changes live as the setting changes.</returns>
        </member>
        <member name="M:JetBrains.Application.Settings.SettingsStoreEx.GetValueProperty``2(JetBrains.Application.Settings.IContextBoundSettingsStoreLive,JetBrains.DataFlow.Lifetime,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object})">
            <summary>
            <para>Gets the value of a non-indexed settings entry as a live property.</para>
            <para>The property will change its value (and fire change events) on the main thread when the entry value changes in this context. If you change property value externally, the new value will be applied to the entry in this context using the SmartSave strategy.</para>
            <para>Note that you will always get a meaningful value (the entry default value), even if the entry value has not been set, or if the entry parent key does not exist (if there's no instance for such indexed key index). If you're reading entries of an indexed key or its ancestors, verify that key instance exists first.</para>
            </summary>
            <param name="thіs"></param>
            <param name="lifetime"></param>
            <param name="lambdaexpression">The settigs entry whose value is to be read.</param>
            <param name="keyIndices">If this entry is parented by one or more indexed keys, the indices to those keys. It is an error to have an index omitted for an indexed key.</param>
            <returns>The value, as set in the highest-priority storage which is not restricted for overriding. The settings entry default value otherwise (<c>Null</c> if not available).</returns>
        </member>
        <member name="M:JetBrains.Application.Settings.SettingsStoreEx.AdviseChange(JetBrains.Application.Settings.ISettingsChangedEventSource,JetBrains.DataFlow.Lifetime,JetBrains.Application.Settings.SettingsEntry,System.Action)">
            <summary>
            <para>Advises the settings entry change event.</para>
            <para>Fires on any change in settings entries in any child key, in any settings context.</para>
            <para>To sink changes in a specific context only, <see cref="M:JetBrains.Application.Settings.ISettingsStore.BindToContextLive(JetBrains.DataFlow.Lifetime,JetBrains.Application.Settings.ContextRange,JetBrains.Application.Settings.Store.Implementation.BindToContextFlags)">bind the store to that context</see> and use its <see cref="M:JetBrains.Application.Settings.SettingsStoreEx.AdviseChange(JetBrains.Application.Settings.ISettingsChangedEventSource,JetBrains.DataFlow.Lifetime,JetBrains.Application.Settings.SettingsEntry,System.Action)"/> method.</para>
            </summary>
            <param name="thіs"></param>
            <param name="lifetime">Duration.</param>
            <param name="entry">Entity to be watched for possible changes.</param>
            <param name="FOnChange">Executes when the change is detected.</param>
        </member>
        <member name="M:JetBrains.Application.Settings.SettingsStoreEx.AdviseChange(JetBrains.Application.Settings.ISettingsChangedEventSource,JetBrains.DataFlow.Lifetime,JetBrains.Application.Settings.SettingsKey,System.Action)">
            <summary>
            <para>Advises the settings key change event.</para>
            <para>Fires on any change in settings entries in any child key, in any settings context.</para>
            <para>To sink changes in a specific context only, <see cref="M:JetBrains.Application.Settings.ISettingsStore.BindToContextLive(JetBrains.DataFlow.Lifetime,JetBrains.Application.Settings.ContextRange,JetBrains.Application.Settings.Store.Implementation.BindToContextFlags)">bind the store to that context</see> and use its <see cref="M:JetBrains.Application.Settings.SettingsStoreEx.AdviseChange(JetBrains.Application.Settings.ISettingsChangedEventSource,JetBrains.DataFlow.Lifetime,JetBrains.Application.Settings.SettingsEntry,System.Action)"/> method.</para>
            </summary>
            <param name="thіs"></param>
            <param name="lifetime">Duration.</param>
            <param name="key">Entity to be watched for possible changes.</param>
            <param name="FOnChange">Executes when the change is detected.</param>
        </member>
        <member name="M:JetBrains.Application.Settings.SettingsStoreEx.CopyTo(JetBrains.Application.Settings.IContextBoundSettingsStore,JetBrains.Application.Settings.IContextBoundSettingsStore,JetBrains.Util.ILogger,JetBrains.Application.Settings.SettingsKey,System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object})">
            <summary>
            Copies all of the settings defined in the current context into the given context.
            </summary>
            <param name="thіs">Source context.</param>
            <param name="target">Target context to copy the settings into.</param>
            <param name="logger">Handles errors in this specific routine. Note that any of the store access errors will still go to the logger of that store.</param>
            <param name="keyRoot">Optional. If <c>Null</c>, the whole store available in this context is dumped. If non-<c>Null</c>, only those values under the given schema key are included.</param>
            <param name="keyIndices">Optional. Indices to <paramref name="keyRoot"/>, if it's specified.</param>
        </member>
        <member name="M:JetBrains.Application.Settings.SettingsStoreEx.EnumEntryIndices(JetBrains.Application.Settings.IContextBoundSettingsStore,JetBrains.Application.Settings.SettingsIndexedEntry,System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object})">
            <summary>
            <para>Gives out all of the indexed entry indices currently present in the store.</para>
            <para>Note that reading indexed entry values by some of these indices might actually return <c>Null</c> due to:</para> 
            <para>• Multithreaded access to the setings store.</para>
            <para>• Some technical info leftovers present in the store under this index, but not the actual value.</para>
            <para>• The entry indexed value is set in a base layer and then removed in a higher-priority layer, in which case the removal technical entry will report the index as present, but the actual value will be missing.</para>
            </summary>
            <param name="thіs"></param>
            <param name="entry">Identifies the indexed entry.</param>
            <param name="keyIndices">If this entry is parented by one or more indexed keys, the indices to those keys. It is an error to have an index omitted for an indexed key.</param>
            <returns>An enumeration of the index objects. The CLR type of these objects is defined by the settings entry declaration.</returns>
        </member>
        <member name="M:JetBrains.Application.Settings.SettingsStoreEx.EnumKeyIndices(JetBrains.Application.Settings.IContextBoundSettingsStore,JetBrains.Application.Settings.SettingsIndexedKey,System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object})">
            <summary>
            <para>Gives out all of the indexed key indices currently present in the store.</para>
            <para>Note that checking <see cref="M:JetBrains.Application.Settings.IContextBoundSettingsStore.IsIndexedKeyDefined(JetBrains.Application.Settings.SettingsKey,System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object})"/> by some of these indices might actually return <c>False</c> due to:</para> 
            <para>• Multithreaded access to the setings store.</para>
            <para>• Some technical info leftovers present in the store under this index, but not the actual value.</para>
            <para>• The key indexed instance is defined in a base layer and then removed in a higher-priority layer, in which case the removal technical record will report the index as present, but the actual key instance will be missing.</para>
            <para>• You're enumerating indices to an indexed key which is a descendant of another indexed key instance which is not defined itself.</para>
            </summary>
            <param name="thіs"></param>
            <param name="key">Identifies the indexed key.</param>
            <param name="parentKeyIndices">If this key is parented by one or more indexed keys, the indices to those keys. It is an error to have an index omitted for an indexed key. Note that this should not include the index to the <paramref name="key"/> itself because its possible indices are to be enumerated, but it's not an error if it's present.</param>
            <returns>An enumeration of the index objects. The CLR type of these objects is defined in the settings key attribute.</returns>
        </member>
        <member name="M:JetBrains.Application.Settings.SettingsStoreEx.GetKey(JetBrains.Application.Settings.IContextBoundSettingsStore,JetBrains.Application.Settings.SettingsKey,System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object},JetBrains.Application.Settings.ISettingsOptimization)">
            <summary>
            <para>Gets the values of all of the settings key's entries and returns them in a settings key class.</para>
            <para>This is always non-<c>Null</c> for a simple (non-indexed) key whose parents are also all simple. If there's no data on that key in the storage, default values will be returned for all of its entries.</para>
            <para>For an indexed key, or a key with an indexed ancestor, this will be <c>Null</c> if no instance is defined for the particular index value specified in <see cref="!:keyIndices"/>.</para>
            </summary>
            <param name="thіs"></param>
            <param name="key">The settigs key to be read.</param>
            <param name="keyIndices">If this key is parented by one or more indexed keys or is indexed itself, the indices to those keys. It is an error to have an index omitted for an indexed key.</param>
            <param name="optimization">Allows to operate whole settings keys faster by applying object-specific optimizations.</param>
            <returns>An instance of the key class with non-indeexed entries read with <see cref="M:JetBrains.Application.Settings.IContextBoundSettingsStore.GetValue(JetBrains.Application.Settings.SettingsScalarEntry,System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object})"/> and indexed entries exposed as with <see cref="M:JetBrains.Application.Settings.SettingsStoreEx.CreateIndexedEntryAccess(JetBrains.Application.Settings.IContextBoundSettingsStore,JetBrains.Application.Settings.SettingsIndexedEntry,System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object},JetBrains.Util.ILogger)"/>.</returns>
        </member>
        <member name="M:JetBrains.Application.Settings.SettingsStoreEx.SetKey(JetBrains.Application.Settings.IContextBoundSettingsStore,JetBrains.Application.Settings.SettingsKey,System.Object,System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object},JetBrains.Application.Settings.ISettingsOptimization)">
            <summary>
            <para> Stores the values of all of the settings key's scalar entries.</para>
            <para> It's semantic is equivalent to calling <see cref="M:JetBrains.Application.Settings.IContextBoundSettingsStore.SetValue(JetBrains.Application.Settings.SettingsScalarEntry,System.Object,System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object})"/> for each scalar entry of the key. </para>
            </summary>
            <param name="key">The settigs key to be written.</param>
            <param name="value">The value to be written. Must be of the CLR type specified in the settings entry</param>
            <param name="keyIndices">If <paramref name="key"/> is indexed itself or is parented by one or more indexed keys, the indices to those keys. It is an error to have an index omitted for an indexed key.</param>
            <param name="optimization">Allows to operate whole settings keys faster by applying object-specific optimizations.</param>
        </member>
        <member name="T:JetBrains.Application.Settings.Store.Implementation.ContextBoundSettingsStoreTransient">
            <summary>
            Default implementation of a non-lifetimed (transient) context-bound settings store.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.ContextBoundSettingsStoreTransient.FillKeyPathComponentsAndCheckIsDefined(JetBrains.Application.Settings.Storage.KeyPathComponents,JetBrains.Application.Settings.SettingsKey,System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object})">
            <summary>
            <para>Builds storage keypath for the settings key, and checks that all the indexed keys in the path are marked as defined in the store.</para>
            <para>NOTE: this function is used in much less cases now in favor of <see cref="M:JetBrains.Application.Settings.Store.Implementation.ContextBoundSettingsStoreTransient.FillKeyPathComponentsAndCheckIsDefined_NotActuallyCheckingAnymore(JetBrains.Application.Settings.Storage.KeyPathComponents,JetBrains.Application.Settings.SettingsKey,System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object})"/>, see NP-624.</para>
            </summary>
            <param name="keyPathComponents"></param>
            <param name="key"></param>
            <param name="keyIndices"></param>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.ContextBoundSettingsStoreTransient.FillKeyPathComponentsAndCheckIsDefined_NotActuallyCheckingAnymore(JetBrains.Application.Settings.Storage.KeyPathComponents,JetBrains.Application.Settings.SettingsKey,System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object})">
            <summary>
            <para>Builds storage keypath for the settings key, and checks that all the indexed keys in the path are marked as defined in the store.</para>
            <para>NOTE: this function actually always returns <c>True</c> , but marks the places which used to check for the key to be defined before the design was changed to always read the actual entry value, see NP-624.</para>
            </summary>
            <param name="keyPathComponents"></param>
            <param name="key"></param>
            <param name="keyIndices"></param>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.ContextBoundSettingsStoreTransient.FillKeyPathComponentsAndCheckIsDefined(JetBrains.Application.Settings.Storage.KeyPathComponents,JetBrains.Application.Settings.SettingsEntry,System.Object,System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object})">
            <summary>
            <para>Builds storage keypath for the settings key, and checks that all the indexed keys in the path are marked as defined in the store.</para>
            <para>NOTE: this function is not used anymore in favor of <see cref="M:JetBrains.Application.Settings.Store.Implementation.ContextBoundSettingsStoreTransient.FillKeyPathComponentsAndCheckIsDefined_NotActuallyCheckingAnymore(JetBrains.Application.Settings.Storage.KeyPathComponents,JetBrains.Application.Settings.SettingsKey,System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object})"/>, see NP-624.</para>
            </summary>
            <param name="keyPathComponents"></param>
            <param name="entry"></param>
            <param name="indexToEntry"></param>
            <param name="keyIndices"></param>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.ContextBoundSettingsStoreTransient.FillKeyPathComponentsAndCheckIsDefined_NotActuallyCheckingAnymore(JetBrains.Application.Settings.Storage.KeyPathComponents,JetBrains.Application.Settings.SettingsEntry,System.Object,System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object})">
            <summary>
            <para>Builds storage keypath for the settings key. Does not check that all the indexed keys in the path are marked as defined in the store (but checks that all the key indices are supplied with <paramref name="keyIndices"/>).</para>
            <para>NOTE: this function is identical to <see cref="M:JetBrains.Application.Settings.Store.Implementation.ContextBoundSettingsStoreTransient.FillKeyPathComponentsWithoutChecking(JetBrains.Application.Settings.Storage.KeyPathComponents,JetBrains.Application.Settings.SettingsEntry,System.Object,System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object})"/>, but marks the places which used to check for the key to be defined before the design was changed to always read the actual entry value, see NP-624.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.ContextBoundSettingsStoreTransient.FillKeyPathComponentsWithoutChecking(JetBrains.Application.Settings.Storage.KeyPathComponents,JetBrains.Application.Settings.SettingsEntry,System.Object,System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object})">
            <summary>
            Builds storage keypath for the settings key. Does not check that all the indexed keys in the path are marked as defined in the store (but checks that all the key indices are supplied with <paramref name="keyIndices"/>).
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Store.Implementation.ContextBoundSettingsStoreTransient.myFFillKeyPathComponentsAndCheckIsDefined_CheckKey">
            <summary>
            Cached delegate.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.ContextBoundSettingsStoreTransient.SetIndexedValueCore(JetBrains.Application.Settings.Storage.KeyPathComponents,JetBrains.Application.Settings.SettingsIndexedEntry,System.Object,System.Object,System.Boolean)">
            <summary>
            Indexed entry value writer (gets come storage key info precached).
            Supports indexed entry values removal in higher-priority layers.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Store.Implementation.ContextBoundSettingsStoreTransient.myFCreateIndexedKey_DefineKey">
            <summary>
            Cached delegate.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Store.Implementation.ContextBoundSettingsStoreTransient.IndexedValues.ValueSerialized">
            <summary>
            <para>Value serialized to a primitive storage type, as residing in the storage.</para>
            <para>Must be non-<c>Null</c> for a correct value record after the layer is processed. Can only be <c>Null</c> if we have encountered a value-removal record before the actual value record (<see cref="F:JetBrains.Application.Settings.Store.Implementation.ContextBoundSettingsStoreTransient.IndexedValues.IsRemoved"/> is <c>True</c>). Such a situation after the layer is fully processed means the record should be ignored.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Store.Implementation.ContextBoundSettingsStoreTransient.IndexedValues.LayerIndex">
            <summary>
            Layer idetity to combine entry deletion records with entry values.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Store.Implementation.ContextBoundSettingsStoreTransient.IndexedValues.IsRemoved">
            <summary>
            <c>True</c> if we've seen a removal record for this index.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.ContextBoundSettingsStoreTransient.IContextBoundMountsInfo.GetDataSync(JetBrains.Application.Settings.ISettingsStorageMountPoint[]@,JetBrains.Application.Settings.ISettingsStorageMountPoint@)">
            <summary>
            Gets <see cref="P:JetBrains.Application.Settings.Store.Implementation.ContextBoundSettingsStoreTransient.IContextBoundMountsInfo.Mounts"/> and <see cref="P:JetBrains.Application.Settings.Store.Implementation.ContextBoundSettingsStoreTransient.IContextBoundMountsInfo.LastWideMount"/> which are synchronized with each other, with one call.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Settings.Store.Implementation.ContextBoundSettingsStoreTransient.IContextBoundMountsInfo.Mounts">
            <summary>
            Gets the mounting points present in the context at the moment.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Settings.Store.Implementation.ContextBoundSettingsStoreTransient.IContextBoundMountsInfo.LastWideMount">
            <summary>
            <para>Gets the mounting point out of <see cref="P:JetBrains.Application.Settings.Store.Implementation.ContextBoundSettingsStoreTransient.IContextBoundMountsInfo.Mounts"/> outside of which (with lower priority) writes are not allowed.</para>
            <para>Note that in case of a live context you cannot guarantee the property values are in sync, use <see cref="M:JetBrains.Application.Settings.Store.Implementation.ContextBoundSettingsStoreTransient.IContextBoundMountsInfo.GetDataSync(JetBrains.Application.Settings.ISettingsStorageMountPoint[]@,JetBrains.Application.Settings.ISettingsStorageMountPoint@)"/> when this is critical.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.ContextBoundSettingsStoreTransient.ContextBoundMountsInfoTransient.FromContextRange(JetBrains.Application.Settings.ContextRange,JetBrains.Application.Settings.ISettingsStore,JetBrains.Application.Settings.Store.Implementation.BindToContextFlags,JetBrains.Util.ILogger)">
            <summary>
            Convert ContextRange into the mounts list — non-live.
            </summary>
            <param name="contextRange"></param>
            <param name="store"></param>
            <param name="flags"></param>
            <param name="logger"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.ContextBoundSettingsStoreTransient.ContextBoundMountsInfoTransient.FromContextRangeCore(JetBrains.Application.Settings.ContextRange,JetBrains.Application.Settings.ISettingsStore,JetBrains.Application.Settings.Store.Implementation.BindToContextFlags,System.Boolean,JetBrains.Util.ILogger,JetBrains.Application.Settings.ISettingsStorageMountPoint[]@,JetBrains.Application.Settings.ISettingsStorageMountPoint@)">
            <summary>
            Convert ContextRange into the mounts list — non-live.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.IContextBoundSettingsStoreLive">
            <summary>
            <para>Live version of the context-bound store.</para>
            <para>Is bound to a lifetime, watches for newly-appearing mounting points, retranslates change events.</para>
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.ISettingsChangedEventSource">
            <summary>
            <para>Can fire events on changes in settings.</para>
            <para>Applies to the Settings Store in the whole, and to its live context bindings.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Application.Settings.ISettingsChangedEventSource.Changed">
            <summary>
            Listens to changes in the settings store.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.IContextBoundSettingsStoreLive.GetValueProperty``1(JetBrains.DataFlow.Lifetime,JetBrains.Application.Settings.SettingsScalarEntry,System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object})">
            <summary>
            <para>Gets the value of a non-indexed settings entry as a live property.</para>
            <para>The property will change its value (and fire change events) on the main thread when the entry value changes in this context. If you change property value externally, the new value will be applied to the entry in this context using the SmartSave strategy.</para>
            <para>Note that you will always get a meaningful value (the entry default value), even if the entry value has not been set, or if the entry parent key does not exist (if there's no instance for such indexed key index). If you're reading entries of an indexed key or its ancestors, verify that key instance exists first.</para>
            </summary>
            <param name="lifetime"></param>
            <param name="entry">The settigs entry whose value is to be read.</param>
            <param name="keyIndices">If this entry is parented by one or more indexed keys, the indices to those keys. It is an error to have an index omitted for an indexed key.</param>
            <returns>The value, as set in the highest-priority storage which is not restricted for overriding. The settings entry default value otherwise (<c>Null</c> if not available).</returns>
        </member>
        <member name="P:JetBrains.Application.Settings.IContextBoundSettingsStoreLive.InvolvedMountPointsLive">
            <summary>
            Adds to the base interface's <see cref="P:JetBrains.Application.Settings.IContextBoundSettingsStore.InvolvedMountPoints"/> property: as the live context might see its mount points set change, fires when this happens so that any consumers could update on the new <see cref="P:JetBrains.Application.Settings.IContextBoundSettingsStore.InvolvedMountPoints"/>.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Settings.Store.Implementation.ContextBoundSettingsStoreLive.IContextBoundMountsInfoLive.MountsLive">
            <summary>
            <para>Live version of the mounting points set of this context.</para>
            <para>Used for watching mount changes and notifying of coming/going settings.</para>
            <para>The order is guaranteed to be correct.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.ContextBoundSettingsStoreLive.ContextBoundMountsInfoLiveOnContextRange.OnMountSetChangeDispatched">
            <summary>
            Deferred notification on change in set of applicable mounts, update the <see cref="F:JetBrains.Application.Settings.Store.Implementation.ContextBoundSettingsStoreLive.ContextBoundMountsInfoLiveOnContextRange.myMountsLive"/>.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.Store.Implementation.ContextBoundSettingsStoreLive.ValuePropertiesSupport">
            <summary>
            Creates and manages live value properties for <see cref="T:JetBrains.Application.Settings.Store.Implementation.ContextBoundSettingsStoreLive"/>.
            Allows free-threaded property creation, so there's an object per each thread (<see cref="T:JetBrains.Application.Settings.Store.Implementation.ContextBoundSettingsStoreLive.ValuePropertiesSupport.ValuePropertiesSupportThread"/>) managing that thread's proeprties.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Store.Implementation.ContextBoundSettingsStoreLive.ValuePropertiesSupport.myLockSynchronizeShutdown">
            <summary>
            Has async threads. This lock makes sure the threads are all in a determinate state when the object is terminated on its home thread.
            Background threads take the reader lock when they're busy and cannot have the lifetime terminated.
            Foreground thread terminates the lifetime under a writer lock.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.ContextBoundSettingsStoreLive.ValuePropertiesSupport.GetValueProperty``1(JetBrains.DataFlow.Lifetime,JetBrains.Application.Settings.SettingsScalarEntry,System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object})">
            <summary>
            Gets cached value property, or creates a new one.
            The property is bound to your <paramref name="lifetime"/> and not limited by the lifetime of the <see cref="T:JetBrains.Application.Settings.Store.Implementation.ContextBoundSettingsStoreLive.ValuePropertiesSupport"/> object because the latter might be terminated on any thread which would fire acknowledgement events on a thread not expected by your code. The property will live to the lifetime you pass in here. In all correct scenarios, this is not wider than <see cref="T:JetBrains.Application.Settings.Store.Implementation.ContextBoundSettingsStoreLive.ValuePropertiesSupport"/>.
            </summary>
            <typeparam name="TValue"></typeparam>
            <param name="lifetime"></param>
            <param name="entry"></param>
            <param name="keyIndices"></param>
            <returns></returns>
        </member>
        <member name="F:JetBrains.Application.Settings.Store.Implementation.ContextBoundSettingsStoreLive.ValuePropertiesSupport.myPerThread">
            <summary>
            Per-thread props (within each thread there're no problems with threading issues).
            A thread must be pumping.
            Protected with <see cref="F:JetBrains.Application.Settings.Store.Implementation.ContextBoundSettingsStoreLive.ValuePropertiesSupport.myLockThreadList"/>.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.Store.Implementation.ContextBoundSettingsStoreLive.ValuePropertiesSupport.ValuePropertiesSupportThread">
            <summary>
            Creates and manages properties on a single thread on behalf of <see cref="T:JetBrains.Application.Settings.Store.Implementation.ContextBoundSettingsStoreLive.ValuePropertiesSupport"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Store.Implementation.ContextBoundSettingsStoreLive.ValuePropertiesSupport.ValuePropertiesSupportThread.Dispatcher">
            <summary>
            Identifies the home thread of this object.
            Can only be used-accessed on home thread.
            The only exception is <see cref="M:JetBrains.Application.Settings.Store.Implementation.ContextBoundSettingsStoreLive.ValuePropertiesSupport.ValuePropertiesSupportThread.ExecuteChange(JetBrains.Application.Settings.SettingsStoreChangeArgs)"/> which is called on the change-dispatching background thread.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Store.Implementation.ContextBoundSettingsStoreLive.ValuePropertiesSupport.ValuePropertiesSupportThread.myActiveProperties">
            <summary>
            Properties which are alive.
            Protected with <see cref="F:JetBrains.Application.Settings.Store.Implementation.ContextBoundSettingsStoreLive.ValuePropertiesSupport.ValuePropertiesSupportThread.myLock"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.ContextBoundSettingsStoreLive.ValuePropertiesSupport.ValuePropertiesSupportThread.GetValueProperty``1(JetBrains.DataFlow.Lifetime,JetBrains.Application.Settings.SettingsScalarEntry,System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object})">
            <summary>
            Gets or creates the property (in responce to a user's call to <see cref="M:JetBrains.Application.Settings.IContextBoundSettingsStoreLive.GetValueProperty``1(JetBrains.DataFlow.Lifetime,JetBrains.Application.Settings.SettingsScalarEntry,System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object})"/>).
            Must be called on home thread of this object.
            NOTE: synchronization lock must be held by the caller.
            </summary>
            <typeparam name="TValue"></typeparam>
            <param name="lifetime"></param>
            <param name="entry"></param>
            <param name="keyIndices"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.ContextBoundSettingsStoreLive.ValuePropertiesSupport.ValuePropertiesSupportThread.GetValueProperty_Create``1(JetBrains.Application.Settings.SettingsScalarEntry,System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object},JetBrains.Application.Settings.Storage.KeyPathComponents)">
            <summary>
            Works when the property has to be created.
            Must be called on home thread of this object.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.ContextBoundSettingsStoreLive.ValuePropertiesSupport.ValuePropertiesSupportThread.ExecuteChange(JetBrains.Application.Settings.SettingsStoreChangeArgs)">
            <summary>
            This function is called on an arbitrary thread so that this object analyzed possible changes for its properties (on that thread) and then marshalled to the destination thread to update the property value, as appropriate.
            NOTE: owner calls this function under synchronization which makes sure the lifetime won't be terminated while we're here.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.Store.Implementation.ContextBoundSettingsStoreLive.ValuePropertiesSupport.ValuePropertiesSupportThread.ValueProperty">
            <summary>
            Base untyped nongeneric property class to enable managing properties of all types in a loop.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Store.Implementation.ContextBoundSettingsStoreLive.ValuePropertiesSupport.ValuePropertiesSupportThread.ValueProperty.FGetItemKey">
            <summary>
            Cached key getter for dictionary-like bin-search arrays.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Store.Implementation.ContextBoundSettingsStoreLive.ValuePropertiesSupport.ValuePropertiesSupportThread.ValueProperty.TokenUpdateFromSettingsStore">
            <summary>
            When a property change is annotated with this token, then it's due to a sync to the settings store change.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.ContextBoundSettingsStoreLive.ValuePropertiesSupport.ValuePropertiesSupportThread.ValueProperty.Cast``1">
            <summary>
            Returns the typed version: casts if it's really the proper type, or thows if this is a property of some other type.
            </summary>
            <typeparam name="TValue"></typeparam>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.ContextBoundSettingsStoreLive.ValuePropertiesSupport.ValuePropertiesSupportThread.ValueProperty.AttachToLifetime(JetBrains.DataFlow.Lifetime)">
            <summary>
            Adds one more user request for this property to keep it alive.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.ContextBoundSettingsStoreLive.ValuePropertiesSupport.ValuePropertiesSupportThread.ValueProperty.ReadValueFromStore">
            <summary>
            Re-reads property value from the Settings Store.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.Store.Implementation.ContextBoundSettingsStoreLive.ValuePropertiesSupport.ValuePropertiesSupportThread.ValueProperty`1">
            <summary>
            Wraps functioning of a single SettingsStore bidi-bound property.
            </summary>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.ContextBoundSettingsStoreLive.ValuePropertiesSupport.ValuePropertiesSupportThread.ValueProperty`1.AttachToLifetime(JetBrains.DataFlow.Lifetime)">
            <summary>
            Property is attached to each of the user's lifetimes, to be terminated when there're no clients for the property.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.Store.Implementation.DefaultIsAvailableOptimizedGroup">
            <summary>
            Default optimized group hosts just one item for which there was never ever a fitting group found.
            It does not accept any other items so that not to steal good items from their specialized groups.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.IIsAvailableOptimizedGroup">
            <summary>
            Optimizes querying availability of a group of items with one call.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.IIsAvailableOptimizedGroup.TryAddItem(JetBrains.DataFlow.Lifetime,System.Object,JetBrains.Application.Settings.IIsAvailable)">
            <summary>
            <para>Tells whether the given item belongs to this availability group, and will be returned from <see cref="M:JetBrains.Application.Settings.IIsAvailableOptimizedGroup.EvaluateItems(System.Collections.IList,JetBrains.Application.DataContext.IDataContext)"/> when it fits.</para>
            <para>If yes, adds the item to the group for the duration of the <paramref name="lifetime"/>.</para>
            <para>Must be thread-safe.</para>
            </summary>
            <param name="lifetime">If the item fits, it should be managed by the group for the duration of the lifetime. If the item does not fit, this function MUST NOT add actions to the lifetime.</param>
            <param name="item">The item to try adding to the group.</param>
            <param name="availability">Availability object of the item being added to the group. Validate it for being fit for management by this group.</param>
            <returns><c>True</c> if item is added and tied to the lifetime, <c>False</c> otherwise.</returns>
        </member>
        <member name="M:JetBrains.Application.Settings.IIsAvailableOptimizedGroup.EvaluateItems(System.Collections.IList,JetBrains.Application.DataContext.IDataContext)">
            <summary>
            <para>Evaluates items in the group for availability.</para>
            <para>Must be thread-safe.</para>
            </summary>
            <param name="items">Target list to which the fitting items of this group should be added (to the end, in an undefined order).</param>
            <param name="context">The context against which the availability of the items in the group should be checked.</param>
        </member>
        <member name="P:JetBrains.Application.Settings.IIsAvailableOptimizedGroup.Items">
            <summary>
            <para>Gets the list of items currently in the group (such that were submitted to <see cref="M:JetBrains.Application.Settings.IIsAvailableOptimizedGroup.TryAddItem(JetBrains.DataFlow.Lifetime,System.Object,JetBrains.Application.Settings.IIsAvailable)"/> with <c>True</c> result, and whose lifetime has not been terminated).</para>
            <para>Mostly used for reclaiming groups in which no items remain.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Store.Implementation.DefaultIsAvailableOptimizedGroup.myItemArrayWhenPresent">
            <summary>
            Caches the item array when it's actually present.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.Store.Implementation.DefaultSettingsMountPoints">
            <summary>
            Helps with mounting your storages representing the default settings of the product: you cannot specify default values for indexed entries and keys, you have to mount a storage which provides them at the lowest-priortity level.
            You could use this component to load them from resources and such.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.DefaultSettingsMountPoints.LoadFromResources(JetBrains.DataFlow.Lifetime,System.Reflection.Assembly,System.String)">
            <summary>
            Loads a settings storage from an XML resource and mounts into the settings store into the global context at a low priority.
            NOTE: you SHOULD rather implement <see cref="T:JetBrains.Application.Settings.IHaveDefaultSettingsStream"/> for pull-providing the default settings storage instead of calling this method push-style.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.DefaultSettingsMountPoints.LoadFromStream(JetBrains.DataFlow.Lifetime,System.String,System.IO.Stream,JetBrains.Application.Settings.Storage.Persistence.SettingsStorageBinaryCache.StorageCacheIdentity)">
            <summary>
            Loads a settings storage from an XML stream and mounts into the settings store into the global context at a low priority.
            NOTE: you SHOULD rather implement <see cref="T:JetBrains.Application.Settings.IHaveDefaultSettingsStream"/> for pull-providing the default settings storage instead of calling this method push-style.
            </summary>
            <param name="lifetime">Lifetime for the storage.</param>
            <param name="name">Storage name.</param>
            <param name="stream">The stream in Storage XML format to read the storage contents from. You can dispose of the stream immediately after calling this method.</param>
            <param name="identity">Optional identity to binary-cache the loading of this resource.</param>
        </member>
        <member name="F:JetBrains.Application.Settings.Store.Implementation.DefaultSettingsMountPoints.DefaultSettingsComposedStorage.myMountsCurrentlyComposed">
            <summary>
            What currently takes part in composition.
            Read/write access under <see cref="F:JetBrains.Application.Settings.Store.Implementation.DefaultSettingsMountPoints.DefaultSettingsComposedStorage.myLockData"/> only.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Store.Implementation.DefaultSettingsMountPoints.DefaultSettingsComposedStorage.myMountsDesiredComposition">
            <summary>
            What should take part in composition after a Compose call.
            Read/write access under <see cref="F:JetBrains.Application.Settings.Store.Implementation.DefaultSettingsMountPoints.DefaultSettingsComposedStorage.myLockData"/> only.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Store.Implementation.DefaultSettingsMountPoints.DefaultSettingsComposedStorage.myStorageComposed">
            <summary>
            We recompose this from time to time taking all of the <see cref="F:JetBrains.Application.Settings.Store.Implementation.DefaultSettingsMountPoints.DefaultSettingsComposedStorage.myMountsAwaitingComposition"/> into it.
            NULL when no valid storage composed yet.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Store.Implementation.DefaultSettingsMountPoints.DefaultSettingsComposedStorage.myMountsAwaitingComposition">
            <summary>
            When new mounts are added, before next recomposition they're pending in this list.
            Write access udner <see cref="F:JetBrains.Application.Settings.Store.Implementation.DefaultSettingsMountPoints.DefaultSettingsComposedStorage.myLockData"/>.
            Read access (e.g. when accessing not-yet-composed layers) is lock-free.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.DefaultSettingsMountPoints.DefaultSettingsComposedStorage.AddMount(JetBrains.DataFlow.Lifetime,JetBrains.Application.Settings.ISettingsStorageMountPoint)">
            <summary>
            Adds/removes a mount.
            The changes are not quite applied until you call <see cref="M:JetBrains.Application.Settings.Store.Implementation.DefaultSettingsMountPoints.DefaultSettingsComposedStorage.Compose"/>.
            </summary>
            <param name="lifetime"></param>
            <param name="mount"></param>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.DefaultSettingsMountPoints.DefaultSettingsComposedStorage.Compose">
            <summary>
            Composes pending things.
            Free-threaded.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.DefaultSettingsMountPoints.DefaultSettingsComposedStorage.Compose_Add(JetBrains.Application.Settings.ISettingsStorageMountPoint)">
            <summary>
            New mountpoint in composition.
            Just add its data to the composed storage.
            </summary>
            <param name="mount"></param>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.DefaultSettingsMountPoints.DefaultSettingsComposedStorage.Compose_Remove(JetBrains.Application.Settings.ISettingsStorageMountPoint,JetBrains.Application.Settings.ISettingsStorageMountPoint[])">
            <summary>
            Mountpoint being removed.
            Enum its values and see if any of the remaining mounts still provides a value for the same key.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.IHaveDefaultSettingsStream">
            <summary>
            If you got default settings to be always preloaded into the Settings Store, you can either push them into the <see cref="T:JetBrains.Application.Settings.Store.Implementation.DefaultSettingsMountPoints"/> (NOT recommended) or expose by implementing this interface. In the latter case, they will be available immediately upon composition, and the composition will be more performant.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.IHaveDefaultSettingsStream.GetDefaultSettingsStream(JetBrains.DataFlow.Lifetime)">
            <summary>
            Requests your settings for loading into the system as default settings.
            </summary>
            <param name="lifetime">Lifetime of caller's use of the returned stream.</param>
            <returns>The stream which can be loaded into an <see cref="T:JetBrains.Application.Settings.Storage.Persistence.ISettingsStorageStreamSerialization"/>. It is the callee's responsibility to dispose of the stream correctly if needed, according to the lifetime provided by the caller. Returning a NULL is a valid case if you SUDDENLY discovered you would not like to provide settings in this environment.</returns>
        </member>
        <member name="P:JetBrains.Application.Settings.IHaveDefaultSettingsStream.Name">
            <summary>
            The name for the mounting point which will be mounting your settings stream into the settings store.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.Store.Implementation.IsAvailable">
            <summary>
            Availability function which tells whether the owner is avwailable in the given <see cref="T:JetBrains.Application.DataContext.IDataContext"/>.
            Default implementation.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.IIsAvailable">
            <summary>
            Availability function which tells whether the owner is avwailable in the given <see cref="T:JetBrains.Application.DataContext.IDataContext"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.IIsAvailable.IsAvailable(JetBrains.Application.DataContext.IDataContext)">
            <summary>
            Gets whether the owner is available in the given <see cref="T:JetBrains.Application.DataContext.IDataContext"/>.
            </summary>
            <param name="context">The data context which defines the availability.</param>
            <returns>Availability.</returns>
        </member>
        <member name="F:JetBrains.Application.Settings.Store.Implementation.IsAvailable.Always">
            <summary>
            Always available.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Store.Implementation.IsAvailable.Never">
            <summary>
            Never available.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.IsAvailable.Create(System.Func{JetBrains.Application.DataContext.IDataContext,System.Boolean})">
            <summary>
            Constructor wrapper for smart completion.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.IIsAvailableOptimization">
            <summary>
            Availability function which allows to group a set of items and calculate their availability in one action (<see cref="T:JetBrains.Application.Settings.IIsAvailableOptimizedGroup"/>).
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.IIsAvailableOptimization.CreateEmptyGroup">
            <summary>
            Creates a new empty optimization group might be optimizing this item. This group MUST accept the item it was created from when it is passed to <see cref="M:JetBrains.Application.Settings.IIsAvailableOptimizedGroup.TryAddItem(JetBrains.DataFlow.Lifetime,System.Object,JetBrains.Application.Settings.IIsAvailable)"/>.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.Store.Implementation.IsAvailable.Everavailable.OptimizationGroup">
            <summary>
            Groups all of the items that are always available. Just pours them into the list.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.Store.Implementation.IsAvailable.Neveravailable.OptimizationGroup">
            <summary>
            Groups all of the items that are never available. Just skips them all off the output.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.Store.Implementation.IsAvailableByDataConstant`1">
            <summary>
            Checks availability by comparing a dataconstant in the datacontext to the predefined value.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.IsAvailableByDataConstant`1.#ctor(JetBrains.DataFlow.Lifetime,JetBrains.Application.DataContext.DataConstant{`0},`0,JetBrains.Application.IShellLocks)">
            <summary>
            Checks availability by comparing a dataconstant in the datacontext to the predefined value.
            </summary>
            <param name="lifetime">The limiting lifetime for the <paramref name="value"/> you supplied. The value will not be used after the lifetime terminates.</param>
            <param name="constant">The data constant to get from the data context.</param>
            <param name="value">The value of <paramref name="constant"/> in the datacontext must be equal to this <paramref name="value"/> for the availability to be <c>True</c>.</param>
            <param name="locks">Optional locks. If specified, data context access will be protected with a reader lock.</param>
        </member>
        <member name="T:JetBrains.Application.Settings.Store.Implementation.IsAvailableByDataConstant`1.OptimizedGroup">
            <summary>
            Hashmap of available items set by data constant value.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.Store.Implementation.ISettingsChangeDispatch">
            <summary>
            Defines the strategy for dispatching changes in settings.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.ISettingsChangeDispatch.RegisterForDispatch(JetBrains.DataFlow.Lifetime,System.Action)">
            <summary>
            Registers with a grouping-event-like interface for doing the dispatch.
            Call the returned function when you want to schedule a dispatch, and your <paramref name="FDispatch"/> will be called on an undefined thread when it's time to (in the same manner as grouping event's incoming-outgoing).
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.ISettingsChangeDispatch.SuppressThreadDispatch">
            <summary>
            Prevents changes from being dispatched on this thread.
            You must thoroughly balance <see cref="M:JetBrains.Application.Settings.Store.Implementation.ISettingsChangeDispatch.SuppressThreadDispatch"/> and <see cref="M:JetBrains.Application.Settings.Store.Implementation.ISettingsChangeDispatch.ResumeThreadDispatch"/> calls.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.ISettingsChangeDispatch.ResumeThreadDispatch">
            <summary>
            Resumes changes dispatch on this thread.
            You must thoroughly balance <see cref="M:JetBrains.Application.Settings.Store.Implementation.ISettingsChangeDispatch.SuppressThreadDispatch"/> and <see cref="M:JetBrains.Application.Settings.Store.Implementation.ISettingsChangeDispatch.ResumeThreadDispatch"/> calls.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.Store.Implementation.Provider`1">
            <summary>
            Default implementation of the <see cref="T:JetBrains.Application.Settings.IProvider`1"/> interface.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.ReadonlyXmlStreamSettingsStorage.ReadFromXmlStream(JetBrains.DataFlow.Lifetime,System.String,System.IO.Stream,JetBrains.Util.ILogger,JetBrains.Application.Settings.Storage.InternKeyPathComponent,JetBrains.Application.Settings.Storage.Persistence.SettingsStorageBinaryCache.StorageCacheIdentity)">
            <summary>
            Creates a new storage and reads XML stream contents into it.
            </summary>
            <param name="lifetime">Lifetime for the storage.</param>
            <param name="name">Storage name.</param>
            <param name="stream">The stream in Storage XML format to read the storage contents from. You can dispose of the stream immediately after calling this method.</param>
            <param name="logger"></param>
            <param name="interned"></param>
            <param name="identity">Optional identity to binary-cache the loading of this resource.</param>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Application.Settings.Store.Implementation.ScalarSettingsStoreAccess">
            <summary>
            Simple interface for accessing the Settings Store on a single mounting point only.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.ScalarSettingsStoreAccess.FillKeyPathComponentsAndCheckIsDefined(JetBrains.Application.Settings.Storage.KeyPathComponents,JetBrains.Application.Settings.ISettingsStorageMountPoint,JetBrains.Application.Settings.SettingsEntry,System.Object,System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object},JetBrains.Application.Settings.Storage.ISettingsStorageTransactionContext,JetBrains.Util.IExceptionThrowingLogger)">
            <summary>
            Builds storage keypath for the settings key, and checks that all the indexed keys in the path are marked as defined in the store.
            </summary>
            <param name="keyPathComponents"></param>
            <param name="mount"> </param>
            <param name="entry"></param>
            <param name="indexToEntry"></param>
            <param name="keyIndices"></param>
            <param name="transaction"> </param>
            <param name="logger"> </param>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.ScalarSettingsStoreAccess.FillKeyPathComponentsAndCheckIsDefined(JetBrains.Application.Settings.Storage.KeyPathComponents,JetBrains.Application.Settings.ISettingsStorageMountPoint,JetBrains.Application.Settings.SettingsKey,System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object},JetBrains.Application.Settings.Storage.ISettingsStorageTransactionContext,JetBrains.Util.ILogger)">
            <summary>
            Builds storage keypath for the settings key, and checks that all the indexed keys in the path are marked as defined in the store.
            </summary>
            <param name="keyPathComponents"></param>
            <param name="mount"> </param>
            <param name="key"></param>
            <param name="keyIndices"></param>
            <param name="transaction"> </param>
            <param name="logger"> </param>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.ScalarSettingsStoreAccess.FillKeyPathComponentsWithoutChecking(JetBrains.Application.Settings.Storage.KeyPathComponents,JetBrains.Application.Settings.SettingsEntry,System.Object,System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object},JetBrains.Util.IExceptionThrowingLogger)">
            <summary>
            Builds storage keypath for the settings key. Does not check that all the indexed keys in the path are marked as defined in the store (but checks that all the key indices are supplied with <paramref name="keyIndices"/>).
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Store.Implementation.SettingsChangeDispatch.myDelegateComparer">
            <summary>
            <para>The current implementation of delegate's hash code in &gt;NET yields the same value for *all* the <see cref="T:System.Action"/> delegates, turning a hashset into a list. Differentiate over methods and targets.</para>
            <para>Our equality: don't allow implicit delegate equality because we're not doing “<c>-=</c>” on new method group delegates, so we're checking equality on references.</para>
            <para>Our hashcode: don't ask for method-info because it might be slow in getting out of the delegate, just check the closure instance; NOTE: now calling <c>Object::GetHashCode</c> nonvirtually on the instance to get its default instance-specific hashcode.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.SettingsChangeDispatch.GroupingEventDispatchChanges">
            <summary>
            Async case: grouping event's outgoing action has fired.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.SettingsChangeDispatch.GroupingEventRequestDispatch">
            <summary>
            Just requests gevent dispatch, after all of the internal structs are configured for that.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.SettingsChangeDispatch.CommitPendingChangesCore">
            <summary>
            Forces pending changes in the settings to be processed immediately.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.Store.Implementation.SettingsEntryToSettingsStorageSerialization">
            <summary>
            Runtime settings store values are freehand CLR types, while writing them as settings storage values or as parts of settings storage keys (as indices) requires serializing them to primitive types.
            Here are common accessors, and the <see cref="T:JetBrains.Application.Settings.Store.Implementation.SettingsEntryToSettingsStorageSerialization.CoreStorageSerialization"/> class contains raw serialization routines.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.SettingsEntryToSettingsStorageSerialization.DeserializeStorageValueToEntryValue(JetBrains.Application.Settings.SettingsScalarEntry,System.Object,JetBrains.Util.IExceptionThrowingLogger)">
            <summary>
            Settings Storage value serialized to a primitive type => settings store settings entry value of a CLR type.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.SettingsEntryToSettingsStorageSerialization.DeserializeStorageValueToEntryValue(JetBrains.Application.Settings.SettingsIndexedEntry,System.Object,JetBrains.Util.IExceptionThrowingLogger)">
            <summary>
            Settings Storage value serialized to a primitive type => settings store settings entry (indexed) value of a CLR type.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.SettingsEntryToSettingsStorageSerialization.SerializeEntryValueToStorageValue(JetBrains.Application.Settings.SettingsScalarEntry,System.Object,JetBrains.Util.IExceptionThrowingLogger)">
            <summary>
            Settings Store settings entry value of a CLR type => Settings Storage value serialized to a primitive type.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.SettingsEntryToSettingsStorageSerialization.SerializeEntryValueToStorageValue(JetBrains.Application.Settings.SettingsIndexedEntry,System.Object,JetBrains.Util.IExceptionThrowingLogger)">
            <summary>
            Settings Store settings entry (indexed) value of a CLR type => Settings Storage value serialized to a primitive type.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.SettingsEntryToSettingsStorageSerialization.SerializeEntryIndexToStorageValue(JetBrains.Application.Settings.SettingsIndexedEntry,System.Object,JetBrains.Util.IExceptionThrowingLogger)">
            <summary>
            Serializes an index to an indexed entry or an indexed ket for storing as a settings storage value (for info only; useful form of indices is within the settings storage key).
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.SettingsEntryToSettingsStorageSerialization.DeserializeStorageKeyToEntryIndex(JetBrains.Application.Settings.SettingsIndexedEntry,System.String,JetBrains.Util.IExceptionThrowingLogger)">
            <summary>
            Settings Storage key part serialized to a string => settings store indexed settings entry index of a CLR type.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.SettingsEntryToSettingsStorageSerialization.DeserializeStorageKeyToKeyIndex(JetBrains.Application.Settings.SettingsIndexedKey,System.String,JetBrains.Util.IExceptionThrowingLogger)">
            <summary>
            Settings Storage key part serialized to a string => settings store indexed settings key index of a CLR type.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.SettingsEntryToSettingsStorageSerialization.SerializeEntryIndexToStorageKey(JetBrains.Application.Settings.SettingsIndexedEntry,System.Object,JetBrains.Util.IExceptionThrowingLogger)">
            <summary>
            Settings Store indexed settings entry index of a CLR type => part of the Settings Storage key serialized to a string.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.SettingsEntryToSettingsStorageSerialization.SerializeKeyIndexToStorageKey(JetBrains.Application.Settings.SettingsIndexedKey,System.Object,JetBrains.Util.IExceptionThrowingLogger)">
            <summary>
            Settings Store indexed settings key index of a CLR type => part of the Settings Storage key serialized to a string.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.Store.Implementation.SettingsEntryToSettingsStorageSerialization.CoreStorageSerialization">
            <summary>
            Contains raw serialization routines.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.SettingsEntryToSettingsStorageSerialization.CoreStorageSerialization.DeserializeStorageValue(JetBrains.Application.Settings.SettingsStoreSerializerType,System.Object,System.Type,JetBrains.Util.ILogger)">
            <summary>
            <para>Deserializes a value in the settings storage back into the CLR type.</para>
            </summary>
            <returns>Note: serialization for taking part in a settings storage key has much more limitations than serializing for storing in the settings storage value, that's why there're two sets of serialization functions.</returns>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.SettingsEntryToSettingsStorageSerialization.CoreStorageSerialization.SerializeStorageValue(JetBrains.Application.Settings.SettingsStoreSerializerType,System.Object,System.Type,JetBrains.Util.ILogger)">
            <summary>
            <para>Serializes a runtime CLR object for storing the value in the settings storage.</para>
            </summary>
            <returns>Note: serialization for taking part in a settings storage key has much more limitations than serializing for storing in the settings storage value, that's why there're two sets of serialization functions.</returns>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.SettingsEntryToSettingsStorageSerialization.CoreStorageSerialization.DeserializeStorageKey(JetBrains.Application.Settings.SettingsStoreSerializerType,System.String,System.Type,JetBrains.Util.ILogger)">
            <summary>
            <para>Deserializes a value taken out of a settings storage key part back into the CLR type for use as an index to indexed keys/entries.</para>
            </summary>
            <returns>Note: serialization for taking part in a settings storage key has much more limitations than serializing for storing in the settings storage value, that's why there're two sets of serialization functions.</returns>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.SettingsEntryToSettingsStorageSerialization.CoreStorageSerialization.SerializeStorageKey(JetBrains.Application.Settings.SettingsStoreSerializerType,System.Object,JetBrains.Util.ILogger)">
            <summary>
            <para>Serializes a runtime CLR index to indexed keys/entries object for using as a local name part of a settings storage key.</para>
            </summary>
            <returns>Note: serialization for taking part in a settings storage key has much more limitations than serializing for storing in the settings storage value, that's why there're two sets of serialization functions.</returns>
        </member>
        <member name="T:JetBrains.Application.Settings.Store.Implementation.SettingsEntryToSettingsStorageSerialization.CoreStorageSerialization.StringToLocalNameSerializer">
            <summary>
            <para>Serializes an arbitrary string so that it fit the charset of a local name within a storage key.</para>
            <para>The secondary objective is to retain “good” strings unmangled, i.e. if a string fits the charset already, it should be written as is to save space, speed, and human-readability.</para>
            <para>Currently the algorithm lets latin alphanumerics through, and all other characters are encoded similar to QuotedPrintable, but with an underscore as a designator instead of an equality sign.</para>
            <para>To ensure identity on all serializations of the same key, we state that <c>[0-9A-Za-z]</c> are always let thru AS IS, and all others are encoded with an <see cref="F:JetBrains.Application.Settings.Store.Implementation.SettingsEntryToSettingsStorageSerialization.CoreStorageSerialization.StringToLocalNameSerializer.EscapeCharacter">underscore</see> followed by four uppercase hex digits of the UTF-16 character code, starting with the most significant one.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Store.Implementation.SettingsEntryToSettingsStorageSerialization.CoreStorageSerialization.StringToLocalNameSerializer.EscapeCharacter">
            <summary>
            The char which leads the quoted-printable escape sequence. Followed by four uppercase hex digits.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.SettingsEntryToSettingsStorageSerialization.CoreStorageSerialization.StringToLocalNameSerializer.Serialize(System.String)">
            <summary>
            Serializes an arbitrary strings into a localname-fitting form.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.SettingsEntryToSettingsStorageSerialization.CoreStorageSerialization.StringToLocalNameSerializer.Deserialize(System.String)">
            <summary>
            Deserializes a previously serialized string back into the original string.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.SettingsEntryToSettingsStorageSerialization.CoreStorageSerialization.StringToLocalNameSerializer.IsLetThruChar(System.Char)">
            <summary>
            If the char could be let thru.
            Note that even though an underscore is allowed within a local name, we reserve it for an escaping character and do not let thru.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.Store.Implementation.SettingsStorageMountPoint">
            <summary>
            Default implementation for a mountpoint.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.ISettingsStorageMountPoint">
            <summary>
            To make a physical settings storage available for use with the Settings Store access, it must be mounted into the Settings Store using this interface.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Settings.ISettingsStorageMountPoint.Name">
            <summary>
            Gets the name of the mounting point. Usually, this is the same as the storage name. However, it is possible to mount different subpaths of a storage separately, in which case individual mount names should be provided.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Settings.ISettingsStorageMountPoint.IsAvailable">
            <summary>
            Gets whether the mounting point is available in specific contexts.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Settings.ISettingsStorageMountPoint.Priority">
            <summary>
            Gets the priority of this mounting point.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Settings.ISettingsStorageMountPoint.Flags">
            <summary>
            Basic characteristics of the mounting point.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Settings.ISettingsStorageMountPoint.Metadata">
            <summary>
            Custom metadata to provide extensive information on the mounting point.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Settings.ISettingsStorageMountPoint.Storage">
            <summary>
            Gets the underlying storage of the mounting point.
            All of the storage operations should go under <see cref="P:JetBrains.Application.Settings.ISettingsStorageMountPoint.PathInStorage"/>.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Settings.ISettingsStorageMountPoint.PathInStorage">
            <summary>
            The mounting path in the storage under which all of the data accessible through this mounting point resides.
            This allows to mount several subparts of the same storage individually.
            </summary>
            <remarks>The type of this property is essentially a string, but it is strongly-typed to enable smart-completing typical default values when a new mounting point is created.</remarks>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.SettingsStorageMountPoint.#ctor(JetBrains.Application.Settings.Storage.ISettingsStorage,JetBrains.Application.Settings.Store.Implementation.SettingsStorageMountPoint.MountPath,JetBrains.Application.Settings.MountPointFlags,System.Double,JetBrains.Application.Settings.IIsAvailable,System.String)">
            <summary>
            
            </summary>
            <param name="storage"></param>
            <param name="pathInStorage"></param>
            <param name="flags"></param>
            <param name="priority"></param>
            <param name="isAvailable"></param>
            <param name="name">
            <para>The name of the mouting point. Usually, this is the same as the storage name. However, it is possible to mount different subpaths of a storage separately, in which case individual mount names should be provided.</para>
            <para><c>Null</c> to use the storage name automatically.</para>
            </param>
        </member>
        <member name="T:JetBrains.Application.Settings.Store.Implementation.SettingsStorageMountPoint.MountPath">
            <summary>
            A special typed wrapper for the mounted path.
            Its main goal is to provide a convenient shortcut to the default value for the mounting path.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Store.Implementation.SettingsStorageMountPoint.MountPath.Default">
            <summary>
            The default value to be used in most cases.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Settings.Store.Implementation.SettingsStorageMountPoint.MountPath.Value">
            <summary>
            Value inside the typed wrapper.
             TODO: minimize use of this value, because its behavior around slashes is inconsistent
            </summary>
        </member>
        <member name="P:JetBrains.Application.Settings.Store.Implementation.SettingsStorageMountPoint.MountPath.KeyPathComponent">
            <summary>
            Value inside the typed wrapper.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.Store.Implementation.SettingsStorageMountPoints">
            <summary>
            Accumulates all advertised settings storage mount points and optimizes typical access to them.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Store.Implementation.SettingsStorageMountPoints.myMountsGroupedByAvailabilityLocked">
            <summary>
            <para>Same mounts as in <see cref="F:JetBrains.Application.Settings.Store.Implementation.SettingsStorageMountPoints.MountPoints"/> and <see cref="F:JetBrains.Application.Settings.Store.Implementation.SettingsStorageMountPoints.EnumMountPointsLiveOrdered"/>, but here they're gathered into groups of the same priority and same availability, with an option to quickly calculate availability of the whole group.</para>
            <para>The groups (all items in group of the same priority) are sorted by priority, ascending.</para>
            <para>For access for modification and when the <see cref="F:JetBrains.Application.Settings.Store.Implementation.SettingsStorageMountPoints.myMountsGroupedByAvailabilityLockFree"/> is outdated only.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Store.Implementation.SettingsStorageMountPoints.myLockMountsGroupedByAvailabilityLocked">
            <summary>
            Locks access to <see cref="F:JetBrains.Application.Settings.Store.Implementation.SettingsStorageMountPoints.myMountsGroupedByAvailabilityLocked"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Store.Implementation.SettingsStorageMountPoints.myMountsGroupedByAvailabilityLockFree">
            <summary>
            <para>A lock-free cache of <see cref="F:JetBrains.Application.Settings.Store.Implementation.SettingsStorageMountPoints.myMountsGroupedByAvailabilityLocked"/>. When <c>Null</c>, should be recalculated from source.</para>
            <para>Recalculation is not performed on every modification because there might be many modifications in a row and here we get a chance to realloc the array only once.</para>
            <para>Reads are lock-free, writes are protected with the same lock as reads of <see cref="F:JetBrains.Application.Settings.Store.Implementation.SettingsStorageMountPoints.myMountsGroupedByAvailabilityLocked"/>.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Store.Implementation.SettingsStorageMountPoints.Empty">
            <summary>
            Gets an instance without any mountpoints at all.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.SettingsStorageMountPoints.AssertConsistentSlow">
            <summary>
            Self-check for calling only in consistency-checking mode.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.Store.Implementation.SettingsStorageMountPoints.SelfCheckControl">
            <summary>
            Whether the owning class should be doing slow self-checks on any modification to ensure consistent modification of the optimization groups.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.Store.Implementation.SettingsStorageMountPoints.SelfCheckControlOffForNormalRuntime">
            <summary>
            Constructed by Shell to run the real product without this slow self-check.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.Store.Implementation.SettingsStorageMountPoints.SelfCheckControlOn">
            <summary>
            Constructed by Shell to run the real product without this slow self-check.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.Store.Implementation.SettingsStorageOnMountPoints">
            <summary>
            Emulates settings-storage-like API on a group of settings storages mounted with mounting points.
            This involves:
            (1) Dispatching access to mounting points favoring storage key translation against the mounting path of each mounting point.
            (2) When reading: looking thru the stack of the mounting points, along their priority, for the highest-priority defined value.
            (3) When writing: either writing to the highest possible mounting point, or implementing the SmartSave strategy.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.SettingsStorageOnMountPoints.GetExObsolete(System.String,JetBrains.Application.Settings.Storage.ISettingsStorageTransactionContext)">
            <summary>
            Gets the value along with the exact storage in which the value was found.
            If the value is not found in either storage, the whole return value is <c>Null</c>, not only the tuple components.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.SettingsStorageOnMountPoints.GetExRaw(JetBrains.Application.Settings.Storage.KeyPathComponents,JetBrains.Application.Settings.Storage.ISettingsStorageTransactionContext,JetBrains.Util.ILogger)">
            <summary>
            Gets the value along with the exact storage in which the value was found.
            If the value is not found in either storage, the whole return value is <c>Null</c>, not only the tuple components.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.SettingsStorageOnMountPoints.SetSmartRaw(JetBrains.Application.Settings.Storage.KeyPathComponents,System.Object,JetBrains.Application.Settings.Store.Implementation.SettingsStorageOnMountPoints.SetFlags,JetBrains.Application.Settings.Storage.ISettingsStorageTransactionContext)">
            <summary>
            A shortcut to <see cref="M:JetBrains.Application.Settings.Store.Implementation.SettingsStorageOnMountPoints.SetSmartRaw(JetBrains.Application.Settings.Storage.KeyPathComponents,System.Object,JetBrains.Application.Settings.Store.Implementation.SettingsStorageOnMountPoints.SetFlags,JetBrains.Application.Settings.Storage.ISettingsStorageTransactionContext)"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.SettingsStorageOnMountPoints.SetSmartRaw(JetBrains.Application.Settings.Storage.KeyPathComponents,System.Object,JetBrains.Application.Settings.Store.Implementation.SettingsStorageOnMountPoints.SetFlags,JetBrains.Application.Settings.Storage.ISettingsStorageTransactionContext,JetBrains.Application.Settings.Storage.KeyPathComponent@,System.Object)">
            <summary>
            Sets a value, according with the SmartSave strategy.
            </summary>
            <remarks>
            <para>Here's a detailed description of what SmartSave startegy is about.</para>
            <para>We operate on a layered structure of settings mount points, ordered by priority, some of them writable and some not. A typical picture (as per specific context of a project file) would be:</para>
            <para>• Global User Settings (writable, lowest priority)</para>
            <para>• Solution Shared Settings (R/O)</para>
            <para>• Solution User Settings (writable)</para>
            <para>• Project Shared Settings (R/O)</para>
            <para>• Project User Settings (writable, highest priority)</para>
            <para>Besides that, non-indexed entries have default values defined for them in the Schema, which take effect when neither of this layers has a value defined for the entry.</para>
            <para>SmartSave follows the policy:</para>
            <para><b>(1)</b> As we set the value, the effective value of this context must be read from the deepest layer possible (Defaults is the best choice).</para>
            <para><b>(2)</b> The value assigned must also be effective in all the “parent” contexts of this context.</para>
            <para>These rules guarantee that if user changes a setting here he will also see the effect in other files/projects/solutions, unless explicitly overridden there.</para>
            <para>To fullfill rule 1, we shouldn't be writing into more-specific layers unless we really have to. By default we're writing to the global layer, wiping out all of the more specific overrides. If there're any readonly overrides, we also set the desired value into the lowest availavble writable layer above which there're no overrides for this setting in readonly layers.</para>
            <para>To fullfill rule 2, we're covering each override defined in a readonly layer with a higher-priority override in the nearest writable layer. Even though of all such overrides only the highest one can bee “seen” in exactly this context, overriding intermediate ones guarantees the new value is consistent through all contexts.</para>
            <para>Extension for the secondary value smart-set simultaneousely: this allows to smart-set the primary value almost as usual plus some additional value to have the desired value on all of the mounts which have the primary value assigned, if possible. This is to implement the indexed value removal flag: it's queried for only on the same mount as the value itself, and when setting/removing an indexed value it must take the correct true/false form. In our algorithm, besides writing one more value, this affects the detection of whether we have to cover an override in a readonly layer: the primary value might be OK but the secondary one is bad =&gt; both must be written to a higher-priority writable layer for correct behavior.</para>
            </remarks>
            <param name="keyPathComponentsWithEmptySlot">Storage key to the value (with the first empty slot for MountGet/MountSet).</param>
            <param name="valuePrimary">A non-<c>Null</c> value to set. You cannot set value to <c>Null</c> in terms of the SmartSave strategy (but setting to default value is likely to have such an effect), the set-to-<c>Null</c> operation is only applicable when writing to specific mounting points.</param>
            <param name="flags"></param>
            <param name="transaction"></param>
            <param name="componentSecondary">If we're co-setting the secondary value (<see cref="!:valueSecondary"/> is non-<c>Null</c>), specifies the replacement key path component for the last path component of the primary value (<see cref="!:keyPathComponentsWithEmptySlot"/>). Hence, the secondary value can differ in the last path component only. Passed byref to save on params stack.</param>
            <param name="valueSecondary">If we're co-setting the secondary value, gives the non-<c>Null</c> secondary value (<paramref name="flags"/> define whether it's the default value). If <c>Null</c>, we're not co-setting.</param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.SettingsStorageOnMountPoints.EnumKeysObsolete(System.String,JetBrains.Application.Settings.Storage.ISettingsStorageTransactionContext)">
            <summary>
            Enums keys from all the mounts. Duplicates are removed.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.SettingsStorageOnMountPoints.CopyToObsolete(JetBrains.Application.Settings.ISettingsStorageMountPoint,JetBrains.Application.Settings.Storage.ISettingsStorageTransactionContext,JetBrains.Application.Settings.Storage.ISettingsStorageTransactionContext,JetBrains.Util.ILogger,System.String)">
            <summary>
            Copies the contents of this layered storage to the target mounting point.
            </summary>
            <param name="mountTarget"></param>
            <param name="transactionThis"></param>
            <param name="transactionTarget"></param>
            <param name="logger">Reports outer errors with copying. Note that in-storage failures will go to the logging facility of the respective storage.</param>
            <param name="sRootKey">Optional. If only a part of the mounting point's contents should be copied, specifies the root key of the data to copy. If <c>Null</c> or an empty string, the whole storage under the mounting path will be copied.</param>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.SettingsStorageOnMountPoints.EraseObsolete(System.String,System.Boolean,JetBrains.Application.Settings.Storage.ISettingsStorageTransactionContext)">
            <summary>
            Erases all of the data in all the [writable] layers under the given key.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.SettingsStorageOnMountPoints.IsMountWritable(JetBrains.Application.Settings.ISettingsStorageMountPoint,System.Boolean)">
            <summary>
            Gets whether we should be writing into the mounting point, favoring its writeability flags and whether we're in the ignore-readonly-flag mode.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.SettingsStorageOnMountPoints.EnumRaw(JetBrains.Application.Settings.Storage.KeyPathComponents,System.Int32,System.Action{JetBrains.Application.Settings.Storage.KeyPathComponents,System.Object},JetBrains.Application.Settings.Storage.ISettingsStorageTransactionContext)">
            <summary>
            Enumerates all of the mounted storages, either under a specific key, or the whole mounted section.
            </summary>
            <param name="keyPathComponentsWithEmptySlot">Storage key to the root to be enumerated (with the first empty slot for MountEnum).</param>
            <param name="nTakeChildLevelOnly"></param>
            <param name="FCallback">Calls you back on each encountered storage key. Includes the mountpath in the first component (whatever it is, not necessarily default/empty). Might call multuple times for the same path if it's present in more than one mountpoint.</param>
            <param name="transaction"></param>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.SettingsStorageOnMountPoints.JetBrains#Application#Settings#Storage#ISettingsStorage#Enum(JetBrains.Application.Settings.Storage.KeyPathComponents,System.Int32,System.Action{JetBrains.Application.Settings.Storage.KeyPathComponents,System.Object},JetBrains.Application.Settings.Storage.ISettingsStorageTransactionContext)">
            <summary>
            Warning! This method is slower than calling <see cref="M:JetBrains.Application.Settings.ISettingsStorageMountPointEx.MountEnumRaw(JetBrains.Application.Settings.ISettingsStorageMountPoint,JetBrains.Application.Settings.Storage.KeyPathComponents,System.Int32,System.Action{JetBrains.Application.Settings.Storage.KeyPathComponents,System.Object},JetBrains.Application.Settings.Storage.ISettingsStorageTransactionContext,JetBrains.Util.ILogger)"/> manually because here it has to cut the first path component out of the mount-enummed data.
            </summary>
            <param name="root"></param>
            <param name="nTakeChildLevelOnly"></param>
            <param name="FCallback"></param>
            <param name="transaction"></param>
        </member>
        <member name="T:JetBrains.Application.Settings.Store.Implementation.SettingsStorageOnMountPoints.SetSmartResult">
            <summary>
            The replacement dummy empty <see cref="T:JetBrains.Application.Settings.Store.Implementation.SettingsStorageOnMountPoints.SetSmartResult"/> ('cause we don't need its data at the moment and want to keep the stack memory low, and don't want to drop all of the code yet, it's useful for debug and such).
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.Store.Implementation.SettingsStorageOnMountPoints.SetSmartResult_ReplacedWithDummy">
            <summary>
            This is the real <see cref="T:JetBrains.Application.Settings.Store.Implementation.SettingsStorageOnMountPoints.SetSmartResult"/>.
            Has been replaced by a dummy to save on stack traffic because right now we seemingly do not need the thing.
            If it's ever required again, just rename it back.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Store.Implementation.SettingsStorageOnMountPoints.SetSmartResult_ReplacedWithDummy.EffectiveReadMountPoint">
            <summary>
            The mount which provides the newly-set value.
            Returned non-<c>Null</c> in SmartSave case if succeeded to set the value (can fail if writing to writables only and another value is set in a higher-priority readonly mount), <c>Null</c> otherwise (because direct-write does not read any values).
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Store.Implementation.SettingsStorageOnMountPoints.SetSmartResult_ReplacedWithDummy.WrittenTo">
            <summary>
            The list of mounting points we've written to.
            In non-smart-save case, just the highest-priority [writable] mounting point.
            In smart-save case, when setting a <c>Null</c> value, all of the mounting points we've removed value from.
            In smart-save case, when setting a non-<c>Null</c> value: could be empty if non-must-write, or just the wide mounting point, or wide than narrow (if writing to wide didn't have effect for layered reading).
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Store.Implementation.SettingsStorageOnMountPoints.SetSmartResult_ReplacedWithDummy.IsSuccessful">
            <summary>
            Whether we succeeded to make the given value the effective value of the context.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Store.Implementation.SettingsStorageOnMountPoints.SetSmartResult_ReplacedWithDummy.EffectiveReadLayerIndex">
            <summary>
            Index of the <see cref="F:JetBrains.Application.Settings.Store.Implementation.SettingsStorageOnMountPoints.SetSmartResult_ReplacedWithDummy.EffectiveReadMountPoint"/> as a layer in the layered structure.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.SettingsStorageOnMountPoints.SetSmartResult_ReplacedWithDummy.SetResult(System.Boolean,System.Int32,JetBrains.Application.Settings.ISettingsStorageMountPoint)">
            <summary>
            Assigns the result-outlining properties.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Store.Implementation.SettingsStorageOnMountPoints.SetSmartResult_ReplacedWithDummy.WriteData.MountPoint">
            <summary>
            The mounting point the write was performed into.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Store.Implementation.SettingsStorageOnMountPoints.SetSmartResult_ReplacedWithDummy.WriteData.Action">
            <summary>
            Why this layer is listed.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Store.Implementation.SettingsStorageOnMountPoints.SetSmartResult_ReplacedWithDummy.WriteData.LayerIndex">
            <summary>
            Index of the <see cref="F:JetBrains.Application.Settings.Store.Implementation.SettingsStorageOnMountPoints.SetSmartResult_ReplacedWithDummy.WriteData.MountPoint"/> as a layer in the layered structure.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Store.Implementation.SettingsStorageOnMountPoints.SetFlags.IgnoreReadonlyFlag">
            <summary>
            Set: does not favor <see cref="F:JetBrains.Application.Settings.MountPointFlags.IsWritable"/> when looking for the mount to write to.
            Not set: writes only to <see cref="F:JetBrains.Application.Settings.MountPointFlags.IsWritable"/> mounts.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Store.Implementation.SettingsStorageOnMountPoints.SetFlags.IsNullValueOk">
            <summary>
            Some values have implicit defaults which take effect when a value is not set on any layers. When we're setting a value which is the same as the defaults, the preferrable behavior for SmartSave is toIf during SmartSave we're able to wipe out all of the values set in layers so that reading the storage returns <c>Null</c>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Store.Implementation.SettingsStorageOnMountPoints.SetFlags.IsSecondaryNullValueOk">
            <summary>
            Same as <see cref="F:JetBrains.Application.Settings.Store.Implementation.SettingsStorageOnMountPoints.SetFlags.IsNullValueOk"/>, but applies to the secondary value of the <see cref="M:JetBrains.Application.Settings.Store.Implementation.SettingsStorageOnMountPoints.SetSmartRaw(JetBrains.Application.Settings.Storage.KeyPathComponents,System.Object,JetBrains.Application.Settings.Store.Implementation.SettingsStorageOnMountPoints.SetFlags,JetBrains.Application.Settings.Storage.ISettingsStorageTransactionContext)"/> method.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Store.Implementation.SettingsStorageOnMountPoints.SmartWriteAction.PassedReadonlyOk">
            <summary>
            Encountered a value in a readonly layer which was equal to the desired value.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Store.Implementation.SettingsStorageOnMountPoints.SmartWriteAction.PassedReadonlyConflicting">
            <summary>
            Encountered a value in a readonly layer which was not equal to the desired value.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Store.Implementation.SettingsStorageOnMountPoints.SmartWriteAction.ValueAlreadyWritten">
            <summary>
            Was about to write a value to a writable layer (to cover defaults or readonlies), but the layer is already set to the desired value.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Store.Implementation.SettingsStorageOnMountPoints.SmartWriteAction.WroteValue">
            <summary>
            Wrote the desired value to a writable layer.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Store.Implementation.SettingsStorageOnMountPoints.SmartWriteAction.ErasedValue">
            <summary>
            Erased a value from a writable layer.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.Store.Implementation.SettingsStore">
            <summary>
            Main implementation of the Settings Store.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.ISettingsStoreInTransaction">
            <summary>
            An interface to the settings store that has been created as a child transaction to some other settings store.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.ISettingsStore">
            <summary>
            The central interface for accessing Settings in terms of Keys &amp; Entries in various contexts.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.ISettingsStore.BindToContextLive(JetBrains.DataFlow.Lifetime,JetBrains.Application.Settings.ContextRange,JetBrains.Application.Settings.Store.Implementation.BindToContextFlags)">
            <summary>
            <para>Binds Settings Store for reading and writing values in a specific context.</para>
            <para>The resulting object is live, which means it will see the newly-added mounting points (if they fit the context) and can fire events when settings change in this context.</para>
            </summary>
            <param name="lifetime">Lifetime for the live context.</param>
            <param name="contextrange">Range of the contexts for reading and writing.</param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Application.Settings.ISettingsStore.BindToContextTransient(JetBrains.Application.Settings.ContextRange,JetBrains.Application.Settings.Store.Implementation.BindToContextFlags)">
            <summary>
            <para>A lightweight method which binds Settings Store for reading and writing values in a specific context.</para> 
            <para>Do not store the resulting objects because they will not see any newly-added mounts. Does not require a lifetime.</para>
            </summary>
            <param name="contextrange">Range of the contexts for reading and writing.</param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Application.Settings.ISettingsStore.CreateNestedTransaction(JetBrains.DataFlow.Lifetime,System.String)">
            <summary>
            <para>Creates a nested transaction in the current Settings Store.</para>
            <para>All of the changes to the transacted Settings Store are not visible outside the transaction until you commit them.</para>
            <para>You have the same interface to the transacted Settings Store as to the normal one, with addition of a few methods for committing and reverting its transaction.</para>
            </summary>
            <param name="lifetime">Lifetime of the transaction. The transaction is automatically reverted when this lifetime ends. If you would like to commit the changes, call <see cref="M:JetBrains.Application.Settings.ISettingsStoreInTransaction.CommitTransaction"/> before terminating the transaction lifetime.</param>
            <param name="name"></param>
        </member>
        <member name="M:JetBrains.Application.Settings.ISettingsStore.GetOrderedMountPointsInContext(JetBrains.Application.DataContext.IDataContext)">
            <summary>
            Returns the sequence of mounting points applicable to the specified context, sorted by priority ascending.
            </summary>
            <param name="context">Filtering context.</param>
            <returns>Sequence.</returns>
        </member>
        <member name="M:JetBrains.Application.Settings.ISettingsStore.BindToMountPoints(System.Collections.Generic.IEnumerable{JetBrains.Application.Settings.ISettingsStorageMountPoint},JetBrains.Application.Settings.ISettingsStorageMountPoint,JetBrains.Application.Settings.Store.Implementation.BindToContextFlags)">
            <summary>
            Binds the context to the explicitly specified mount points.
            With non-transacted settings store, this means just creating a new bound store on the mount points.
            In transacted stores, the current implementation of the transactions means adding a new overlay mounting point per each orignal mounting point. That's why we need to pipe context creation thru the transacted store object: to add the overlay mounts correctly.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.ISettingsStore.BindToMountPoints(JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.IListEvents{JetBrains.Application.Settings.ISettingsStorageMountPoint},JetBrains.DataFlow.IProperty{JetBrains.Application.Settings.ISettingsStorageMountPoint},JetBrains.Application.Settings.Store.Implementation.BindToContextFlags)">
            <summary>
            Binds the context to the explicitly specified mount points.
            With non-transacted settings store, this means just creating a new bound store on the mount points.
            In transacted stores, the current implementation of the transactions means adding a new overlay mounting point per each orignal mounting point. That's why we need to pipe context creation thru the transacted store object: to add the overlay mounts correctly.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Settings.ISettingsStore.Schema">
            <summary>
            Gets the settings schema which describes possible Keys and Entries which can be read or written on the Settings Store.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Settings.ISettingsStore.DataContexts">
            <summary>
            <para>Gets the helper object which creates the data contexts to define the contexts in which settings are read or written.</para>
            <para>For example, two project files might have different settings because different mounting points are available in their contexts.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Application.Settings.ISettingsStore.MountPoints">
            <summary>
            <para>Gets the total list of mounting points available for storing the settings.</para>
            <para>Binding the store to a context filters this list down to those mounting points available in a specific context.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Application.Settings.ISettingsStore.MountingPointsTransaction">
            <summary>
            <para>Gets the transaction object which this settings store uses for accessing the underlying mounted storages.</para>
            <para>This is always non-<c>Null</c> if this settings store is running within a transaction (and is <see cref="T:JetBrains.Application.Settings.ISettingsStoreInTransaction"/> actually).</para>
            <para>If this settings store is not in a transaction, then this is <c>Null</c>.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.ISettingsStoreInTransaction.CommitTransaction">
            <summary>
            <para>Commits the changes accumulated within this transaction to the parent context (to the real Settings Store if this is not a nested transaction).</para>
            <para>You can continue using the transaction after it's committed.</para>
            </summary>
            <remarks>The operation is thread-safe in that the Settings Store will be running consistently, but you might encounter side-effects if you are working on another thread with the transaction being committed.</remarks>
        </member>
        <member name="M:JetBrains.Application.Settings.ISettingsStoreInTransaction.RevertTransaction">
            <summary>
            <para>Reverts all of the changes performed within the transaction.</para>
            <para>You can continue using the transaction after it's reverted.</para>
            <para>Terminating the transaction lifetime also terminates the transaction, so it's not required to call <see cref="M:JetBrains.Application.Settings.ISettingsStoreInTransaction.RevertTransaction"/> before dropping the obhect.</para>
            </summary>
            <remarks>The operation is thread-safe in that the Settings Store will be running consistently, but you might encounter side-effects if you are working on another thread with the transaction being reverted.</remarks>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.SettingsStore.#ctor(JetBrains.DataFlow.Lifetime,JetBrains.Application.Settings.ISettingsSchema,JetBrains.Application.Settings.Store.Implementation.SettingsStorageMountPoints,JetBrains.Application.DataContext.DataContexts,JetBrains.Application.Settings.Storage.ISettingsStorageTransactionContext,JetBrains.Application.Settings.Logging.ISettingsLogger,JetBrains.Application.Settings.Store.Implementation.ISettingsChangeDispatch)">
            <summary>
            Creates a new store instance.
            </summary>
            <param name="lifetime"></param>
            <param name="schema">This schema must include all of the keys and entries you intend to access thru this store.</param>
            <param name="mountpoints">The list of mounting points which are layers with settings, filtered for availability when you bind to a context.</param>
            <param name="dataContexts">Helper for creating data contexts. The store itself does not quite need it, but it's required by helper APIs for binding to the context conveniently.</param>
            <param name="transaction">Non-<c>Null</c> if this store is accessing settings within a transaction. New transactions must be opened by the calling party (e.g. <see cref="M:JetBrains.Application.Settings.Store.Implementation.SettingsStore.CreateNestedTransaction(JetBrains.DataFlow.Lifetime,System.String)"/> method).</param>
            <param name="logging">Logging facility of the Settings subsystem.</param>
            <param name="changedispatch"></param>
        </member>
        <member name="F:JetBrains.Application.Settings.Store.Implementation.BindToContextFlags.IgnoreReadonlyFlag">
            <summary>
            Writes into readonly mounting points.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.Store.Implementation.SettingsStoreChangeSink">
            <summary>
            Implements sinking changes in mount point storages for the <see cref="T:JetBrains.Application.Settings.Store.Implementation.SettingsStore"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.SettingsStoreChangeSink.RegisterMount(JetBrains.DataFlow.Lifetime,JetBrains.Application.Settings.Store.Implementation.SettingsStoreChangeSink.ClientInfo,JetBrains.Application.Settings.ISettingsStorageMountPoint,System.Boolean)">
            <summary>
            Called when a client wants to register one more mount for it, for the lifetime specified. Also called for initial lifetimes, <see cref="!:isWithAddAcknowledgement"/> is <c>False</c> for such mounts.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.SettingsStoreChangeSink.DispatchChanges">
            <summary>
            Does processing the recorded changes (storage keys and mountpoints set) on a background thread when the grouping event ticks.
            NOTE: threading policy depends on the <see cref="T:JetBrains.Application.Settings.Store.Implementation.ISettingsChangeDispatch"/> strategy.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Store.Implementation.SettingsStoreChangeSink.myMapClientsToSimpleChanges">
            <summary>
            Individual changed keys, as should be dispatched to clients.
            The key path components of the change contain a placeholder for the mounting path.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Store.Implementation.SettingsStoreChangeSink.myMapClientsToWholeMountChanges">
            <summary>
            Whole mount contents change, as should be dispatched to clients.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Store.Implementation.SettingsStoreChangeSink.myMapMountToClients">
            <summary>
            Maps mounts to the clients which are listening for those mounts at the moment.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.SettingsStoreChangeSink.RegisterClientForMounts(JetBrains.DataFlow.Lifetime,System.Collections.Generic.IEnumerable{JetBrains.Application.Settings.ISettingsStorageMountPoint})">
            <summary>
            Entry point for sinking any changes.
            </summary>
            <param name="lifetime">Your client lifetime.</param>
            <param name="mountsInitial">The mounts you got initially. This is a static snapshot.</param>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.SettingsStoreChangeSink.RegisterClientForMountsLive(JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.ICollectionEvents{JetBrains.Application.Settings.ISettingsStorageMountPoint})">
            <summary>
            Entry point for sinking any changes.
            </summary>
            <param name="lifetime">Your client lifetime.</param>
            <param name="mountsLive">The mounts you got initially, and any further changes to the mounts set. Changes will be fired for contents of any mounts not present initially.</param>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.SettingsStoreChangeSink.SinkMountChanges(JetBrains.DataFlow.Lifetime,JetBrains.Application.Settings.ISettingsStorageMountPoint,JetBrains.Application.Settings.Storage.ISettingsStorageTransactionContext,JetBrains.Util.ILogger)">
            <summary>
            For each known mount, sinks its changes while its known.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.SettingsStoreChangeSink.ClientInfo.#ctor(JetBrains.DataFlow.Lifetime,System.Collections.Generic.IEnumerable{JetBrains.Application.Settings.ISettingsStorageMountPoint},System.Action{JetBrains.DataFlow.Lifetime,JetBrains.Application.Settings.Store.Implementation.SettingsStoreChangeSink.ClientInfo,JetBrains.Application.Settings.ISettingsStorageMountPoint,System.Boolean},JetBrains.Util.ILogger)">
            <summary>
            
            </summary>
            <param name="lifetime"></param>
            <param name="mountsInitial">Enumerable, for a static collection. A <see cref="T:JetBrains.DataFlow.ICollectionEvents`1"/>, for a live collection.</param>
            <param name="FRegisterMount"></param>
            <param name="logger"></param>
        </member>
        <member name="T:JetBrains.Application.Settings.Store.Implementation.StoreToStorageTranslation">
            <summary>
            <para>Defines translation between <see cref="T:JetBrains.Application.Settings.SettingsSchema"/> in terms of end-user Settings Store entities (<see cref="T:JetBrains.Application.Settings.SettingsEntry"/>, <see cref="T:JetBrains.Application.Settings.SettingsKey"/>) to string keys in the Settings Storage which physically holds the values.</para>
            </summary>
            <remarks>
            <h1>Schema</h1>
            <para><see cref="T:JetBrains.Application.Settings.SettingsSchema">The schema</see> is the logical schema on <see cref="T:JetBrains.Application.Settings.SettingsKey">settings keys</see> / <see cref="T:JetBrains.Application.Settings.SettingsEntry">settings entries</see>, exposed to the application for getting/setting values of arbitrary user types.</para>
            <para>It is collected by reading classes with <see cref="T:JetBrains.Application.Settings.SettingsKeyAttribute"/> (which produces hierarchy of keys) and inspecting their members for <see cref="T:JetBrains.Application.Settings.SettingsEntryAttribute"/> (which produces key entries).</para>
            
            <h1>Physical Storage</h1>
            <para>Physically, all of the data is stored in the settings storage, which is a key-value store with string keys and values of a few primitive types.</para>
            <para>The logical schema maps into the settings storage keys. For each settings key or settings entry there might be zero or more metadata values written into the storage under a storage key corresponding to one of the metadata items of the key/entry. Some metadata items are required for storing/reading the value, and others are purely informational and might be used for storage browsers and human-readability.</para>
            
            <h1>Storage Keys</h1>
            <para><i>(note: there are Settings Keys, which are logical entities of the Settings Schema and which contain Settings Entries; and there are Settings Storage keys which are string values keying the physical key-value storage actually holding raw values, which is actually written to disk)</i></para>
            <para>Storage keys are slash-separated strins: <c>/one/two/three/four/@metadata</c>.</para>
            <para>The format of the storage keys strings vaguely resembles that of an XPath request. Speaking in terms of XPath, we're only addressing “xml attribute values” in the physical storage. In the storage key string, this means it always ends with “/@metadataname” (a path-separating slash, metadata prefix and name of some <see cref="T:JetBrains.Application.Settings.Store.Implementation.StoreToStorageTranslation.Metadata">metadata</see>).</para>
            <para>Here are syntax definitions of valid settings storage keys pointing to some schema-originating metadata.</para>
            <para>Settings Key metadata:</para>
            <code>
               KeyPathSeparator MountPointPathInStorage 
            
               (
                   KeyPathSeparator KeyLocalName
                   [ KeyPathSeparator ValueInLocalNamePrefix SerializedIndex ]  // Indexed keys only
               )+                                                               // Each key in parent keys chain
            
               KeyPathSeparator MetadataPrefix MetadataName
            </code>
            <para>Settings Entry metadata:</para>
            <code>
               KeyPathSeparator MountPointPathInStorage 
            
               (
                   KeyPathSeparator KeyLocalName
                   [ KeyPathSeparator ValueInLocalNamePrefix SerializedIndex ]  // Indexed keys only
               )+                                                               // Each key in parent keys chain
            
               KeyPathSeparator EntryLocalName
               [ KeyPathSeparator ValueInLocalNamePrefix SerializedIndex ]      // Indexed entries only
            
               KeyPathSeparator MetadataPrefix MetadataName
            </code>
            <para>Legend:</para>
            <list type="table">
            <listheader><term>Keyword</term><description>Meaning</description></listheader>
            <item><term><c>KeyPathSeparator</c></term><description><para><c>“/”</c>. Constant. Defined in <see cref="T:JetBrains.Application.Settings.Store.Implementation.StoreToStorageTranslation.PathComposition"/> as <see cref="F:JetBrains.Application.Settings.Store.Implementation.StoreToStorageTranslation.PathComposition.KeyPathSeparator"/>.</para><para>Separates local names of settings keys and entries, index values on indexed keys and entries, and tailing metadata name in the path making the settings storage key. Analogous to the XPath separator.</para></description></item>
            <item><term><c>ValueInLocalNamePrefix</c></term><description><para><c>“=”</c>. Constant. Defined in <see cref="T:JetBrains.Application.Settings.Store.Implementation.StoreToStorageTranslation.PathComposition"/> as <see cref="F:JetBrains.Application.Settings.Store.Implementation.StoreToStorageTranslation.PathComposition.ValueInLocalNamePrefix"/>.</para><para>When one of the storage key path components are formed from a user-supplied value (for example, indices of indexed keys or entries), denotes such keys for telling them apart from key path components coming from keys/entries' local names.</para><para>If this prefix appears after a settings key or entry local name component in the storage key path, means the key or entry is indexed rather than simple.</para></description></item>
            <item><term><c>MetadataPrefix</c></term><description><para><c>“@”</c>. Constant. Defined in <see cref="T:JetBrains.Application.Settings.Store.Implementation.StoreToStorageTranslation.PathComposition"/> as <see cref="F:JetBrains.Application.Settings.Store.Implementation.StoreToStorageTranslation.PathComposition.MetadataPrefix"/>.</para><para>The last component of the settings storage key on which actual data is stored is a metadata name, which is denoted by this prefix to tell apart from other key components.</para></description></item>
            <item><term><c>MountPointPathInStorage</c></term><description><para>This is not in the scope of this class.</para><para>This path is added by the <see cref="T:JetBrains.Application.Settings.ISettingsStorageMountPoint">mounting point</see> when it mounts a path of a physical storage for access in a specific context.</para><para>As the single storage file might host several independent mount points, they're designated with a prefix on the storage key actually written to the file.</para><para>The mounting point handles appending/removing of this prefix when exposing the storage, so store-to-storage translation does not have to deal with this prefx.</para></description></item>
            <item><term><c>KeyLocalName</c></term><description>Local name of the Settings Key. Defined by <see cref="F:JetBrains.Application.Settings.SettingsKey.LocalName"/>.</description></item>
            <item><term><c>EntryLocalName</c></term><description>Local name of the Settings Entry. Defined by <see cref="F:JetBrains.Application.Settings.SettingsEntry.LocalName"/>.</description></item>
            <item><term><c>SerializedIndex</c></term><description>An index to a particular instance of an indexed key or an indexed entry, in a serialized form. Defined by the actual index value passed to the key/entry access functions.</description></item>
            <item><term><c>MetadataName</c></term><description>Name of the metadata on this key or entry. Possible names defined in <see cref="T:JetBrains.Application.Settings.Store.Implementation.StoreToStorageTranslation.Metadata"/>, see descriptions and possible usages below.</description></item>
            </list>
            
            <h1>Settings Key</h1>
            <para>There is no required metadata for a Settings Store <see cref="T:JetBrains.Application.Settings.SettingsKey">Settings Key</see> because keys themselves have no values in Settings Store. Only entry values are written to the storage. A key is just an organizational unit in the logical schema which helps with early-bound key values and typed deserialization.</para>
            <para>A <see cref="T:JetBrains.Application.Settings.SettingsKey">Settings Key</see> maps to the storage key formed by concatenating local names of it and all of the parent keys. For example, WebProxy under Internet under Environment under root makes the <c>/Environment/Internet/WebProxy</c> settings storage key.</para>
            
            <para><b>Common Settings Key</b> metadata:</para>
            <para>Metadata stored for a settings key, supposing <c>/K/E/Y</c> is its key path:</para>
            <para><i>(note: these are not settings entries of the key yet, just optional metadata for the logical settings key in the physical storage)</i></para>
            <list type="table">
            <listheader><term>Key</term><description>Meaning</description></listheader>
            <item><term><c>/K/E/Y/@KeyDescription</c></term><description><para>(<c>String</c>) Description of the key, as specified in <see cref="!:SettingsKeyAttribute.Description"/>.</para> <para>Optional, non-vital, written when setting value, could be used by settings storage browsers.</para></description></item>
            </list>
            <para><b>Non-indexed Settings Key</b> metadata:</para>
            <para>No special metadata on a non-indexed key — just the all-keys common items.</para>
            <para><b>Indexed Settings Key</b> metadata:</para>
            <para>The storage key for an indexed key includes the serialized form of a particular index which defines the specific instance of an indexed key: <c>/K/E/Y/=IndexSerialized</c>.</para>
            <para>This applies to all of the indexed keys in the parent keys path. For example, if key <c>K</c> is also indexed, the sample path would look like <c>/K/=KIndexSerialized/E/Y/=YIndexSerialized</c>. When reading samples for entry storage keys below, take into account that any indexed key in entrie's parents has also to include its index value.</para>
            <list type="table">
            <listheader><term>Key</term><description>Meaning</description></listheader>
            <item><term><c>/K/E/Y/=IndexSerialized/@KeyIndexDefined</c></term><description><para>(<c>Boolean</c>) <c>True</c> means there is an instance of an indexed key defined for this index. Note that there might be no entry values written to the storage for this key instance if they're all in their default values, still the key instance will be marked as existent.</para><para><c>False</c> means the key might be defined on some of the lower-priority layers, but has been revoked at a higher-priority layer and all of its entries must be ignored.</para><para>{no value} means the key instance is not defined for this index (even though there might be some leftovers of settings entry values in the storage). </para><para>If this value is undefined in all the layers, the key instance will not be present in the logical Settings Store. However, if it's defined to <c>True</c> on at least one layer's storage, all of the entry values on all the storages on any layers, even those without the <c>KeyIndexDefined</c> set, will take part in entry values composition.</para> <para><b>Required.</b> Vital, an indexed key instance will be treated as non-existent without this value.</para></description></item>
            <item><term></term><description></description></item>
            </list>
            
            <h1>Settings Entry</h1>
            
            <para>All information on a <see cref="T:JetBrains.Application.Settings.SettingsEntry">Settings Entry</see> is stored under the key path of its parent Settings Key, plus the local name of the settings entry. Example settings storage key: <c>/K/E/Y/EntryLocalName</c></para>
            
            <para>Common metadata for indexed and non-indexed settings entries (all optional and non-vital):</para>
            <list type="table">
            <listheader><term>Key</term><description>Meaning</description></listheader>
            <item><term><c>/K/E/Y/EntryLocalName/@EntryDescription</c></term><description><para>(<c>String</c>) Description of the entry, as specified in <see cref="!:SettingsEntryAttribute.Description"/>.</para> <para>Optional, non-vital, written when setting value, could be used by settings storage browsers.</para></description></item>
            <item><term></term><description></description></item>
            </list>
            
            <para><b>Non-indexed Settings Entry</b> metadata:</para>
            <list type="table">
            <listheader><term>Key</term><description>Meaning</description></listheader>
            <item><term><c>/K/E/Y/EntryLocalName/@EntryValue</c></term><description><para>(any type) The serialized value of the entry.</para> <para><b>Required.</b> Vital for reading the entry value.</para></description></item>
            <item><term><c>/K/E/Y/EntryLocalName/@EntryType</c></term><description><para>(<c>String</c>) Full name of the <see cref="T:System.Type">CLR type</see> of the settings entry member which was serialized into the settings storage primitive type.</para> <para>Optional, non-vital.</para></description></item>
            <item><term><c>/K/E/Y/EntryLocalName/@EntrySerializer</c></term><description><para>(<c>String</c>) <see cref="T:JetBrains.Application.Settings.SettingsStoreSerializerType"/> enum member name representing the value serializer used when writing the value.</para> <para>Optional, non-vital.</para></description></item>
            </list>
            
            <para><b>Indexed Settings Entry</b> metadata:</para>
            <para>Indexed entries are mapping a simple index to a simple value.</para>
            <para>The following metadata is added to the entry itself, stored under the <c>/K/E/Y/EntryLocalName</c> storage key:</para>
            <list type="table">
            <listheader><term>Key</term><description>Meaning</description></listheader>
            <item><term><c>/K/E/Y/EntryLocalName/@EntryIndexType</c></term><description><para>(<c>String</c>) Full name of the <see cref="T:System.Type">CLR type</see> of the indexed settings entry index.</para> <para>Optional, non-vital.</para></description></item>
            <item><term><c>/K/E/Y/EntryLocalName/@EntryIndexSerializer</c></term><description><para>(<c>String</c>) <see cref="T:JetBrains.Application.Settings.SettingsStoreSerializerType"/> enum member name representing the value serializer used when writing the index.</para> <para>Optional, non-vital.</para></description></item>
            <item><term><c>/K/E/Y/EntryLocalName/@EntryIndexedValueType</c></term><description><para>(<c>String</c>) Full name of the <see cref="T:System.Type">CLR type</see> of the indexed settings entry value.</para> <para>Optional, non-vital.</para></description></item>
            <item><term><c>/K/E/Y/EntryLocalName/@EntryIndexedValueSerializer</c></term><description><para>(<c>String</c>) <see cref="T:JetBrains.Application.Settings.SettingsStoreSerializerType"/> enum member name representing the value serializer used when writing the indexed value.</para> <para>Optional, non-vital.</para></description></item>
            </list>
            <para>An indexed entry is a set of (index, value) pairs, which should have fast lookup by index. Such pairs are units of storage.</para>
            <para>For each pair, its data is stored under the <c>/K/E/Y/EntryLocalName/=IndexSerialized</c> storage key.</para>
            <list type="table">
            <listheader><term>Key</term><description>Meaning</description></listheader>
            <item><term><c>/K/E/Y/EntryLocalName/=IndexSerialized/@EntryIndexedValue</c></term><description><para>(any type) The serialized indexed value of the (index, value) pair.</para> <para><b>Required.</b> <b>Vital</b> for reading the indexed value stored for a specific index.</para></description></item>
            <item><term><c>/K/E/Y/EntryLocalName/=IndexSerialized/@EntryIndex</c></term><description><para>(any type) The serialized index of the (index, value) pair.</para> <para>Optional. Non-vital. Useful for reading the storage because the "IndexSerialized" representation is serialized into a restricted charset and is often unreadable with a bare eye, while in this place a more permissive regular entry value serializer is put to use.</para></description></item>
            <item><term><c>/K/E/Y/EntryLocalName/=IndexSerialized/@EntryIndexRemoved</c></term><description><para>(<c>Boolean</c>) <c>True</c> to force removing the indexed value from the indexed entry values set.</para> <para>This has an effect when a stack of storages is merged, and the indexed entry has has a value for this index in some lower-priority storage, which a higher-priority storage wants to remove altogether as if it has never been set.</para><para>Note that for <c>EntryIndexRemoved</c> to work as intended, <c>EntryIndexedValue</c> must also be set to some (dummy) value on the same storage. For performance reasons, storage lookup through layers is only done for <c>EntryIndexedValue</c>, and <c>EntryIndexRemoved</c> is only checked on those storages found during this lookup.</para> <para>Optional. <b>Vital</b> for removing indexed values in an overriding storage.</para></description></item>
            </list>
            <para>The serialization behavior for index values taking part in storage keys (<c>IndexSerialized</c> in the above examples) differs from that of the indexed values and scalar entry values (and <c>EntryIndex</c> metadata) because we're enforcing strict rules on key local names character set.</para>
            </remarks>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.StoreToStorageTranslation.AppendIndex(System.String,JetBrains.Application.Settings.SettingsIndexedKey,System.Object,JetBrains.Util.IExceptionThrowingLogger)">
            <summary>
            Appends a serialized index value.
            </summary>
            <param name="sKeyBase">Base key. MUST NOT be slash-terminated.</param>
            <param name="key"></param>
            <param name="index">Index value.</param>
            <param name="logger"></param>
            <returns>Composed string. MUST NOT be slash-terminated.</returns>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.StoreToStorageTranslation.AppendIndex(System.String,JetBrains.Application.Settings.SettingsIndexedEntry,System.Object,JetBrains.Util.ILogger)">
            <summary>
            Appends a serialized index value.
            </summary>
            <param name="sKeyBase">Base key. MUST NOT be slash-terminated.</param>
            <param name="entry"></param>
            <param name="index">Index value.</param>
            <param name="logger"></param>
            <returns>Composed string. MUST NOT be slash-terminated.</returns>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.StoreToStorageTranslation.AppendMetadata(System.String,System.String)">
            <summary>
            Appends metadata name.
            </summary>
            <param name="sKeyBase">Base key. MUST NOT be slash-terminated.</param>
            <param name="sMetadataName">Metadata name to append. MUST NOT include the metadata prefix.</param>
            <returns>Composed string. MUST NOT be slash-terminated.</returns>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.StoreToStorageTranslation.AppendLocalName(System.String,System.String)">
            <summary>
            Appends the local name as the next key component.
            </summary>
            <param name="sKeyBase">Base key. MUST NOT be slash-terminated.</param>
            <param name="sLocalName">Local name to append. MUST NOT include leading or trailing (or any) slashes.</param>
            <returns>Composed string. MUST NOT be slash-terminated.</returns>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.StoreToStorageTranslation.ParseStorageKeys_Key(System.Collections.Generic.IList{JetBrains.Application.Settings.SettingsStoreChangeArgs.SettingsKeyInstance},JetBrains.Application.Settings.Storage.KeyPathComponents,JetBrains.Application.Settings.ISettingsSchema,System.Collections.Generic.List{JetBrains.Application.Settings.Store.Implementation.StoreToStorageTranslation.StorageKeyParsedComponent},JetBrains.Util.IExceptionThrowingLogger)">
            <summary>
            Aggregates one more changed key into the total changes delta tree.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Store.Implementation.StoreToStorageTranslation.FillKeyPathComponents(JetBrains.Application.Settings.Storage.KeyPathComponents,JetBrains.Application.Settings.SettingsKey,System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object},JetBrains.Util.ILogger,System.Func{JetBrains.Application.Settings.Storage.KeyPathComponents,System.Boolean})">
            <summary>
            Writes key path to the settings key into the empty components list.
            Leaves one empty leading slot for mounting path component.
            Throws out exceptions for caller: missing key index.
            </summary>
            <param name="keyPathComponents">Writes here. Must be empty.</param>
            <param name="key">Settings key (its parents and its own components will be written, as well as key index components).</param>
            <param name="keyIndices">Indices to the indexed keys in path.</param>
            <param name="logger">Logger.</param>
            <param name="FCallAfterEachIndexedKey">Callback to be invoked after writing an index for each indexed key. If <c>False</c>, processing is aborted and <c>False</c> is returned.</param>
            <returns>Whether any of the <paramref name="FCallAfterEachIndexedKey"/> calls returned <c>False</c>. If so, results might be incomplete.</returns>
        </member>
        <member name="T:JetBrains.Application.Settings.Store.Implementation.StoreToStorageTranslation.Metadata">
            <summary>
            <para>When settings store data is written into the physical settings storage, all of the storage keys end with the last path component containing metadata names (prefixed with <see cref="F:JetBrains.Application.Settings.Store.Implementation.StoreToStorageTranslation.PathComposition.MetadataPrefix"/> for distinction).</para>
            <para>Taking an analogy to XPath syntax, we're only addressing attributes, so all of the expected storage keys end with <c>“/@metadataname”</c>.</para>
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.Store.Implementation.StoreToStorageTranslation.PathComposition">
            <summary>
            Individual elements for composing full storage key paths out of individual local names, index values, and metadata names.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Store.Implementation.StoreToStorageTranslation.PathComposition.KeyPathSeparator">
            <summary>
            Separates local names of settings keys and entries, index values on indexed keys and entries, and tailing metadata name in the path making the settings storage key. Analogous to the XPath separator.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Store.Implementation.StoreToStorageTranslation.PathComposition.MetadataPrefix">
            <summary>
            The last component of the settings storage key on which actual data is stored is a metadata name, which is denoted by this prefix to tell apart from other key components.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Store.Implementation.StoreToStorageTranslation.PathComposition.ValueInLocalNamePrefix">
            <summary>
            <para>When one of the storage key path components are formed from a user-supplied value (for example, indices of indexed keys or entries), denotes such keys for telling them apart from key path components coming from keys/entries' local names.</para>
            <para>If this prefix appears after a settings key or entry local name component in the storage key path, means the key or entry is indexed rather than simple.</para>
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.SettingsEntryAttribute">
            <summary>
            Use this attribute to mark those fields and properties of a <see cref="T:JetBrains.Application.Settings.SettingsKeyAttribute">settings key class</see> that should be settings store simple entries.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.SettingsEntryAttributeBase">
            <summary>
            Base attribute for settings entries.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.SettingsEntryAttributeBase.#ctor(System.String)">
            <summary>
            
            </summary>
            <param name="Description">The string that explains the setting for the means of human-readable settings serialization or settings browser.</param>
        </member>
        <member name="P:JetBrains.Application.Settings.SettingsEntryAttributeBase.EntryNameOverride">
            <summary>
            <para><c>Null</c> to use the field/property member name as the <see cref="F:JetBrains.Application.Settings.SettingsEntry.LocalName">settings entry local name</see> in the settings schema.</para>
            <para>Non-empty to override the local name with a custom string (must comply to key/entry local name rules).</para>
            </summary>
        </member>
        <member name="P:JetBrains.Application.Settings.SettingsEntryAttributeBase.Description">
            <summary>
            Gets the string that explains the setting for the means of human-readable settings serialization or settings browser.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Settings.SettingsEntryAttributeBase.ValueSerializer">
            <summary>
            Gets or sets how the value of the field/property should be serialized for storage.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.SettingsEntryAttributeBase.ReflectionHelpers.myMapPrimitiveTypeNamesToStorageTypesWithCoersion">
            <summary>
            By a name of a primitive mscorlib type, gives out the storage type that will be holding this type (possibly, after coersion).
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.SettingsEntryAttributeBase.ReflectionHelpers.GuessValueSerializer(JetBrains.Application.Catalogs.PartCatalogAttribute,JetBrains.Application.Catalogs.PartCatalogType)">
            <summary>
            If the value serializer type is <see cref="F:JetBrains.Application.Settings.SettingsStoreSerializerType.Auto"/>, guesses the actual type by the member type.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.SettingsEntryAttribute.#ctor(System.Object,System.String)">
            <summary>
            
            </summary>
            <param name="DefaultValue">
            <para>The default value for this entry. You do not need to initialize the field itself in the inline initializer or the constructor. Instead, you MUST set this to the desired initial value, for serialization to work consistently.</para>
            <para>The possible values are:</para>
            <para>• <c>Null</c>, which means the default value for the <see cref="T:System.Type"/> of the field (<c>Null</c> for reference types and zero memory for value types).</para>
            <para>• Some value of the same type as the <see cref="T:System.Type"/> of the field, or a value type convertible to it.</para>
            <para>• An invariant string representation of a value that cannot be presented inline in the attribute ctor. value of the same type as the <see cref="T:System.Type"/> of the field, or a value type convertible to it. The appropriate <see cref="T:System.ComponentModel.TypeConverter"/> is used for reading the value.</para>
            </param>
            <param name="Description">The string that explains the setting for the means of human-readable settings serialization or settings browser.</param>
        </member>
        <member name="P:JetBrains.Application.Settings.SettingsEntryAttribute.DefaultValue">
            <summary>
            <para>The default value for this entry. You do not need to initialize the field itself in the inline initializer or the constructor. Instead, you MUST set this to the desired initial value, for serialization to work consistently.</para>
            <para>The possible values are:</para>
            <para>• <c>Null</c>, which means the default value for the <see cref="T:System.Type"/> of the field (<c>Null</c> for reference types and zero memory for value types).</para>
            <para>• Some value of the same type as the <see cref="T:System.Type"/> of the field, or a value type convertible to it.</para>
            <para>• An invariant string representation of a value that cannot be presented inline in the attribute ctor. value of the same type as the <see cref="T:System.Type"/> of the field, or a value type convertible to it. The appropriate <see cref="T:System.ComponentModel.TypeConverter"/> is used for reading the value.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.SettingsEntryAttribute.ReflectionHelpers.GetDefaultValueFromRuntimeType``2(System.Linq.Expressions.Expression{System.Func{``0,``1}},JetBrains.Util.ILogger)">
            <summary>
            <para>Uses Reflection to get the entry default value from the loaded runtime type. Avoid using wherever possible because it needs a loaded assembly. For use in static context where settings store is not available and the settings key/entry class is about to be used anyway. NOT for use in any of the Settings Store infrastructure code.</para>
            </summary>
            <param name="lambdaexpression">Identifies the entry.</param>
            <param name="logger"></param>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Application.Settings.SettingsIndexedEntryAttribute">
            <summary>
            <para>Use this attribute to mark those fields and properties of a <see cref="T:JetBrains.Application.Settings.SettingsKeyAttribute">settings key class</see> that should be indexed store entries.</para>
            <para>Such an entry declares a set of values accessible with an index, which works as a dictionary or a list in a settings store.</para>
            <para>The field or property annotated with this attribute must be of type <see cref="T:JetBrains.Application.Settings.Store.IIndexedEntry`2"/> where generic parameters define the index type and the value indexed type.</para>
            </summary>
            <remarks>
            <para>While simple <see cref="T:JetBrains.Application.Settings.SettingsEntryAttribute"/> enables storing atomic values, this option allows to stores dictionaries with arbitrary keys and lists.</para>
            <para>A list has to be represented as a dictionary because it requires an identity (an index) to define rules for overriding when store is composited from layers. If your list items bear their identity themselves, use them as indices and define values as a simple boolean. If an additional identity is required, use the index as the identity and values as the payload information.</para>
            </remarks>
        </member>
        <member name="M:JetBrains.Application.Settings.SettingsIndexedEntryAttribute.#ctor(System.String)">
            <summary>
            
            </summary>
            <param name="Description">The string that explains the setting for the means of human-readable settings serialization or settings browser.</param>
        </member>
        <member name="P:JetBrains.Application.Settings.SettingsIndexedEntryAttribute.KeySerializer">
            <summary>
            Gets or sets how indices should be serialized for storage.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.SettingsIndexedEntryAttribute.ReflectionHelpers.GuessKeySerializer(JetBrains.Application.Catalogs.PartCatalogAttribute,JetBrains.Application.Catalogs.PartCatalogType)">
            <summary>
            Reads the key serializer, also resolves <see cref="F:JetBrains.Application.Settings.SettingsStoreSerializerType.Auto"/> into a specific type.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.SettingsIndexedKeyAttribute">
            <summary>
            <para>Marks a class that will be used as a frontend to settings.</para>
            <para>Represents an indexed settings key which exists in multiple copies per different index values.</para>
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.SettingsKeyAttributeBase">
            <summary>
            Base attribute for settings keys.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.SettingsKeyAttributeBase.#ctor(System.Type,System.String)">
            <param name="Parent">
            <para>The parent settings key. </para>
            <para><see cref="T:System.Reflection.Missing"/> denotes top-level settings keys. You should only have a few in the product. Consider mounting to an existing category instead of creating an new one.</para>
            </param>
            <param name="Description">The string that explains the setting for the means of human-readable settings serialization or settings browser.</param>
        </member>
        <member name="P:JetBrains.Application.Settings.SettingsKeyAttributeBase.Description">
            <summary>
            Gets the string that explains the setting for the means of human-readable settings serialization or settings browser.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Settings.SettingsKeyAttributeBase.Parent">
            <summary>
            <para>Gets the parent settings key. </para>
            <para><see cref="T:System.Reflection.Missing"/> denotes top-level settings keys. You should only have a few in the product. Consider mounting to an existing category instead of creating a new one.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Application.Settings.SettingsKeyAttributeBase.KeyNameOverride">
            <summary>
            <para>By default, the class name is used as the settings key name (but for the "Settings" suffix).</para>
            <para>If this property is non-empty, its value will be used as the key name instead.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.SettingsKeyAttributeBase.ReflectionHelpers.GetParentTypeIfNotRoot(JetBrains.Application.Catalogs.PartCatalogAttribute)">
            <summary>
            Reads the parent specification out of the attribute, returns its type info (unless it's pointing to the special root type).
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.SettingsIndexedKeyAttribute.#ctor(System.Type,System.String,System.Type)">
            <param name="Parent">
            <para>The parent settings key. </para>
            <para><see cref="T:System.Reflection.Missing"/> denotes top-level settings keys. You should only have a few in the product. Consider mounting to an existing category instead of creating an new one.</para>
            </param>
            <param name="Description">The string that explains the setting for the means of human-readable settings serialization or settings browser.</param>
            <param name="IndexType">Type of the indices to this indexed key.</param>
        </member>
        <member name="P:JetBrains.Application.Settings.SettingsIndexedKeyAttribute.IndexType">
            <summary>
            Gets the type of the indices to this indexed key.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Settings.SettingsIndexedKeyAttribute.IndexSerializer">
            <summary>
            Gets or sets how indices should be serialized.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.SettingsIndexedKeyAttribute.ReflectionHelpers.GuessKeySerializer(JetBrains.Application.Catalogs.PartCatalogAttribute,JetBrains.Application.Catalogs.PartCatalogType)">
            <summary>
            Reads the key serializer, also resolves <see cref="F:JetBrains.Application.Settings.SettingsStoreSerializerType.Auto"/> into a specific type.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.SettingsKeyAttribute">
            <summary>
            <para>Marks a class that will be used as a frontend to settings.</para>
            <para>Represents a settings key.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.SettingsKeyAttribute.#ctor(System.Type,System.String)">
            <param name="Parent">
            <para>The parent settings key. </para>
            <para><see cref="T:System.Reflection.Missing"/> denotes top-level settings keys. You should only have a few in the product. Consider mounting to an existing category instead of creating an new one.</para>
            </param>
            <param name="Description">The string that explains the setting for the means of human-readable settings serialization or settings browser.</param>
        </member>
        <member name="T:JetBrains.Application.Settings.ContextRange">
            <summary>
            Specifies a range of contexts for <c>BindToContext</c>-family methods on <see cref="T:JetBrains.Application.Settings.ISettingsStore"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.ContextRange.FGetWideContext">
            <summary>
            Gets the widest allowed context of the SmartSave.
            <c>NULL</c> if the context is not limited on the wide edge (e.g. SmartSave writes can go to the whole range of the narrow context mounts).
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.GuidIndex.#ctor(System.Guid)">
            <summary>
            Converts from a system <see cref="T:System.Guid"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.GuidIndex.#ctor(System.String)">
            <summary>
            Converts from a string. Ideally, the string must match for format and convert just 32 hex uppercase chars.
            Does not throw if something goes wrong: uses zeros for missing bytes.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.GuidIndex.#ctor(System.Byte[])">
            <summary>
            Creates a GUID out of raw data. Ideally, the data should have exactly 16 bytes.
            Does not throw if something goes wrong: uses zeros for missing bytes.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.GuidIndex.ToString">
            <summary>
            Converts to the default <see cref="T:JetBrains.Application.Settings.GuidIndex"/> format string: 32 uppercase hex digits without any other decorations.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.GuidIndex.ToGuid">
            <summary>
            Converts to the classic GUID.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.GuidIndex.ToString(System.String)">
            <summary>
            Converts to a GUID string using the <see cref="T:System.Guid"/> format specifiers.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.GuidIndex.ToString(System.String,System.IFormatProvider)">
            <summary>
            Converts to a GUID string using the <see cref="T:System.Guid"/> format specifiers.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.MountPointFlags.IsDefaultValues">
            <summary>
            This mounting point is providing default values for settings entries and keys.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.MountPointFlags.IsWritable">
            <summary>
            This mounting point is user writable by default under normal conditions.
            Mounting points without this flag shouldn't be written to, unless this is specifically desired by user/algorithm.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.SettingsStorageMountPointPriorityClasses">
            <summary>
            <para>Standard priority classes for well-known settings storages.</para>
            <para>NOTE: you should avoid assigning zero priority to mounting points because relative priorities of injected layers will not work correctly in this case.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.SettingsStorageMountPointPriorityClasses.AmbientStorage">
            <summary>
            Storages providing default settings.
            For example, built-in live templates, SSR patterns mounted by plugins, etc.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.SettingsStorageMountPointPriorityClasses.GlobalAllProductStorage">
            <summary>
            One more global storage for per-user settings, for all products. Settings could be promoted here from per-product global user storage.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.SettingsStorageMountPointPriorityClasses.GlobalPerProductStorage">
            <summary>
            The default global storage for per-user settings. Specific to the product.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.SettingsStorageMountPointPriorityClasses.HierarchyStorage">
            <summary>
            Base priority for nested storages within the hierarchy (for R#, these are solution/project storages).
            If you need more than one priority level per hierarchy, use different mantissa with the same exponent (i. e. multiply by a positive number below ten).
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.SettingsStorageMountPointPriorityClasses.SyntheticPriorityOfSmartLayer">
            <summary>
            When we're rendering the settings layers, mount-originating layers take the priority of the underlying mount.
            The “Smart” synthetic layer does not have a single mount under it. To be displayed in a sorted list along with other layers, it uses this fake priority level.
            Do not use for real mounting points.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.SettingsStoreChangeArgs">
            <summary>
            Describes a group of changes to the logical settings store.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.SettingsStoreChangeArgs.RootKeys">
            <summary>
            <para>Entry point to the hierarchical representation of the changed entities.</para>
            <para>These objects follow the hierarchy of the logical schema. Only the part of the schema that has changes described by this object is included.</para>
            <para>By inspecting these objects, you can determine whether the particular key or entry has changed itself. If a key is included but not <see cref="F:JetBrains.Application.Settings.SettingsStoreChangeArgs.SettingsKeyInstance.IsChangedItself"/>, then there're some changes in its child keys or entries.</para>
            <para>For indexed keys and entries, you can get particular index values.</para>
            <para>This list is ordered by key local names and then index serialized values, which makes it possible to do binary searches.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.SettingsStoreChangeArgs.ChangedStorageKeys">
            <summary>
            A sorted hash set of any storage keys affected by this change.
            This is a hybrid path: the first path component MUST be empty because it's reserved for the mounting path, and the remaining components represent the physical path within the mounted storage.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.SettingsStoreChangeArgs.ChangedKeys">
            <summary>
            <para>Quick access to all of the changed keys listed under <see cref="F:JetBrains.Application.Settings.SettingsStoreChangeArgs.RootKeys"/>.</para>
            <para>Note that this means that either the key has changed, or rather one of its descendants.</para>
            <para>To get information on indexed key indices, inspect <see cref="F:JetBrains.Application.Settings.SettingsStoreChangeArgs.RootKeys"/>.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.SettingsStoreChangeArgs.ChangedEntries">
            <summary>
            <para>Quick access to all of the changed entries listed under <see cref="F:JetBrains.Application.Settings.SettingsStoreChangeArgs.RootKeys"/>.</para>
            <para>To get information on indexed entry indices, inspect <see cref="F:JetBrains.Application.Settings.SettingsStoreChangeArgs.RootKeys"/>.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.SettingsStoreChangeArgs.RemoveUnchangedThingsAndCollectLists(JetBrains.Util.ILogger)">
            <summary>
            There might be such entities in the lists for which there're no descendants with is-changed-itself status (e.g. only technical changes were registered for those).
            Remove such entities.
            </summary>
            <param name="logger"></param>
        </member>
        <member name="T:JetBrains.Application.Settings.SettingsStoreChangeArgs.SettingsKeyInstance">
            <summary>
            A change to a settings key instance.
            “Instance” means that for an indexed key this refers to a speficic instance (identified by a particular index value) rather then the schema key in general.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.SettingsStoreChangeArgs.SettingsKeyInstance.SettingsKey">
            <summary>
            The changed settings key.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.SettingsStoreChangeArgs.SettingsKeyInstance.Children">
            <summary>
            Child keys of this key, if there were any changes in them.
            For indexed keys, only particular instances are listed. If more than one instance of the same key was changed, there will be more than one instance of the same key in the list.
            This list is sorted by key local name and then index serialized value.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.SettingsStoreChangeArgs.SettingsKeyInstance.IsChangedItself">
            <summary>
            If <c>True</c>, there were changes to this exactly key (only applies to indexed key instances, because they might be created and deleted).
            If <c>False</c>, the key itself didn't change, but this node has some ancestors which changed themselves.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.SettingsStoreChangeArgs.SettingsKeyInstance.Entries">
            <summary>
            Changed entries of this key, if any.
            For indexed entries, only particular instances are listed. If more than one instance of the same entry was changed, there will be more than one instance of the same entry in the list.
            This list is sorted by key local name and then index serialized value.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.SettingsStoreChangeArgs.SettingsKeyInstance.IndexSerialized">
            <summary>
            If <see cref="F:JetBrains.Application.Settings.SettingsStoreChangeArgs.SettingsKeyInstance.SettingsKey"/> is an indexed key, a non-<c>Null</c> index to the particular instance. Otherwise, <c>Null</c>.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.SettingsStoreChangeArgs.SettingsKeyInstance.FGetLocalNameAndIndex">
            <summary>
            Cached delegate.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.SettingsStoreChangeArgs.SettingsKeyInstance.myLocalNameAndIndex">
            <summary>
            Serves as a dictionary key when indexing this stull in a parent.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.SettingsStoreChangeArgs.SettingsKeyInstance.TryGetIndexValue">
            <summary>
            If this is an indexed key instance, deserializes the <see cref="F:JetBrains.Application.Settings.SettingsStoreChangeArgs.SettingsKeyInstance.IndexSerialized"/> index value into a runtime object.
            </summary>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Application.Settings.SettingsStoreChangeArgs.SettingsEntryInstance">
            <summary>
            A change to a settings entry instance.
            “Instance” means that for an indexed entry this refers to a speficic instance (identified by a particular index value) rather then the schema entry in general.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.SettingsStoreChangeArgs.SettingsEntryInstance.SettingsEntry">
            <summary>
            The changed settings entry.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.SettingsStoreChangeArgs.SettingsEntryInstance.IndexSerialized">
            <summary>
            If <see cref="F:JetBrains.Application.Settings.SettingsStoreChangeArgs.SettingsEntryInstance.SettingsEntry"/> is an indexed entry, a non-<c>Null</c> index to the particular instance. Otherwise, <c>Null</c>.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.SettingsStoreChangeArgs.SettingsEntryInstance.IsChangedItself">
            <summary>
            If <c>True</c>, there were significant changes to this exactly entry.
            If <c>False</c>, then the entry is only present because some technical information on it might have changed which does not affect the entry value.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.SettingsStoreChangeArgs.SettingsEntryInstance.FGetLocalNameAndIndex">
            <summary>
            Cached delegate.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.SettingsStoreChangeArgs.SettingsEntryInstance.TryGetIndexValue">
            <summary>
            If this is an indexed entry instance, deserializes the <see cref="F:JetBrains.Application.Settings.SettingsStoreChangeArgs.SettingsEntryInstance.IndexSerialized"/> index value into a runtime object.
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Application.Settings.SettingsStoreChangeArgs.SettingsEntryInstance.GetIndexValue">
            <summary>
            If this is an indexed entry instance, deserializes the <see cref="F:JetBrains.Application.Settings.SettingsStoreChangeArgs.SettingsEntryInstance.IndexSerialized"/> index value into a runtime object.
            Throws otherwise or on failures.
            </summary>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Application.Settings.SettingsStoreSerializerType">
            <summary>
            Defines the choice of serializers for storing Settings Store data in the underlying physical storage.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.SettingsStoreSerializerType.Auto">
            <summary>
            Chooses the best serializer automatically based on the member type of the member annotated with the attribute.
            For primitive types, it's <see cref="F:JetBrains.Application.Settings.SettingsStoreSerializerType.Primitive"/>. In most other cases, <see cref="F:JetBrains.Application.Settings.SettingsStoreSerializerType.TypeConverterToInvariantString"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.SettingsStoreSerializerType.Primitive">
            <summary>
            The value is serialized AS IS, as a primitive type. Is not applicable to non-primitive types (those not directly supported by the settings store types).
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.SettingsStoreSerializerType.TypeConverterToInvariantString">
            <summary>
            The <see cref="T:System.ComponentModel.TypeDescriptor"/> is queried for <see cref="T:System.ComponentModel.TypeConverter"/> and it is used to convert between the typed value and an invariant string.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.SettingsStoreSerializerType.XmlSerializer">
            <summary>
            The object is serialized into string and back with <see cref="T:System.Xml.Serialization.XmlSerializer"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.SettingsStoreSerializerType.XamlSerializer">
            <summary>
            The object is serialized into string with <see cref="T:System.Windows.Markup.XamlWriter"/> and back with <see cref="T:System.Windows.Markup.XamlReader"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.SettingsStoreSerializerType.BinaryFormatter">
            <summary>
            The object is serialized into BLOB and back with <see cref="T:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter"/>.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.SchemaStorageKeyPathComponent">
            <summary>
            <see cref="F:JetBrains.Application.Settings.SettingsEntry.CachedPathComponents"/> and <see cref="F:JetBrains.Application.Settings.SettingsKey.CachedPathComponents"/> items.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.SchemaStorageKeyPathComponent.Component">
            <summary>
            Path component.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.SchemaStorageKeyPathComponent.IndexRequired">
            <summary>
            If non-<c>Null</c>, an additional path component with an index value for this indexed key is required after this component.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.SettingsEntry">
            <summary>
            Base class for entries of a settings key.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.SettingsEntry.LocalName">
            <summary>
            <para>Local name of the entry.</para>
            <para>Appended to the full name of the containing settings key to get the actual key in the settings storage key-value store.</para>
            <para>Complies with the identifier rules (<see cref="M:JetBrains.Application.Settings.Storage.SettingsStorageHelpers.AssertValidLocalName(System.String)"/>).</para>
            <para>By default, equal to <see cref="F:JetBrains.Application.Settings.SettingsEntry.SettingsKeyClassMemberName"/>, but might be overridden with <see cref="P:JetBrains.Application.Settings.SettingsEntryAttributeBase.EntryNameOverride"/>.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.SettingsEntry.SettingsKeyClassMemberName">
            <summary>
            <para>As this entry has been defined by some member (field/property) in the settings key class, gives the name of that member.</para>
            <para>Same as the <see cref="F:JetBrains.Application.Settings.SettingsEntry.LocalName"/> by default, but the latter might be overridden with <see cref="P:JetBrains.Application.Settings.SettingsEntryAttributeBase.EntryNameOverride"/>.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.SettingsEntry.myDescription">
            <summary>
            Gets the string that explains the setting for the means of human-readable settings serialization or settings browser.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.SettingsEntry.SettingsKeyClassMemberClrType">
            <summary>
            Gets the CLR type of the member (field, property, etc) representing the entry in the settings key class.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.SettingsEntry.CachedPathComponents">
            <summary>
            Cached path components for mapping this settings schema entity to physical keys in the settings storage.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Settings.SettingsEntry.Parent">
            <summary>
            The settings key containing this entry.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Settings.SettingsEntry.Description">
            <summary>
            Gets the string that explains the setting for the means of human-readable settings serialization or settings browser.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Settings.SettingsEntry.IsIndexed">
            <summary>
            <para>Gets whether this entry is an indexed entry.</para>
            <para>When <c>True</c>, this instance is actually of type <see cref="T:JetBrains.Application.Settings.SettingsIndexedEntry"/> which has additional information about the index type. Otherwise, the actual type of the instance is <see cref="T:JetBrains.Application.Settings.SettingsScalarEntry"/>.</para>
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.SettingsIndexedEntry">
            <summary>
            Describes an indexed settings entry in the settings schema.
            </summary>
            <seealso cref="T:JetBrains.Application.Settings.SettingsIndexedEntryAttribute"/>
        </member>
        <member name="F:JetBrains.Application.Settings.SettingsIndexedEntry.IndexSerializer">
            <summary>
            <para>The way indices should be serialized.</para>
            <para>Note that the final algorithm is a bit different from what's applied to serializing entry values because serialized indices take part in the settings storage keys as local names, which implies strict limitations on their type (always a string) and character set.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.SettingsIndexedEntry.IndexedValueSerializer">
            <summary>
            The way indexed values should be serialized. Equivalent to <see cref="F:JetBrains.Application.Settings.SettingsScalarEntry.ValueSerializer"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.SettingsIndexedEntry.SettingsStorageIndexedValueType">
            <summary>
            The type in settings storage with which indexed values are stored.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.SettingsIndexedEntry.SettingsStorageIndexType">
            <summary>
            <para>The type in settings storage with which indices might be stored as settings storage values.</para>
            <para>Note that normally indices are used as local names within the settings storage key path, where they must always be strings.</para>
            <para>However, for human readability, we might be writing a copy of the index into the value, in which case it's serialized against the same rules as normal settings entry values. That's where this datum applies.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.SettingsIndexedEntry.IndexClrType">
            <summary>
            <para>The CLR type of the index.</para>
            <para>This is the first generic actual parameter on <see cref="F:JetBrains.Application.Settings.SettingsEntry.SettingsKeyClassMemberClrType"/>.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.SettingsIndexedEntry.IndexedValueClrType">
            <summary>
            <para>The CLR type of the indexed values.</para>
            <para>This is the second generic actual parameter on <see cref="F:JetBrains.Application.Settings.SettingsEntry.SettingsKeyClassMemberClrType"/>.</para>
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.SettingsIndexedKey">
            <summary>
            <para>Describes an indexed settings key in the settings schema.</para>
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.SettingsKey">
            <summary>
            <para>Describes a settings key (indexed or not) in the settings schema.</para>
            <para>Indexed keys are described by a more specific type <see cref="T:JetBrains.Application.Settings.SettingsIndexedKey"/>.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.SettingsKey.myEntriesTmp">
            <summary>
            Entries are kept here before the key completes loading entries and gets frozen.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.SettingsKey.myEntriesFrozenSorted">
            <summary>
            Entries are kept in this array, sorted by member-name for quicker lookup (lambda expressions give us the CLR member name), after the key completes loading its entries and is frozen.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.SettingsKey.SettingsKeyClassClrType">
            <summary>
            CLR type of the class which defined this settings key.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.SettingsKey.ParentSettingsKeyClassClrType">
            <summary>
            <para>CLR type of the class which defined the parent settings key, or <c>Null</c> if this is one of the root keys.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.SettingsKey.myParent">
            <summary>
            Backend for <see cref="P:JetBrains.Application.Settings.SettingsKey.Parent"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.SettingsKey.LocalName">
            <summary>
            <para>Local name of the key.</para>
            <para>Appended to the full name of the parent settings key to get the actual key in the settings storage key-value store.</para>
            <para>Complies with the identifier rules (<see cref="M:JetBrains.Application.Settings.Storage.SettingsStorageHelpers.AssertValidLocalName(System.String)"/>).</para>
            <para>By default, equal to <see cref="F:JetBrains.Application.Settings.SettingsKey.SettingsKeyClassClrType"/>.<see cref="P:JetBrains.Application.Parts.PartCatalogueType.LocalName"/>, but might be overridden with <see cref="P:JetBrains.Application.Settings.SettingsKeyAttributeBase.KeyNameOverride"/>.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.SettingsKey.FreezeEntries">
            <summary>
            After entries are added to the newly-loaded key, freezes its entries list to check consistensy and sort them for quicker lookup.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.SettingsKey.AddEntry(JetBrains.Application.Settings.SettingsEntry)">
            <summary>
            For adding entries to a newly-created key when it's being loaded.
            </summary>
            <param name="entry"></param>
        </member>
        <member name="M:JetBrains.Application.Settings.SettingsKey.GetEntryByMemberName(System.String)">
            <summary>
            Optimizes lookup thru lambda expressions which give us the member name.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.SettingsKey.CachedPathComponents">
            <summary>
            Cached path components for mapping this settings schema entity to physical keys in the settings storage.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Settings.SettingsKey.Children">
            <summary>
            <para>Gets the child settings keys of this key. Their <see cref="P:JetBrains.Application.Settings.SettingsKey.Parent"/> will be pointing to this instance.</para>
            <para>When defining a settings key as a class with <see cref="T:JetBrains.Application.Settings.SettingsKeyAttribute"/> or <see cref="T:JetBrains.Application.Settings.SettingsIndexedKeyAttribute"/>, the <see cref="P:JetBrains.Application.Settings.SettingsKey.Parent"/> is specified as a parameter to the attribute. CLR inheritance has nothing to do with settings key parenting in the schema.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Application.Settings.SettingsKey.Entries">
            <summary>
            <para>Gets the settings entries of this settings key.</para>
            <para>They are defined as fields or properties in the settings key class marked with <see cref="T:JetBrains.Application.Settings.SettingsEntryAttribute"/> or <see cref="T:JetBrains.Application.Settings.SettingsIndexedEntryAttribute"/>.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Application.Settings.SettingsKey.Description">
            <summary>
            Gets the string that explains the setting for the means of human-readable settings serialization or settings browser.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Settings.SettingsKey.IsIndexed">
            <summary>
            <para>Gets whether this key is an indexed key. To get an entry value, you must provide an index to each indexed key in the parent keys chain.</para>
            <para>When <c>True</c>, this instance is actually of type <see cref="T:JetBrains.Application.Settings.SettingsIndexedKey"/> which has additional information about the index type.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Application.Settings.SettingsKey.Parent">
            <summary>
            <para>Gets the parent key of this settings key, or <c>Null</c> if this key is one of the root keys.</para>
            <para>When defining a settings key as a class with <see cref="T:JetBrains.Application.Settings.SettingsKeyAttribute"/> or <see cref="T:JetBrains.Application.Settings.SettingsIndexedKeyAttribute"/>, the <see cref="P:JetBrains.Application.Settings.SettingsKey.Parent"/> is specified as a parameter to the attribute. CLR inheritance has nothing to do with settings key parenting in the schema.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.SettingsIndexedKey.IndexClrType">
            <summary>
            <para>The type of the index to this indexed key.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.SettingsIndexedKey.IndexSerializer">
            <summary>
            <para>The way indices should be serialized.</para>
            <para>Note that the final algorithm is a bit different from what's applied to serializing entry values because serialized indices take part in the settings storage keys as local names, which implies strict limitations on their type (always a string) and character set.</para>
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.SettingsScalarEntry">
            <summary>
            Describes a scalar settings entry in the settings schema.
            </summary>
            <seealso cref="T:JetBrains.Application.Settings.SettingsEntryAttribute"/>
        </member>
        <member name="F:JetBrains.Application.Settings.SettingsScalarEntry.RawDefaultValue">
            <summary>
            <para>Gets the default value to be used for this settings entry in case it's not set for this context.</para>
            <para>Note that the type of this default value is neither <see cref="F:JetBrains.Application.Settings.SettingsScalarEntry.SettingsStorageEntryType"/> nor the <see cref="F:JetBrains.Application.Settings.SettingsScalarEntry.ValueClrType"/>. It's the object value written in the <see cref="T:JetBrains.Application.Settings.SettingsEntryAttribute"/>. <see cref="M:JetBrains.Application.Settings.Storage.SettingsStorageHelpers.CoerceEntryDefaultValueToRuntimeType(System.Object,System.Type,JetBrains.Util.ILogger)"/> contains special logic for converting this into the runtime entry value type.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.SettingsScalarEntry.ValueSerializer">
            <summary>
            <para>Gets how the value of the field/property should be serialized for storage.</para>
            <para>Used for converting values between <see cref="F:JetBrains.Application.Settings.SettingsScalarEntry.ValueClrType"/> and <see cref="F:JetBrains.Application.Settings.SettingsScalarEntry.SettingsStorageEntryType"/> back and forth</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.SettingsScalarEntry.SettingsStorageEntryType">
            <summary>
            The type of this entry in the setting storage. This only matches <see cref="F:JetBrains.Application.Settings.SettingsScalarEntry.ValueClrType"/> for select primitive types. In all other cases, <see cref="F:JetBrains.Application.Settings.SettingsScalarEntry.ValueSerializer"/> is used for converting values between <see cref="F:JetBrains.Application.Settings.SettingsScalarEntry.ValueClrType"/> and <see cref="F:JetBrains.Application.Settings.SettingsScalarEntry.SettingsStorageEntryType"/> back and forth.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.SettingsScalarEntry.ValueClrType">
            <summary>
            <para>Gets the CLR type of the value of this scalar entry.</para>
            <para>This is the type of the object you'll be getting from the <see cref="T:JetBrains.Application.Settings.Store.Implementation.SettingsStore"/> when reading this value.</para>
            <para>For a scalar entry, matches the <see cref="F:JetBrains.Application.Settings.SettingsEntry.SettingsKeyClassMemberClrType">class member type</see>.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.SettingsScalarEntry.GetDefaultValueInEntryMemberType">
            <summary>
            Converts the <see cref="F:JetBrains.Application.Settings.SettingsScalarEntry.RawDefaultValue">raw default value</see> to the <see cref="F:JetBrains.Application.Settings.SettingsScalarEntry.ValueClrType">entry value runtime type</see>.
            <para>If possible, should not let exceptions out.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.SettingsScalarEntry.GetDefaultValue``2(JetBrains.Application.Settings.ISettingsStore,System.Linq.Expressions.Expression{System.Func{``0,``1}},JetBrains.Util.ILogger)">
            <summary>
            <para>Gets the entry default value. Accessible even when the settings store is not available at the point (e.g. in a static context or when running in fallback mode without the Shell).</para>
            </summary>
            <typeparam name="TKeyClass"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="settings">The settings store, if available. If specified, will be for a quick look up of the entry default value. If <c>Null</c>, the default value will be parsed out of the entry itself, which might be slow.</param>
            <param name="lambdaexpression">Identifies the entry.</param>
            <param name="logger"></param>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Application.Settings.SettingsSchema">
            <summary>
            <para>This schema is the logical schema on <see cref="T:JetBrains.Application.Settings.SettingsKey">settings keys</see> / <see cref="T:JetBrains.Application.Settings.SettingsEntry">settings entries</see>, exposed to the application for getting/setting values of arbitrary user types.</para>
            <para>It is collected by reading classes with <see cref="T:JetBrains.Application.Settings.SettingsKeyAttribute"/> (which produces hierarchy of keys) and inspecting their members for <see cref="T:JetBrains.Application.Settings.SettingsEntryAttribute"/> (which produces key entries).</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.SettingsSchemaCollector.myCacheAssemblyNames">
            <summary>
            Backend for <see cref="M:JetBrains.Application.Settings.SettingsSchemaCollector.GetCachedRuntimeAssemblyName(System.Reflection.Assembly)"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.SettingsSchemaCollector.myMapTypeToSettingsKey">
            <summary>
            The main cache of the schema. Call <see cref="M:JetBrains.Application.Settings.SettingsSchemaCollector.EnsureValidCache"/> before any use.
            CopyOnWrite, so requires no locking for read access. Modifications are quite rare, so we can afford COW here.
            The first item of the tuple says whether the cache is valid at all.
            Note: must be a reference type to ensure atomic replacement.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.SettingsSchemaCollector.mySettingsKeyTypesFromCatalogs">
            <summary>
            Raw data from catalog: the type of the settings key class, plus some metainfo on it from the attribute.
            Updated sync on changes from catalogset (under main thread guard). Update invalidates the <see cref="F:JetBrains.Application.Settings.SettingsSchemaCollector.myMapTypeToSettingsKey"/>'s <see cref="P:JetBrains.Util.JetTuple`2.A"/> flag, and on next access to the schema the keys set is rebuilt (newcomer keys are intraspected for entries, etc).
            Locked with <see cref="F:JetBrains.Application.Settings.SettingsSchemaCollector.myLockSettingsKeyTypesFromCatalogs"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.SettingsSchemaCollector.GetCachedRuntimeAssemblyName(System.Reflection.Assembly)">
            <summary>
            It has been shown that getting the short name out of a runtime assembly takes considerable time. Cache the result to make settings access faster.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.SettingsSchemaCollector.Intraspection.EnsureValidCache_AddNew_KeysReadEntries_CatalogType_AddBaseMembers(JetBrains.Application.Catalogs.PartCatalogType,JetBrains.Util.dataStructures.Sources.CollectionSource{JetBrains.Application.Catalogs.PartCatalogTypeMember},System.Collections.Generic.Dictionary{JetBrains.Util.dataStructures.Sources.StringSource,JetBrains.Application.Catalogs.PartCatalogTypeMember})">
            <summary>
            Walk base classes (if any) to collect their members as settings entries into a settings class.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.SettingsSchemaCollector.Intraspection.EnsureValidCache_AddNew_KeysReadEntries_CatalogType_Member(JetBrains.Application.Settings.SettingsKey,JetBrains.Application.Catalogs.PartCatalogTypeMember)">
            <summary>
            Processes a single member in the settings entry class.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.SettingsSchemaCollector.Intraspection.EnsureValidCache_AddNew_KeysReadEntries_CatalogType_Member_CreatePartType(JetBrains.Application.Catalogs.PartCatalogType)">
            <summary>
            Detaches a metadata type from the metadata reader (by converting it to a <see cref="T:JetBrains.Application.Catalogs.PartCatalogType"/>) so that it can be used after the reader is released, in a way which can be late-bound to the actual CLR <see cref="T:System.RuntimeType"/>.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.SettingsSchemaCollector.TypeInWeakAssembly">
            <summary>
            Stores the full name of the type and the short name of the assembly (without the strong name, version, etc).
            Using this identity for types allows us to avoid problems with binding redirections not quite working in our metadata assembly APIs.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.SettingsSchemaCollector.TypeInWeakAssembly.#ctor(System.Type)">
            <summary>
            Warning! Getting runtime assembly name is a lengthy operation.
            Use assembly name caching at your side (like <see cref="M:JetBrains.Application.Settings.SettingsSchemaCollector.GetCachedRuntimeAssemblyName(System.Reflection.Assembly)"/>) and call the (string,string) .ctor.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.Upgrade.IMigrateSettings">
            <summary>
              <para>Implement this interface on a <see cref="T:JetBrains.Application.Settings.Upgrade.MigrateSettingsAttribute"/>-annotated class to migrate settings to a newer semantic layout within the Settings Store.</para>
              <para>You can import components in your constructor. Your object won't have any thread affinity.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Upgrade.IMigrateSettings.GetEntriesToMigrate(JetBrains.Application.Settings.ISettingsSchema)">
            <summary>
              <para>Same as <see cref="M:JetBrains.Application.Settings.Upgrade.IMigrateSettings.GetKeysToMigrate(JetBrains.Application.Settings.ISettingsSchema)"/>, but applies to individual entries when the whole key is not considered for migration to the new format.</para>
              <para>If you're not migrating the whole key, you don't have to list any entries from it or child keys in this parameter.</para>
              <para>Might be called on any thread.</para>
            </summary>
            <param name="schema"></param>
        </member>
        <member name="M:JetBrains.Application.Settings.Upgrade.IMigrateSettings.GetKeysToMigrate(JetBrains.Application.Settings.ISettingsSchema)">
            <summary>
              <para>Yield the keys which your migration routine would like to migrate to the new format, should there be any values under them.</para>
              <para>Your migration routine will only be called if these are present in some layer, and this migration routine has not yet been called on that layer.</para>
              <para>This also includes all the entries in these keys, so you don't have to individually list them within <see cref="M:JetBrains.Application.Settings.Upgrade.IMigrateSettings.GetEntriesToMigrate(JetBrains.Application.Settings.ISettingsSchema)"/>.</para>
              <para>Child keys are also included.</para>
              <para>Might be called on any thread.</para>
            </summary>
            <param name="schema"></param>
        </member>
        <member name="M:JetBrains.Application.Settings.Upgrade.IMigrateSettings.Migrate(JetBrains.Application.Settings.IContextBoundSettingsStore)">
            <summary>
              <para>Called on a specific settings layer when a migration case is detected.</para>
              <para>(1) The settings covered by <see cref="M:JetBrains.Application.Settings.Upgrade.IMigrateSettings.GetKeysToMigrate(JetBrains.Application.Settings.ISettingsSchema)"/> or <see cref="M:JetBrains.Application.Settings.Upgrade.IMigrateSettings.GetEntriesToMigrate(JetBrains.Application.Settings.ISettingsSchema)"/> are defined in this layer.</para>
              <para>(2) This migration routine has not yet been called for this layer.</para>
            </summary>
            <param name="store">The settings store bound to the specific layer. The default settings layers are not included in the stack.</param>
            <returns>Optional async implementation.</returns>
        </member>
        <member name="T:JetBrains.Application.Settings.Upgrade.MigrateSettingsAttribute">
            <seealso cref="T:JetBrains.Application.Settings.Upgrade.IMigrateSettings"/>
        </member>
        <member name="T:JetBrains.Application.Settings.Upgrade.SettingsMigrationManager">
            <summary>
              <para>Helps with migrating the semantical settings format to newer versions within Settings Store.</para>
              <para>Collects possible <see cref="T:JetBrains.Application.Settings.Upgrade.IMigrateSettings"/>, determines their applicability, calls per mount.</para>
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.Upgrade.SettingsMigrationSettingsKey">
            <seealso cref="T:JetBrains.Application.Settings.Upgrade.SettingsMigrationManager"/>
            <seealso cref="T:JetBrains.Application.Settings.Upgrade.IMigrateSettings"/>
        </member>
        <member name="T:JetBrains.Application.Settings.UserInterface.FileInjectedLayers.FileInjectedLayers">
            <summary>
            Manages user-injected settings layers based on disk files.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.UserInterface.FileInjectedLayers.FileInjectedLayerSettingsKey">
            <summary>
            Serializes information on a file-based user-injected layer to enable restoring it after application restarts.
            The index is just an unique key.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.UserInterface.FileInjectedLayers.RegisterInjectedMounts.ForEachHostingLayer(JetBrains.DataFlow.Lifetime,JetBrains.Application.Settings.UserInterface.UserFriendlySettingsLayer)">
            <summary>
            When a new hosting layer appears, we're notified of it (layer additions are originated in a guarded context).
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.UserInterface.FileInjectedLayers.RegisterInjectedMounts.SynchronizeHostLayer(JetBrains.Application.Settings.UserInterface.UserFriendlySettingsLayer)">
            <summary>
            Reads the list of injections from the host layer and synchronizes the list on our <see cref="F:JetBrains.Application.Settings.UserInterface.FileInjectedLayers.RegisterInjectedMounts.myMapHostToInjected"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.UserInterface.FileInjectedLayers.RegisterInjectedMounts.mySynchronizeReadHostLayerCurrentData">
            <summary>
            Ensures synchronization on reading injected layer settings from the host layer: that the lifetime does not terminate while we're busy.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.UserInterface.FileInjectedLayers.RegisterInjectedMounts.Synchronize">
            <summary>
            Normally, host layers are watched for injections info async with a delay.
            If you've just added injection info, call into this method to immediately update the set of injected layers.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.UserInterface.FileInjectedLayers.RegisterInjectedMounts.FileInjectedLayerInstance.ActualPath">
            <summary>
            The current actual absolute path of the layer (either calculated from the relative, or taken as absolute).
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.UserInterface.InjectedLayersSettingsKey">
            <summary>
            Base key for all injected layers related data.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.UserInterface.ResetSettings">
            <summary>
            Requests for resetting the settings to their defaults should be sent thru this class.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.UserInterface.ResetSettings.Reset(JetBrains.Application.Settings.UserInterface.UserFriendlySettingsLayer.Identity,System.Collections.Generic.IEnumerable{JetBrains.Util.JetTuple{JetBrains.Application.Settings.SettingsKey,System.Collections.Generic.IDictionary{JetBrains.Application.Settings.SettingsKey,System.Object}}})">
            <summary>
            <para>Resets settings to their defaults.</para>
            <para>Unlike <see cref="M:JetBrains.Application.Settings.UserInterface.ResetSettings.ResetAllSettings"/>, does not treat user-injected layers in a special way.</para>
            </summary>
            <param name="layerid">Optional. The layer to reset settings in. If omitted, settings will be reset in all the layers.</param>
            <param name="keys">Optional. Keys whose child settings should be reset. Settings outside these keys will not be affected. Resets all applicable settings if omitted.</param>
        </member>
        <member name="M:JetBrains.Application.Settings.UserInterface.ResetSettings.ResetAllSettings">
            <summary>
            <para>Resets all settings to their factory defaults.</para>
            <para>User-injected layers are not wiped, they are just deleted as injected layers. If they are injected from a file, the settings in that file remain intact.</para>
            <para>See also <see cref="T:JetBrains.Application.Settings.UserInterface.ResetSettings"/> which wipes specific (or all) layers without telling injected ones apart.</para>
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.UserInterface.UserFriendlySettingsLayer">
            <summary>
            We can be settings on options pages in different contexts, like “Smart”, “Solution Shared Settings Only”.
            Also we might be mounting new settings files as layers and changing their order.
            This class describes one of these layers, as visible to the user..
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.UserInterface.UserFriendlySettingsLayer.Id">
            <summary>
            Identifies this layer in an instance-invariant and transaction-invariant manner.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.UserInterface.UserFriendlySettingsLayer.Priority">
            <summary>
            Priority of this layer when displaying a sorted layers list.
            The lower the number, the higher the priority.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.UserInterface.UserFriendlySettingsLayer.Metadata">
            <summary>
            <para>Exposes the metadata of the layer (writable).</para>
            <para>For layers based on a mounting point, this is the metadata of the mounting point.</para>
            <para>For the default layer, this is just a disconnected local bag.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.UserInterface.UserFriendlySettingsLayer.DisplayName">
            <summary>
            Display name of the layer. This is composed out of the <see cref="F:JetBrains.Application.Settings.UserInterface.UserFriendlySettingsLayers.DisplayName"/> metadata and the mounting point name (<see cref="P:JetBrains.Application.Settings.UserInterface.UserFriendlySettingsLayer.Name"/>) if the former is empty.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.UserInterface.UserFriendlySettingsLayer.Icon">
            <summary>
            Icon of the layer. This is composed out of the <see cref="F:JetBrains.Application.Settings.UserInterface.UserFriendlySettingsLayers.Icon"/> metadata
            </summary>
        </member>
        <member name="P:JetBrains.Application.Settings.UserInterface.UserFriendlySettingsLayer.SettingsStoreContext">
            <summary>
            The settings context for reading/writing on this layer.
            All of these are opened over the same settings store transaction. If you're working with these in an Options dialog, then they're in the Options Dialog transaction.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Settings.UserInterface.UserFriendlySettingsLayer.IsDefault">
            <summary>
            Whether it's the default “Smart” “settings layer” (a combination of all application-wide mounts) which is edited in the default Options dialog.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.UserInterface.UserFriendlySettingsLayer.Identity">
            <summary>
            Allows to identify and match settings layers in different transactions.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.UserInterface.UserFriendlySettingsLayer.Identity.CharacteristicMount">
            <summary>
            Any layer besides the default (smart) one originates from a mounting point, which is made writable and to which all of the mounting points with factory defaults are mixed in.
            This gives out this originating mount of the layer, or <c>Null</c> for the default (smart) layer.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.UserInterface.UserFriendlySettingsLayers">
            <summary>
            We can be editing settings on options pages in different contexts, like “Smart”, “Solution Shared Settings Only” (displayed as tabs above settings page in the options view).
            This class describes a set of such contexts.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.UserInterface.UserFriendlySettingsLayers.DefaultLayer">
            <summary>
            The default options context for smart editing which always exists.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.UserInterface.UserFriendlySettingsLayers.UserEditableLayers">
            <summary>
            The list of available options context which could be manually selected for editing by the user.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.UserInterface.UserFriendlySettingsLayers.VisibleLayers">
            <summary>
            The list of layers that are visible. This is a superset of <see cref="F:JetBrains.Application.Settings.UserInterface.UserFriendlySettingsLayers.UserEditableLayers"/> and includes
            any layer that has the <see cref="F:JetBrains.Application.Settings.UserInterface.UserFriendlySettingsLayers.IsNonUserEditable"/> metadata set (e.g. extensions)
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.UserInterface.UserFriendlySettingsLayers.IsHiddenFromUserFriendlyLayers">
            <summary>
            Set this metadata to <c>True</c> on a mounting point if you want to keep it from appearing in the user-friendly settings layers list (in Options' SaveTo, in SettingsLayers dialog, etc).
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.UserInterface.UserFriendlySettingsLayers.IsNonUserEditable">
            <summary>
            If set to <c>True</c>, this settings in the mount point cannot be edited by the user, so this layer should not be presented to the user as a save location
            </summary>
            <remarks>
            <para>Primarily intended for settings exposed by extensions, where the user shouldn't edit them (they should save changes in e.g. the smart layer), but the layer should still be visible in the manage options dialog</para>
            <para>Use <see cref="F:JetBrains.Application.Settings.UserInterface.UserFriendlySettingsLayers.IsHiddenFromUserFriendlyLayers"/> to completely hide the layer from the user</para>
            </remarks>
        </member>
        <member name="F:JetBrains.Application.Settings.UserInterface.UserFriendlySettingsLayers.Origin">
            <summary>
            Some text which hints on the origin of the layer — e.g. from appdata or solution folder.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.UserInterface.UserFriendlySettingsLayers.DiskFilePath">
            <summary>
            In case this layer originates as a disk file, exposes the full path to that file.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.UserInterface.UserFriendlySettingsLayers.DisplayName">
            <summary>
            If non-empty, could be used as the display name for the layer in the user interface. Otherwise, the mount point name should be used where applicable.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.UserInterface.UserFriendlySettingsLayers.LayerId">
            <summary>
            Layer ID
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.UserInterface.UserFriendlySettingsLayers.Icon">
            <summary>
            If non-empty, could be used as the icon for the layer in the user interface. Otherwise, the mount point name should be used where applicable.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.UserInterface.UserFriendlySettingsLayers.Flags.IncludeHiddenLayers">
            <summary>
            By default, layers with <see cref="F:JetBrains.Application.Settings.UserInterface.UserFriendlySettingsLayers.IsHiddenFromUserFriendlyLayers"/> metadata are excluded from the user-friendly-layers list.
            This flag overrides the behavior to include all of the available layers.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers">
            <summary>
            <para>Central management authority for user-injected settings layers — those that were added by a user when mounting e.g. a disk file as a new settings layer.</para>
            <para>“User-Injected Layer” — a settings layer (backed up by a <see cref="T:JetBrains.Application.Settings.ISettingsStorageMountPoint">mounting point</see> in the <see cref="T:JetBrains.Application.Settings.ISettingsStore">Settings Store</see>) created by the user over some disk file or URI or other media.</para>
            <para>“Layer Hosting User Injections” — to restore injected layers in subsequent sessions, information on them is stored as settings in one of the regular layers. A layer which can store such information is a hosting layer (regardless of whether it has any such records already or not). Each user-injected layer belongs to exactly one hosting layer, so they have some kind of a parent-child relation. Currently an injected layer cannot host injections, but that might be a subject to change.</para>
            <para>The overall operation is as follows: when <see cref="T:JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers"/> sees a new hosting layer, it publishes it on the <see cref="F:JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers.LayersHostingUserInjections"/> collection. Specific user injected layer implementations watch this structure, load their settings from each new hosting layer, and call into <see cref="T:JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers"/> for registering the layer. Creation of a brand new injected layer is on the handlers' part. Layer deletion could be initiated from <see cref="T:JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers"/> because there should be the single deletion action for the layers.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers.IsHostingUserInjections">
            <summary>
            If the mounting point is holding the list of user-mounted layers which are mounted when the mounting point is loaded and aligned in the same “group” as their parent mount.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers.IsUserInjected">
            <summary>
            If the mounting point was created as a user-mounted layer based on the list in some <see cref="F:JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers.IsHostingUserInjections"/> mounting point.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers.InjectedLayerDescriptor">
            <summary>
            Metadata on the mounting point of the injected layer with its descriptor object, as provided by the owner.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers.LayersHostingUserInjections">
            <summary>
            Lists all of the injection hosting layers which might possibly contain records on injected layers in them.
            Injection handlers should watch this collection, read their own injection information in their own format from the settings of that layer, and <see cref="M:JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers.RegisterUserInjectedLayer(JetBrains.DataFlow.Lifetime,JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers.UserInjectedLayerDescriptor)"/> for each of such layers.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers.myMapInjectedMountToInjectedLayer">
            <summary>
            Allows to get injection runtime info by injected layer ID.
            Mounts are created by <see cref="T:JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers.UserInjectedLayerRuntimeInfo"/>s, a runtime info lives the whole span the injection is defined, while the mounts get recreated from time to time.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers.myMapHostMountToHostingLayer">
            <summary>
            Allows to get hosting layer runtime info by hosting layer ID.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers.myLayersHostingUserInjectionsInternal">
            <summary>
            Same as <see cref="F:JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers.LayersHostingUserInjections"/>, but contains the full info.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers.RegisterUserInjectedLayer(JetBrains.DataFlow.Lifetime,JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers.UserInjectedLayerDescriptor)">
            <summary>
            <para>Registers a user-injected layer in the settings system.</para>
            <para>After calling this method, the layer becomes available with the Settings Store, and this class registers its relation between the injection host and injected layer.</para>
            <para>This method is to be called by injections functionality implementation (for example, file-based injections). That code should watch for any new <see cref="F:JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers.LayersHostingUserInjections"/>, read the feature-specific injection information from it, create the storage and the mounting point WIHTOUT registering them with the settings system, set <see cref="F:JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers.IsUserInjected"/> metadata on the mounting point, and supply the metadata to this function. When the layer is just injected by the user in the UI, the injection settings should be written to the appropriate injections host, the functionality should then get the change notification and process it by creating the storage and supplying it to this function.</para> 
            </summary>
            <param name="lifetimeInjection">Duration of the injection registration.</param>
            <param name="descriptor"></param>
        </member>
        <member name="M:JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers.IsUserInjectedLayer(JetBrains.Application.Settings.UserInterface.UserFriendlySettingsLayer.Identity)">
            <summary>
            Gets whether this layer has been user-injected.
            </summary>
            <param name="layerPossiblyInjected"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers.IsHostingUserInjectedLayers(JetBrains.Application.Settings.UserInterface.UserFriendlySettingsLayer.Identity)">
            <summary>
            Gets if the layer might yield user-injected layers.
            Note that this does not necessarily mean it will.
            </summary>
            <param name="layerPossiblyHostingInjections"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers.TryGetLayerHostingUserInjectedLayer(JetBrains.Application.Settings.UserInterface.UserFriendlySettingsLayer.Identity)">
            <summary>
            If this layer is user-injected, gets the layer which is hosting it.
            Otherwise, <c>NULL</c>.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers.GetLayerHostingUserInjectedLayer(JetBrains.Application.Settings.UserInterface.UserFriendlySettingsLayer.Identity)">
            <summary>
            If this layer is user-injected, gets the layer which is hosting it.
            Otherwise, throws an exception.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers.Init_WatchForHostingLayers(JetBrains.DataFlow.Lifetime,JetBrains.Application.Settings.Store.Implementation.SettingsStorageMountPoints,JetBrains.Application.Settings.UserInterface.UserFriendlySettingsLayers,JetBrains.Threading.IThreading,JetBrains.Util.ILogger)">
            <summary>
            Expose those mounts that might have user-mounted layers written to them.
            </summary>
            <param name="lifetime"></param>
            <param name="mounts"></param>
            <param name="layers"></param>
            <param name="threading"></param>
            <param name="logger"></param>
        </member>
        <member name="M:JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers.Init_AssertValidFlags(JetBrains.DataFlow.Lifetime,JetBrains.Application.Settings.Store.Implementation.SettingsStorageMountPoints,JetBrains.Util.ILogger)">
            <summary>
            Asserts user-mounted-layer-related metadata flags combination is valid on mounting points.
            </summary>
            <param name="lifetime"></param>
            <param name="mounts"></param>
            <param name="logger"></param>
        </member>
        <member name="M:JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers.GetAllUserInjectedLayers">
            <summary>
            Gets user-injected layers coming from all the hosts.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers.GetUserInjectedLayersFromHost(JetBrains.Application.Settings.UserInterface.UserFriendlySettingsLayer.Identity)">
            <summary>
            Gets user-injected layers coming from the specific host.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers.DeleteUserInjectedLayer(JetBrains.Application.Settings.UserInterface.UserFriendlySettingsLayer.Identity)">
            <summary>
            Deletes the user-injected layer: the record on the injection in the hosting layer is erased, and the layer disappears from the settings system.
            </summary>
            <param name="layerInjected"></param>
        </member>
        <member name="M:JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers.TurnInjectedLayerOnOff(JetBrains.Application.Settings.UserInterface.UserFriendlySettingsLayer.Identity,System.Nullable{System.Boolean})">
            <summary>
            <para>An injected layer might be turned off, in which case all of its settings do not take effect, even though information about the layer is not removed from the system.</para>
            <para>This method allows to toggle the state.</para>
            </summary>
            <param name="layerInjected"></param>
            <param name="desired"><c>True</c> to turn on, <c>False</c> to turn off, <c>Null</c> to toggle.</param>
            <returns>Actual on/off state after this method runs (especially useful with Toggle).</returns>
        </member>
        <member name="M:JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers.IsInjectedLayerOn(JetBrains.Application.Settings.UserInterface.UserFriendlySettingsLayer.Identity)">
            <summary>
            See <see cref="M:JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers.TurnInjectedLayerOnOff(JetBrains.Application.Settings.UserInterface.UserFriendlySettingsLayer.Identity,System.Nullable{System.Boolean})"/>.
            Gets the current state.
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers.CanReorderInjectedLayers(JetBrains.Application.Settings.UserInterface.UserFriendlySettingsLayer.Identity,JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers.ReorderInjectedLayersFlags)">
            <summary>
            Gets whether we can change relative order of the injected layers of the same hosting layer.
            </summary>
            <param name="layerToMove">The layer whose position is supposed to be changed.</param>
            <param name="how">How the potision should be changed. See flag values for details.</param>
        </member>
        <member name="M:JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers.ReorderInjectedLayers(JetBrains.Application.Settings.UserInterface.UserFriendlySettingsLayer.Identity,JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers.ReorderInjectedLayersFlags,JetBrains.Application.Settings.UserInterface.UserFriendlySettingsLayer.Identity)">
            <summary>
            Changes relative order of the injected layers of the same hosting layer.
            </summary>
            <param name="layerToMove">The layer whose position is to be changed.</param>
            <param name="how">How the potision should be changed. See flag values for details.</param>
            <param name="other">Meaning depends on the <paramref name="how"/> value, see flag values for details.</param>
        </member>
        <member name="T:JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers.UserInjectedLayerDescriptor">
            <summary>
            Info provided by layer registrator.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers.UserInjectedLayerDescriptor.InjectionsHostLayer">
            <summary>
            The injections host (which stores the information about the injected layer in its settings). If you're watching for <see cref="F:JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers.LayersHostingUserInjections"/>, then it's the layer you got notified of.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers.UserInjectedLayerDescriptor.Identity">
            <summary>
            <para>The persistent identity of this injected layer. For such features as turning injected layers on/off and editing their priority to work between sessions, this must be persistent between sessions per layer. This should be related to the information stored in the hosting layer by the injection handlers.</para>
            <para>NOTE: this identity must be unique per hosting layer.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers.UserInjectedLayerDescriptor.InjectedLayerStorage">
            <summary>
            The storage which should be mounted as an injected layer.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers.UserInjectedLayerDescriptor.DeleteRequested">
            <summary>
            Called by <see cref="T:JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers"/> when user requests deletion of an injected layer.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers.UserInjectedLayerDescriptor.InitialMetadata">
            <summary>
            Any initial metadata, such as a custom <see cref="F:JetBrains.Application.Settings.UserInterface.UserFriendlySettingsLayers.DisplayName">display name</see>, which will be applied to the mounting points created to represent your injected layer in the Settings Store.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers.UserInjectedLayerRuntimeInfo">
            <summary>
            Info on the runtime instance of an injected layer, as stored by this class.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers.UserInjectedLayerRuntimeInfo.HostingLayer">
            <summary>
            Data on the hosting layer (“parent” of this injected layer).
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers.UserInjectedLayerRuntimeInfo.InjectedMount">
            <summary>
            The mounting point currently representing this injected layer.
            It is registered with the Settings Store.
            It is recreated per each combination of the flags, e.g. on change of the priority.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers.UserInjectedLayerRuntimeInfo.IsOn">
            <summary>
            When <c>True</c>, the contents of the mount take part in the Settings Store.
            When <c>False</c> (which corresponds to the unchecked checkbox in the Settings Layers dialog), the contents of the mount are excluded from the Settings Store, even though it's still listed throughout the system.
            This is manifested thru the <see cref="P:JetBrains.Application.Settings.ISettingsStorageMountPoint.IsAvailable"/> parameter.
            A mount is recreated to update this flag.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers.UserInjectedLayerRuntimeInfo.RelativePriority">
            <summary>
            The mount priority, as exposed in <see cref="P:JetBrains.Application.Settings.ISettingsStorageMountPoint.Priority"/>.
            A mount is recreated to update this flag.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers.UserInjectedLayerRuntimeInfo.Identity">
            <summary>
            Exposes <see cref="F:JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers.UserInjectedLayerRuntimeInfo.Descriptor"/>.<see cref="F:JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers.UserInjectedLayerDescriptor.Identity"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers.UserInjectedLayerRuntimeInfo.DisplayName">
            <summary>
            Bound to the display name metadata on all of the mounts.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers.HostingLayerRuntimeInfo.InjectedLayers">
            <summary>
            Lists the injected layers of this host. Is a hash set.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers.HostingLayerRuntimeInfo.myMapIdentityToInjectedLayer">
            <summary>
            Helper dictionary for navigating <see cref="F:JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers.HostingLayerRuntimeInfo.InjectedLayers"/> by identities.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers.HostingLayerRuntimeInfo.ReorderInjectedLayers(JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers.UserInjectedLayerRuntimeInfo,JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers.ReorderInjectedLayersFlags,JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers.UserInjectedLayerRuntimeInfo)">
             <summary>
             Changes relative order of the injected layers of the same hosting layer.
             </summary>
             <param name="injectedToMove">The layer whose position is to be changed.</param>
             <param name="how">How the potision should be changed. See flag values for details.</param>
             <param name="injectedOther">Meaning depends on the <paramref name="how"/> value, see flag values for details.</param>
             <remarks>
             Invariants: 
             (1) The priorities must be changed so that the desired order applies.
             (2) We assume that all of the existing priorities are different (otherwise (2) might not be totally fulfilled). // TODO: validate on host load
             (3) As few positions as possible must be changed, because a position change means recreating mounting points and firing settings changes on each operation.
            
             Algorithm:
             Determine two priorities between which the item should be placed. On edges, higher one is zero and lower one is last plus one.
             Choose the new priority to be the mean value of those two priorities.
             </remarks>
        </member>
        <member name="M:JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers.HostingLayerRuntimeInfo.ReorderInjectedLayers_GetAllPrioritiesConsistent">
            <summary>
            Reads all of the priorities known to customization settings, and makes sure they're consistent in that there're no missing, negative, or duplicate values. Rewrites priorities in the settings store before returning the list as needed.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers.ReorderInjectedLayersFlags.MakeFirst">
            <summary>
            <para>Makes the layer first in the list (with the highest priority).</para>
            <para>This flag does not require the “other” parameter.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers.ReorderInjectedLayersFlags.MakeLast">
            <summary>
            <para>Makes the layer last in the list (with the highest priority).</para>
            <para>This flag does not require the “other” parameter.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers.ReorderInjectedLayersFlags.PutBefore">
            <summary>
            <para>Places the layer immediately before another layer (with a slightly higher priority).</para>
            <para>This flag requires the “other” parameter.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers.ReorderInjectedLayersFlags.PutAfter">
            <summary>
            <para>Places the layer immediately after another layer (with a slightly lower priority).</para>
            <para>This flag requires the “other” parameter.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers.ReorderInjectedLayersFlags.UpOne">
            <summary>
            <para>Takes the nearest layer with a higher priority and does <see cref="F:JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers.ReorderInjectedLayersFlags.PutBefore"/> for it.</para>
            <para>This flag does not require the “other” parameter.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers.ReorderInjectedLayersFlags.DownOne">
            <summary>
            <para>Takes the nearest layer with a lower priority and does <see cref="F:JetBrains.Application.Settings.UserInterface.UserInjectedSettingsLayers.ReorderInjectedLayersFlags.PutAfter"/> for it.</para>
            <para>This flag does not require the “other” parameter.</para>
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.EnvironmentSettings">
            <summary>
            <para>Root key for Environment settings.</para>
            <para>Refer to it in your settings classes that should be directly parented under Environment — but preferrably choose any of the existing nodes under Environment.</para>
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.HousekeepingSettings">
            <summary>
            <para>Root key for all housekeeping data (i.e. cached shortcuts data, recently used something global etc).</para>
            <para>Refer to it in your settings classes that should be directly parented under Housekeeping — but preferrably choose any of the existing nodes under Housekeeping.</para>
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.Storage.Persistence.ISettingsStorageStreamSerialization">
            <summary>
            Handles binding settings storage to some physical media exposed as a stream.
            If you got some stream (e.g. a file stream), you can use this interface to serialize storages.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.Persistence.ISettingsStorageStreamSerialization.Load(JetBrains.Application.Settings.Storage.SettingsStorageLoadFlag,System.Action{System.Action{System.IO.Stream}},JetBrains.Util.ILogger)">
            <summary>
            </summary>
            <param name="flag"></param>
            <param name="FWithStream"></param>
            <param name="logger"></param>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.Persistence.ISettingsStorageStreamSerialization.Save(System.Action{System.Action{System.IO.Stream}},System.Action{System.Action{System.IO.Stream}},JetBrains.Util.ILogger,JetBrains.Util.ILogger)">
            <summary>
            </summary>
            <param name="FWithReadStream"></param>
            <param name="FWithWriteStream"></param>
            <param name="loggerForReading"></param>
            <param name="loggerForWriting"></param>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Application.Settings.Storage.Persistence.SettingsStorageXmlStreamSerialization">
            <summary>
            Operates over <see cref="T:JetBrains.Application.Settings.Storage.Persistence.ISettingsStorageEntriesSerialization"/> (whose serialization works on entries' in-memory representation). Uses <see cref="T:JetBrains.Application.Settings.Storage.Persistence.EntriesReader"/> and <see cref="T:JetBrains.Application.Settings.Storage.Persistence.EntriesWriter"/> to convert it into XML serialization over the given stream.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.Storage.SettingsStorageChangeArgs">
            <summary>
            Args for <see cref="M:JetBrains.Application.Settings.Storage.ISettingsStorage.AdviseChange(JetBrains.DataFlow.Lifetime,System.Action{JetBrains.Application.Settings.Storage.SettingsStorageChangeArgs},JetBrains.Application.Settings.Storage.ISettingsStorageTransactionContext)"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.SettingsStorageChangeArgs.Keys">
            <summary>
            <para>The list of the keys which were assigned to a new value or whose value was reset.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.ISettingsStorageEx_Obsolete.GetObsolete(JetBrains.Application.Settings.Storage.ISettingsStorage,System.String,JetBrains.Application.Settings.Storage.ISettingsStorageTransactionContext)">
            <summary>
            Tries to get the value of the key. 
            </summary>
            <param name="thіs"></param>
            <param name="key">Key.</param>
            <param name="transaction"></param>
            <returns>Either a value of one of the predefined types (<see cref="T:JetBrains.Application.Settings.Storage.SettingsStorageHelpers.StorageValueTypeId"/>), or <c>Null</c> if the value for this key is not set.</returns>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.ISettingsStorageEx_Obsolete.SetObsolete(JetBrains.Application.Settings.Storage.ISettingsStorage,System.String,System.Object,JetBrains.Application.Settings.Storage.ISettingsStorageTransactionContext)">
            <summary>
            Sets or resets the value of the key.
            </summary>
            <param name="thіs"></param>
            <param name="key">Key.</param>
            <param name="value">Either a value of one of the predefined types (<see cref="T:JetBrains.Application.Settings.Storage.SettingsStorageHelpers.StorageValueTypeId"/>) to assign, or <c>Null</c> to reset the value of the given key.</param>
            <param name="transaction"></param>
        </member>
        <member name="T:JetBrains.Application.Settings.Storage.Persistence.EntriesReader">
            <summary>
            State machine for reading settings entries from a possibly-broken XML stream.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.Persistence.EntriesReader.myXmlReader">
            <summary>
            The XML reader actually used for reading. Non-NULL while we're operational.
            Could be either directly the reader passed in, or the wrapping positional XML reader, if we're recording positions.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.Persistence.EntriesReader.myLocationAwareXmlReader">
            <summary>
            Wrapping XML reader to know the positions, if we're recording positions. Otherwise, NULL. Also indicates whether we're recording positions.
            When non-NULL, points to the same object as <see cref="F:JetBrains.Application.Settings.Storage.Persistence.EntriesReader.myXmlReader"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.Persistence.EntriesReader.Entries">
            <summary>
            What we've read from the stream up to the current moment.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.Persistence.EntriesReader.EntryPositions">
            <summary>
            Records positions of the entries encountered as pairs of entry key and position.
            Note that entry keys are not unique here because each entry might be encountered multiple times in the stream (which is not valid, but possible). The count might be larger than <see cref="F:JetBrains.Application.Settings.Storage.Persistence.EntriesReader.Entries"/> for that reason.
            Note that this list might contain positions of invalid entries (without a key, with an invalid value, and so on).
            Empty unless <see cref="F:JetBrains.Application.Settings.Storage.Persistence.EntriesReader.EntryPositionsFlag.Record"/> in ctor.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.Persistence.EntriesReader.ResourceDictionaryPositions">
            <summary>
            Records positions of <see cref="T:System.Windows.ResourceDictionary"/> elements (normally the root element holding all of the entries) encountered in the stream.
            A valid stream should have exactly one, at the root, parenting all of the entries.
            Empty unless <see cref="F:JetBrains.Application.Settings.Storage.Persistence.EntriesReader.EntryPositionsFlag.Record"/> in ctor.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.Persistence.EntriesReader.Run(System.Xml.XmlReader,JetBrains.Application.Settings.Storage.Persistence.EntriesReader.EntryPositionsFlag)">
            <summary>
            Runs the reader. Fluent.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.Persistence.EntriesReader.Step_ReadEntryElementStart_GetEntryKey">
            <summary>
            The key is in the x:Key attribute on the entry element.
            As our entry elements are only convertible from a string value (cannot be assigned thru a proeprty in either attribute or element syntax), the value must be given as text content of the element (this cannot be mixed content, XAML parser fails on that "Cannot have property elements on objects created via TypeConverter"). Thus there's no place to give x:Key in element syntax, and it can be only in the attribute.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.Persistence.EntriesReader.Step_Any_GetEntryTypeId">
            <summary>
            When reader is at an element (opening tag of an element, or an empty element), checks the element fq name to see if it's a settings entry element. Throws if it's not.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.Persistence.EntriesReader.Step_Any_IsResourceDictionaryElement">
            <summary>
            Gets if the current element is a resource dictionary.
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.Persistence.EntriesReader.Step_Any_TryGetEntryTypeId">
            <summary>
            When reader is at an element (opening tag of an element, or an empty element), checks the element fq name to see if it's a settings entry element. <c>Null</c> if it's not.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.Persistence.EntriesReader.ReadEntryValueData.XmlSpace">
            <summary>
            XML Space (preserve/default) will be applied to value content after reading it thru, when we'll be positioned on the next element already, must use the actual entry element's value.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.Persistence.EntriesReader.State.Initial">
            <summary>
            Before stepping.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.Persistence.EntriesReader.State.GenericRead">
            <summary>
            Default reading state. Waiting for an entry element.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.Persistence.EntriesReader.State.UsedUp">
            <summary>
            When done.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.Persistence.EntriesReader.State.ReadEntryElementStart">
            <summary>
            We've encountered an element which is likely an entry, called when the reader is positioned on this element to acknowledge entry type/key and start reading its value.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.Persistence.EntriesReader.State.ReadEntryValueBegin">
            <summary>
            After acknowledging the entry element, initializes into value reading. Still positioned on the entry element.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.Persistence.EntriesReader.State.ReadEntryValueEndClear">
            <summary>
            We're thru with reading entry value content nodes, store the entry value and proceed to generic-read.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.Persistence.EntriesReader.State.ReadEntryValueNodes">
            <summary>
            The reader is positioned inside the value content, we're reading the nodes and collecting the content.
            Looking for either end tag of content element (checking by reader depth) or for any other entries which might erronousely be placed inside (eg when an element closing tag is lost during merge).
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.Storage.Persistence.EntriesReader.EntryPositionsFlag">
            <summary>
            Whether to record locations of the entries when scanning through the XML document.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.Storage.Persistence.EntriesWriter">
            <summary>
            Utility for writing settings entry into an XML stream based on the existing possibly-broken XML stream with entries and various other XML data.
            The writer must persist the existing non-settings element and order of the already-existing entries.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.Persistence.EntriesWriter.Run(System.Collections.Generic.Dictionary{System.String,System.Object},System.Action{System.Action{System.Xml.XmlReader}},System.Action{System.Action{System.Xml.XmlWriter}},JetBrains.Util.ILogger,JetBrains.Util.ILogger)">
            <summary>
            Runs the task.
            </summary>
            <param name="entries">The entries to be written.</param>
            <param name="FCreateReader">
            <para>Opens the reader to the previously existing XML stream which should be updated with the new entries.</para>
            <para>Might be called up to two times, first for choosing the writing positions for the new entries, then for streaming into the output writer.</para>
            <para>Yield <c>NULL</c> if there were no pre-existing stream (e.g. writing for the first time).</para>
            <para>Note: <paramref name="FCreateReader"/> and <paramref name="FCreateWriter"/> cannot be on the same stream (file, etc) because they might be created at the same time to pipe the content thru.</para>
            </param>
            <param name="FCreateWriter">
            <para>Opens the writer to emit the new XML stream (which includes the new entries and any other nodes from the previously existing stream, if there were any).</para>
            <para>If this function is never called during the run, then the output is empty and you might delete the storage altogether.</para>
            <para>Note: <paramref name="FCreateReader"/> and <paramref name="FCreateWriter"/> cannot be on the same stream (file, etc) because they might be created at the same time to pipe the content thru.</para>
            </param>
            <param name="loggerForReading">Logging facility used by the entries reader reading the existing entries stream.</param>
            <param name="loggerForWriting">Logging facility used by this class when writing data.</param>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.Persistence.EntriesWriter.Run_UpdateExistingXml_WriteThruSingleNode(System.Xml.XmlWriter,System.Xml.XmlReader,JetBrains.Util.ILogger)">
            <summary>
            For simple node types, writes them thru.
            Based on <see cref="M:System.Xml.XmlWriter.WriteNode(System.Xml.XmlReader,System.Boolean)"/>, but only handles single-node types and never calls Read on the reader.
            The abovementioned std method is only good for elements. When called on a text node, also kills the next element ('cause it awats for some kind of EndElement to stop).
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.Persistence.EntriesWriter.Run_UpdateExistingXml_WriteThroughElementOpeningTag(JetBrains.Application.Settings.Storage.Persistence.LocationAwareXmlReader,System.Xml.XmlWriter)">
            <summary>
            Pipes the opening tag of an element thru.
            </summary>
            <param name="xmlreader"></param>
            <param name="xmlwriter"></param>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.Persistence.EntriesWriter.Run_UpdateExistingXml_IsElementWithEntriesInside(System.Collections.Generic.List{JetBrains.Application.Settings.Storage.Persistence.EntriesWriter.PositionAction},System.Int32,JetBrains.Application.Settings.Storage.Persistence.LocationAwareXmlReader.NodePosition,JetBrains.Util.ILogger)">
            <summary>
            Looks up quickly if there're any entry positions child to the element identified by the position.
            </summary>
            <param name="elementactions">Sorted actions list.</param>
            <param name="nIndexInElementActions">Index of the current position in the sorted actions list. Must be AFTER a <see cref="M:JetBrains.Application.Settings.Storage.Persistence.EntriesWriter.Run_UpdateExistingXml_TryGetEntryElementAction(System.Collections.Generic.List{JetBrains.Application.Settings.Storage.Persistence.EntriesWriter.PositionAction},JetBrains.Application.Settings.Storage.Persistence.LocationAwareXmlReader.NodePosition,System.Int32@,JetBrains.Application.Settings.Storage.Persistence.EntriesWriter.EntryElementAction@,System.String@,JetBrains.Util.ILogger)"/> lookup for the current position.</param>
            <param name="position">Position of the element we're checking for child entries.</param>
            <param name="logger"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.Persistence.EntriesWriter.Run_UpdateExistingXml_IsElementEntrysFirstChild(System.Collections.Generic.List{JetBrains.Application.Settings.Storage.Persistence.EntriesWriter.PositionAction},System.Int32,JetBrains.Application.Settings.Storage.Persistence.LocationAwareXmlReader.NodePosition)">
            <summary>
            Looks up quickly if this element is the first child of an entry.
            Removing the first entry child element “reveals” the content nodes of the parent that were previously blocked by this element.
            </summary>
            <param name="elementactions">Sorted actions list.</param>
            <param name="nIndexInElementActions">Index of the current position in the sorted actions list. Must be AFTER a <see cref="M:JetBrains.Application.Settings.Storage.Persistence.EntriesWriter.Run_UpdateExistingXml_TryGetEntryElementAction(System.Collections.Generic.List{JetBrains.Application.Settings.Storage.Persistence.EntriesWriter.PositionAction},JetBrains.Application.Settings.Storage.Persistence.LocationAwareXmlReader.NodePosition,System.Int32@,JetBrains.Application.Settings.Storage.Persistence.EntriesWriter.EntryElementAction@,System.String@,JetBrains.Util.ILogger)"/> lookup for the current position.</param>
            <param name="position">Position of the element we're checking for being the first child.</param>
            <remarks>How: look into the previous position, if it's our parent =&gt; we're the first child.</remarks>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.Persistence.EntriesWriter.Run_UpdateExistingXml_TryGetEntryElementAction(System.Collections.Generic.List{JetBrains.Application.Settings.Storage.Persistence.EntriesWriter.PositionAction},JetBrains.Application.Settings.Storage.Persistence.LocationAwareXmlReader.NodePosition,System.Int32@,JetBrains.Application.Settings.Storage.Persistence.EntriesWriter.EntryElementAction@,System.String@,JetBrains.Util.ILogger)">
            <summary>
            Looks up the next sequential item in the sorted list.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.Persistence.EntriesWriter.XX_GetValueAndTypeId(System.String,System.Collections.Generic.IDictionary{System.String,System.Object},JetBrains.Application.Settings.Storage.SettingsStorageHelpers.StorageValueTypeId@,System.Object@)">
            <summary>
            Safely gets the value out of the map, checks that it's of a valid type, and gets its Type ID.
            This method throws all of its errors out.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.Storage.Persistence.EntriesWriter.RunResult">
            <summary>
            What's been done to the output stream, and how you should treat it.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.Persistence.EntriesWriter.RunResult.NewSignificantContent">
            <summary>
            The XML Writer creator was called, the new significant content (different from the previous one) has been written. Should be persisted to media.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.Persistence.EntriesWriter.RunResult.NoChange">
            <summary>
            There're no changes to do to the content, the old one could be used. If a file, just don't touch.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.Persistence.EntriesWriter.RunResult.NoSignificantContent">
            <summary>
            There're no entries to write.
            The XML Writer creator was called, the insignificant content (any non-entry elements encountered in the input stream) has been written.
            Generally, should be persisted to media (to maintain any content we don't understand, eg from newer versions).
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.Persistence.EntriesWriter.RunResult.NoContentAtAll">
            <summary>
            There're no entries to write, and there were no insignificant content (any non-entry elements encountered in the input stream).
            The XML Writer creator was called, and the settings storage XML stream infrastructure has been emitted, but there's nothing else.
            If the file presence is important (e.g. per-project settings), the file might be freely deleted.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.Storage.Format.Base64Blob">
            <summary>
            Represents serialization of the BLOB type as a BASE64 string.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.Storage.Persistence.LocationAwareXmlReader">
            <summary>
            A wrapping XML reader that can tell the (stable enough) position of the current node. These positions have linear order and can be used to identify the same node when reading the document for the next time.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.Persistence.LocationAwareXmlReader.CurrentPositionSnapshot">
            <summary>
            Creates a copy of the current node hierarchical position (contains a list of indices, so a snapshot is required of you'd like to store it for later use).
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.Persistence.LocationAwareXmlReader.CurrentPositionVolatile">
            <summary>
            Returns a view on the current position (without cloning its byref part). Cannot be stored for later use because will be invalidated on the next step.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Settings.Storage.Persistence.LocationAwareXmlReader.NodeAbsoluteIndex">
            <summary>
            Zero-based absolute index of the node.
            Note that this depends on reader settings (whether to autoexpand entities or not) and read process decisions (whether to resolve into each particular entity or not), so it's recommended to use the <see cref="M:JetBrains.Application.Settings.Storage.Persistence.LocationAwareXmlReader.CurrentPositionSnapshot"/>, which is accurate on element nodes.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.Persistence.LocationAwareXmlReader.NodePosition.ElementIndices">
            <summary>
            Hierarchical index of the current element (if it's the current node), or the element containing the current node for non-element nodes (such as text, comments, whitespace, etc).
            The first item is the index of the top-level element (always <c>0</c> in a valid XML document, could be above zero in XML fragments), the second is the index of its child element, and so on.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.Persistence.LocationAwareXmlReader.NodePosition.OffsetFromElementTag">
            <summary>
            If the current node is the element tag, <c>0</c> for opening, closing, and self-closed tags (see <see cref="F:JetBrains.Application.Settings.Storage.Persistence.LocationAwareXmlReader.NodePosition.ElementTagKind"/> for kind).
            If the current node is not an element tag, the number of nodes encountered since the last element opening, closing, or self-closed tag (see <see cref="F:JetBrains.Application.Settings.Storage.Persistence.LocationAwareXmlReader.NodePosition.ElementTagKind"/>for kind: <see cref="F:JetBrains.Application.Settings.Storage.Persistence.LocationAwareXmlReader.NodePosition.ElementTagKinds.Opening"/> means the node is after the opening tag and is a child of that element; <see cref="F:JetBrains.Application.Settings.Storage.Persistence.LocationAwareXmlReader.NodePosition.ElementTagKinds.Closing"/> or <see cref="F:JetBrains.Application.Settings.Storage.Persistence.LocationAwareXmlReader.NodePosition.ElementTagKinds.EmptyElement"/> means it's after the closing or self-closed tag, i.e. the node is on the same level as the element).
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.Persistence.LocationAwareXmlReader.NodePosition.ElementTagKind">
            <summary>
            For an element tag node: the kind of that tag.
            For a non-element node: <see cref="F:JetBrains.Application.Settings.Storage.Persistence.LocationAwareXmlReader.NodePosition.ElementTagKinds.Opening"/> means that <see cref="F:JetBrains.Application.Settings.Storage.Persistence.LocationAwareXmlReader.NodePosition.ElementIndices"/> points to the parent element of this node (there were no previous sibling elements to address from yet), and other values mean that <see cref="F:JetBrains.Application.Settings.Storage.Persistence.LocationAwareXmlReader.NodePosition.ElementIndices"/> is some prev-prev-...-sibling of this node, and nodes are counted starting with its closing tag (which is <see cref="F:JetBrains.Application.Settings.Storage.Persistence.LocationAwareXmlReader.NodePosition.OffsetFromElementTag"/>=<c>0</c>), or the self-closed tag.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.Persistence.LocationAwareXmlReader.NodePosition.Clone">
            <summary>
            Snapshots the position.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.Persistence.LocationAwareXmlReader.NodePosition.IsElement">
            <summary>
            Gets whether this node is either an element opening tag or an empty element's self-closed tag.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.Persistence.LocationAwareXmlReader.NodePosition.CreateFromXmlElement(System.Xml.XmlElement)">
            <summary>
            Creates a node position from an XML element in an XML document.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.Persistence.LocationAwareXmlReader.NodePosition.GetXmlElementByPosition(System.Xml.XmlDocument)">
            <summary>
            Looks up an element in the XML document by this position.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Settings.Storage.Persistence.LocationAwareXmlReader.NodePosition.Depth">
            <summary>
            Gets the depth of the node indicated by the position, just the same way as <see cref="P:System.Xml.XmlReader.Depth"/> would do.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.Storage.Persistence.SettingsStorageXmlHelpers">
            <summary>
            Helpers for serializing Settings Storage entries to and from XML.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.Persistence.SettingsStorageXmlHelpers.NamespaceUri.SystemWindows">
            <summary>
            XML NS alias for the System.Windows namespace (and a couple others).
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.Persistence.SettingsStorageXmlHelpers.NamespaceUri.SystemInMscorlib">
            <summary>
            XML NS for the System namespace in mscorlib (CLR NS form only, no URI alias).
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.Persistence.SettingsStorageXmlHelpers.NamespaceUri.SystemWindowsMarkup">
            <summary>
            XML NS alias for the System.Windows.Markup namespace.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.Persistence.SettingsStorageXmlHelpers.NamespaceUri.SettingsStorageFormat">
            <summary>
            XML NS alias for our CLR namespace that contains the BLOB class.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.Persistence.SettingsStorageXmlHelpers.XmlNamespaceDescriptions.ResolveNamespaceUri(System.String)">
            <summary>
            Tries to resolve XML namespace URI in any form to one of the known kinds (could be a CLR namespace, an alias URI, etc).
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.Storage.Persistence.SettingsStoreSerializationToXmlDiskFile">
            <summary>
            Binds <see cref="T:JetBrains.Application.Settings.Storage.SettingsStorageBase"/> to a disk file.
            </summary>
            <remarks>
            <para>Path is supplied as a property. Whenever the property value changes, or the file content pointed to by the path changes, the settings storage is reloaded.</para>
            <para>Behavior depending on the path and its file conditions (when discovered):</para>
            <para>• Path is <c>Null</c>: means the disk storage is not available, operate in-memory only (e.g. temp solution — doesn't have the file yet). Action: memory storage operates normally (do not clear), no reload actions are taken. We hope to have some path for the final save, but if not, the settings will be dropped.</para>
            <para>• Path is non-<c>Null</c>, but the file does not exist: possible causes: either the storage got empty and the file has been deleted, or the file has been temporarily deleted during a write or merge operation, or the storage path has changed to the new location. Action: if path has changed, save in-memory storage ASAP to the new location; otherwise, keep memory storage intact for some amount of time or until a forced save is requested; at then, reload as if from the empty storage (all in-memory content but for the dirty diff is deleted).</para>
            <para>• Path is non-<c>Null</c>, the file exists, but its content is invalid: keep the in-memory copy for as long as possible; when forced to save, overwrite the corrupted content.</para>
            <para>• Path is non-<c>Null</c>, the file exists, and its content is valid: read to replace the from-stream cache of the storage, the dirty diff remains as-is.</para>
            </remarks>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.Persistence.SettingsStoreSerializationToXmlDiskFile.myIsReloadReschedulled">
            <summary>
            A failed reload is reschedulled.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.Persistence.SettingsStoreSerializationToXmlDiskFile.myIsSaveReschedulled">
            <summary>
            A failed save is reschedulled.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.Persistence.SettingsStoreSerializationToXmlDiskFile.#ctor(JetBrains.DataFlow.Lifetime,JetBrains.Application.Settings.Storage.ISettingsStorageSerializable,JetBrains.DataFlow.IProperty{JetBrains.Util.FileSystemPath},JetBrains.Application.Settings.Storage.Persistence.SettingsStoreSerializationToXmlDiskFile.SavingEmptyContent,JetBrains.Application.FileSystemTracker.IFileSystemTracker,JetBrains.Threading.IThreading,JetBrains.Application.Settings.Storage.Persistence.IFileSettingsStorageBehavior)">
            <summary>
            
            </summary>
            <param name="lifetime"></param>
            <param name="storage">What loads and saves from the stream on our file.</param>
            <param name="path">
            <para>The path to the file, or <c>Null</c> if the file location is not currently available.</para>
            <para>The value is used for reading (<c>Null</c> will cause a clean storage) or writing (<c>Null</c> will skip writing and keep all changes in memory).</para>
            <para>Also the path is watched for changes to reload new content when the file is modified (e.g. from SCC or another instance).</para>
            <para>When you point the path at the new location, it gets overwritten with the current in-memory changes.</para>
            </param>
            <param name="whenNoContent"></param>
            <param name="filetracker">Enables watching for external changes.</param>
            <param name="threading"></param>
            <param name="behavior"></param>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.Persistence.SettingsStoreSerializationToXmlDiskFile.Init_SaveOnDirty(JetBrains.DataFlow.Lifetime,JetBrains.Application.Settings.Storage.ISettingsStorageSerializable,JetBrains.Threading.IThreading,JetBrains.Application.Settings.Storage.Persistence.IFileSettingsStorageBehavior)">
            <summary>
            Schedulles save operation when the storage gets dirty.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.Persistence.SettingsStoreSerializationToXmlDiskFile.SaveRequested">
            <summary>
            Requests that the save operation be done soon. Can be called on any thread, does not wait for save to be completed. Normally schedulles save on another thread.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.Persistence.SettingsStoreSerializationToXmlDiskFile.myLockSerialization">
            <summary>
            Protects the file read-write operations in the whole.
            Also synchronizes lifetime termination on this object.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.Persistence.SettingsStoreSerializationToXmlDiskFile.ReloadReschedulled(System.Boolean)">
            <summary>
            Updates whether there's a pending reload reschedulled.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.Persistence.SettingsStoreSerializationToXmlDiskFile.SaveReschedulled(System.Boolean)">
            <summary>
            Updates whether there's a pending save reschedulled.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.Persistence.SettingsStoreSerializationToXmlDiskFile.Reload_IsWaitingForMissedFile(JetBrains.Util.FileSystemPath,JetBrains.Application.Settings.Storage.Persistence.SettingsStoreSerializationToXmlDiskFile.ReloadReason)">
            <summary>
            <para>This function is called when the file we're about to reload is missing from disk.</para>
            <para>If the file we're trying to reload is reported missing, wait for it for some time to reappear (e.g. user is in process of replacing the file with another version).</para>
            <para>This means that for some time we're not treating the missing file as an empty storage to load, but keeping the in-memory content in hope to load the actual file.</para>
            </summary>
            <param name="path"></param>
            <param name="reason"></param>
            <returns>Whether the reload process should be aborted and wait for the file to reappear.</returns>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.Persistence.SettingsStoreSerializationToXmlDiskFile.Reload_ReadStream(JetBrains.Util.FileSystemPath,System.Action{System.IO.Stream})">
            <summary>
            Reads the file stream while loading with appropriate locking and lockwaiting, throws out if the lock cannot be achieved in the time alotted.
            </summary>
            <param name="path"></param>
            <param name="F"></param>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.Persistence.SettingsStoreSerializationToXmlDiskFile.Save(JetBrains.Application.Settings.Storage.Persistence.SettingsStoreSerializationToXmlDiskFile.SaveDiffFlags,JetBrains.Application.Settings.Storage.Persistence.SettingsStoreSerializationToXmlDiskFile.SaveForcedFlags)">
            <summary>
            <para>Requests that the storage be saved to disk immediately and synchronously, on the main thread.</para>
            <para>Thread affinity is enforced to enable placing <see cref="M:JetBrains.Application.Settings.Storage.Persistence.FileSettingsStorageBehavior.QueryEditFile(JetBrains.Util.FileSystemPath)"/> calls which are affined to the main thread.</para>
            <para>If you're calling from a background thread, or do not care about synchronous execution, use <see cref="M:JetBrains.Application.Settings.Storage.Persistence.SettingsStoreSerializationToXmlDiskFile.SaveRequested"/>.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.Persistence.SettingsStoreSerializationToXmlDiskFile.Save_QueryEditFile">
            <summary>
            <para>Queries into the behavior whether the file could be written.</para>
            <para>Main thread only, due to SCC limitations.</para>
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.Persistence.SettingsStoreSerializationToXmlDiskFile.Save_WriteFile_OpenStreamAndTakeLock(JetBrains.DataFlow.Lifetime,JetBrains.Util.FileSystemPath,JetBrains.Application.Settings.Storage.Persistence.SettingsStoreSerializationToXmlDiskFile.SaveForcedFlags,System.Boolean)">
            <summary>
            Opens the file stream exclusively, which constitutes the interprocess lock.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.Persistence.SettingsStoreSerializationToXmlDiskFile.Save_WriteFile_PromoteWriteCache(System.IO.FileStream,JetBrains.Util.dataStructures.ChunkedMemoryStream,System.Action{JetBrains.Application.Settings.Storage.Persistence.SettingsStorageBinaryCache.StorageCacheIdentity},JetBrains.Util.FileSystemPath)">
            <summary>
            Applies written data to the on-disk file.
            As we're now writing into an in-memory stream, this means writing the stream into the file.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.Persistence.SettingsStoreSerializationToXmlDiskFile.OptionWaitForDisappearedFileTimeout">
            <summary>
            See remarks to class. When the file disappears, we expect it might come back within this amount of time.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.Persistence.SettingsStoreSerializationToXmlDiskFile.myIsStorageCorruptedOnLoad">
            <summary>
            See remarks on the class.
            Means we should not auto-overwrite the settings, assuming the corruption might be due to the SCC conflict and might be fixed soon.
            Only overwrite on forced save if there is dirty content (but make a backup in such a case).
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.Persistence.SettingsStoreSerializationToXmlDiskFile.StreamAccessRetryInitialMs">
            <summary>
            Initial interval before file access retry attempts, in milliseconds. Doubled with each next try.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.Persistence.SettingsStoreSerializationToXmlDiskFile.MaxReadStreamAccessWaitMs">
            <summary>
            The maximum waiting time to gain access to a stream when loading, in milliseconds.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.Persistence.SettingsStoreSerializationToXmlDiskFile.RescheduleOnFailedSaveOrReloadInterval">
            <summary>
            If <see cref="M:JetBrains.Application.Settings.Storage.Persistence.SettingsStoreSerializationToXmlDiskFile.Reload(JetBrains.Application.Settings.Storage.Persistence.SettingsStoreSerializationToXmlDiskFile.ReloadReason)"/> can't get lock for reading the file, reschedulles the next reloading.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.Persistence.SettingsStoreSerializationToXmlDiskFile.myIsFileEverSeenExisting">
            <summary>
            This flag helps with <see cref="M:JetBrains.Application.Settings.Storage.Persistence.SettingsStoreSerializationToXmlDiskFile.Reload_IsWaitingForMissedFile(JetBrains.Util.FileSystemPath,JetBrains.Application.Settings.Storage.Persistence.SettingsStoreSerializationToXmlDiskFile.ReloadReason)"/> to only wait for disappeared files (which were ever seen existing). If the file has never been ever seen, it can be overwritten or treated as missing immediately, without the delay.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Settings.Storage.Persistence.SettingsStoreSerializationToXmlDiskFile.FileWhenNoContent">
            <summary>
            Whether the file should be deleted if there're no settings in it (and no unrecognized content we're obliged to keep).
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.Persistence.SettingsStoreSerializationToXmlDiskFile.SaveDiffFlags.ApplyInMemoryDiff">
            <summary>
            Normal behavior. The modifications done to the storage are applied to what we got on disk.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.Persistence.SettingsStoreSerializationToXmlDiskFile.SaveDiffFlags.OverwriteWithMemoryContent">
            <summary>
            Any on-disk content is ignored, in-memory loaded content &amp; changes are forced onto disk.
            This is the behavior when storage is relocated to the new path (otherwise, all of the settings would be lost).
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.Persistence.SettingsStoreSerializationToXmlDiskFile.SaveForcedFlags.WriteIfPossible">
            <summary>
            Just some new settings have been written to the storage, and that would be a nice idea to save it to the disk.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.Persistence.SettingsStoreSerializationToXmlDiskFile.SaveForcedFlags.ForcedWrite">
            <summary>
            We really have to save now. For example, we're exiting and there're dirty changes.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.Storage.Persistence.SettingsStoreSerializationToXmlDiskFile.SavingEmptyContent">
            <summary>
            What to do when we're about to save a settings file that has no content.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.Persistence.SettingsStoreSerializationToXmlDiskFile.SavingEmptyContent.KeepFile">
            <summary>
            Save a valid empty file.
            After the first save, a file will appear on disk.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.Persistence.SettingsStoreSerializationToXmlDiskFile.SavingEmptyContent.DeleteFile">
            <summary>
            Delete the file from disk.
            Preferrable for SCC-keeped files (otherwise, empty storages would be created for all solutions/projects).
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.Storage.SettingsStorageBase">
            <summary>
            The implementation of the settings storage entrails. Operates on strings, so has to convert each key-path-components based access.
            Its load &amp; save are externally driven in terms of entries (serialization formats are not this object's responsibility).
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.SettingsStorageBase.#ctor(JetBrains.DataFlow.Lifetime,System.String,JetBrains.Util.ILogger)">
            <summary>
            
            </summary>
            <param name="lifetime">Limiting lifetime for the storage objects.</param>
            <param name="name">Diagnostics name of this storage.</param>
            <param name="logger"></param>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.SettingsStorageBase.myDiffToStream">
            <summary>
            <para><see cref="F:JetBrains.Application.Settings.Storage.SettingsStorageBase.myEntriesInStream"/> diff: what should be applied to the settings storage on save to ensure merging of the conflicts.</para>
            <para>Protected with <see cref="F:JetBrains.Application.Settings.Storage.SettingsStorageBase.myLockDiffToStream"/>.</para>
            <para>Set to <c>Null</c> when empty to enabled lock-free checks for the “no-dirty” state.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.SettingsStorageBase.myEntriesInStream">
            <summary>
            <para>The settings storage entries, as read from the persistent storage.</para>
            <para>Maps keys to values.</para>
            <para>In-memory changes are stored in <see cref="F:JetBrains.Application.Settings.Storage.SettingsStorageBase.myDiffToStream"/> until persisted to the storage.</para>
            <para>Protected with the <see cref="F:JetBrains.Application.Settings.Storage.SettingsStorageBase.myLockEntriesInStream"/>.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.SettingsStorageBase.CommitDiffToStream(System.Collections.Generic.IDictionary{System.String,System.Object},System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            <para>Commits the diffs dictionary to the main dictionary, respecting recorded adds and removes.</para>
            <para>Normally is non-throwing.</para>
            </summary>
            <param name="main">Main dictionary. Will be overwritten by commit with changes from <paramref name="diff"/>.</param>
            <param name="diff">Might be <c>Null</c> if there's no diff yet.</param>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.SettingsStorageBase.myLockSerialization">
            <summary>
            Held while a save or load process is in progress to avoid runnnig one more in parallel.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.SettingsStorageBase.SetBatchWithDiffWriteLocked(System.Collections.Generic.ICollection{System.Collections.Generic.KeyValuePair{System.String,System.Object}},System.Collections.Generic.List{System.String})">
            <summary>
            Does a batch-set to the out-of-transaction storage when committing a transaction.
            Writer lock on diff-to-stream must be held by the caller.
            </summary>
            <param name="items">Transaction changes to apply.</param>
            <param name="keysChanged">Keys which were changed by the batch-change must be written here.</param>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.SettingsStorageBase.TransactionData.InTransactionStorage">
            <summary>
            The transaction is currently implemented as one more storage which actually implements all reading &amp; writing. That's it.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.SettingsStorageBase.TransactionData.OuterTransactionStorage">
            <summary>
            In case of nested transaction, the nearest outer storage (storage from the parent transaction). Otherwise, <see cref="F:JetBrains.Application.Settings.Storage.SettingsStorageBase.TransactionData.OutOfTransactionStorage"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.SettingsStorageBase.TransactionData.OutOfTransactionStorage">
            <summary>
            The same storage, but outside all transaction. That's the interface which the outer world uses for accessing the storage.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Settings.Storage.Persistence.XmlFileSettingsStorage">
            <summary>
            Implements a storage with a disk XML file backend.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.Persistence.XmlFileSettingsStorage.#ctor(JetBrains.DataFlow.Lifetime,System.String,JetBrains.DataFlow.IProperty{JetBrains.Util.FileSystemPath},JetBrains.Application.Settings.Storage.Persistence.SettingsStoreSerializationToXmlDiskFile.SavingEmptyContent,JetBrains.Threading.IThreading,JetBrains.Application.FileSystemTracker.IFileSystemTracker,JetBrains.Application.Settings.Storage.Persistence.IFileSettingsStorageBehavior,JetBrains.Application.Settings.Storage.InternKeyPathComponent)">
            <summary>
            
            </summary>
            <param name="lifetime"></param>
            <param name="name"></param>
            <param name="path">
            <para>The path to the file, or <c>Null</c> if the file location is not currently available.</para>
            <para>The value is used for reading (<c>Null</c> will cause a clean storage) or writing (<c>Null</c> will skip writing and keep all changes in memory).</para>
            <para>Also the path is watched for changes to reload new content when the file is modified (e.g. from SCC or another instance).</para>
            <para>When you point the path at the new location, it gets overwritten with the current in-memory changes.</para>
            </param>
            <param name="whenNoContent"></param>
            <param name="threading"></param>
            <param name="filetracker"></param>
            <param name="behavior"></param>
            <param name="interned"></param>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.Persistence.XmlFileSettingsStorage.#ctor(JetBrains.DataFlow.Lifetime,System.String,JetBrains.Util.FileSystemPath,JetBrains.Application.Settings.Storage.Persistence.SettingsStoreSerializationToXmlDiskFile.SavingEmptyContent,JetBrains.Threading.IThreading,JetBrains.Application.FileSystemTracker.IFileSystemTracker,JetBrains.Application.Settings.Storage.Persistence.IFileSettingsStorageBehavior,JetBrains.Application.Settings.Storage.InternKeyPathComponent)">
            <summary>
            </summary>
            <param name="lifetime"></param>
            <param name="name"></param>
            <param name="path">
              <para>The path to the file, or <c>Null</c> if the file location is not currently available.</para>
              <para>The value is used for reading (<c>Null</c> will cause a clean storage) or writing (<c>Null</c> will skip writing and keep all changes in memory).</para>
              <para>Also the path is watched for changes to reload new content when the file is modified (e.g. from SCC or another instance).</para>
              <para>When you point the path at the new location, it gets overwritten with the current in-memory changes.</para>
            </param>
            <param name="whenNoContent"></param>
            <param name="threading"></param>
            <param name="filetracker"></param>
            <param name="behavior"></param>
            <param name="interned"></param>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.Persistence.XmlFileSettingsStorage.ReloadFromDiskRequested">
            <summary>
            Requests an async reload of settings from disk in some near future.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.Persistence.XmlFileSettingsStorage.ReloadFromDiskNow">
            <summary>
            Reloads from disk synchronously.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.Persistence.XmlFileSettingsStorage.SaveToDiskRequested">
            <summary>
            Requests an async saving of settings to disk in some near future.
            Note that the settings are saved even if there're no in-memory changes (there's no need to request a save with in-memory changes because it will occur automatically).
            </summary>
        </member>
        <member name="M:JetBrains.Application.Settings.Storage.Persistence.XmlFileSettingsStorage.SaveToDiskNow">
            <summary>
            Saves to disk synchronously.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.Persistence.XmlFileSettingsStorage.SettingsStorageFileExtensionNoDot">
            <summary>
            The default extensions for Settings Storage files in XML format.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Settings.Storage.Persistence.XmlFileSettingsStorage.SettingsStorageFileExtensionWithDot">
            <summary>
            The default extensions for Settings Storage files in XML format.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Settings.Storage.Persistence.XmlFileSettingsStorage.FileWhenNoContent">
            <summary>
            Whether the file should be deleted if there're no settings in it (and no unrecognized content we're obliged to keep).
            </summary>
        </member>
        <member name="T:JetBrains.Application.ApplyCommandLineKeysToLogger">
            <summary>
            Applies the command line arguments to the logger.
            </summary>
        </member>
        <member name="M:JetBrains.Application.OneTimeInitializationChecker.IsInitializationNeeded(System.String,System.Boolean,System.Action{System.Exception},JetBrains.Application.Environment.Components.ProductSettingsLocation)">
            <summary>
            Checks if the one-time-init is needed.
            Optionally, marks it as done in the Registry (write-touches Current User hive only).
            </summary>
            <param name="identity">Identity of user</param>
            <param name="bMarkAsDone">Whether to mark one-time-init as performed for this config.</param>
            <param name="failed">Action to execute if check failed, or null</param>
            <returns>Whether one-time-init was required.</returns>
        </member>
        <member name="M:JetBrains.Application.OneTimeInitializationChecker.GetActualIdentity(JetBrains.Application.IApplicationHost)">
            <summary>
            If the per-machine one-time-init value is not available, this value is used instead.
            </summary>
            <param name="applicationDescriptor"></param>
        </member>
        <member name="M:JetBrains.Application.OneTimeInitializationManager.OnCheckFailed(System.Exception)">
            <summary>
            Invoked when one-time-init fails to read/write the Registry. Should report to the user in an app-dependent manner.
            </summary>
        </member>
        <member name="P:JetBrains.Application.OneTimeInitializationManager.IsOneTimeInitAllowed">
            <summary>
            Gets whether the one-time-init is allowed to run at the moment, e.g. the main window has already been created.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Shell.AddProductIdentityToLogs">
            <summary>
            On product shell start-stop, exposes the product info in the logs.
            </summary>
        </member>
        <member name="T:JetBrains.Application.ShellComponents">
            <summary>
            The anchor class for various extension methods that expose the app-global components. Should not have any class members. All of the members should be added as extension methods, even in this assembly (otherwise, some of them might get less discoverable).
            </summary>
            <remarks>Notes to implementors: use the <see cref="P:JetBrains.Application.ShellComponents.ComponentContainer"/> prop to get the component instead of its own statics, as this is more consistent against the known instance of the component container.</remarks>
        </member>
        <member name="P:JetBrains.Application.ShellComponents.ComponentContainer">
            <summary>
            Gets the <see cref="P:JetBrains.Application.ShellComponents.ComponentContainer"/> instance whose components this object is serving.
            </summary>
        </member>
        <member name="T:JetBrains.Application.ShellComponentsEx">
            <summary>
            <see cref="T:JetBrains.Application.ShellComponents"/> in this assembly.
            </summary>
            <remarks>Excluded: <see cref="T:JetBrains.Application.OneTimeInitializationManager"/>, <see cref="!:OleUndoManagerFactory"/>.</remarks>
        </member>
        <member name="M:JetBrains.Application.ShellComponentsEx.Get``1(JetBrains.Application.ShellComponents)">
            <summary>
            Gets the component whose interface type is <typeparamref name="TInterface"/>.
            Throws if there is no such component. Use <see cref="M:JetBrains.Application.ShellComponentsEx.Has``1(JetBrains.Application.ShellComponents)"/> to check.
            </summary>
        </member>
        <member name="M:JetBrains.Application.ShellComponentsEx.Has``1(JetBrains.Application.ShellComponents)">
            <summary>
            Gets whether a component whose interface type is <typeparamref name="TInterface"/> is available.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Configuration.ShellSettingsComponent.GetWorkspaceDocument">
            <summary>
            Tries to load the XML Document for <see cref="F:JetBrains.Application.Configuration.XmlExternalizationScope.UserSettings"/> (either from current version location, or any of the legacy dirs for an upgrade).
            </summary>
        </member>
        <member name="M:JetBrains.Application.Configuration.ShellSettingsComponent.GetUserSettingsDocument_CurrentVersion">
            <summary>
            Looks for just the current version. Also saves initial content and timestamp to check for overwrites.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Configuration.ShellSettingsComponent.GetUserSettingsDocument_LegacyVersion">
            <summary>
            Settings from prev versions for upgrade. Initial-content/timestamp not saved in this branch.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Configuration.ShellSettingsComponent.GetUserSettingsDocument">
            <summary>
            Tries to load the XML Document for <see cref="F:JetBrains.Application.Configuration.XmlExternalizationScope.UserSettings"/> (either from current version location, or any of the legacy dirs for an upgrade).
            </summary>
        </member>
        <member name="F:JetBrains.Application.Configuration.ShellSettingsComponent.PropGetLegacySettingsFiles">
            <summary>
            A property that <see cref="!:IApplicationDescriptor"/>s could put into their <see cref="!:IApplicationDescriptor.Bag"/>s to look for older-version settings in non-standard folders when there are no up-to-date-version settings found and we would like to upgrade from an older version.
            The strings are file path names.
            The versions are versions of the product to which the settings supposedly belong.
            </summary>
        </member>
        <member name="T:JetBrains.Application.ApplicationMutex">
            <summary>
            Can be taken once per process (not per thread as <see cref="T:System.Threading.Mutex"/>). Only one acquire per process is possible.
            </summary>
        </member>
        <member name="T:JetBrains.Application.ExecuteOrQueueSingular">
            <summary>
            Wraps <see cref="M:JetBrains.Threading.ReentrancyGuard.ExecuteOrQueue(System.String,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)"/> by executing the same single action. If the execution has been delayed because another execution is in progress (<see cref="M:JetBrains.Threading.ReentrancyGuard.Queue(System.String,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)"/> scenario), does not queue any more executions until the pending one is executed. When the object is disposed of, drops all of the pending executions so that they're never executed after the <see cref="M:System.IDisposable.Dispose"/>.
            Mostly like a <see cref="T:JetBrains.Threading.GroupingEvent"/>, but without any grouping or additional delaying.
            </summary>
        </member>
        <member name="M:JetBrains.Application.ExecuteOrQueueSingular.#ctor(JetBrains.DataFlow.Lifetime,System.String,System.Action,JetBrains.Threading.IThreading)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Object"/> class.
            </summary>
        </member>
        <member name="M:JetBrains.Application.ExecuteOrQueueSingular.#ctor(JetBrains.DataFlow.Lifetime,System.Action,System.Action{System.Action})">
            <summary>
            Initializes a new instance of the <see cref="T:System.Object"/> class.
            Allows to specify the execute-or-queue action manually.
            </summary>
            <param name="lifetime"></param>
            <param name="FUserAction">The useful user action to be executed when the guarded context is entered.</param>
            <param name="FExecuteOrQueue">The action that causes something to be executed or queued.</param>
        </member>
        <member name="M:JetBrains.Application.InterruptableReadActivity.Start">
            <summary>
            Override this method with activity that should happen in primary thread before background thread
            </summary>
        </member>
        <member name="M:JetBrains.Application.InterruptableReadActivity.Work">
            <summary>
            Override this method with activity that happens in background thread.
            </summary>
            This method should periodically check return value of <c>interrupt</c> and either return or 
            throw <c>ProcessCancelledException</c>
        </member>
        <member name="M:JetBrains.Application.InterruptableReadActivity.Finish">
            <summary>
            Override this method with activity that will happen in primary thread after worker thread finishesþ
            </summary>
        </member>
        <member name="M:JetBrains.Application.InterruptableReadActivity.OnInterrupt">
            <summary>
            This method is invoked in primary thread if work is interrupted. 
            <b>NOTE: read lock is released between interruption and this method call!</b>
            If this method is invoked, <cref>Finish</cref> will NOT be called.
            </summary>
        </member>
        <member name="T:JetBrains.Application.InterruptableReadActivityThe">
            <summary>
            A non-abstract implementation for the <see cref="T:JetBrains.Application.InterruptableReadActivity"/> that allows to specify its behavior externally, without creating an inheritor.
            </summary>
        </member>
        <member name="M:JetBrains.Application.InterruptableReadActivityThe.#ctor(JetBrains.DataFlow.Lifetime,JetBrains.Application.IShellLocks,System.Func{System.Boolean})">
            <summary>
            Constructs the instance.
            </summary>
            <param name="shellLocks"></param>
            <param name="funcIsCancelled">The function that will be checked for cancellation periodically by the <see cref="P:JetBrains.Application.InterruptableReadActivityThe.FuncRun"/> function.</param>
        </member>
        <member name="M:JetBrains.Application.InterruptableReadActivityThe.Finish">
            <summary>
            Override this method with activity that will happen in primary thread after worker thread finishesþ
            </summary>
        </member>
        <member name="M:JetBrains.Application.InterruptableReadActivityThe.OnInterrupt">
            <summary>
            This method is invoked in primary thread if work is interrupted. 
            </summary>
            If this method is invoked, <cref>Finish</cref> will NOT be called.
            
        </member>
        <member name="M:JetBrains.Application.InterruptableReadActivityThe.Start">
            <summary>
            Override this method with activity that should happen in primary thread before background thread
            </summary>
        </member>
        <member name="M:JetBrains.Application.InterruptableReadActivityThe.Work">
            <summary>
            Override this method with activity that happens in background thread.
            </summary>
            This method should periodically check return value of <c>d</c> and either return or 
            throw <c>ProcessCancelledException</c>
        </member>
        <member name="P:JetBrains.Application.InterruptableReadActivityThe.FuncCancelled">
            <summary>
            Gets or sets the function that is executed in case the action is aborted.
            </summary>
        </member>
        <member name="P:JetBrains.Application.InterruptableReadActivityThe.FuncCompleted">
            <summary>
            Gets or sets the function that gets executed on the UI thread in case the action completes successfully.
            </summary>
        </member>
        <member name="P:JetBrains.Application.InterruptableReadActivityThe.FuncCompletedOrCancelled">
            <summary>
            Gets or sets the function that is executed on the UI thread when the action finishes execution with either result.
            </summary>
        </member>
        <member name="P:JetBrains.Application.InterruptableReadActivityThe.FuncRun">
            <summary>
            Gets or sets the worker function that executes on the secondary thread. Its parameter is similar to <c>funcIsCancelled</c> in the <c>.ctor</c>, but includes additional conditions from the implementation. Returns the success flag.
            </summary>
        </member>
        <member name="P:JetBrains.Application.InterruptableReadActivityThe.FuncStart">
            <summary>
            Gets or sets the function that is executed on the primary thread when the action starts.
            </summary>
        </member>
        <member name="P:JetBrains.Application.InterruptableReadActivityThe.Name">
            <summary>
            Gets or sets the name for the operation, and for the worker thread of the operation.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Threading.ShellLocks">
            <summary>
            Groups the locking-related methods in the Shell.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Threading.ShellLocks.myIsRecurringActivityAllowed">
            <summary>
            Gets or sets whether the application is currently active (and background activities are allowed).
            Used to suspend recurring actions execution when inactive.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.ShellLocks.#ctor(JetBrains.DataFlow.Lifetime)">
            <summary>
            Creates shell locks over an existing threading object.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Threading.Tasks.SingleThreadExecutorView.CurrentlyExecuting">
            <summary>
              Property that contains task which is currently beeing executed or null if executor's queue is empty
            </summary>
        </member>
        <member name="F:JetBrains.Application.Threading.Tasks.SingleThreadExecutorView.Idle">
            <summary>
            Property that contains true is some task is currently beeing executed or null if executor's queue is empty.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.SingleThreadExecutorView.Queue(System.Threading.Tasks.Task,System.Boolean)">
            <summary>
              Warning!!! Think twice before queueing task in SYNC mode, very dealock-prone pattern.
              Queue task to execution in sequential mode. It's guaranteed that all tasks are beeing executed sequentialy and if
              task was queued after other task with same priority, their
              order will be retained.
            </summary>
            <param name="task"></param>
            <param name="sync">whether execute action synchronously and wait until execution is completed</param>
        </member>
        <member name="P:JetBrains.Application.Threading.Tasks.SingleThreadExecutorView.SyncContinuationAction">
            <summary>
            Action will be executed syncronously after each task, before other task in this scheduler will be executed
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.ITaskHost.Queue(JetBrains.DataFlow.Lifetime,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)">
            <summary>
            Queues <paramref name="action"/> on threads managed by <see cref="P:JetBrains.Application.Threading.Tasks.ITaskHost.Scheduler"/> with given priority
            </summary>
            <param name="lifetime"></param>
            <param name="action"></param>
            <param name="priority"></param>
            <returns><see cref="T:System.Threading.Tasks.Task"/> that was created. Its execution progress can be viewed by <see cref="P:System.Threading.Tasks.Task.Status"/></returns>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.ITaskHost.QueueAt(JetBrains.DataFlow.Lifetime,System.Action,System.DateTime)">
            <summary>
            Queues <paramref name="action"/> on threads managed by <see cref="P:JetBrains.Application.Threading.Tasks.ITaskHost.Scheduler"/> with priority <see cref="F:JetBrains.Util.Threading.Tasks.TaskPriority.AboveNormal"/> with certain delay expressed by <paramref name="date"/>
            </summary>
            <param name="lifetime"></param>
            <param name="action"></param>
            <param name="date">Date, when task will be queued to execution</param>
            <returns><see cref="T:System.Threading.Tasks.Task"/> that was created. Its execution progress can be viewed by <see cref="P:System.Threading.Tasks.Task.Status"/></returns>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.ITaskHost.QueueRecurring(JetBrains.DataFlow.Lifetime,System.Action,System.DateTime,System.TimeSpan)">
            <summary>
            Queues <paramref name="action"/> reccurenly on threads managed by <see cref="P:JetBrains.Application.Threading.Tasks.ITaskHost.Scheduler"/> with priority <see cref="F:JetBrains.Util.Threading.Tasks.TaskPriority.AboveNormal"/> with certain delay 
            expressed by <paramref name="firstTime"/>
            </summary>
            <param name="lifetime"></param>
            <param name="action"></param>
            <param name="firstTime">Date, when task will be queued to execution</param>
            <param name="interval">Interval between end and begin of execution of two adjancent repetition. If action execution time extends <paramref name="interval"/> then 
            they will be executed sequentially one by one. It's guaranteed that new action repetition can't start before old one is finished.</param>    
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.ITaskHost.Create(JetBrains.DataFlow.Lifetime,System.Action,System.Func{System.Boolean},System.Threading.Tasks.TaskCreationOptions,JetBrains.Application.Threading.Tasks.TaskJetProperties)">
            <summary>
            Creates task in <see cref="F:System.Threading.Tasks.TaskStatus.Created"/> state. <paramref name="checkForInterrupt"/> and lifetime termitation is beeing propated into task, that can 
            throw <see cref="T:JetBrains.Application.Progress.ProcessCancelledException"/> and finish execution in  <see cref="F:System.Threading.Tasks.TaskStatus.Faulted"/> state. State <see cref="F:System.Threading.Tasks.TaskStatus.Canceled"/> state is not supported.
            In case of normal execution, <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion"/> is assigned to task.
            </summary>
            <param name="lifetime"></param>
            <param name="action"></param>
            <param name="checkForInterrupt"></param>
            <param name="options"></param>
            <param name="properties"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.ITaskHost.Create``1(JetBrains.DataFlow.Lifetime,System.Func{``0},System.Func{System.Boolean},System.Threading.Tasks.TaskCreationOptions,JetBrains.Application.Threading.Tasks.TaskJetProperties)">
            <summary>
            Creates task in <see cref="F:System.Threading.Tasks.TaskStatus.Created"/> state. <paramref name="checkForInterrupt"/> and lifetime termitation is beeing propated into task, that can 
            throw <see cref="T:JetBrains.Application.Progress.ProcessCancelledException"/> and finish execution in  <see cref="F:System.Threading.Tasks.TaskStatus.Faulted"/> state. State <see cref="F:System.Threading.Tasks.TaskStatus.Canceled"/> state is not supported.
            In case of normal execution, <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion"/> is assigned to task.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.ITaskHost.CreateBarrier(JetBrains.DataFlow.Lifetime,System.Func{System.Boolean},System.Boolean,System.Boolean,System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            Must be used with <code>using</code>. On dispose synchronously waits all activities that were enqueued by <see cref="M:JetBrains.Application.Threading.Tasks.TaskBarrier.EnqueueJob(System.Action)"/> and <see cref="M:JetBrains.Application.Threading.Tasks.TaskBarrier.EnqueueDependentJobs(System.Collections.Generic.IEnumerable{System.Action},JetBrains.Util.OneToSetMap{System.Action,System.Action})"/>
            </summary>
            <param name="lifetime"></param>
            <param name="checkForInterrupt">if null inherits current thread's <see cref="T:JetBrains.Application.InterruptableActivityCookie"/> into all jobs</param>
            <param name="sync">whether to execute all enqueued jobs in the same thread as enqueue call</param>
            <param name="takeReadLock">whether to take readlock in each job. True by default (legacy of MulticoreFibersPool)</param>
            <param name="options">options to all tasks in barrier</param>
            <returns></returns>
        </member>
        <member name="P:JetBrains.Application.Threading.Tasks.ITaskHost.Scheduler">
            <summary>
            Scheduler of all tasks created by our code either <see cref="M:JetBrains.Application.Threading.Tasks.TaskHost.Create(JetBrains.DataFlow.Lifetime,System.Action,System.Func{System.Boolean},System.Threading.Tasks.TaskCreationOptions,JetBrains.Application.Threading.Tasks.TaskJetProperties)"/>, <see cref="T:System.Threading.Tasks.Task"/> constructor, continuations, etc. Manages execution and timer threads.    
            </summary>
        </member>
        <member name="P:JetBrains.Application.Threading.Tasks.ITaskHost.Factory">
            <summary>
            Factory of all task. Can be used to obtain functionality such as <see cref="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task[]})"/>,
            <see cref="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task})"/>    
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.ITaskHostEx2.Run(JetBrains.Application.Threading.Tasks.ITaskHost,JetBrains.DataFlow.Lifetime,JetBrains.Application.Threading.Tasks.Scheduling,System.Action)">
            <summary>
            Creates a task and puts it in the started state.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.ITaskHostEx2.RunEmpty(JetBrains.Application.Threading.Tasks.ITaskHost)">
            <summary>
            Creates an empty task and puts it in the started state.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.ITaskHostEx2.Run``1(JetBrains.Application.Threading.Tasks.ITaskHost,JetBrains.DataFlow.Lifetime,JetBrains.Application.Threading.Tasks.Scheduling,System.Func{``0})">
            <summary>
            Creates a task and puts it in the started state.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.ITaskHostEx2.GetTaskScheduler(JetBrains.Threading.JetDispatcher)">
            <summary>
            Allows to schedule async tasks execution on a Dispatcher thread.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.ITaskHostEx2.ContinueWithTask(System.Threading.Tasks.Task,JetBrains.DataFlow.Lifetime,System.Threading.Tasks.Task)">
            <summary>
            Awaits for <paramref name="thіs"/> task to complete, then executes <paramref name="taskAfter"/>, and returns the task that represents this execution.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.ITaskHostEx2.Run(JetBrains.Application.Threading.Tasks.ITaskHost,JetBrains.DataFlow.Lifetime,System.Action,System.Func{System.Boolean},System.Threading.Tasks.TaskCreationOptions,JetBrains.Application.Threading.Tasks.TaskJetProperties,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Creates a task and puts it in the started state.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.ITaskHostEx2.Run``1(JetBrains.Application.Threading.Tasks.ITaskHost,JetBrains.DataFlow.Lifetime,System.Func{``0},System.Func{System.Boolean},System.Threading.Tasks.TaskCreationOptions,JetBrains.Application.Threading.Tasks.TaskJetProperties,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Creates a task and puts it in the started state.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Threading.Tasks.Scheduling.FreeThreaded">
            <summary>
            Tasks will be run on an MTA thread pool, with maximum parallelism.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Threading.Tasks.Scheduling.MainDispatcher">
            <summary>
            Tasks will be run with the <see cref="T:JetBrains.Threading.JetDispatcher">Dispatcher</see> of the main thread (one of the <see cref="T:JetBrains.Threading.IThreading"/> component) — i.e. on the main thread when smb pumps the Windows Message Queue. No reentrancy guarantee for these.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Threading.Tasks.Scheduling.MainGuard">
            <summary>
            Tasks will be run with the <see cref="T:JetBrains.Threading.ReentrancyGuard">Guard</see> of the main thread (one of the <see cref="T:JetBrains.Threading.IThreading"/> component) — i.e. on the main thread when smb pumps the Windows Message Queue and when no other guarded tasks are running. Tasks executed with the Guard will never reenter one another. NOTE: eventually, all such tasks will be taking the reader lock automatically (if available in the current Shell).
            </summary>
        </member>
        <member name="T:JetBrains.Application.Threading.Tasks.TaskBarrier">
            <summary>
            Replace of MulticoreFibersPool. When you dispose this object it synchronously waits all task that were enqueued by <see cref="M:JetBrains.Application.Threading.Tasks.TaskBarrier.EnqueueJob(System.Action)"/> and <see cref="M:JetBrains.Application.Threading.Tasks.TaskBarrier.EnqueueDependentJobs(System.Collections.Generic.IEnumerable{System.Action},JetBrains.Util.OneToSetMap{System.Action,System.Action})"/>
            Create an instance with <see cref="M:JetBrains.Application.Threading.Tasks.ITaskHost.CreateBarrier(JetBrains.DataFlow.Lifetime,System.Func{System.Boolean},System.Boolean,System.Boolean,System.Threading.Tasks.TaskCreationOptions)"/>  
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.TaskBarrier.EnqueueTask(System.Threading.Tasks.Task)">
            <summary>
            Enqueue a custom (possibly already running) task under the task barrier. If task is not started it will be started.
            </summary>
            <remarks>Note that custom tasks (in contrast with tasks created by EnqueueJob) will not share check-for-interrupt, proiority, and sync and read-lock flag defined in TaskBarrier ctor.</remarks>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.TaskBarrier.EnqueueJob(System.Action)">
            <summary>
            Create and start a new task under the task barrier.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Threading.Tasks.TaskJetProperties">
            <summary>
            Additional task properties that influece on its execution
            </summary>
        </member>
        <member name="P:JetBrains.Application.Threading.Tasks.TaskJetProperties.Priority">
            <summary>
            Task execution priority. Higher priorities are executed first.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Threading.Tasks.TaskJetProperties.TakeReadLock">
            <summary>
            Whether to take system ReadLock on task execution
            </summary>
        </member>
        <member name="P:JetBrains.Application.Threading.Tasks.TaskJetProperties.ExecutionId">
            <summary>
            Internal number that designated in which order tasks are entered into <see cref="!:JetScheduler.QueueTask(System.Threading.Tasks.Task)"/> method
            </summary>
        </member>
        <member name="P:JetBrains.Application.Threading.Tasks.TaskJetProperties.Name">
            <summary>
            Internal number that designated in which order tasks are entered into <see cref="!:JetScheduler.QueueTask(System.Threading.Tasks.Task)"/> method
            </summary>
        </member>
        <member name="P:JetBrains.Application.Threading.Tasks.TaskJetProperties.ScheduledTime">
            <summary>
            For scheduled tasks with delayed execution
            </summary>
        </member>
        <member name="P:JetBrains.Application.Threading.Tasks.TaskJetProperties.AssignedToExecutor">
            <summary>
            internal status of task
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.TaskEx.Start(System.Threading.Tasks.Task,JetBrains.Application.Threading.Tasks.ITaskHost,System.Boolean)">
            <summary>
            Helper that parametrize task start mode: syncronous (on the same thread, instantly) or asyncronous (on thread pool managed by <see cref="T:JetBrains.Application.Threading.Tasks.Scheduler.JetScheduler"/>)
            </summary>
            <param name="task"></param>
            <param name="host"></param>
            <param name="sync">if true run task synchronously (on the same thread)</param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.TaskEx.WaitOnMonitor(JetBrains.Application.Threading.Tasks.ITaskHost,System.Object,System.Int32)">
            <summary>
            Wait on monitor <code>mySentry</code> with awareness about MainThread
            </summary>
            <param name="tasks"></param>
            <param name="sentry"></param>
            <param name="timeToWaitMillis"></param>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.TaskEx.IsProcessCancelled(System.Threading.Tasks.Task)">
            <summary>
            Task is faulted because of PCE
            </summary>
            <param name="task"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.TaskEx.ParseAggregateException(System.Exception@,System.AggregateException)">
            <summary>
            Try to find out ProcessCancelledException in AggregateException. If no PCE but some other exception exist, return it.
            </summary>
            <param name="toUpdate">Return value that can be updated based on possibleAggregateException</param>
            <param name="possibleAggregateException">AggregateException or null</param>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.TaskEx.CantBeJetTask(System.Threading.Tasks.Task)">
            <summary>
            Sometimes some external action can be scheduled here with some state. 
            https://youtrack.jetbrains.com/issue/RSRP-440328
            </summary>
            <param name="task"></param>
            <returns></returns>
        </member>
        <member name="F:JetBrains.Application.Threading.Tasks.TaskEx.False">
            <summary>
            An already completed task.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.TaskEx.FromResult``1(``0)">
            <summary>
            Creates a started and completed tasks which yields the given result.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.TaskEx.Delay(System.TimeSpan,System.Nullable{System.Threading.CancellationToken})">
            <summary>
            Creates a started tasks which will get a completed state after the specified amount of time.
            </summary>
        </member>
        <member name="M:JetBrains.Application.TryWriteLockCookie.ReleaseConditionally">
            <summary>
            Can throw ProcessCancelledException
            </summary>
        </member>
        <member name="M:JetBrains.Application.TryWriteLockCookie.ReleaseAndSleep(System.Int32)">
            <summary>
            Can throw ProcessCancelledException
            </summary>
            <param name="millisToSleep"></param>
        </member>
        <member name="F:JetBrains.Util.UnguardedAlarm.ourRequests">
            <summary>
            Maps requests to invocation times
            </summary>
        </member>
        <member name="F:JetBrains.Util.UnguardedAlarm.myRequests">
            <summary>
            List of requests for specific alarm
            </summary>
        </member>
        <member name="F:JetBrains.Util.UnguardedAlarm.ourTimer">
            <summary>
            The alarms timer
            </summary>
        </member>
        <member name="T:JetBrains.Application.AssemblyManager">
            <summary>
            Controls execution of the assembly-load-time-handlers in various assemblies of the product.
            </summary>
        </member>
        <member name="M:JetBrains.Application.AssemblyManager.LoadAssemblies(System.String,System.Collections.Generic.IEnumerable{System.Reflection.Assembly})">
            <summary>
            Creates the descriptors for the already-loaded assemblies (eg plugins') and executes load handlers for 'em.
            </summary>
        </member>
        <member name="T:JetBrains.Application.changes.ChangeEventArgs">
            <summary>
            Represents arguments of change event
            </summary>
        </member>
        <member name="M:JetBrains.Application.changes.ChangeManager.ExecuteAfterChange(System.Action)">
            <summary>
            Executes the specified action after the current change has finished or immediately if there
            is no change currently in progress.
            </summary>
        </member>
        <member name="M:JetBrains.Application.changes.ChangeManager.RegisterChangeProvider(JetBrains.Application.changes.IChangeProvider)">
            <summary>
            Registers change provider in the dispatching scheme.
            </summary>
        </member>
        <member name="M:JetBrains.Application.changes.ChangeManager.UnregisterChangeProvider(JetBrains.Application.changes.IChangeProvider)">
            <summary>
            Unregisters change provider from the dispatching scheme.
            </summary>
            <remarks>Remove all dependencies in which the provider participates</remarks>
        </member>
        <member name="M:JetBrains.Application.changes.ChangeManager.OnProviderChanged(JetBrains.Application.changes.IChangeProvider,System.Object,JetBrains.Application.Progress.ITaskExecutor)">
            <summary>
            Initiates the event dispatching process using the specified provider as a starting point.
            </summary>
        </member>
        <member name="M:JetBrains.Application.changes.ChangeManager.AddDependency(JetBrains.Application.changes.IChangeProvider,JetBrains.Application.changes.IChangeProvider)">
            <summary>
            Adds dependency between two providers.
            </summary>
            <remarks>Both providers must have already been registered</remarks>
        </member>
        <member name="M:JetBrains.Application.changes.ChangeManager.RemoveDependency(JetBrains.Application.changes.IChangeProvider,JetBrains.Application.changes.IChangeProvider)">
            <summary>
            Removes dependency between two providers.
            </summary>
            <remarks>Both providers must have already been registered</remarks>
        </member>
        <member name="M:JetBrains.Application.changes.ChangeManager.Dump(System.IO.TextWriter)">
            <summary>
            Dumps the internal structure into the specified writer.
            </summary>
        </member>
        <member name="F:JetBrains.Application.changes.ChangeManager.Changed2">
            <summary>
            The event about changes in the system.
            Supports lifetimes.
            </summary>
        </member>
        <member name="E:JetBrains.Application.changes.ChangeManager.Changed">
            <summary>
            The event about changes in the system.
            Does not support lifetimes, see for <see cref="F:JetBrains.Application.changes.ChangeManager.Changed2"/>.
            </summary>
        </member>
        <member name="T:JetBrains.Application.changes.Pattern">
            <summary>
            Defines set of file names that match the specified regular expression
            </summary>
        </member>
        <member name="M:JetBrains.Application.HostCommandLine.#ctor(JetBrains.Util.FileSystemPath,System.String[])">
            <summary>
            Parsing rules:
            Keyed parameters start with “/” or “-”. Non-keyed parameters don't have this prefix and wholy go to the value.
            The keyed parameter is of the “key=value” or “key:value” form, where value might be omitted with or without the separator.
            All parameters afer "--" are non-keyed.
            "/" support is limited to Windows-only
            <code>( ( '/'|'-' 'key' ['='|':' ['value'] ] ) | ( 'value' ) )*</code> 
            </summary>
            <param name="args">Command line args.</param>
            <param name="startupDirectory">The startup directory which is required for treating relative paths in command line args.</param>
        </member>
        <member name="M:JetBrains.Application.HostCommandLine.GetCommandLineParameterText(JetBrains.Application.CommandLineParameter,System.String,System.Boolean)">
            <summary>
            Forms the complete standalone host command line parameter presentation.
            </summary>
            <param name="parameter">Command line argument name and value (either optional, but not both at a time).</param>
            <param name="sProductName">Product name (prefixes the arg).</param>
            <param name="isOmittingDefaultProductName">If this is the default product of the standalone host, its name can be omitted in the host command line (non-product-name-prefixed keys are attributed to the default product of the host, if there's one on that host).</param>
        </member>
        <member name="M:JetBrains.Application.HostCommandLine.GetCommandLineText(System.Collections.Generic.IEnumerable{JetBrains.Application.CommandLineParameter},System.String,System.Boolean)">
            <summary>
            Forms the standalone host command line containing multiple parameters.
            </summary>
            <param name="parameters">Each parameter will be presented with <see cref="M:JetBrains.Application.HostCommandLine.GetCommandLineParameterText(JetBrains.Application.CommandLineParameter,System.String,System.Boolean)"/>, see there for details.</param>
            <param name="sProductName">Product name (prefixes the arg).</param>
            <param name="isOmittingDefaultProductName">If this is the default product of the standalone host, its name can be omitted in the host command line (non-product-name-prefixed keys are attributed to the default product of the host, if there's one on that host).</param>
        </member>
        <member name="M:JetBrains.Application.HostCommandLine.CreateFromCurrentEnvironment(System.String[])">
            <summary>
            Gets everything from the current process environment.
            </summary>
            <param name="strings"></param>
        </member>
        <member name="P:JetBrains.Application.HostCommandLine.Keys">
            <summary>
            Array of defined keys: /Key[=Value]
            </summary> 
        </member>
        <member name="P:JetBrains.Application.HostCommandLine.NonKeyedParameters">
            <summary>
            Strings, that does not start with '/'.
            </summary> 
        </member>
        <member name="T:JetBrains.Application.CommandLineSwitchAttribute">
            <summary>
            Defines a command-line switch that will be known to the shell and registered with the hosting app, as needed.
            </summary>
        </member>
        <member name="M:JetBrains.Application.CommandLineSwitchAttribute.#ctor(System.String,System.Int32)">
            <summary>
            Defines a command-line switch that will be known to the shell and registered with the hosting app, as needed.
            </summary>
            <param name="name">The name of the command line switch, without the prefix.</param>
            <param name="parameterscount">The number of parameters of the command line switch.</param>
        </member>
        <member name="P:JetBrains.Application.CommandLineSwitchAttribute.Name">
            <summary>
            Gets the name of the command line switch, without the prefix.
            </summary>
        </member>
        <member name="P:JetBrains.Application.CommandLineSwitchAttribute.ParametersCount">
            <summary>
            Gets the number of parameters of the command line switch.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Install.AssemblyAttributeInstallerAttribute">
            <summary>
            An attribute to mark the classes that process the installation data written in the form of assembly attributes of type <see cref="P:JetBrains.Application.Install.AssemblyAttributeInstallerAttribute.AttributeToInstall"/> during registration and unregistration.
            Such classes will also be called once to perform their own attribute-independent installation.
            The class must implement the <see cref="T:JetBrains.Application.Install.IAssemblyAttributeInstaller`1"/> interface.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Install.AssemblyAttributeInstallerAttribute.#ctor(System.Type,JetBrains.Application.Install.InstallerVsVersionAffinity)">
            <summary>
            Creates the attribute.
            </summary>
            <param name="typeAttributeToInstall">Type of the attribute for which the class marked by <see cref="T:JetBrains.Application.Install.AssemblyAttributeInstallerAttribute"/> should be invoked to process the installation.</param>
            <param name="vsversionaffinity">Specifies the affinity of this installer to the VS version, see enum member summaries for details.</param>
        </member>
        <member name="P:JetBrains.Application.Install.AssemblyAttributeInstallerAttribute.AttributeToInstall">
            <summary>
            Gets the type of the attribute for which the class marked by <see cref="T:JetBrains.Application.Install.AssemblyAttributeInstallerAttribute"/> should be invoked to process the installation.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Install.Installer">
            <summary>
            Invokes installation/uninstallation related services.
            This class should not be made static (and, conscequently, public interface methods on it), so that it were created and disposed accordingly, with its underlying <see cref="T:JetBrains.Metadata.Utils.AssemblyResolver"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Install.Installer.AssertVersionSpecific">
            <summary>
            Throws if <see cref="P:JetBrains.Application.Install.Installer.IsVsVersionNeutral"/>.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Install.Installer.InstallationData">
            <summary>
            Gets all the Registry data that should be written to or erased from the Registry upon installation or uninstallation.
            This includes the static app-global Registry data and dynamic registration info collected from the Assembly attributes.
            The first call is slow (the installation data is harvested), subsequent calls are fast because the result is cached.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Install.Installer.IsVsVersionNeutral">
            <summary>
              <para>Gets whether the installer is currently running in the VS-version-neutral mode.</para>
              <para>The installer is conscequently run on the same data for each of VS versions supported, to produce VS-version-specific data for each VS.</para>
              <para>Also it's run once in VS-version-neutral mode to collect the shared things (and avoid collecting them more than once, if included in version-specific runs).</para>
              <para>When <c>False</c>, you can use the <see cref="P:JetBrains.Application.Install.Installer.VsVersion"/>, <see cref="!:VsRootSuffix"/>, and <see cref="!:VsHive"/> attributes to learn the version. When <c>True</c>, the abovementioned properties cannot be access, and will throw.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Application.Install.Installer.SourceFoldersResolver">
            <summary>
            Can locate files and folders with files on the source system to be deployed to the target system.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Install.Installer.VsVersion">
            <summary>
            Gets the version of the Visual Studio. Example: “8.0”.
            If the installer is running in the VS-version-neutral mode, throws an exception.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Install.Installer.InstallerBaseFolders">
            <summary>
            Initializes the installer to enable its capability to resolve source folders with files to be deployed.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Install.Installer.InstallerBaseFolders.ProductBinariesDir">
            <summary>
            Product DLLs location.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Install.Installer.InstallerBaseFolders.ProductHomeDir">
            <summary>
            Home directory of the product. Required for most of the operation modes.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Install.Installer.InstallerSourceFoldersResolver">
            <summary>
            Can locate files and folders with files on the source system to be deployed to the target system.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Install.Installer.InstallerSourceFoldersResolver.FindFilesInProductBinariesDir(System.String)">
            <summary>
            Gets the matching files under the product binaries directory.
            </summary>
            <param name="mask">A relative path to the file. Might have a mask in place of the file name.</param>
        </member>
        <member name="M:JetBrains.Application.Install.Installer.InstallerSourceFoldersResolver.FindFilesUnderRoot(JetBrains.Application.Install.InstallationData.InstallationSourceDirRoot,System.String,JetBrains.Metadata.Utils.AssemblyNameInfo)">
            <summary>
              <para>Invokes either <see cref="M:JetBrains.Application.Install.Installer.InstallerSourceFoldersResolver.FindFilesInProductBinariesDir(System.String)"/> or <see cref="!:FindFilesInReferencesDirectories"/>, depending on <see cref="!:root"/>. Read their documentation for details.</para>
              <para>The <paramref name="assembly"/> is used to look up its owning subplatform.</para>
            </summary>
            <param name="root">Lookup root choice.</param>
            <param name="mask">A relative path to the file. Might have a mask in place of the file name.</param>
            <param name="assembly">Defines the subplatform for references directory lookup. Ignored on product binaries directory lookup.</param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Application.Install.Installer.InstallerSourceFoldersResolver.GetProductBinariesDir">
            <summary>
            Gets the build target folder within the current build process.
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Application.Install.Installer.InstallerSourceFoldersResolver.GetProductReferencesDir">
            <summary>
            Gets the references dir which is global to the product and does not belong to any module.
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Application.Install.Installer.InstallerSourceFoldersResolver.GetRootDirectory(JetBrains.Application.Install.InstallationData.InstallationSourceDirRoot,JetBrains.Metadata.Utils.AssemblyNameInfo)">
            <summary>
              <para>Invokes either <see cref="M:JetBrains.Application.Install.Installer.InstallerSourceFoldersResolver.GetProductBinariesDir"/> or <see cref="M:JetBrains.Application.Install.Installer.InstallerSourceFoldersResolver.GetSubplatformReferencesDir(System.String)"/>, depending on <see cref="!:root"/>. Read their documentation for details.</para>
              <para>The <paramref name="assembly"/> is used to look up its owning subplatform. If <paramref name="root"/> is <see cref="F:JetBrains.Application.Install.InstallationData.InstallationSourceDirRoot.ReferencesDirectories"/> and <paramref name="assembly"/> is <c>Null</c>, throws an exception.</para>
            </summary>
            <param name="root">Lookup root choice.</param>
            <param name="assembly">Defines the subplatform for references directory lookup. Ignored on product binaries directory lookup.</param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Application.Install.Installer.InstallerSourceFoldersResolver.GetSubplatformReferencesDir(System.String)">
            <summary>
            Gets the references folder of the specific subplatform.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Install.Installer.InstallerSourceFoldersResolver.GetMaskDirAndName(System.String,JetBrains.Util.FileSystemPath@,System.String@)">
            <summary>
            Splits relative path of the mask into a folder path and a file name mask.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Install.Installer.InstallerSourceFoldersResolver.GetProductHomeDir">
            <summary>
            Throws if <see cref="F:JetBrains.Application.Install.Installer.InstallerBaseFolders.ProductHomeDir"/> was <c>Null</c>.
            NOTE: must not be made public! Internal use only! Expose semantic methods for any other folders which might be needed.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Install.RegistrationStage">
            <summary>
            Defines the exact stage of the registration process of which the handler is being queried.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Install.RegistrationStage.Register">
            <summary>
            The assembly is being registered.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Install.RegistrationStage.Unregister">
            <summary>
            The assembly is being unregistered.
            </summary>
        </member>
        <member name="P:JetBrains.Application.License.LicenseChecker.IsChecksumOK">
            does stored checksum corresponds to the username's one?
            checksum occupies 16 bits
        </member>
        <member name="P:JetBrains.Application.License.LicenseChecker.Version">
            gets OmniaMea version stored in the license code
            occupies 16 bits
        </member>
        <member name="P:JetBrains.Application.License.LicenseChecker.Type">
            gets type of the license stored in the license code
            occupies 8 bits
        </member>
        <member name="P:JetBrains.Application.License.LicenseChecker.GenerationDate">
            gets license generation date stored in the license code
            occupies 16 bits
        </member>
        <member name="P:JetBrains.Application.License.LicenseChecker.ExpirationDate">
            gets license expiration date stored in the license code
            occupies 16 bits
        </member>
        <member name="P:JetBrains.Application.License.LicenseChecker.SubscriptionEndDate">
            gets license subscription end date stored in the license code
            occupies 16 bits
        </member>
        <member name="M:JetBrains.Application.Progress.CommandLineProgressIndicator.Render">
            <summary>
              Renders current state of Console progress
            </summary>
        </member>
        <member name="T:JetBrains.Application.Progress.CommandLineTaskExecutor">
            <summary>
            Task executor for progress in console
            </summary>
        </member>
        <member name="T:JetBrains.Application.Progress.ITaskExecutor">
            <summary>
            Can execute a task.
            </summary>
            <remarks>
            This object is stateless, and thus not disposable.
            Execution of each of the tasks is an action in itself, with its own disposable scope.
            </remarks>
        </member>
        <member name="M:JetBrains.Application.Progress.ITaskExecutor.ExecuteTask(System.String,JetBrains.Application.Progress.TaskCancelable,System.Action{JetBrains.Application.Progress.IProgressIndicator})">
            <summary>
            Executes the task without exiting the method until the task is completed.
            </summary>
            <param name="name">
            <para>Task title, short form.</para>
            <para>This is used for the progress window title by the UI progress indicators.</para>
            <para>The long form of the task caption should go to the <see cref="P:JetBrains.Application.Progress.IProgressIndicator.TaskName"/> of the <paramref name="task"/>'s <see cref="T:JetBrains.Application.Progress.IProgressIndicator"/>.</para>
            <para>Prepended with the product name automatically. Might be empty, in which case the product name will be used.</para>
            </param>
            <param name="task">The task to execute.</param>
            <param name="cancelable">
            <para>Whether the task could be canceled by the user, if the task progress indication provided by <see cref="T:JetBrains.Application.Progress.ITaskExecutor"/> supports canceling.</para>
            <para>The <see cref="T:JetBrains.Application.Progress.ProcessCancelledException"/> pattern is supported, which means that an <see cref="T:JetBrains.Application.InterruptableActivityCookie"/> is plugged on the task thread to throw a <see cref="T:JetBrains.Application.Progress.ProcessCancelledException"/> when called for a check with a <see cref="P:JetBrains.Application.Progress.IProgressIndicatorModel.IsCanceled"/> <c>False</c>; such an exception is called by the task executor and converted into a <c>False</c> return value.</para>
            </param>
            <returns>Whether the task has completed execution (i.e. was not canceled). Note that even a <see cref="F:JetBrains.Application.Progress.TaskCancelable.No"/> task could be canceled by setting <see cref="P:JetBrains.Application.Progress.IProgressIndicatorModel.IsCanceled"/> to <c>False</c> or throwing a <see cref="T:JetBrains.Application.Progress.ProcessCancelledException"/> or letting some other exception out of the <paramref name="task">task function</paramref>.</returns>
            <remarks>If you would like to return any values from the <paramref name="task"/>, assign them to local variables within the closure.</remarks>
        </member>
        <member name="T:JetBrains.Application.Install.Guids.GuidEntry">
            <summary>
            An entry in the GUID Store.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Install.Guids.GuidEntry.Guid">
            <summary>
            GUID value of this entry.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Install.Guids.GuidEntry.IsDefineConstant">
            <summary>
            Whether this GUID is exposed as a #define constant to the involved programming languages (mainly, WiX).
            </summary>
            <remarks>WiX hits the command line length limit if we expose ALL of them, but it actually needs only a few.</remarks>
        </member>
        <member name="P:JetBrains.Application.Install.Guids.GuidEntry.Key">
            <summary>
            Key to this entry. Must be unique throughout the dictionary.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Install.Guids.GuidEntryKey">
            <summary>
            Key to the GUID in the GUID Store.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Install.Guids.GuidEntryKey.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            true if the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>; otherwise, false.
            </returns>
            <param name="obj">The <see cref="T:System.Object"/> to compare with the current <see cref="T:System.Object"/>. </param><exception cref="T:System.NullReferenceException">The <paramref name="obj"/> parameter is null.</exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.Application.Install.Guids.GuidEntryKey.GetHashCode">
            <summary>
            Serves as a hash function for a particular type. 
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object"/>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.Application.Install.Guids.GuidEntryKey.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.Application.Install.Guids.GuidEntryKey.Equals(JetBrains.Application.Install.Guids.GuidEntryKey)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            true if the current object is equal to the <paramref name="other"/> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="P:JetBrains.Application.Install.Guids.GuidEntryKey.Name">
            <summary>
            Gets the name of the key.
            This is the only key identity.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Install.Guids.GuidEntryKeyConverter">
            <summary>
            Knows how to switch between <see cref="T:JetBrains.Application.Install.Guids.GuidEntryKey"/>s and <see cref="T:System.String"/>s.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Install.Guids.GuidEntryKeyConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            Returns whether this converter can convert an object of the given type to the type of this converter, using the specified context.
            </summary>
            <returns>
            true if this converter can perform the conversion; otherwise, false.
            </returns>
            <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext"/> that provides a format context. </param><param name="sourceType">A <see cref="T:System.Type"/> that represents the type you want to convert from. </param>
        </member>
        <member name="M:JetBrains.Application.Install.Guids.GuidEntryKeyConverter.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            Returns whether this converter can convert the object to the specified type, using the specified context.
            </summary>
            <returns>
            true if this converter can perform the conversion; otherwise, false.
            </returns>
            <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext"/> that provides a format context. </param><param name="destinationType">A <see cref="T:System.Type"/> that represents the type you want to convert to. </param>
        </member>
        <member name="M:JetBrains.Application.Install.Guids.GuidEntryKeyConverter.ConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)">
            <summary>
            Converts the given object to the type of this converter, using the specified context and culture information.
            </summary>
            <returns>
            An <see cref="T:System.Object"/> that represents the converted value.
            </returns>
            <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext"/> that provides a format context. </param><param name="culture">The <see cref="T:System.Globalization.CultureInfo"/> to use as the current culture. </param><param name="value">The <see cref="T:System.Object"/> to convert. </param><exception cref="T:System.NotSupportedException">The conversion cannot be performed. </exception>
        </member>
        <member name="M:JetBrains.Application.Install.Guids.GuidEntryKeyConverter.ConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object,System.Type)">
            <summary>
            Converts the given value object to the specified type, using the specified context and culture information.
            </summary>
            <returns>
            An <see cref="T:System.Object"/> that represents the converted value.
            </returns>
            <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext"/> that provides a format context. </param><param name="culture">A <see cref="T:System.Globalization.CultureInfo"/>. If null is passed, the current culture is assumed. </param><param name="value">The <see cref="T:System.Object"/> to convert. </param><param name="destinationType">The <see cref="T:System.Type"/> to convert the <paramref name="value"/> parameter to. </param><exception cref="T:System.ArgumentNullException">The <paramref name="destinationType"/> parameter is null. </exception><exception cref="T:System.NotSupportedException">The conversion cannot be performed. </exception>
        </member>
        <member name="T:JetBrains.Application.Install.Guids.GuidEntryKeys">
            <summary>
            Well-known values for <see cref="T:JetBrains.Application.Install.Guids.GuidEntryKey"/>.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Install.Guids.GuidStore">
            <summary>
            Represents a store of GUIDs keyed by strings.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Install.Guids.GuidStore.NamespaceGuid">
            <summary>
            Namespace guid for <see cref="T:JetBrains.Util.Uuid"/>, see <see cref="P:JetBrains.Application.Install.Guids.GuidStore.AutoGuidCategory"/> for details.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Install.Guids.GuidStore.GetEntry(JetBrains.Application.Install.Guids.GuidEntryKey)">
            <summary>
            Tries to get an entry by its key.
            Throws if missing.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Install.Guids.GuidStore.TryGetEntry(JetBrains.Application.Install.Guids.GuidEntryKey)">
            <summary>
            Tries to get an entry by its key.
            <c>Null</c>s if missing.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Install.Guids.GuidStore.TryGetEntryOrPropose(JetBrains.Application.Install.Guids.GuidEntryKey)">
            <summary>
            Tries to get an entry by its key.
            If missing, adds a new entry to the <see cref="P:JetBrains.Application.Install.Guids.GuidStore.ProposedEntries"/> collection, and returns an empty (but still non-<c>Null</c>) GUID.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Install.Guids.GuidStore.AutoGuidCategory">
            <summary>
            If specified to a non-empty string, turns on fallback behavior for missing GUIDs: those are silently generated with <see cref="T:JetBrains.Util.Uuid"/>
            </summary>
        </member>
        <member name="P:JetBrains.Application.Install.Guids.GuidStore.Entries">
            <summary>
            A GUID value with its key.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Install.Guids.GuidStore.ProposedEntries">
            <summary>
            For GUID values whose keys were missing from the store, new entries are emitted into this collection, so that they could be moved into the main <see cref="P:JetBrains.Application.Install.Guids.GuidStore.Entries"/> collection by the operator.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Install.InstallationData.InstalledFolder">
            <summary>
            Folders that contain files that should be installed on the target system.
            In MSI, they create <c>Directory</c>s and <c>Component</c>s.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Install.InstallationData.InstalledFolder.AddFile(JetBrains.Util.Storage.SimpleFileItem,System.String)">
            <summary>
            Adds a new file of type <see cref="T:JetBrains.Application.Install.InstallationData.InstalledFile"/>.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Install.InstallationData.InstalledFolder.Id">
            <summary>
            An ID for this folder entry, from which the component, folder and file IDs in the installation database are derived.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Install.InstallationData.InstalledFolder.TargetDir">
            <summary>
            Relative path from the <see cref="P:JetBrains.Application.Install.InstallationData.InstalledFolder.TargetRoot">specified root</see> to the directory on the target system.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Install.InstallationData.InstalledFolder.TargetRoot">
            <summary>
            One of the root folders to locate the file on the target system.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Communication.WebProxySettings">
            <summary>
            Web proxy settings. Use <see cref="T:JetBrains.Application.Communication.WebProxySettingsReader"/> to create a .NET-API-compatible proxy object.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Install.InstallationData.InstallationMacroName">
            <summary>
            An enumeration of possible macro names, is not used directly in the XML files, but instead serves as a reference info or string constants from the code.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Install.InstallationData.InstallationMacroName.PackageCodeBase">
            <summary>
            Location of the Package assembly.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Install.InstallationData.InstallationMacroName.SystemDir">
            <summary>
            The System directory. Used to locate the mscoree.dll that is the COM Server for us.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Install.InstallationData.InstallationMacroName.ProductBinariesDir">
            <summary>
            The directory that contains the product binaries.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Install.InstallationData.InstallationMacroName.DateTime">
            <summary>
            Date and time at the moment the macro is resolved, in an arbitrary format. Use with care, because the date-time might resolve at the installation time on the user machine. The format is not defined. Fits for producing generation numbers.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Install.InstallationData.InstallationTargetDirRoot.InstallDir">
            <summary>
            Binaries installation directory on the remote system (the Bin folder).
            </summary>
        </member>
        <member name="F:JetBrains.Application.Install.InstallationData.InstallationTargetDirRoot.StartMenuPrograms">
            <summary>
            Binaries installation directory on the remote system (the Bin folder).
            </summary>
        </member>
        <member name="F:JetBrains.Application.Install.InstallationData.InstallationTargetDirRoot.DevEnvInstallDir">
            <summary>
            Visual Studio installation directory on the remote system, the one that contains the DevEnv.exe executable file (the Common7\IDE folder).
            </summary>
        </member>
        <member name="F:JetBrains.Application.Install.InstallationData.InstallationTargetDirRoot.DevEnvRootDir">
            <summary>
            Visual Studio root directory on the remote system, this is two levels above the Visual Studio InstallDir that contains the DevEnv.exe executable file (the Common7\IDE folder).
            </summary>
        </member>
        <member name="T:JetBrains.Application.Install.InstallationData.InstalledFile">
            <summary>
            A single satellite file in the installation.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Install.InstallationData.InstalledFile.#ctor(JetBrains.Util.Storage.SimpleFileItem,System.String)">
            <summary>
            An installation of a file whose source name (on the source file system) and target name (on the target file system) are different.
            </summary>
            <param name="source">The source file to be deployed on the target system.</param>
            <param name="sTargetName">Name for this file on the target file system. If omitted, the name of the source file will be used.</param>
        </member>
        <member name="F:JetBrains.Application.Install.InstallationData.InstalledFile.Metadata">
            <summary>
            Any additional metadata on the files.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Install.InstallationData.InstalledFile.SourceFile">
            <summary>
            The source file to be deployed on the target system.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Install.InstallationData.InstalledFile.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />.
            </summary>
            <returns>
            true if the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />; otherwise, false.
            </returns>
            <param name="obj">The <see cref="T:System.Object" /> to compare with the current <see cref="T:System.Object" />. </param>
            <exception cref="T:System.NullReferenceException">The <paramref name="obj" /> parameter is null.</exception>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.Application.Install.InstallationData.InstalledFile.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object" />.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.Application.Install.InstallationData.InstalledFile.System#IComparable{JetBrains#Application#Install#InstallationData#InstalledFile}#CompareTo(JetBrains.Application.Install.InstallationData.InstalledFile)">
            <summary>
            Compares the current object with another object of the same type.
            </summary>
            <returns>
            A 32-bit signed integer that indicates the relative order of the objects being compared. The return value has the following meanings: Value Meaning Less than zero This object is less than the <paramref name="other" /> parameter.Zero This object is equal to <paramref name="other" />. Greater than zero This object is greater than <paramref name="other" />.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:JetBrains.Application.Install.InstallationData.InstalledFile.Equals(JetBrains.Application.Install.InstallationData.InstalledFile)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="T:JetBrains.Application.Install.InstallationData.InstalledRegistryKey">
            <summary>
            Registry Keys to install and then REMOVE when uninstalling.
            A registry value does not require that you write its parent key here. Write a key if you'd like to make sure it will be removed by uninstall.
            For that matter, do not add foreign keys (eg Visual Studio ones) into which we're writing our values.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Install.InstallationData.InstalledRegistryItemBase">
            <summary>
            Base class for installer Registry keys and values.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Install.InstallationData.InstalledRegistryItemBase.#ctor(JetBrains.Application.Install.InstallationData.InstalledRegistryHive,JetBrains.Util.RelativePath)">
            <summary>
            Creates a <see cref="T:JetBrains.Application.Install.InstallationData.InstalledRegistryValue"/> object.
            </summary>
            <param name="hive">Hive.</param>
            <param name="key">Path to the key under the hive.</param>
        </member>
        <member name="M:JetBrains.Application.Install.InstallationData.InstalledRegistryItemBase.GetWindowsRegistryRootKey(JetBrains.Application.BuildScript.Install.IsolationOptions)">
            <summary>
            Gets the proper Windows Registry root key.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Install.InstallationData.InstalledRegistryItemBase.System#IComparable{JetBrains#Application#Install#InstallationData#InstalledRegistryItemBase}#CompareTo(JetBrains.Application.Install.InstallationData.InstalledRegistryItemBase)">
            <summary>
            Compares the current object with another object of the same type.
            </summary>
            <returns>
            A 32-bit signed integer that indicates the relative order of the objects being compared. The return value has the following meanings: Value Meaning Less than zero This object is less than the <paramref name="other" /> parameter.Zero This object is equal to <paramref name="other" />. Greater than zero This object is greater than <paramref name="other" />.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="P:JetBrains.Application.Install.InstallationData.InstalledRegistryItemBase.Hive">
            <summary>
            The Registry hive.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Install.InstallationData.InstalledRegistryItemBase.Key">
            <summary>
            Path to the key.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Install.InstallationData.InstalledRegistryKey.#ctor(JetBrains.Application.Install.InstallationData.InstalledRegistryHive,JetBrains.Util.RelativePath)">
            <summary>
            Creates a <see cref="T:JetBrains.Application.Install.InstallationData.InstalledRegistryValue"/> object.
            </summary>
            <param name="hive">Hive.</param>
            <param name="key">Path to the key under the hive.</param>
        </member>
        <member name="M:JetBrains.Application.Install.InstallationData.InstalledRegistryKey.CreateKey(JetBrains.Util.RelativePath)">
            <summary>
            Creates a new Registry Key under the current Registry key.
            </summary>
            <param name="relpath">Relative path of the nested Key.</param>
            <returns>The new registry value.</returns>
        </member>
        <member name="M:JetBrains.Application.Install.InstallationData.InstalledRegistryKey.CreateValue(System.String,System.Object)">
            <summary>
            Creates a new Registry Value that derives its Hive and Key path from the current Registry key.
            </summary>
            <param name="name">Name of the value.</param>
            <param name="value">Value of the value, must be either a <see cref="T:System.String"/> or an <see cref="T:System.Int32"/>.</param>
            <returns>The new registry value.</returns>
        </member>
        <member name="M:JetBrains.Application.Install.InstallationData.InstalledRegistryKey.ToString">
            <summary>
            Returns a <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </summary>
            <returns>
            A <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.Application.Install.InstallationData.InstalledRegistryKey.System#IComparable{JetBrains#Application#Install#InstallationData#InstalledRegistryKey}#CompareTo(JetBrains.Application.Install.InstallationData.InstalledRegistryKey)">
            <summary>
            Compares the current object with another object of the same type.
            </summary>
            <returns>
            A 32-bit signed integer that indicates the relative order of the objects being compared. The return value has the following meanings: Value Meaning Less than zero This object is less than the <paramref name="other" /> parameter.Zero This object is equal to <paramref name="other" />. Greater than zero This object is greater than <paramref name="other" />.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="F:JetBrains.Application.Install.InstallationData.InstalledRegistryHive.Hkcr">
            <summary>
            <c>HKEY_CLASSES_ROOT</c>.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Install.InstallationData.InstalledRegistryHive.Hklm">
            <summary>
            <c>HKEY_LOCAL_MACHINE</c>.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Install.InstallationData.InstalledRegistryHive.Hkcu">
            <summary>
            <c>HKEY_CURRENT_USER</c>.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Install.InstallationData.InstalledRegistryHive.Hkmu">
            <summary>
            <c>HKEY_LOCAL_MACHINE</c> or <c>HKEY_CURRENT_USER</c>, depending on whether the installation is per-machine or per-user.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Install.InstallationData.InstalledRegistryValue">
            <summary>
            Represents a value to be written to the Registry. On uninstallation, the value will be deleted. It is not necessary to have a key element for each value, unless you want it to be deleted upon uninstallation.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Install.InstallationData.InstalledRegistryValue.#ctor(JetBrains.Application.Install.InstallationData.InstalledRegistryHive,JetBrains.Util.RelativePath,System.String,System.Object)">
            <summary>
            Creates a <see cref="T:JetBrains.Application.Install.InstallationData.InstalledRegistryValue"/> object.
            </summary>
            <param name="hive">Hive.</param>
            <param name="key">Path to the key under the hive.</param>
            <param name="name">Name of the value.</param>
            <param name="value">Value of the value, must be either a <see cref="T:System.String"/> or an <see cref="T:System.Int32"/>.</param>
        </member>
        <member name="M:JetBrains.Application.Install.InstallationData.InstalledRegistryValue.ToString">
            <summary>
            Returns a <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </summary>
            <returns>
            A <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.Application.Install.InstallationData.InstalledRegistryValue.System#IComparable{JetBrains#Application#Install#InstallationData#InstalledRegistryValue}#CompareTo(JetBrains.Application.Install.InstallationData.InstalledRegistryValue)">
            <summary>
            Compares the current object with another object of the same type.
            </summary>
            <returns>
            A 32-bit signed integer that indicates the relative order of the objects being compared. The return value has the following meanings: Value Meaning Less than zero This object is less than the <paramref name="other" /> parameter.Zero This object is equal to <paramref name="other" />. Greater than zero This object is greater than <paramref name="other" />.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="P:JetBrains.Application.Install.InstallationData.InstalledRegistryValue.IsPermanent">
            <summary>
            Specifies that the value should be written on registration and left intact on unregistration.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Install.InstallationData.InstalledRegistryValue.Name">
            <summary>
            Name of the value under its key, or an empty string for the default value of the key.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Install.InstallationData.InstalledRegistryValue.Type">
            <summary>
            Type of the value, which determines the type of the Windows Registry value to be created. The Value must be formatted accordingly.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Install.InstallationData.InstalledRegistryValue.Value">
            <summary>
            Value for the value.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Install.InstallationData.InstallationSourceDirRoot.ProductBinariesDir">
            <summary>
              <para>A directory to which the product is built; contains all of the product binaries.</para>
              <para>Warning: when doing a local install, this is the same as the target InstallDir.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Install.InstallationData.InstallationSourceDirRoot.ReferencesDirectories">
            <summary>
              <para>References directories of the product and its submodules.</para>
              <para>The product references directory is “/Lib” under the product root, and module's references directory is “/Lib” under the module root.</para>
              <para>Deployment code of each module can only use references from its own module and any modules it depends on, transitively; plus, the product references directory.</para>
              <para>The file must be unique by its path relative to the references folder throughout the product. Any conflict results in a failure.</para>
            </summary>
        </member>
        <member name="T:JetBrains.Application.Install.InstallationData.InstalledRegistryValueType">
            <summary>
            Lists possible types for the Registry values.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Install.InstallationData.InstalledRegistryValueType.Dword">
            <summary>
            An integer DWORD value.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Install.InstallationData.InstalledRegistryValueType.String">
            <summary>
            A string value.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Install.InstallationData.InstalledRegistryValueType.Binary">
            <summary>
            Binary hex-encoded value
            </summary>
        </member>
        <member name="T:JetBrains.Application.Install.InstallationData.InstalledShellLink">
            <summary>
            Installs a shell link (an .lnk file shortcut).
            Its <see cref="P:JetBrains.Application.Install.InstallationData.InstalledFileItemBase.TargetName"/> and parent folder's <see cref="P:JetBrains.Application.Install.InstallationData.InstalledFolder.TargetRoot"/>/<see cref="P:JetBrains.Application.Install.InstallationData.InstalledFolder.TargetDir"/> point to the place where the shell link file will be created (.lnk), while the <see cref="F:JetBrains.Application.Install.InstallationData.InstalledShellLink.ShellLinkTargetRoot"/>/<see cref="F:JetBrains.Application.Install.InstallationData.InstalledShellLink.ShellLinkTargetDir"/>/<see cref="F:JetBrains.Application.Install.InstallationData.InstalledShellLink.ShellLinkTargetName"/> point to the target the shell link will be referencing.
            The source information on the parent <see cref="T:JetBrains.Application.Install.InstallationData.InstalledFolder"/> is not used for the shell link.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Install.InstallationData.InstalledShellLink.#ctor(System.String,JetBrains.Application.Install.InstallationData.InstallationTargetDirRoot,JetBrains.Util.RelativePath,System.String)">
            <summary>
             Sets the name of the file item on the target filesystem.
            </summary>
            <param name="sShellLinkFileTargetName">
              Name of the shell link file itself on the target filesystem.
            </param>
            <param name="shellLinkTargetRoot">
              Root folder on the target file system this Shell Link will be pointing to.
              Note that this is not the location of the shell link (.lnk) file itself.
            </param>
            <param name="shellLinkTargetDir">
              Relative path from the
            <see cref="F:JetBrains.Application.Install.InstallationData.InstalledShellLink.ShellLinkTargetRoot">root folder</see>
            on the target file system this Shell Link will be pointing to.
              Note that this is not the location of the shell link (.lnk) file itself.
            </param>
            <param name="shellLinkTargetName">
              Name of the file on the target file system this Shell Link will be pointing to.
              Note that this is not the location of the shell link (.lnk) file itself.
            </param>
        </member>
        <member name="F:JetBrains.Application.Install.InstallationData.InstalledShellLink.ShellLinkTargetDir">
            <summary>
            Relative path from the <see cref="F:JetBrains.Application.Install.InstallationData.InstalledShellLink.ShellLinkTargetRoot">root folder</see> on the target file system this Shell Link will be pointing to.
            Note that this is not the location of the shell link (.lnk) file itself.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Install.InstallationData.InstalledShellLink.ShellLinkTargetName">
            <summary>
            Name of the file on the target file system this Shell Link will be pointing to.
            Note that this is not the location of the shell link (.lnk) file itself.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Install.InstallationData.InstalledShellLink.ShellLinkTargetRoot">
            <summary>
            Root folder on the target file system this Shell Link will be pointing to.
            Note that this is not the location of the shell link (.lnk) file itself.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Install.InstallationData.InstalledShellLink.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />.
            </summary>
            <returns>
            true if the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />; otherwise, false.
            </returns>
            <param name="obj">The <see cref="T:System.Object" /> to compare with the current <see cref="T:System.Object" />. </param>
            <exception cref="T:System.NullReferenceException">The <paramref name="obj" /> parameter is null.</exception>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.Application.Install.InstallationData.InstalledShellLink.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object" />.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.Application.Install.InstallationData.InstalledShellLink.Equals(JetBrains.Application.Install.InstallationData.InstalledShellLink)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="T:JetBrains.Application.DataFlowEx">
            <summary>
            DataFlow extension methods that require a Shell.
            </summary>
        </member>
        <member name="M:JetBrains.Application.DataFlowEx.AssertUiThreadFiring``1(JetBrains.DataFlow.ISignal{``0},JetBrains.Threading.IThreading)">
            <summary>
            Prevents any property modifications if called on any thread but the primary one.
            </summary>
        </member>
        <member name="M:JetBrains.Application.DataFlowEx.AssertUiThreadModifications``1(JetBrains.DataFlow.ICollectionEvents{``0},JetBrains.Threading.IThreading)">
            <summary>
            Prevents any collection modifications if called on any thread but the primary one.
            </summary>
        </member>
        <member name="M:JetBrains.Application.DataFlowEx.AssertUiThreadModifications``1(JetBrains.DataFlow.IProperty{``0},JetBrains.Threading.IThreading)">
            <summary>
            Prevents any property modifications if called on any thread but the primary one.
            </summary>
        </member>
        <member name="M:JetBrains.Application.DataFlowEx.BeginSetGuarded``1(JetBrains.DataFlow.IProperty{``0},``0,JetBrains.Threading.IThreading,System.Object)">
            <summary>
            Assigns a new value to the property under a <see cref="T:JetBrains.Threading.ReentrancyGuard"/> on the primary thread, asynchronously.
            The <see cref="M:JetBrains.Threading.ReentrancyGuard.ExecuteOrQueue(System.String,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)"/> logic is not used, the asynchronous <see cref="M:JetBrains.Threading.ReentrancyGuard.Queue(System.String,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)"/> is always called instead, even if allowed to <see cref="M:JetBrains.Threading.ReentrancyGuard.Execute(System.String,System.Action)"/> in the moment. This guarantees that the property value assignments will always be serialized (eg a later <see cref="M:JetBrains.Threading.ReentrancyGuard.Execute(System.String,System.Action)"/> will not be overwritten when a previous <see cref="M:JetBrains.Threading.ReentrancyGuard.Queue(System.String,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)"/> gets to run).
            </summary>
        </member>
        <member name="M:JetBrains.Application.DataFlowEx.EnsureGuarded``1(JetBrains.DataFlow.Property{``0},JetBrains.Threading.IThreading)">
            <summary>
            Ensures that the property is modified (and the events are fired) in a <see cref="T:JetBrains.Threading.ReentrancyGuard">guarded context</see> only.
            </summary>
        </member>
        <member name="M:JetBrains.Application.DataFlowEx.EnsureGuarded``1(JetBrains.DataFlow.Property{``0},JetBrains.DataFlow.Lifetime,JetBrains.Threading.ReentrancyGuard)">
            <summary>
            Ensures that the property is modified (and the events are fired) in a <see cref="T:JetBrains.Threading.ReentrancyGuard">guarded context</see> only.
            </summary>
        </member>
        <member name="M:JetBrains.Application.DataFlowEx.EnsureGuarded``1(JetBrains.DataFlow.Property{``0},JetBrains.DataFlow.Lifetime,JetBrains.Threading.IThreading)">
            <summary>
            Ensures that the property is modified (and the events are fired) in a <see cref="T:JetBrains.Threading.ReentrancyGuard">guarded context</see> only.
            </summary>
        </member>
        <member name="M:JetBrains.Application.DataFlowEx.EnsureGuarded``1(JetBrains.DataFlow.Property{``0},JetBrains.Threading.ReentrancyGuard)">
            <summary>
            Ensures that the property is modified (and the events are fired) in a <see cref="T:JetBrains.Threading.ReentrancyGuard">guarded context</see> only.
            </summary>
        </member>
        <member name="M:JetBrains.Application.DataFlowEx.EnsureGuarded``1(JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.Lifetime,JetBrains.Threading.ReentrancyGuard)">
            <summary>
            Ensures that the property is modified (and the events are fired) in a <see cref="T:JetBrains.Threading.ReentrancyGuard">guarded context</see> only.
            </summary>
        </member>
        <member name="M:JetBrains.Application.DataFlowEx.EnsureGuarded``1(JetBrains.DataFlow.Signal{``0},JetBrains.Threading.IThreading)">
            <summary>
            Ensures that the signal is fired in a <see cref="T:JetBrains.Threading.ReentrancyGuard">guarded context</see> only.
            </summary>
        </member>
        <member name="M:JetBrains.Application.DataFlowEx.EnsureGuarded(JetBrains.DataFlow.SimpleSignal,JetBrains.Threading.IThreading)">
            <summary>
            Ensures that the signal is fired in a <see cref="T:JetBrains.Threading.ReentrancyGuard">guarded context</see> only.
            </summary>
        </member>
        <member name="M:JetBrains.Application.DataFlowEx.EnsureGuarded``1(JetBrains.DataFlow.CollectionEvents{``0},JetBrains.Threading.ReentrancyGuard)">
            <summary>
            Ensures that the collection is modified (and the events are fired) in a <see cref="T:JetBrains.Threading.ReentrancyGuard">guarded context</see> only.
            </summary>
        </member>
        <member name="M:JetBrains.Application.DataFlowEx.EnsureGuarded``2(JetBrains.DataFlow.DictionaryEvents{``0,``1},JetBrains.Threading.ReentrancyGuard)">
            <summary>
            Ensures that the collection is modified (and the events are fired) in a <see cref="T:JetBrains.Threading.ReentrancyGuard">guarded context</see> only.
            </summary>
        </member>
        <member name="M:JetBrains.Application.DataFlowEx.EnsurePrimaryThread``1(JetBrains.DataFlow.Property{``0},JetBrains.Threading.IThreading)">
            <summary>
            Ensures that the property is modified (and the events are fired) on the <see cref="P:JetBrains.Threading.IThreading.Dispatcher"/> only.
            </summary>
        </member>
        <member name="M:JetBrains.Application.DataFlowEx.FlowIntoGuarded_NoReplay``1(JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.IProperty{``0},JetBrains.Threading.ReentrancyGuard,System.Object,System.Boolean)">
            <summary>
            <para>Establishes a data flow between two properties. The assignment to the target property only happens in the <see cref="T:JetBrains.Threading.ReentrancyGuard">guarded context</see> on the <see cref="!:guard">specified thread</see>.</para>
            <para>It is guaranteed that the values are properly serialized, ie a delayed early value will not overwrite a later direct execution.</para>
            <para>Not suitable for high-throughput property changes, as it schedulles a new guarded execution for each change. Use <see cref="M:JetBrains.DataFlow.IPropertyEx.FlowIntoViaGroupingEvent``1(JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.IProperty{``0},JetBrains.Threading.GroupingEvent,System.Boolean,JetBrains.DataFlow.StandardPreconditions.ReadonlyToken)"/> in such cases.</para>
            </summary>
            <remarks>Supports the <see cref="P:JetBrains.Threading.JetDispatcher.IsAsyncBehaviorProhibited"/> mode.</remarks>
        </member>
        <member name="M:JetBrains.Application.DataFlowEx.FlowIntoGuarded_NoReplay``1(JetBrains.DataFlow.ISignal{``0},JetBrains.DataFlow.Lifetime,JetBrains.DataFlow.ISignal{``0},JetBrains.Threading.ReentrancyGuard,System.Object)">
            <summary>
            <para>Establishes a data flow between two signals. The firing of the target signal only happens in the <see cref="T:JetBrains.Threading.ReentrancyGuard">guarded context</see> on the <see cref="!:guard">specified thread</see>.</para>
            <para>Not suitable for high-throughput property changes, as it schedulles a new guarded execution for each change. Use a <see cref="T:JetBrains.Threading.GroupingEvent"/> in such scenarios.</para>
            </summary>
            <remarks>Supports the <see cref="P:JetBrains.Threading.JetDispatcher.IsAsyncBehaviorProhibited"/> mode.</remarks>
        </member>
        <member name="M:JetBrains.Application.DataFlowEx.FlowIntoGuarded_Replay``1(JetBrains.DataFlow.ICollectionEvents{``0},JetBrains.DataFlow.ICollectionEvents{``0},System.Object,System.Boolean,JetBrains.Util.Concurrency.UnguardedCallbackMerger,JetBrains.Threading.IThreading)">
            <summary>
            <para>Establishes a data flow between two collections. The changes to the target collection only happen in the <see cref="T:JetBrains.Threading.ReentrancyGuard">guarded context</see> on the <see cref="P:JetBrains.Threading.IThreading.Dispatcher">primary thread</see>.</para>
            <para>It is guaranteed that the values are properly serialized, ie a delayed early value will not overwrite a later direct execution.</para>
            <para>Returns a cookie for terminating the flow.</para>
            <para>Not suitable for high-throughput changes, as it schedulles a new guarded execution for each change.</para>
            <para>Uses the given callback merger for guarding the changes.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Application.DataFlowEx.FlowIntoGuarded_Replay``1(JetBrains.DataFlow.ICollectionEvents{``0},JetBrains.DataFlow.ICollectionEvents{``0},System.Object,System.Boolean,JetBrains.Threading.IThreading)">
            <summary>
            <para>Establishes a data flow between two collections. The changes to the target collection only happen in the <see cref="T:JetBrains.Threading.ReentrancyGuard">guarded context</see> on the <see cref="P:JetBrains.Threading.IThreading.Dispatcher">primary thread</see>.</para>
            <para>It is guaranteed that the values are properly serialized, ie a delayed early value will not overwrite a later direct execution.</para>
            <para>Returns a cookie for terminating the flow.</para>
            <para>Not suitable for high-throughput changes, as it schedulles a new guarded execution for each change.</para>
            </summary>
        </member>
        <member name="T:JetBrains.Application.DataFlowEx.FlowIntoCollectionAction`1">
            <summary>
            Helper for <see cref="!:DataFlowEx.FlowIntoGuarded_Replay&lt;TValue&gt;(JetBrains.DataFlow.ICollectionEvents&lt;TValue&gt;,JetBrains.DataFlow.ICollectionEvents&lt;TValue&gt;,object,bool)"/>.
            </summary>
        </member>
        <member name="T:JetBrains.Application.ExceptionReport.ExceptionReporting">
            <summary>
              Central class of the Exception Reporting subsystem.
            </summary>
        </member>
        <member name="F:JetBrains.Application.ExceptionReport.ExceptionReporting.myDispatcher">
            <summary>
              Identifies the owning thread.
            </summary>
        </member>
        <member name="M:JetBrains.Application.ExceptionReport.ExceptionReporting.#ctor(JetBrains.Application.ExceptionReport.IExceptionReportService,JetBrains.Application.Progress.ITaskExecutor,System.Collections.Generic.IEnumerable{JetBrains.Application.ExceptionReport.IExceptionReportDataProvider},JetBrains.Application.ExceptionReport.ExceptionManager,JetBrains.DataFlow.Lifetime,JetBrains.Application.Threading.Tasks.ITaskHost,JetBrains.Application.ExceptionReport.IExceptionReportStrategy)">
            <summary>
              Main constructor
            </summary>
            <param name="exceptionReportService"></param>
            <param name="taskexecutor"></param>
            <param name="exceptionReportDataProviders"></param>
            <param name="defaultStrategy"></param>
        </member>
        <member name="M:JetBrains.Application.ExceptionReport.ExceptionReporting.IsRelevantException(System.Exception)">
            <summary>
              Looks for our company/product names in the stack trace.
            </summary>
        </member>
        <member name="M:JetBrains.Application.ExceptionReport.ExceptionReporting.AttachToLogger">
            <summary>
              Starts listening logger events with this exception reporter. Previously listening exception reporters are stacked beneath and deactivated until this method is reverted by disposing of its return value.
            </summary>
        </member>
        <member name="P:JetBrains.Application.ExceptionReport.ExceptionReporting.TaskExecutor">
            <summary>
              Gets the task executor passed to nested <see cref="M:JetBrains.Application.ExceptionReport.ExceptionReporting.SetStrategy(JetBrains.Application.ExceptionReport.IExceptionReportStrategy)">strategies</see> to handle the exceptions.
            </summary>
        </member>
        <member name="F:JetBrains.Application.ExceptionReport.ExceptionReporting.ExceptionReporterAttachedToLogger.myReportersStack">
            <summary>
              Free-threaded, lock-free reads, copy-on-write. Stacks reporters, the last one is active.
            </summary>
        </member>
        <member name="M:JetBrains.Application.ExceptionReport.ExceptionReporting.ExceptionReporterAttachedToLogger.AddReporter(JetBrains.Application.ExceptionReport.ExceptionReporting)">
            <summary>
              Starts listening logger events with this exception reporter. Previously listening exception reporters are stacked beneath and deactivated until this method is reverted by disposing of its return value.
            </summary>
        </member>
        <member name="M:JetBrains.Application.ExceptionReport.ExceptionReporting.ExceptionReporterAttachedToLogger.OnException(System.Object,JetBrains.DataFlow.EventArgs{System.Exception})">
            <summary>
              Exception occured. Dispatch to reporter on top of stack. Might be empty, as we would never remove exception listener.
            </summary>
        </member>
        <member name="M:JetBrains.Application.FileSystemTracker.IFileSystemTracker.AdviseFileChanges(JetBrains.DataFlow.Lifetime,JetBrains.Util.FileSystemPath,System.Action{JetBrains.Application.changes.FileSystemChangeDelta})">
            <summary>
             Listens for changes in <paramref name="path" /> and executes <paramref name="onChangeAction" /> on it
             (on FileSystemTrackerCommit thread in async mode and on main thread in sync mode).
             Delta argument of <paramref name="onChangeAction"/> receives only changes related to <paramref name="path"/>
             </summary>
        </member>
        <member name="M:JetBrains.Application.FileSystemTracker.IFileSystemTracker.AdviseDirectoryChanges(JetBrains.DataFlow.Lifetime,JetBrains.Util.FileSystemPath,System.Boolean,System.Action{JetBrains.Application.changes.FileSystemChangeDelta})">
            <summary>
             Listens for changes in <paramref name="path" /> and executes <paramref name="onChangeAction" /> on it
             (on FileSystemTrackerCommit thread in async mode and on main thread in sync mode)
             Delta argument of <paramref name="onChangeAction"/> receives only changes related to <paramref name="path"/>
             </summary>
        </member>
        <member name="M:JetBrains.Application.FileSystemTracker.IFileSystemTracker.CommitChanges(JetBrains.Util.FileSystemPath[])">
            <summary>
             Queues immediate file system changes commit on separate thread (async mode) or fires Changed event on main thread (sync mode).
             </summary>
        </member>
        <member name="M:JetBrains.Application.FileSystemTracker.IFileSystemTracker.IgnoreChangesInFolder(JetBrains.DataFlow.Lifetime,JetBrains.Util.FileSystemPath)">
            <summary>
            Forbids changes in folder to be propagated to the system. 
            Necessary for caches folder that may be located inside project.
            </summary>
        </member>
        <member name="M:JetBrains.Application.FileSystemTracker.IFileSystemTracker.RegisterPrioritySink(JetBrains.DataFlow.Lifetime,System.Action{JetBrains.Application.changes.FileSystemChange},JetBrains.Application.FileSystemTracker.HandlingPriority)">
            <summary>
            Register the handler to get the update syncronously as fast as possible according to the priority.
            </summary>
        </member>
        <member name="P:JetBrains.Application.FileSystemTracker.IFileSystemTracker.AutoCommitEnabled">
            <summary>
            Whether file system changes are allowd to commit automaticall when detected.
            Obsolete. Use <see cref="M:JetBrains.Application.FileSystemTracker.IFileSystemTracker.SuppressAutoCommit(JetBrains.DataFlow.Lifetime,System.Object)"/> instead.
            </summary>
        </member>
        <member name="P:JetBrains.Application.FileSystemTracker.IFileSystemTracker.Changed">
            <summary>
             Fires on file system change from OS in separate guarded thread (async mode) or in main thread (sync mode).
             </summary>
        </member>
        <member name="T:JetBrains.Application.FileSystemTracker.FileSystemScanner">
            <summary>
            Helper class for scanning a directory for files matching a pattern
            </summary>
        </member>
        <member name="M:JetBrains.Application.FileSystemTracker.FileSystemTrackerImpl.RegisterPrioritySink(JetBrains.DataFlow.Lifetime,System.Action{JetBrains.Application.changes.FileSystemChange},JetBrains.Application.FileSystemTracker.HandlingPriority)">
            <summary>
            Register the handler to get the update syncronously as fast as possible according to the priority.
            </summary>
        </member>
        <member name="F:JetBrains.Application.FileSystemTracker.HandlingPriority.Existence">
            <summary>
            For file existence caches, i.e. AssemblyExistsService
            </summary>
        </member>
        <member name="F:JetBrains.Application.FileSystemTracker.HandlingPriority.Caching">
            <summary>
            For file information caches
            </summary>
        </member>
        <member name="M:JetBrains.Application.Install.BindingRedirectionsInstaller.CleanupOldEntries(JetBrains.Application.BuildScript.Application.HostInfo,System.Xml.XmlDocument)">
            <summary>
            Looks for previous patchings in the config, removes them.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Install.BindingRedirectionsInstaller.LoadConfigFile(JetBrains.Application.Install.InstallationData.InstallationSourceDirRoot,System.String,JetBrains.Metadata.Utils.AssemblyNameInfo)">
            <summary>
            Loads the source config file, or creates a new one.
            Ensures it contains enough top-level elements.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Install.BindingRedirectionsInstaller.WriteNewEntries(JetBrains.Application.Install.Installer,System.Xml.XmlDocument,JetBrains.Application.IApplicationHost)">
            <summary>
            Patches the config XML document with redirections.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Install.FileInstaller">
            <summary>
            Processes the <see cref="T:JetBrains.Application.Install.InstallFileAttribute"/> installations.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Install.InstallBindingRedirectionsConfigFileAttribute">
            <summary>
            Updates (compile-time) a config file to include the binding redirections for the current version of the product.
            A new file could also be created.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Install.InstallBindingRedirectionsConfigFileAttribute.#ctor(System.String)">
            <summary>
            Schedulles creation of a new assembly configuration file with binding redirections.
            </summary>
            <param name="sTargetConfigFileName">Local name of the resulting config file, including all of the extensions. This file will be installed into the <see cref="F:JetBrains.Application.Install.InstallationData.InstallationTargetDirRoot.InstallDir"/> folder.</param>
        </member>
        <member name="M:JetBrains.Application.Install.InstallBindingRedirectionsConfigFileAttribute.#ctor(System.String,JetBrains.Application.Install.InstallationData.InstallationSourceDirRoot,System.String)">
            <summary>
            Schedulles patching of an existing assembly configuration file with binding redirections.
            </summary>
            <param name="sTargetConfigFileName">Local name of the resulting config file, including all of the extensions. This file will be installed into the <see cref="F:JetBrains.Application.Install.InstallationData.InstallationTargetDirRoot.InstallDir"/> folder.</param>
            <param name="sourceroot">Root folder for looking up the original file. This could be <see cref="F:JetBrains.Application.Install.InstallationData.InstallationSourceDirRoot.ProductBinariesDir"/> (same as destination), but this is not a recommended scenario, as the file might be patched multiple times in this case. If <paramref name="sSourceRelativePath"/> is not specified, this value is ignored.</param>
            <param name="sSourceRelativePath">An optional path to the source file, relative to <paramref name="sourceroot"/>. If non-<c>Null</c>, then the binding redirections are added to the contents of that file. If <c>Null</c>, then a new file is created.</param>
        </member>
        <member name="T:JetBrains.Application.Install.InstallerVsVersionAffinity">
            <summary>
            Specifies how the installation action is interested in VisualStudio version.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Install.InstallerVsVersionAffinity.Neutral">
            <summary>
            The installation data is VS-version-neutral, and the installer will be called only if <see cref="P:JetBrains.Application.Install.Installer.VsVersion"/> is <c>Null</c> (to avoid duplicating the same data coming from runs for different versions).
            </summary>
        </member>
        <member name="F:JetBrains.Application.Install.InstallerVsVersionAffinity.Specific">
            <summary>
            The installation data depends on the VS version, and the installer will be called only when <see cref="P:JetBrains.Application.Install.Installer.VsVersion"/> is set to a specific value. Be sure not to generate the same data (target file names, MSI GUIDs) in this mode.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Install.InstallerVsVersionAffinity.CallAlways">
            <summary>
            The installer is always called, regardless of the <see cref="P:JetBrains.Application.Install.Installer.VsVersion"/> value.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Install.InstallFileAttribute">
            <summary>
            Adds one or more arbitrary files to the installation.
            The files may reside either in Lib or Bin folders.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Install.InstallFileAttribute.#ctor(System.String,JetBrains.Application.Install.InstallationData.InstallationTargetDirRoot,System.String,JetBrains.Application.Install.InstallationData.InstallationSourceDirRoot,System.String)">
            <summary>
            Adds one or more arbitrary files to the installation.
            </summary>
            <param name="targetroot">Base folder on the installation site.</param>
            <param name="sTargetRelativeDir">Relative path to the files from the base folder on the installation site.</param>
            <param name="sourceroot">Base folder on the compilation site.</param>
            <param name="sSourceRelativePath">Relative file path from the base folder on the compilation site. The file name might include wildcards for picking the files from the folder on the compilation site (source). More than one file is OK. File names will be the same on the installation site (target).</param>
            <param name="id">The unique identifier for this installation entry.</param>
        </member>
        <member name="P:JetBrains.Application.Install.InstallFileAttribute.Id">
            <summary>
            The unique identifier for this installation entry.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Install.InstallFileAttribute.SourceRelativePath">
            <summary>
            <para>Relative file path from the base folder on the compilation site. The file name might include wildcards for picking the files from the folder on the compilation site (source). More than one file is OK. File names will be the same on the installation site (target).</para>
            <para>Must not be a <see cref="T:JetBrains.Util.FileSystemPath"/> because of the wildcards.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Application.Install.InstallFileAttribute.SourceRoot">
            <summary>
            Base folder on the compilation site.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Install.InstallFileAttribute.TargetRelativeDir">
            <summary>
            Relative path from the base folder on the installation site.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Install.InstallFileAttribute.TargetRoot">
            <summary>
            Base folder on the installation site.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Progress.ProgressIndicatorMarshalled">
            <summary>
            As the original <see cref="T:JetBrains.Application.Progress.ProgressIndicator"/> is free-threaded, wraps it into a new <see cref="T:JetBrains.Application.Progress.IProgressIndicatorModel"/> that fires its changes on the primary thread only.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Progress.ProgressIndicatorMarshalled.Create(JetBrains.DataFlow.Lifetime,JetBrains.Application.Progress.IProgressIndicatorModel,JetBrains.Threading.IThreading)">
            <summary>
            As the original <see cref="T:JetBrains.Application.Progress.ProgressIndicator"/> is free-threaded, wraps it into a new <see cref="T:JetBrains.Application.Progress.IProgressIndicatorModel"/> that fires its changes on the primary thread only.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Progress.ProgressIndicatorMarshalled.CreateWithoutSafeThreadCheck(JetBrains.DataFlow.Lifetime,JetBrains.Application.Progress.IProgressIndicatorModel,JetBrains.Threading.IThreading)">
            <summary>
            As the original <see cref="T:JetBrains.Application.Progress.ProgressIndicator"/> is free-threaded, wraps it into a new <see cref="T:JetBrains.Application.Progress.IProgressIndicatorModel"/> that fires its changes on the primary thread only.
            Note: you should call the <see cref="M:JetBrains.Application.Progress.ProgressIndicatorMarshalled.Create(JetBrains.DataFlow.Lifetime,JetBrains.Application.Progress.IProgressIndicatorModel,JetBrains.Threading.IThreading)"/> version whenever possible.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Progress.SimpleTaskExecutor">
            <summary>
            A task executor that just calls the task method.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Progress.SimpleTaskExecutor.PushProgressCanceledInterruptableCookie(JetBrains.Application.Progress.IProgressIndicator)">
            <summary>
            Throws the <see cref="T:JetBrains.Application.Progress.ProcessCancelledException"/> on <see cref="P:JetBrains.Application.Progress.IProgressIndicatorModel.IsCanceled"/>.
            This is the simple non-UI implementation. UI-related implementations should use a similar method from the <c>UITaskExecutorRun</c>.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Progress.TaskCancelable">
            <summary>
            Whether an <see cref="T:JetBrains.Application.Progress.ITaskExecutor"/> task could be user-canceled.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Progress.TaskCancelable.No">
            <summary>
            <para>The task does not quite support canceling, so there's no use in displaying the "Cancel" button to the user.</para>
            <para>Note that the task might still be canceled and your <see cref="T:JetBrains.Application.Progress.ITaskExecutor"/> run might still return <c>False</c> in some cases, like throwing <see cref="T:JetBrains.Application.Progress.ProcessCancelledException"/> from the task implementation.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Progress.TaskCancelable.Yes">
            <summary>
            The task supports canceling, looks for <see cref="P:JetBrains.Application.Progress.IProgressIndicator.IsCanceled"/>, and user should be presented with the "Cancel" option in the progress UI.
            </summary>
        </member>
        <member name="T:JetBrains.Threading.Invocator">
            <summary>
              <para>A combined invocator that encapsulates both <see cref="P:JetBrains.Threading.Invocator.ReentrancyGuard"/> and <see cref="T:JetBrains.Threading.TimedActionsHost"/>.</para>
              <para>When disposed of, shuts down the <see cref="T:JetBrains.Threading.TimedActionsHost"/> and cancels all of its timed actions. It's OK for individual alarm consumers to dispose of them as well.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Threading.Invocator.myIsRecurringActivityAllowed">
            <summary>
            Gets or sets whether the application is currently active (and background activities are allowed).
            Used to suspend recurring actions execution when inactive.
            </summary>
        </member>
        <member name="P:JetBrains.Threading.Invocator.Dispatcher">
            <summary>
            Gets the dispatcher of the thread served by this Invocator.
            On a Shell's invocator, this would be the application's main thread.
            </summary>
        </member>
        <member name="P:JetBrains.Threading.Invocator.IsRecurringActivityAllowed">
            <summary>
            Gets or sets whether the application is currently active (and background activities are allowed).
            Used to suspend recurring actions execution when inactive.
            </summary>
        </member>
        <member name="P:JetBrains.Threading.Invocator.ReentrancyGuard">
            <summary>
            Gets the reentrancy guard that implements the non-timed actions of this Invocator.
            </summary>
        </member>
        <member name="P:JetBrains.Threading.Invocator.TimedActions">
            <summary>
            Provides access to the underlying <see cref="T:JetBrains.Threading.TimedActionsHost"/>, <see cref="P:JetBrains.Threading.Invocator.ReentrancyGuard"/>, <see cref="T:JetBrains.Threading.JetDispatcher"/>, and <see cref="T:System.Threading.Thread"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Threading.MultiCoreFiberStrategy.Disable">
            <summary>
            Do not use multi-core fibers
            </summary>
        </member>
        <member name="F:JetBrains.Application.Threading.MultiCoreFiberStrategy.Normal">
            <summary>
            Regular fiber usage. Number of fibers equals to processur number
            </summary>
        </member>
        <member name="F:JetBrains.Application.Threading.MultiCoreFiberStrategy.Agressive">
            <summary>
            Agressive fiber usage. Number od fibers is twice processor count
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.IMultiCoreFibers.EnqueueJob(System.Action)">
            <summary>
            Add job to the end fof the queue
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.IMultiCoreFibers.EnqueuePriorityJob(System.Action)">
            <summary>
            Add job to the beginning fof the queue
            </summary>
        </member>
        <member name="T:JetBrains.Application.Threading.MultiCoreFibersPool">
            <summary>
            Utility class to parallelize jobs on multiple processor cores
            </summary>
        </member>
        <member name="T:JetBrains.UI.Wpf.AutomationWrapper">
            <summary>
            Guises any object with an <see cref="T:JetBrains.UI.Wpf.IAutomation"/> interface suitable for our MVVM UI.
            </summary>
        </member>
        <member name="T:JetBrains.UI.Wpf.AAutomation">
            <summary>
            Base implementation of <see cref="T:JetBrains.UI.Wpf.IAutomation"/> which handles dummy-implementing the <see cref="T:System.ComponentModel.INotifyPropertyChanged"/> interface. You may use this as a base if you would not like to implement the interface member in your own code.
            </summary>
        </member>
        <member name="T:JetBrains.UI.Wpf.IAutomation">
            <summary>
            Base interface for Automation Objects (roughly corresponding to the ViewModel tier of MVVM) which would like to participate in autodiscovery of automation object views.
            </summary>
            <remarks>The <see cref="T:System.ComponentModel.INotifyPropertyChanged"/> is a dummy inclusion to avoid memory leaks on part of WPF because it would use <see cref="T:System.ComponentModel.TypeDescriptor"/>'s means for tracking possible value changes in absence of this interface, which causes the automation objects to be leaked over eternal references from static objects.</remarks>
        </member>
        <member name="T:JetBrains.UI.CrossFramework.EitherControl">
            <summary>
            Adapts the WinForms and Avalon controls to one another.
            </summary>
        </member>
        <member name="F:JetBrains.UI.CrossFramework.EitherControl.myControl">
            <summary>
            Stores the WinForms control, if explicitly inited.
            <see cref="F:JetBrains.UI.CrossFramework.EitherControl.myControl"/> and <see cref="F:JetBrains.UI.CrossFramework.EitherControl.myElement"/> are mutually exclusive.
            </summary>
        </member>
        <member name="F:JetBrains.UI.CrossFramework.EitherControl.myElement">
            <summary>
            Stores the Avalon element, if explicitly inited.
            <see cref="F:JetBrains.UI.CrossFramework.EitherControl.myControl"/> and <see cref="F:JetBrains.UI.CrossFramework.EitherControl.myElement"/> are mutually exclusive.
            </summary>
        </member>
        <member name="F:JetBrains.UI.CrossFramework.EitherControl.myElementHost">
            <summary>
            Stores the element host that adapts an Avalon control to the WinForms host, in case we were created with an Avalon control. Lazy-created.
            </summary>
        </member>
        <member name="F:JetBrains.UI.CrossFramework.EitherControl.myWindowsFormsHost">
            <summary>
            Stores the winforms host that adapts a WinForms control to the Avalon host, in case we were created with a WinForms control. Lazy-created.
            </summary>
        </member>
        <member name="F:JetBrains.UI.CrossFramework.EitherControl.myAutomation">
            <summary>
            The automation (viewmodel) object to which a data template should be applied to present it correctly.
            </summary>
        </member>
        <member name="M:JetBrains.UI.CrossFramework.EitherControl.#ctor(System.Windows.Forms.Control)">
            <summary>
            Initializes from a WinForms control.
            </summary>
        </member>
        <member name="M:JetBrains.UI.CrossFramework.EitherControl.#ctor(System.Windows.UIElement)">
            <summary>
            Initializes from an Avalon element.
            </summary>
        </member>
        <member name="M:JetBrains.UI.CrossFramework.EitherControl.#ctor(JetBrains.UI.Wpf.IAutomation)">
            <summary>
            Initializes from an Avalon element.
            </summary>
        </member>
        <member name="M:JetBrains.UI.CrossFramework.EitherControl.FromObject(System.Object)">
            <summary>
            Detects the control type, throws if neither. Calls the appropriate ctor.
            </summary>
        </member>
        <member name="M:JetBrains.UI.CrossFramework.EitherControl.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:JetBrains.UI.CrossFramework.EitherControl.Control">
            <summary>
            Gets the contained either-control as a Windows Forms control, creating a wrapper as needed.
            </summary>
        </member>
        <member name="P:JetBrains.UI.CrossFramework.EitherControl.Element">
            <summary>
            Gets the contained either-control as an Avalon UI element, creating a wrapper as needed.
            </summary>
        </member>
        <member name="P:JetBrains.UI.CrossFramework.EitherControl.IsAvalon">
            <summary>
            Gets whether this natively is an Avalon Element (or an Automation object), and using it as a WinForms Control will cause wrapping into a <see cref="T:System.Windows.Forms.Integration.ElementHost"/>.
            </summary>
        </member>
        <member name="P:JetBrains.UI.CrossFramework.EitherControl.IsDisposed">
            <summary>
            Gets whether the WinForms controls have been disposed of.
            </summary>
        </member>
        <member name="P:JetBrains.UI.CrossFramework.EitherControl.IsWinForms">
            <summary>
            Gets whether this natively is a WinForms Control, and using it as an Avalon Element will cause wrapping into a <see cref="T:System.Windows.Forms.Integration.WindowsFormsHost"/>.
            </summary>
        </member>
        <member name="P:JetBrains.UI.CrossFramework.EitherControl.IsAutomation">
            <summary>
            <para>Gets whether this control is given as an automation object and should be placed as a content into a content control to be presented correctly.</para>
            <para>Note that getting such a control as a WinForms control will probably not work correctly.</para>
            </summary>
        </member>
        <member name="P:JetBrains.UI.CrossFramework.EitherControl.IsWrapperCreated">
            <summary>
            Gets whether this control was ever requested in a non-native type, for which a wrapper has been created.
            If you'd like to be more specific about which kind of wrapper was created, it can be deduced from the <see cref="P:JetBrains.UI.CrossFramework.EitherControl.IsAvalon"/>/<see cref="P:JetBrains.UI.CrossFramework.EitherControl.IsWinForms"/> properties.
            </summary>
        </member>
        <member name="P:JetBrains.UI.CrossFramework.EitherControl.Automation">
            <summary>
            Returns the automation object if incapsulated by this control. It is never autogenerated.
            </summary>
        </member>
        <member name="T:JetBrains.UI.CrossFramework.EitherControl.DockedWindowsFormsHost">
            <summary>
            Represents workaround for such cases when Windows Forms control is docked or anchored to all availbale space.
            </summary>
        </member>
        <member name="T:JetBrains.Application.ExceptionReport.StoringExceptionReportService">
            <summary>
            Stores all of the reported exceptions (with either reporting method) without showing them to the user.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Defines">
             <summary>Pre-compile-time defined constants that emulate the C++ #define that has a value.</summary>
            <remarks>The set of #defines and their default values are given in an MSBuild file. The defauls could be overridden on the build server.</remarks>
        </member>
        <member name="F:JetBrains.Application.Defines.CompanyName">
             <summary>
              <para>
                <c>#define CompanyName JetBrains</c>
              </para>
              <para>Short company name.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.DateTimeForSubscriptionCheck">
             <summary>
              <para>
                <c>#define DateTimeForSubscriptionCheck 9999-12-31T23:59:59</c>
              </para>
              <para>The date when the recent product's 2-digit version is released. Used for subscription license check.</para>
              <para>If the date is not set, product build time is used.</para>
              <para>Do not change DateTimeForSubscriptionCheck here, edit the property on TeamCity instead</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.DateTimeProductBirth">
             <summary>
              <para>
                <c>#define DateTimeProductBirth 2003-01-01</c>
              </para>
              <para>The date when the product was founded. Used for the lower copyright year and so on.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.GuidProductUpgradeCodeInstallationCenter">
             <summary>
              <para>
                <c>#define GuidProductUpgradeCodeInstallationCenter {2D580069-BF69-4B47-BDEA-AF2986412F11}</c>
              </para>
              <para>Upgrade Code for the Installation Center family setups. In use starting with Platform-4.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.GuidVsPackageCoClass">
             <summary>
              <para>
                <c>#define GuidVsPackageCoClass {0C6E6407-13FC-4878-869A-C8B4016C57FE}</c>
              </para>
              <para>GUID of the VS Package COM object CoClass. Used on the autogenerated VS package class, and everywhere in the Registry. 
                In a VS-integrated product, must be overridden with a meaningful GUID.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.IsModeAnnotateCallStacks">
             <summary>
              <para>
                <c>#define IsModeAnnotateCallStacks False</c>
              </para>
              <para>Whether call stacks should be annotated when calling standard object methods. If there's a graph of standard objects identifyable only by names (eg IProperty, ICollection, ISignal, etc), a callstack of their interaction does not give out the names of the entities, unless this option is turned on. Has a perf impact.</para>
              <para>Default is ON. OFF for production builds.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.IsModeStatistics">
             <summary>
              <para>
                <c>#define IsModeStatistics False</c>
              </para>
              <para>Whether statistics should be collected by the Statistics class.</para>
              <para>Default is OFF.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.IsMsiIncludePdb">
             <summary>
              <para>
                <c>#define IsMsiIncludePdb True</c>
              </para>
              <para>Whether PDBs for product binaries should be packed into the Setup.</para>
              <para>If True, it is an error if a PDB is missing.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.IsMsiIncludeXmlDoc">
             <summary>
              <para>
                <c>#define IsMsiIncludeXmlDoc True</c>
              </para>
              <para>Whether XmlDocs for product binaries should be packed into the Setup.</para>
              <para>If True, it is an error if an XmlDoc file is missing.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.IsMsiProductBinariesStrongName">
             <summary>
              <para>
                <c>#define IsMsiProductBinariesStrongName True</c>
              </para>
              <para>Whether product binaries packed into MSI must have strong names. If True, Setup build will fail unless assemblies have strong names.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.IsReleaseLicenseAgreement">
             <summary>
              <para>
                <c>#define IsReleaseLicenseAgreement False</c>
              </para>
              <para>Whether the Release license RTF file should be embedded into the installer. Default is False, which takes the pre-release file.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.IsReSharper">
             <summary>
              <para>
                <c>#define IsReSharper True</c>
              </para>
              <para>Demo Define.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.IsReSharperMisbehavesEnabled">
             <summary>
              <para>
                <c>#define IsReSharperMisbehavesEnabled False</c>
              </para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.LicenseProductFamily">
             <summary>
              <para>
                <c>#define LicenseProductFamily 5931F436-2506-415E-A0A9-27F50D7F62BF</c>
              </para>
              <para>A license GUID identifying the product family of the license. Now as we're using version numbers in the license (unlike early versions of ReSharper), this should be persisted throughout the product lifetime.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.LicenseSeed">
             <summary>
              <para>
                <c>#define LicenseSeed RLA90VMnIfMXmT4jbUVOo64qnJqs6APs7SgNXcQVoeeLMp5BpmU4fdw+impX+Wpd</c>
              </para>
              <para>The license state written to the Registry by the installer, which provides for a free trial.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.LicenseSupportIdentifier">
             <summary>
              <para>
                <c>#define LicenseSupportIdentifier AD0738CD-C5DC-4650-A216-F4AF3E651058</c>
              </para>
              <para>An identifier for the evaluation license. Change it to reset the evaluation period.</para>
              <para>Note: do not change LicenseSupportIdentifier here, edit the property on TeamCity instead.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.ModeAnnotateCallStacksName">
             <summary>
              <para>
                <c>#define ModeAnnotateCallStacksName JET_MODE_ANNOTATE_CALL_STACKS</c>
              </para>
              <para>Name of the IsModeAssert-induced conditional compilation symbol.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.ModeAssertName">
             <summary>
              <para>
                <c>#define ModeAssertName JET_MODE_ASSERT</c>
              </para>
              <para>Name of the IsModeAssert-induced conditional compilation symbol.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.ModeStatisticsName">
             <summary>
              <para>
                <c>#define ModeStatisticsName JET_MODE_STATISTICS</c>
              </para>
              <para>Name of the IsModeAssert-induced conditional compilation symbol.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.MsiSupportedVsVersionsList">
             <summary>
              <para>
                <c>#define MsiSupportedVsVersionsList 8.0;9.0;10.0;11.0;12.0</c>
              </para>
              <para>The list of VS Versions the installer should be able to install. Note that adding a new version requires modification of WiX code (and maybe some of the C++ code too). Removing versions from this list should generally go smoothly. Must follow the C++ vs versions lsit format, which is semicolon-separater major.minor.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.NetfxRequiredVersionBuild">
             <summary>
              <para>
                <c>#define NetfxRequiredVersionBuild 0</c>
              </para>
              <para>The minimum .NET Framework version (Build component) required for installing &amp; runnning this product. The platform default is the minimum version required by the platform itself. Usually it's the same for the product.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.NetfxRequiredVersionMajor">
             <summary>
              <para>
                <c>#define NetfxRequiredVersionMajor 3</c>
              </para>
              <para>The minimum .NET Framework version (Major component) required for installing &amp; runnning this product. The platform default is the minimum version required by the platform itself. Usually it's the same for the product.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.NetfxRequiredVersionMinor">
             <summary>
              <para>
                <c>#define NetfxRequiredVersionMinor 5</c>
              </para>
              <para>The minimum .NET Framework version (Minor component) required for installing &amp; runnning this product. The platform default is the minimum version required by the platform itself. Usually it's the same for the product.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.NetfxRequiredVersionRevision">
             <summary>
              <para>
                <c>#define NetfxRequiredVersionRevision 0</c>
              </para>
              <para>The minimum .NET Framework version (Revision component) required for installing &amp; runnning this product. The platform default is the minimum version required by the platform itself. Usually it's the same for the product.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.NumLicenseAppVersion">
             <summary>
              <para>
                <c>#define NumLicenseAppVersion 8000</c>
              </para>
              <para>Application version for the licensing subsystem. Usually changes along with the ProductVersionMajor, but has its own numbering plan.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.NumLicenseFeedbackRequestDays">
             <summary>
              <para>
                <c>#define NumLicenseFeedbackRequestDays 10</c>
              </para>
              <para>Number of days after installation and before feedback of whatever kind is requested.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.NumLicenseFreeTrialDays">
             <summary>
              <para>
                <c>#define NumLicenseFreeTrialDays 30</c>
              </para>
              <para>Free trial days for a newly-installed product.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.NumLicenseLeftDaysNotification">
             <summary>
              <para>
                <c>#define NumLicenseLeftDaysNotification 3</c>
              </para>
              <para>Number of days before license expires to notify the user of that.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.NumTimeBombDays">
             <summary>
              <para>
                <c>#define NumTimeBombDays 0</c>
              </para>
              <para>The product will be inoperational when this time since build date expires. 0 means never expire (release mode), which is the default.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.NUnitCpu">
             <summary>
              <para>
                <c>#define NUnitCpu x86</c>
              </para>
              <para>CPU platform of the NUnit runner process. Tests will be executed in this environment. Values: x86, x64, ANY.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.NUnitInParallel">
             <summary>
              <para>
                <c>#define NUnitInParallel True</c>
              </para>
              <para>Allows running NUnit in parallel (one process per assembly, max CPU-count processes total).</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.NUnitRuntime">
             <summary>
              <para>
                <c>#define NUnitRuntime v4.0</c>
              </para>
              <para>CLR version of the NUnit runner process. Tests will be executed in this environment. Values: v1.1, v2.0, v4.0, ANY.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.NUnitVersion">
             <summary>
              <para>
                <c>#define NUnitVersion NUnit-2.6.1</c>
              </para>
              <para>Version of the NUnit runner used on TeamCity server. The special ReSharper make does better formatting of exception stack traces (without reversing the stacks).</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.PragmaOnce_Platform_Defines_Targets">
             <summary>
              <para>
                <c>#define PragmaOnce_Platform_Defines_Targets True</c>
              </para>
              <para>Pragma Once.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.PragmaOnce_Product_Defines_Targets">
             <summary>
              <para>
                <c>#define PragmaOnce_Product_Defines_Targets True</c>
              </para>
              <para>Pragma Once.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.ProductDisplayName">
             <summary>
              <para>
                <c>#define ProductDisplayName ReSharper</c>
              </para>
              <para>The user-friendly name of the product in the short form (no company, no version). The default choice if you want to mention the product name in UI. See Remarks on IApplicationDescriptor::ProductDisplayNameName for details.</para>
              <para>You MUST NOT use this define where an Application Descriptor is available (this includes any time when Shell is running). This is ONLY for out-of-shell and build-time uses.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.ProductFullName">
             <summary>
              <para>
                <c>#define ProductFullName ReSharper 9.0 EAP</c>
              </para>
              <para>The expanded marketing product name, which is typically the &lt;see cref="ProductDisplayName"/&gt; plus the marketing version number, beta/EAP/RC designation, etc. See Remarks on IApplicationDescriptor::ProductDisplayNameName for details.</para>
              <para>You MUST NOT use this define where an Application Descriptor is available (this includes any time when Shell is running). This is ONLY for out-of-shell and build-time uses.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.ProductName">
             <summary>
              <para>
                <c>#define ProductName ReSharper</c>
              </para>
              <para>The bare technical product name in the shortest form (no company, no version, no spaces, identifier-syntax-compatible). See Remarks on IApplicationDescriptor::ProductDisplayNameName for details.</para>
              <para>If there're multiple products built on these sources, their least common generic name.</para>
              <para>You MUST NOT use this define where an Application Descriptor or IProductNameAndVersion is available (this includes any time when Shell is running). This is ONLY for out-of-shell and build-time uses.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.ProductStandaloneApplicationCaps">
             <summary>
              <para>
                <c>#define ProductStandaloneApplicationCaps None</c>
              </para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.ProductUpgradeCodeLegacyVS0800">
             <summary>
              <para>
                <c>#define ProductUpgradeCodeLegacyVS0800 {F790F14F-E662-4D25-89A0-9CC8677DE27A}</c>
              </para>
              <para>Main historical Upgrade Code for the R# product line. In 3.0 era, was used by the VS80 branch only. Not used by the new products.</para>
              <para>Used by Installation Centers for detecting pre-Platform-4 products in VS80.</para>
              <para>Empty by default. Not a GUID type just to allow empty string values.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.ProductUpgradeCodeLegacyVS0900">
             <summary>
              <para>
                <c>#define ProductUpgradeCodeLegacyVS0900 {5595D9CA-0517-4A8E-9129-F973460986E0}</c>
              </para>
              <para>Side Upgrade Code for the R# products. Was in use in the 3.0 era only, was used by the VS90 branch that had an upgrade line separate from that of VS80. Should be checked for when detecting older versions.</para>
              <para>Used by Installation Centers for detecting pre-Platform-4 products in VS90.</para>
              <para>Empty by default. Not a GUID type just to allow empty string values.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.ProductUpgradeCodeLegacyVS1000">
             <summary>
              <para>
                <c>#define ProductUpgradeCodeLegacyVS1000 </c>
              </para>
              <para>Same as other ProductUpgradeCodeLegacy, but empty in all the products. Introduced for safe looping thru VS versions. Not a GUID type just to allow empty string values.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.ProductVisualStudioIntegrationCaps">
             <summary>
              <para>
                <c>#define ProductVisualStudioIntegrationCaps Required</c>
              </para>
              <para>A required parameter of a platform-based MSI Setup which defines the VS integration capabilities of the product.</para>
              <para>Defines whether the installer should suggest integrating the product into Visual Studio. Possible values are:</para>
              <para>“None” — the product has no VS integration capabilities. Example: early versions of some products like DotTrace Memory, Peek.</para>
              <para>“Optional” — the product can be used without VS, but also provides VS integration. Example: DotTrace Performance.</para>
              <para>“Required” — the product only exists as a VS extension and usually should not be installed without VS integration. Example: ReSharper.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.UriBuy">
             <summary>
              <para>
                <c>#define UriBuy http://www.jetbrains.com/resharper/buy/index.html</c>
              </para>
              <para>URI of the Webpage where the user could buy the product.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.UriCompany">
             <summary>
              <para>
                <c>#define UriCompany http://www.jetbrains.com</c>
              </para>
              <para>URI of the company Website.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.UriEvaluate">
             <summary>
              <para>
                <c>#define UriEvaluate http://www.jetbrains.com/resharper/download/index.html</c>
              </para>
              <para>URI of the Webpage where the user can download an evaluation version of the product.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.UriProduct">
             <summary>
              <para>
                <c>#define UriProduct http://www.jetbrains.com/resharper/</c>
              </para>
              <para>Main product webpage URI. Also used for ARPURLINFOABOUT in the installer.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.UriProductCommunityNewsgroups">
             <summary>
              <para>
                <c>#define UriProductCommunityNewsgroups news://news.jetbrains.com/jetbrains.resharper.community</c>
              </para>
              <para>URI to the product community (support/discussion) newsgroups.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.UriProductHelp">
             <summary>
              <para>
                <c>#define UriProductHelp http://www.jetbrains.com/resharper/documentation/index.html</c>
              </para>
              <para>URI to Product Help. Used for Online F1 in the product and ARPHELPLINK in the installer.</para>
              <para>NOTE: UriProductHelp points to the SINGLE page for all R# versions starting with v4.0. See ReSharperWebHelp class on how the complete URI is producted out of this base: exact product version is appended, plus the options keyword whose help page should be opened. Based on the version number, user is redirected to help for his exact version. Thus, you cannot easily change this URI in a newer version without affecting already-released products.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.UriProductSupportEmail">
             <summary>
              <para>
                <c>#define UriProductSupportEmail mailto:support@jetbrains.com</c>
              </para>
              <para>Email to request for product support. The default is suitable for all JetBrains products.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.UriProductUninstallFeedback">
             <summary>
              <para>
                <c>#define UriProductUninstallFeedback http://www.jetbrains.com/resharper/uninstall/resharper.jsp</c>
              </para>
              <para>An URI to submit the Uninstall Feedback from the installer.</para>
              <para>This URI has query string parameters that are defined in the installer itself (one of its CAs).</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.UriProductUpdateInfoForInstaller">
             <summary>
              <para>
                <c>#define UriProductUpdateInfoForInstaller http://blogs.jetbrains.com/dotnet/category/news/</c>
              </para>
              <para>Installer's ARPURLUPDATEINFO. Default is applicable for dotnet products.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.UriUpdatesFilterXslt">
             <summary>
              <para>
                <c>#define UriUpdatesFilterXslt http://www.jetbrains.com/resharper/updates/online.Updates.xslt</c>
              </para>
              <para>URI to get the XSLT with updates info from (see UpdatesManager).</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.VsPackageLoadKey">
             <summary>
              <para>
                <c>#define VsPackageLoadKey JetBrains s.r.o.;ReSharper;9.0;standard;AHR2RRIDC0RRA9ZMJMEQPPR8ICZZH1D3ZREDEZRRRJR0AARDEPEIC0IAZHQ2KAR8D1QKH3AKIZJCJKHEITIEIJRHHTZEDCIJJ1P8CPAEE2A2JKH9MHMPZPJ9HKHII3HM</c>
              </para>
              <para>VS PLK, as received from the Microsoft website. See “Changing Product Name and Version SOP” on how to do that. 
            		Format: “CompanyName;ProductName;ProductVersion2;VsMinEdition;PLK”. See VsPackageClassEmitter::PackageInfo for format details.</para>
            </summary>
        </member>
        <member name="T:JetBrains.Application.Defines.Const">
             <summary>Literal versions of the properties.</summary>
            <remarks>Use these const fields only where use of a constant is mandatory. Otherwise use the static readonly field in the outer class, which stands better in the compiled assembly.</remarks>
        </member>
        <member name="F:JetBrains.Application.Defines.Const.CompanyName">
             <summary>
              <para>
                <c>#define CompanyName JetBrains</c>
              </para>
              <para>Short company name.</para>
              <para>Use this const field only where use of a constant is mandatory. Otherwise use the static readonly field in the outer class, which stands better in the compiled assembly, and has a more concrete type for non-primitive-type properties.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.Const.DateTimeForSubscriptionCheck">
             <summary>
              <para>
                <c>#define DateTimeForSubscriptionCheck 9999-12-31T23:59:59</c>
              </para>
              <para>The date when the recent product's 2-digit version is released. Used for subscription license check.</para>
              <para>If the date is not set, product build time is used.</para>
              <para>Do not change DateTimeForSubscriptionCheck here, edit the property on TeamCity instead</para>
              <para>Use this const field only where use of a constant is mandatory. Otherwise use the static readonly field in the outer class, which stands better in the compiled assembly, and has a more concrete type for non-primitive-type properties.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.Const.DateTimeProductBirth">
             <summary>
              <para>
                <c>#define DateTimeProductBirth 2003-01-01</c>
              </para>
              <para>The date when the product was founded. Used for the lower copyright year and so on.</para>
              <para>Use this const field only where use of a constant is mandatory. Otherwise use the static readonly field in the outer class, which stands better in the compiled assembly, and has a more concrete type for non-primitive-type properties.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.Const.GuidProductUpgradeCodeInstallationCenter">
             <summary>
              <para>
                <c>#define GuidProductUpgradeCodeInstallationCenter {2D580069-BF69-4B47-BDEA-AF2986412F11}</c>
              </para>
              <para>Upgrade Code for the Installation Center family setups. In use starting with Platform-4.</para>
              <para>Use this const field only where use of a constant is mandatory. Otherwise use the static readonly field in the outer class, which stands better in the compiled assembly, and has a more concrete type for non-primitive-type properties.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.Const.GuidVsDynamicCommandSet">
             <summary>
              <para>
                <c>#define GuidVsDynamicCommandSet {E272D1BE-8216-4919-AFA3-EEB57FAB3537}</c>
              </para>
              <para>Command set GUID for the dynamic commands to be registered by the product at runtime. 
                In a VS-integrated product, must be overridden with a meaningful GUID.</para>
              <para>Use this const field only where use of a constant is mandatory. Otherwise use the static readonly field in the outer class, which stands better in the compiled assembly, and has a more concrete type for non-primitive-type properties.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.Const.GuidVsGroupsCommandSet">
             <summary>
              <para>
                <c>#define GuidVsGroupsCommandSet {9142D617-6500-478F-9DE9-3185145372D0}</c>
              </para>
              <para>Command set GUID for the VS Command Groups that are generated to accomodate commands (created from IExecutableActions) in menus (created from IActionGroups).
                The IDs are entirely autogenerated by VSCT/CTO tool. 
                In a VS-integrated product, must be overridden with a meaningful GUID.</para>
              <para>Use this const field only where use of a constant is mandatory. Otherwise use the static readonly field in the outer class, which stands better in the compiled assembly, and has a more concrete type for non-primitive-type properties.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.Const.GuidVsPackageCoClass">
             <summary>
              <para>
                <c>#define GuidVsPackageCoClass {0C6E6407-13FC-4878-869A-C8B4016C57FE}</c>
              </para>
              <para>GUID of the VS Package COM object CoClass. Used on the autogenerated VS package class, and everywhere in the Registry. 
                In a VS-integrated product, must be overridden with a meaningful GUID.</para>
              <para>Use this const field only where use of a constant is mandatory. Otherwise use the static readonly field in the outer class, which stands better in the compiled assembly, and has a more concrete type for non-primitive-type properties.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.Const.IsModeAnnotateCallStacks">
             <summary>
              <para>
                <c>#define IsModeAnnotateCallStacks False</c>
              </para>
              <para>Whether call stacks should be annotated when calling standard object methods. If there's a graph of standard objects identifyable only by names (eg IProperty, ICollection, ISignal, etc), a callstack of their interaction does not give out the names of the entities, unless this option is turned on. Has a perf impact.</para>
              <para>Default is ON. OFF for production builds.</para>
              <para>Use this const field only where use of a constant is mandatory. Otherwise use the static readonly field in the outer class, which stands better in the compiled assembly, and has a more concrete type for non-primitive-type properties.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.Const.IsModeStatistics">
             <summary>
              <para>
                <c>#define IsModeStatistics False</c>
              </para>
              <para>Whether statistics should be collected by the Statistics class.</para>
              <para>Default is OFF.</para>
              <para>Use this const field only where use of a constant is mandatory. Otherwise use the static readonly field in the outer class, which stands better in the compiled assembly, and has a more concrete type for non-primitive-type properties.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.Const.IsMsiIncludePdb">
             <summary>
              <para>
                <c>#define IsMsiIncludePdb True</c>
              </para>
              <para>Whether PDBs for product binaries should be packed into the Setup.</para>
              <para>If True, it is an error if a PDB is missing.</para>
              <para>Use this const field only where use of a constant is mandatory. Otherwise use the static readonly field in the outer class, which stands better in the compiled assembly, and has a more concrete type for non-primitive-type properties.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.Const.IsMsiIncludeXmlDoc">
             <summary>
              <para>
                <c>#define IsMsiIncludeXmlDoc True</c>
              </para>
              <para>Whether XmlDocs for product binaries should be packed into the Setup.</para>
              <para>If True, it is an error if an XmlDoc file is missing.</para>
              <para>Use this const field only where use of a constant is mandatory. Otherwise use the static readonly field in the outer class, which stands better in the compiled assembly, and has a more concrete type for non-primitive-type properties.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.Const.IsMsiProductBinariesStrongName">
             <summary>
              <para>
                <c>#define IsMsiProductBinariesStrongName True</c>
              </para>
              <para>Whether product binaries packed into MSI must have strong names. If True, Setup build will fail unless assemblies have strong names.</para>
              <para>Use this const field only where use of a constant is mandatory. Otherwise use the static readonly field in the outer class, which stands better in the compiled assembly, and has a more concrete type for non-primitive-type properties.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.Const.IsReleaseLicenseAgreement">
             <summary>
              <para>
                <c>#define IsReleaseLicenseAgreement False</c>
              </para>
              <para>Whether the Release license RTF file should be embedded into the installer. Default is False, which takes the pre-release file.</para>
              <para>Use this const field only where use of a constant is mandatory. Otherwise use the static readonly field in the outer class, which stands better in the compiled assembly, and has a more concrete type for non-primitive-type properties.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.Const.IsReSharper">
             <summary>
              <para>
                <c>#define IsReSharper True</c>
              </para>
              <para>Demo Define.</para>
              <para>Use this const field only where use of a constant is mandatory. Otherwise use the static readonly field in the outer class, which stands better in the compiled assembly, and has a more concrete type for non-primitive-type properties.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.Const.IsReSharperMisbehavesEnabled">
             <summary>
              <para>
                <c>#define IsReSharperMisbehavesEnabled False</c>
              </para>
              <para>Use this const field only where use of a constant is mandatory. Otherwise use the static readonly field in the outer class, which stands better in the compiled assembly, and has a more concrete type for non-primitive-type properties.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.Const.LicenseProductFamily">
             <summary>
              <para>
                <c>#define LicenseProductFamily 5931F436-2506-415E-A0A9-27F50D7F62BF</c>
              </para>
              <para>A license GUID identifying the product family of the license. Now as we're using version numbers in the license (unlike early versions of ReSharper), this should be persisted throughout the product lifetime.</para>
              <para>Use this const field only where use of a constant is mandatory. Otherwise use the static readonly field in the outer class, which stands better in the compiled assembly, and has a more concrete type for non-primitive-type properties.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.Const.LicenseSeed">
             <summary>
              <para>
                <c>#define LicenseSeed RLA90VMnIfMXmT4jbUVOo64qnJqs6APs7SgNXcQVoeeLMp5BpmU4fdw+impX+Wpd</c>
              </para>
              <para>The license state written to the Registry by the installer, which provides for a free trial.</para>
              <para>Use this const field only where use of a constant is mandatory. Otherwise use the static readonly field in the outer class, which stands better in the compiled assembly, and has a more concrete type for non-primitive-type properties.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.Const.LicenseSupportIdentifier">
             <summary>
              <para>
                <c>#define LicenseSupportIdentifier AD0738CD-C5DC-4650-A216-F4AF3E651058</c>
              </para>
              <para>An identifier for the evaluation license. Change it to reset the evaluation period.</para>
              <para>Note: do not change LicenseSupportIdentifier here, edit the property on TeamCity instead.</para>
              <para>Use this const field only where use of a constant is mandatory. Otherwise use the static readonly field in the outer class, which stands better in the compiled assembly, and has a more concrete type for non-primitive-type properties.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.Const.ModeAnnotateCallStacksName">
             <summary>
              <para>
                <c>#define ModeAnnotateCallStacksName JET_MODE_ANNOTATE_CALL_STACKS</c>
              </para>
              <para>Name of the IsModeAssert-induced conditional compilation symbol.</para>
              <para>Use this const field only where use of a constant is mandatory. Otherwise use the static readonly field in the outer class, which stands better in the compiled assembly, and has a more concrete type for non-primitive-type properties.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.Const.ModeAssertName">
             <summary>
              <para>
                <c>#define ModeAssertName JET_MODE_ASSERT</c>
              </para>
              <para>Name of the IsModeAssert-induced conditional compilation symbol.</para>
              <para>Use this const field only where use of a constant is mandatory. Otherwise use the static readonly field in the outer class, which stands better in the compiled assembly, and has a more concrete type for non-primitive-type properties.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.Const.ModeStatisticsName">
             <summary>
              <para>
                <c>#define ModeStatisticsName JET_MODE_STATISTICS</c>
              </para>
              <para>Name of the IsModeAssert-induced conditional compilation symbol.</para>
              <para>Use this const field only where use of a constant is mandatory. Otherwise use the static readonly field in the outer class, which stands better in the compiled assembly, and has a more concrete type for non-primitive-type properties.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.Const.MsiSupportedVsVersionsList">
             <summary>
              <para>
                <c>#define MsiSupportedVsVersionsList 8.0;9.0;10.0;11.0;12.0</c>
              </para>
              <para>The list of VS Versions the installer should be able to install. Note that adding a new version requires modification of WiX code (and maybe some of the C++ code too). Removing versions from this list should generally go smoothly. Must follow the C++ vs versions lsit format, which is semicolon-separater major.minor.</para>
              <para>Use this const field only where use of a constant is mandatory. Otherwise use the static readonly field in the outer class, which stands better in the compiled assembly, and has a more concrete type for non-primitive-type properties.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.Const.NetfxRequiredVersionBuild">
             <summary>
              <para>
                <c>#define NetfxRequiredVersionBuild 0</c>
              </para>
              <para>The minimum .NET Framework version (Build component) required for installing &amp; runnning this product. The platform default is the minimum version required by the platform itself. Usually it's the same for the product.</para>
              <para>Use this const field only where use of a constant is mandatory. Otherwise use the static readonly field in the outer class, which stands better in the compiled assembly, and has a more concrete type for non-primitive-type properties.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.Const.NetfxRequiredVersionMajor">
             <summary>
              <para>
                <c>#define NetfxRequiredVersionMajor 3</c>
              </para>
              <para>The minimum .NET Framework version (Major component) required for installing &amp; runnning this product. The platform default is the minimum version required by the platform itself. Usually it's the same for the product.</para>
              <para>Use this const field only where use of a constant is mandatory. Otherwise use the static readonly field in the outer class, which stands better in the compiled assembly, and has a more concrete type for non-primitive-type properties.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.Const.NetfxRequiredVersionMinor">
             <summary>
              <para>
                <c>#define NetfxRequiredVersionMinor 5</c>
              </para>
              <para>The minimum .NET Framework version (Minor component) required for installing &amp; runnning this product. The platform default is the minimum version required by the platform itself. Usually it's the same for the product.</para>
              <para>Use this const field only where use of a constant is mandatory. Otherwise use the static readonly field in the outer class, which stands better in the compiled assembly, and has a more concrete type for non-primitive-type properties.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.Const.NetfxRequiredVersionRevision">
             <summary>
              <para>
                <c>#define NetfxRequiredVersionRevision 0</c>
              </para>
              <para>The minimum .NET Framework version (Revision component) required for installing &amp; runnning this product. The platform default is the minimum version required by the platform itself. Usually it's the same for the product.</para>
              <para>Use this const field only where use of a constant is mandatory. Otherwise use the static readonly field in the outer class, which stands better in the compiled assembly, and has a more concrete type for non-primitive-type properties.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.Const.NumLicenseAppVersion">
             <summary>
              <para>
                <c>#define NumLicenseAppVersion 8000</c>
              </para>
              <para>Application version for the licensing subsystem. Usually changes along with the ProductVersionMajor, but has its own numbering plan.</para>
              <para>Use this const field only where use of a constant is mandatory. Otherwise use the static readonly field in the outer class, which stands better in the compiled assembly, and has a more concrete type for non-primitive-type properties.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.Const.NumLicenseFeedbackRequestDays">
             <summary>
              <para>
                <c>#define NumLicenseFeedbackRequestDays 10</c>
              </para>
              <para>Number of days after installation and before feedback of whatever kind is requested.</para>
              <para>Use this const field only where use of a constant is mandatory. Otherwise use the static readonly field in the outer class, which stands better in the compiled assembly, and has a more concrete type for non-primitive-type properties.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.Const.NumLicenseFreeTrialDays">
             <summary>
              <para>
                <c>#define NumLicenseFreeTrialDays 30</c>
              </para>
              <para>Free trial days for a newly-installed product.</para>
              <para>Use this const field only where use of a constant is mandatory. Otherwise use the static readonly field in the outer class, which stands better in the compiled assembly, and has a more concrete type for non-primitive-type properties.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.Const.NumLicenseLeftDaysNotification">
             <summary>
              <para>
                <c>#define NumLicenseLeftDaysNotification 3</c>
              </para>
              <para>Number of days before license expires to notify the user of that.</para>
              <para>Use this const field only where use of a constant is mandatory. Otherwise use the static readonly field in the outer class, which stands better in the compiled assembly, and has a more concrete type for non-primitive-type properties.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.Const.NumTimeBombDays">
             <summary>
              <para>
                <c>#define NumTimeBombDays 0</c>
              </para>
              <para>The product will be inoperational when this time since build date expires. 0 means never expire (release mode), which is the default.</para>
              <para>Use this const field only where use of a constant is mandatory. Otherwise use the static readonly field in the outer class, which stands better in the compiled assembly, and has a more concrete type for non-primitive-type properties.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.Const.NUnitCpu">
             <summary>
              <para>
                <c>#define NUnitCpu x86</c>
              </para>
              <para>CPU platform of the NUnit runner process. Tests will be executed in this environment. Values: x86, x64, ANY.</para>
              <para>Use this const field only where use of a constant is mandatory. Otherwise use the static readonly field in the outer class, which stands better in the compiled assembly, and has a more concrete type for non-primitive-type properties.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.Const.NUnitInParallel">
             <summary>
              <para>
                <c>#define NUnitInParallel True</c>
              </para>
              <para>Allows running NUnit in parallel (one process per assembly, max CPU-count processes total).</para>
              <para>Use this const field only where use of a constant is mandatory. Otherwise use the static readonly field in the outer class, which stands better in the compiled assembly, and has a more concrete type for non-primitive-type properties.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.Const.NUnitRuntime">
             <summary>
              <para>
                <c>#define NUnitRuntime v4.0</c>
              </para>
              <para>CLR version of the NUnit runner process. Tests will be executed in this environment. Values: v1.1, v2.0, v4.0, ANY.</para>
              <para>Use this const field only where use of a constant is mandatory. Otherwise use the static readonly field in the outer class, which stands better in the compiled assembly, and has a more concrete type for non-primitive-type properties.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.Const.NUnitVersion">
             <summary>
              <para>
                <c>#define NUnitVersion NUnit-2.6.1</c>
              </para>
              <para>Version of the NUnit runner used on TeamCity server. The special ReSharper make does better formatting of exception stack traces (without reversing the stacks).</para>
              <para>Use this const field only where use of a constant is mandatory. Otherwise use the static readonly field in the outer class, which stands better in the compiled assembly, and has a more concrete type for non-primitive-type properties.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.Const.PragmaOnce_Platform_Defines_Targets">
             <summary>
              <para>
                <c>#define PragmaOnce_Platform_Defines_Targets True</c>
              </para>
              <para>Pragma Once.</para>
              <para>Use this const field only where use of a constant is mandatory. Otherwise use the static readonly field in the outer class, which stands better in the compiled assembly, and has a more concrete type for non-primitive-type properties.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.Const.PragmaOnce_Product_Defines_Targets">
             <summary>
              <para>
                <c>#define PragmaOnce_Product_Defines_Targets True</c>
              </para>
              <para>Pragma Once.</para>
              <para>Use this const field only where use of a constant is mandatory. Otherwise use the static readonly field in the outer class, which stands better in the compiled assembly, and has a more concrete type for non-primitive-type properties.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.Const.ProductDisplayName">
             <summary>
              <para>
                <c>#define ProductDisplayName ReSharper</c>
              </para>
              <para>The user-friendly name of the product in the short form (no company, no version). The default choice if you want to mention the product name in UI. See Remarks on IApplicationDescriptor::ProductDisplayNameName for details.</para>
              <para>You MUST NOT use this define where an Application Descriptor is available (this includes any time when Shell is running). This is ONLY for out-of-shell and build-time uses.</para>
              <para>Use this const field only where use of a constant is mandatory. Otherwise use the static readonly field in the outer class, which stands better in the compiled assembly, and has a more concrete type for non-primitive-type properties.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.Const.ProductFullName">
             <summary>
              <para>
                <c>#define ProductFullName ReSharper 9.0 EAP</c>
              </para>
              <para>The expanded marketing product name, which is typically the &lt;see cref="ProductDisplayName"/&gt; plus the marketing version number, beta/EAP/RC designation, etc. See Remarks on IApplicationDescriptor::ProductDisplayNameName for details.</para>
              <para>You MUST NOT use this define where an Application Descriptor is available (this includes any time when Shell is running). This is ONLY for out-of-shell and build-time uses.</para>
              <para>Use this const field only where use of a constant is mandatory. Otherwise use the static readonly field in the outer class, which stands better in the compiled assembly, and has a more concrete type for non-primitive-type properties.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.Const.ProductName">
             <summary>
              <para>
                <c>#define ProductName ReSharper</c>
              </para>
              <para>The bare technical product name in the shortest form (no company, no version, no spaces, identifier-syntax-compatible). See Remarks on IApplicationDescriptor::ProductDisplayNameName for details.</para>
              <para>If there're multiple products built on these sources, their least common generic name.</para>
              <para>You MUST NOT use this define where an Application Descriptor or IProductNameAndVersion is available (this includes any time when Shell is running). This is ONLY for out-of-shell and build-time uses.</para>
              <para>Use this const field only where use of a constant is mandatory. Otherwise use the static readonly field in the outer class, which stands better in the compiled assembly, and has a more concrete type for non-primitive-type properties.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.Const.ProductStandaloneApplicationCaps">
             <summary>
              <para>
                <c>#define ProductStandaloneApplicationCaps None</c>
              </para>
              <para>Use this const field only where use of a constant is mandatory. Otherwise use the static readonly field in the outer class, which stands better in the compiled assembly, and has a more concrete type for non-primitive-type properties.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.Const.ProductUpgradeCodeLegacyVS0800">
             <summary>
              <para>
                <c>#define ProductUpgradeCodeLegacyVS0800 {F790F14F-E662-4D25-89A0-9CC8677DE27A}</c>
              </para>
              <para>Main historical Upgrade Code for the R# product line. In 3.0 era, was used by the VS80 branch only. Not used by the new products.</para>
              <para>Used by Installation Centers for detecting pre-Platform-4 products in VS80.</para>
              <para>Empty by default. Not a GUID type just to allow empty string values.</para>
              <para>Use this const field only where use of a constant is mandatory. Otherwise use the static readonly field in the outer class, which stands better in the compiled assembly, and has a more concrete type for non-primitive-type properties.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.Const.ProductUpgradeCodeLegacyVS0900">
             <summary>
              <para>
                <c>#define ProductUpgradeCodeLegacyVS0900 {5595D9CA-0517-4A8E-9129-F973460986E0}</c>
              </para>
              <para>Side Upgrade Code for the R# products. Was in use in the 3.0 era only, was used by the VS90 branch that had an upgrade line separate from that of VS80. Should be checked for when detecting older versions.</para>
              <para>Used by Installation Centers for detecting pre-Platform-4 products in VS90.</para>
              <para>Empty by default. Not a GUID type just to allow empty string values.</para>
              <para>Use this const field only where use of a constant is mandatory. Otherwise use the static readonly field in the outer class, which stands better in the compiled assembly, and has a more concrete type for non-primitive-type properties.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.Const.ProductUpgradeCodeLegacyVS1000">
             <summary>
              <para>
                <c>#define ProductUpgradeCodeLegacyVS1000 </c>
              </para>
              <para>Same as other ProductUpgradeCodeLegacy, but empty in all the products. Introduced for safe looping thru VS versions. Not a GUID type just to allow empty string values.</para>
              <para>Use this const field only where use of a constant is mandatory. Otherwise use the static readonly field in the outer class, which stands better in the compiled assembly, and has a more concrete type for non-primitive-type properties.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.Const.ProductVisualStudioIntegrationCaps">
             <summary>
              <para>
                <c>#define ProductVisualStudioIntegrationCaps Required</c>
              </para>
              <para>A required parameter of a platform-based MSI Setup which defines the VS integration capabilities of the product.</para>
              <para>Defines whether the installer should suggest integrating the product into Visual Studio. Possible values are:</para>
              <para>“None” — the product has no VS integration capabilities. Example: early versions of some products like DotTrace Memory, Peek.</para>
              <para>“Optional” — the product can be used without VS, but also provides VS integration. Example: DotTrace Performance.</para>
              <para>“Required” — the product only exists as a VS extension and usually should not be installed without VS integration. Example: ReSharper.</para>
              <para>Use this const field only where use of a constant is mandatory. Otherwise use the static readonly field in the outer class, which stands better in the compiled assembly, and has a more concrete type for non-primitive-type properties.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.Const.UriBuy">
             <summary>
              <para>
                <c>#define UriBuy http://www.jetbrains.com/resharper/buy/index.html</c>
              </para>
              <para>URI of the Webpage where the user could buy the product.</para>
              <para>Use this const field only where use of a constant is mandatory. Otherwise use the static readonly field in the outer class, which stands better in the compiled assembly, and has a more concrete type for non-primitive-type properties.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.Const.UriCompany">
             <summary>
              <para>
                <c>#define UriCompany http://www.jetbrains.com</c>
              </para>
              <para>URI of the company Website.</para>
              <para>Use this const field only where use of a constant is mandatory. Otherwise use the static readonly field in the outer class, which stands better in the compiled assembly, and has a more concrete type for non-primitive-type properties.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.Const.UriEvaluate">
             <summary>
              <para>
                <c>#define UriEvaluate http://www.jetbrains.com/resharper/download/index.html</c>
              </para>
              <para>URI of the Webpage where the user can download an evaluation version of the product.</para>
              <para>Use this const field only where use of a constant is mandatory. Otherwise use the static readonly field in the outer class, which stands better in the compiled assembly, and has a more concrete type for non-primitive-type properties.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.Const.UriProduct">
             <summary>
              <para>
                <c>#define UriProduct http://www.jetbrains.com/resharper/</c>
              </para>
              <para>Main product webpage URI. Also used for ARPURLINFOABOUT in the installer.</para>
              <para>Use this const field only where use of a constant is mandatory. Otherwise use the static readonly field in the outer class, which stands better in the compiled assembly, and has a more concrete type for non-primitive-type properties.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.Const.UriProductCommunityNewsgroups">
             <summary>
              <para>
                <c>#define UriProductCommunityNewsgroups news://news.jetbrains.com/jetbrains.resharper.community</c>
              </para>
              <para>URI to the product community (support/discussion) newsgroups.</para>
              <para>Use this const field only where use of a constant is mandatory. Otherwise use the static readonly field in the outer class, which stands better in the compiled assembly, and has a more concrete type for non-primitive-type properties.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.Const.UriProductHelp">
             <summary>
              <para>
                <c>#define UriProductHelp http://www.jetbrains.com/resharper/documentation/index.html</c>
              </para>
              <para>URI to Product Help. Used for Online F1 in the product and ARPHELPLINK in the installer.</para>
              <para>NOTE: UriProductHelp points to the SINGLE page for all R# versions starting with v4.0. See ReSharperWebHelp class on how the complete URI is producted out of this base: exact product version is appended, plus the options keyword whose help page should be opened. Based on the version number, user is redirected to help for his exact version. Thus, you cannot easily change this URI in a newer version without affecting already-released products.</para>
              <para>Use this const field only where use of a constant is mandatory. Otherwise use the static readonly field in the outer class, which stands better in the compiled assembly, and has a more concrete type for non-primitive-type properties.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.Const.UriProductSupportEmail">
             <summary>
              <para>
                <c>#define UriProductSupportEmail mailto:support@jetbrains.com</c>
              </para>
              <para>Email to request for product support. The default is suitable for all JetBrains products.</para>
              <para>Use this const field only where use of a constant is mandatory. Otherwise use the static readonly field in the outer class, which stands better in the compiled assembly, and has a more concrete type for non-primitive-type properties.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.Const.UriProductUninstallFeedback">
             <summary>
              <para>
                <c>#define UriProductUninstallFeedback http://www.jetbrains.com/resharper/uninstall/resharper.jsp</c>
              </para>
              <para>An URI to submit the Uninstall Feedback from the installer.</para>
              <para>This URI has query string parameters that are defined in the installer itself (one of its CAs).</para>
              <para>Use this const field only where use of a constant is mandatory. Otherwise use the static readonly field in the outer class, which stands better in the compiled assembly, and has a more concrete type for non-primitive-type properties.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.Const.UriProductUpdateInfoForInstaller">
             <summary>
              <para>
                <c>#define UriProductUpdateInfoForInstaller http://blogs.jetbrains.com/dotnet/category/news/</c>
              </para>
              <para>Installer's ARPURLUPDATEINFO. Default is applicable for dotnet products.</para>
              <para>Use this const field only where use of a constant is mandatory. Otherwise use the static readonly field in the outer class, which stands better in the compiled assembly, and has a more concrete type for non-primitive-type properties.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.Const.UriUpdatesFilterXslt">
             <summary>
              <para>
                <c>#define UriUpdatesFilterXslt http://www.jetbrains.com/resharper/updates/online.Updates.xslt</c>
              </para>
              <para>URI to get the XSLT with updates info from (see UpdatesManager).</para>
              <para>Use this const field only where use of a constant is mandatory. Otherwise use the static readonly field in the outer class, which stands better in the compiled assembly, and has a more concrete type for non-primitive-type properties.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Defines.Const.VsPackageLoadKey">
             <summary>
              <para>
                <c>#define VsPackageLoadKey JetBrains s.r.o.;ReSharper;9.0;standard;AHR2RRIDC0RRA9ZMJMEQPPR8ICZZH1D3ZREDEZRRRJR0AARDEPEIC0IAZHQ2KAR8D1QKH3AKIZJCJKHEITIEIJRHHTZEDCIJJ1P8CPAEE2A2JKH9MHMPZPJ9HKHII3HM</c>
              </para>
              <para>VS PLK, as received from the Microsoft website. See “Changing Product Name and Version SOP” on how to do that. 
            		Format: “CompanyName;ProductName;ProductVersion2;VsMinEdition;PLK”. See VsPackageClassEmitter::PackageInfo for format details.</para>
              <para>Use this const field only where use of a constant is mandatory. Otherwise use the static readonly field in the outer class, which stands better in the compiled assembly, and has a more concrete type for non-primitive-type properties.</para>
            </summary>
        </member>
    </members>
</doc>
