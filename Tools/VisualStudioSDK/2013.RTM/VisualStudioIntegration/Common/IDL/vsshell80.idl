/*****************************************************************************
*  The VSSHELL Interfaces
*  Copyright (c) 2002-2003, Microsoft Corporation, All Rights Reserved
*****************************************************************************/

#ifndef INTEROPLIB

// Imports - all imports should go here (inside the ifndef)
import "oaidl.idl";
import "vsshell.idl";
import "vsshell2.idl";
import "context.idl";

#endif

cpp_quote("#if 0")
typedef DWORD_PTR DLGPROC;
typedef DWORD_PTR LPFNPSPCALLBACKA;
typedef DWORD_PTR HINSTANCE;
cpp_quote("#endif")
cpp_quote("#include <prsht.h>")

#include "winerror.h"

/****************************************************************************
********    IMPORTANT!!   *********

All guids for interfaces and co-creatable objects in this file should be defined
in vsshelluuids.h

Do NOT derive from interfaces defined in vshell.idl because:

1. We want to be able to independently implement the new interfaces without having 
to implement all the methods in the old interfaces.
2. This creates dependencies which causes complications for the build process.

****************************************************************************/

#include "vsshelluuids.h"

/****************************************************************************
PLEASE READ THE FOLLOWING NOTES:

***** Note on enumerators and bitwise flags passed as parameters:

When a parameter must be exactly one of a set of values (a true enumerator),
the values should be defined and used as follows:

typedef enum __tagVSSAMPLETYPE
{
ST_THISTYPE     = 0,   // first value should be zero or one, except
ST_THATTYPE     = 1,   // in special cases, and following values
ST_THEOTHERTYPE = 2,   // should use consecutive numbers
} VSSAMPLETYPE;

interface IVsSample : IUnknown
{
HRESULT SampleMethod([in] VSSAMPLETYPE stType);
}

When a parameter must be exactly one of a set of values (a true enumerator),
and is considered a PROPID, the values should be defined and used as follows:

enum __VSSAMPLEPROPID
{
VSSAMPPROPID_LAST     = -7000,  // first value should be a unique
VSSAMPPROPID_This     = -7000,  // number not used by any other
VSSAMPPROPID_That     = -7001,  // PROPID, and following values
VSSAMPPROPID_FIRST    = -7001,  // should use consecutive numbers
};
typedef LONG VSSAMPLEPROPID;

interface IVsSample : IUnknown
{
HRESULT GetProperty([in] VSSAMPLEPROPID propid, [out] VARIANT *pvar);
HRESULT SetProperty([in] VSSAMPLEPROPID propid, [in] VARIANT var);
}

When a parameter can be none of or a combination of values (bitwise),
the values should be defined and used as follows:

enum __VSSAMPLEOPTS
{
SO_THISOPTION     = 0x00000001,   // first value should be one,
SO_THATOPTION     = 0x00000002,   // following values should use
SO_THEOTHEROPTION = 0x00000004,   // consecutive powers of two
};
typedef DWORD VSSAMPLEOPTS;

interface IVsSample : IUnknown
{
HRESULT SampleMethod([in] VSSAMPLEOPTS grfOptions);
}

***** Defining properties

Define properties as follows:

interface IVsSample : IUnknown
{
HRESULT get_Foo([out] BSTR *pbstrFoo);
HRESULT put_Foo([in] BSTR bstrFoo);
}

DO NOT use [propget], [propput] or [propputref] to define properties!!!

***** Array typed args

Pass array type arguments (both in and out) using [] and size_is when the corresponding
size argument is present. You must have the array size as an argument for interop to
work correctly.

interface IVsSample : IUnknown
{
HRESULT MethodPassesInArray([in] int cItems, [in, size_is(cItems)] int prgiItems[]);
}

DO NOT use [in] int piItems[].

****************************************************************************/


#ifdef INTEROPLIB

// define GUID's here to be exposed to managed code
module ShellGuids80
{
    const LPSTR SolutionFolderProject = "{2150E333-8FDC-42A3-9474-1A3956D46DE8}";
}

// define tool window GUID's here to be exposed to managed code
module ToolWindowGuids80
{
    const LPSTR Autos =                     "{F2E84780-2AF1-11D1-A7FA-00A0C9110051}";
    const LPSTR BookmarkWindow =            "{A0C5197D-0AC7-4B63-97CD-8872A789D233}";
    const LPSTR Breakpoints =               "{BE4D7042-BA3F-11D2-840E-00C04F9902C1}";
    const LPSTR BrowserDoc =                "{6B8E94B4-0949-4D9C-A81F-C1B9B744185C}";
    const LPSTR CallBrowserWindow =         "{5415EA3A-D813-4948-B51E-562082CE0887}";
    const LPSTR CallBrowserSecondaryWindow= "{F78BCC56-71F7-4E7D-8215-F690CAE4F452}";
    const LPSTR CallStack =                 "{0504FF91-9D61-11D0-A794-00A0C9110051}";
    const LPSTR ClassDetails =              "{778B5376-AD77-4751-ACDC-F3D18343F8DD}";
    const LPSTR ClassView =                 "{C9C0AE26-AA77-11D2-B3F0-0000F87570EE}";
    const LPSTR CodedefinitionWindow =      "{588470CC-84F8-4A57-9AC4-86BCA0625FF4}";
    const LPSTR CommandWindow =             "{28836128-FC2C-11D2-A433-00C04F72D18A}";
    const LPSTR ConsoleIO =                 "{FC29E0C0-C1AB-4B30-B5DF-24AA452B9661}";
    const LPSTR DataSourceWindow =          "{873151D0-CF2E-48CC-B4BF-AD0394F6A3C3}";
    const LPSTR DefinitionWindow =          "{5B6781C0-E99D-11D0-9954-00A0C91BC8E6}";
    const LPSTR Disassembly =               "{CF577B8C-4134-11D2-83E5-00C04F9902C1}";
    const LPSTR DocumentOutline =           "{25F7E850-FFA1-11D0-B63F-00A0C922E851}";
    const LPSTR ContextWindow =             "{66DBA47C-61DF-11D2-AA79-00C04F990343}";
    const LPSTR ErrorList =                 "{D78612C7-9962-4B83-95D9-268046DAD23A}";
    const LPSTR Find1 =                     "{0F887920-C2B6-11D2-9375-0080C747D9A0}";
    const LPSTR Find2 =                     "{0F887921-C2B6-11D2-9375-0080C747D9A0}";
    const LPSTR FindInFiles =               "{E830EC50-C2B5-11D2-9375-0080C747D9A0}";
    const LPSTR FindAdvanced =              "{E830EC50-C2B5-11D2-9375-0080C747D9A0}";
    const LPSTR ObjectSearchResultsWindow = "{68487888-204A-11D3-87EB-00C04F7971A5}";
    const LPSTR ObjectSearchWindow =        "{53024D34-0EF5-11D3-87E0-00C04F7971A5}";
    const LPSTR FindReplace =               "{CF2DDC32-8CAD-11D2-9302-005345000000}";
    const LPSTR HelpFavorites =             "{57DC5D59-11C2-4955-A7B4-D7699D677E93}";
    const LPSTR HelpHowDoI =                "{4A78E230-DCCB-44DF-95CF-22EE6E2459BB}";
    const LPSTR Helpindex =                 "{73F6DD58-437E-11D3-B88E-00C04F79F802}";
    const LPSTR HelpIndexResults =          "{73F6DD5B-437E-11D3-B88E-00C04F79F802}";
    const LPSTR HelpSearch =                "{46C87F81-5A06-43A8-9E25-85D33BAC49F8}";
    const LPSTR ImmediateWindow =           "{ECB7191A-597B-41F5-9843-03A4CF275DDE}";
    const LPSTR IVSMDPropertyBrowser =      "{74946810-37A0-11D2-A273-00C04F8EF4FF}";
    const LPSTR LocalChanges =              "{53544C4D-5C18-11D3-AB71-0050040AE094}";
    const LPSTR Locals =                    "{4A18F9D0-B838-11D0-93EB-00A0C90F2734}";
    const LPSTR MacroExplorer =             "{07CD18B4-3BA1-11D2-890A-0060083196C6}";
    const LPSTR Memory =                    "{350F9856-A72B-11D2-8AD0-00C04F79E479}";
    const LPSTR Modules =                   "{37ABA9BE-445A-11D3-9949-00C04F68FD0A}";
    const LPSTR ObjectBrowser =             "{269A02DC-6AF8-11D3-BDC4-00C04F688E50}";
    const LPSTR ObjectTestBench =           "{FDFFCCF2-5F63-404F-86AD-33693F544948}";
    const LPSTR Outputwindow =              "{34E76E81-EE4A-11D0-AE2E-00A0C90FFFC3}";
    const LPSTR PortDetails =               "{B869198C-F673-46D2-83AE-64F515277716}";
    const LPSTR Processes =                 "{51C76317-9037-4CF2-A20A-6206FD30B4A1}";
    const LPSTR PropertiesWindow =          "{EEFA5220-E298-11D0-8F78-00A0C9110057}";
    const LPSTR PropertySheetManager =      "{6B8E94B5-0949-4D9C-A81F-C1B9B744185C}";
    const LPSTR Registers =                 "{CA4B8FF5-BFC7-11D2-9929-00C04F68FDAF}";
    const LPSTR ResourceView =              "{2D7728C2-DE0A-45B5-99AA-89B609DFDE73}";
    const LPSTR RunningDocuments =          "{ECDD9EE0-AC6B-11D0-89F9-00A0C9110055}";
    const LPSTR SdmDesignerTransactions =   "{6F409264-641B-46E4-99A8-F6B65654AFF4}";
    const LPSTR ServerExplorer =            "{74946827-37A0-11D2-A273-00C04F8EF4FF}";
    const LPSTR SettingsandConstraints =    "{B8399B49-7330-487B-9235-7D2E969D0A79}";
    const LPSTR SolutionExplorer =          "{3AE79031-E1BC-11D0-8F78-00A0C9110057}";
    const LPSTR StartPage =                 "{387CB18D-6153-4156-9257-9AC3F9207BBE}";
    const LPSTR StyleOrganizerToolWindow =  "{A764E899-518D-11D2-9A89-00C04F79EFC3}";
    const LPSTR SystemView =                "{9F3EC988-1174-4746-A66A-3969715D1FC7}";
    const LPSTR Tableofcontents =           "{4A791147-19E4-11D3-B86B-00C04F79F802}";
    const LPSTR TaskList =                  "{4A9B7E51-AA16-11D0-A8C5-00A0C921A4D2}";
    const LPSTR Threads =                   "{E62CE6A0-B439-11D0-A79D-00A0C9110051}";
    const LPSTR Toolbox =                   "{B1E99781-AB81-11D0-B683-00AA00A3EE26}";
    const LPSTR TrinityDataWindow =         "{983CA650-95A7-4A43-822A-2960D4BD0D7D}";
    const LPSTR UAMSynchronizations =       "{A94C758F-EFB0-4975-BF86-C87B59FDB45D}";
    const LPSTR VCColorPalette =            "{5B6781C0-E99D-11D0-9954-00A0C91BC8E5}";
    const LPSTR VCPropertyManager =         "{DE1FC918-F32E-4DD7-A915-1792A051F26B}";
    const LPSTR Watch =                     "{90243340-BD7A-11D0-93EF-00A0C90F2734}";
    const LPSTR WebBrowserPreviewWindow =   "{E8B06F53-6D01-11D2-AA7D-00C04F990343}";
    const LPSTR WebBrowserWindow =          "{E8B06F52-6D01-11D2-AA7D-00C04F990343}";
}

// define tool window GUID's here that were not exposed in 7.1
module ToolWindowGuids
{
    const LPSTR Toolbox =                   "{B1E99781-AB81-11D0-B683-00AA00A3EE26}";
    const LPSTR PropertyBrowser =           "{EEFA5220-E298-11D0-8F78-00A0C9110057}";
    const LPSTR SolutionExplorer =          "{3AE79031-E1BC-11D0-8F78-00A0C9110057}";
    const LPSTR OutputWindow =              "{34E76E81-EE4A-11D0-AE2E-00A0C90FFFC3}";
    const LPSTR DocOutline =                "{25F7E850-FFA1-11D0-B63F-00A0C922E851}";
    const LPSTR TaskList =                  "{4A9B7E51-AA16-11D0-A8C5-00A0C921A4D2}";
    const LPSTR ServerExplorer =            "{74946827-37A0-11D2-A273-00C04F8EF4FF}";
    const LPSTR MacroExplorer =             "{07CD18B4-3BA1-11D2-890A-0060083196C6}";
    const LPSTR ContextWindow =             "{66DBA47C-61DF-11D2-AA79-00C04F990343}";
    const LPSTR ClassView =                 "{C9C0AE26-AA77-11D2-B3F0-0000F87570EE}";
    const LPSTR ResourceView =              "{2D7728C2-DE0A-45B5-99AA-89B609DFDE73}";
    const LPSTR ObjectSearchWindow =        "{53024D34-0EF5-11D3-87E0-00C04F7971A5}";
    const LPSTR CommandWindow =             "{28836128-FC2C-11D2-A433-00C04F72D18A}";
    const LPSTR ObjectSearchResultsWindow = "{68487888-204A-11D3-87EB-00C04F7971A5}";
    const LPSTR ObjectBrowser =             "{269A02DC-6AF8-11D3-BDC4-00C04F688E50}";
    const LPSTR BrowserDoc =                "{6B8E94B4-0949-4D9C-A81F-C1B9B744185C}";
    const LPSTR FindReplace =               "{CF2DDC32-8CAD-11D2-9302-005345000000}";
    const LPSTR FindAdvanced =              "{E830EC50-C2B5-11D2-9375-0080C747D9A0}";
    const LPSTR FindResults1 =              "{0F887920-C2B6-11D2-9375-0080C747D9A0}";
    const LPSTR FindResults2 =              "{0F887921-C2B6-11D2-9375-0080C747D9A0}";
}

// define UI Context GUID's here to be exposed to managed code
module UIContextGuids80
{
// from VS 2003
    const LPSTR SolutionBuilding =              "{ADFC4E60-0397-11D1-9F4E-00A0C911004F}";
    const LPSTR Debugging =                     "{ADFC4E61-0397-11D1-9F4E-00A0C911004F}";
    const LPSTR Dragging =                      "{B706F393-2E5B-49E7-9E2E-B1825F639B63}";
    const LPSTR FullScreenMode =                "{ADFC4E62-0397-11D1-9F4E-00A0C911004F}";
    const LPSTR DesignMode =                    "{ADFC4E63-0397-11D1-9F4E-00A0C911004F}";
    const LPSTR NoSolution =                    "{ADFC4E64-0397-11D1-9F4E-00A0C911004F}";
    const LPSTR SolutionExists =                "{F1536EF8-92EC-443C-9ED7-FDADF150DA82}";
    const LPSTR EmptySolution =                 "{ADFC4E65-0397-11D1-9F4E-00A0C911004F}";
    const LPSTR SolutionHasSingleProject =      "{ADFC4E66-0397-11D1-9F4E-00A0C911004F}";
    const LPSTR SolutionHasMultipleProjects =   "{93694FA0-0397-11D1-9F4E-00A0C911004F}";
    const LPSTR CodeWindow =                    "{8FE2DF1D-E0DA-4EBE-9D5C-415D40E487B5}";

// new to VS 2005
    const LPSTR NotBuildingAndNotDebugging =  "{48EA4A80-F14E-4107-88FA-8D0016F30B9C}";
    const LPSTR SolutionOrProjectUpgrading =  "{EF4F870B-7B85-4F29-9D15-CE1ABFBE733B}";
    const LPSTR DataSourceWindowSupported =   "{95C314C4-660B-4627-9F82-1BAF1C764BBF}";
    const LPSTR DataSourceWindowAutoVisible = "{2E78870D-AC7C-4460-A4A1-3FE37D00EF81}";
    const LPSTR WindowsFormsDesigner =        "{BA09E2AF-9DF2-4068-B2F0-4C7E5CC19E2F}";
    const LPSTR ToolboxInitialized =          "{DC5DB425-F0FD-4403-96A1-F475CDBA9EE0}";
    const LPSTR SolutionExistsAndNotBuildingAndNotDebugging = "{D0E4DEEC-1B53-4cda-8559-D454583AD23B}";
}

// context guids not exposed to the interop assembly in 7.1
module UIContextGuids
{
    const LPSTR SolutionBuilding =              "{ADFC4E60-0397-11D1-9F4E-00A0C911004F}";
    const LPSTR Debugging =                     "{ADFC4E61-0397-11D1-9F4E-00A0C911004F}";
    const LPSTR Dragging =                      "{B706F393-2E5B-49E7-9E2E-B1825F639B63}";
    const LPSTR FullScreenMode =                "{ADFC4E62-0397-11D1-9F4E-00A0C911004F}";
    const LPSTR DesignMode =                    "{ADFC4E63-0397-11D1-9F4E-00A0C911004F}";
    const LPSTR NoSolution =                    "{ADFC4E64-0397-11D1-9F4E-00A0C911004F}";
    const LPSTR SolutionExists =                "{F1536EF8-92EC-443C-9ED7-FDADF150DA82}";
    const LPSTR EmptySolution =                 "{ADFC4E65-0397-11D1-9F4E-00A0C911004F}";
    const LPSTR SolutionHasSingleProject =      "{ADFC4E66-0397-11D1-9F4E-00A0C911004F}";
    const LPSTR SolutionHasMultipleProjects =   "{93694FA0-0397-11D1-9F4E-00A0C911004F}";
    const LPSTR CodeWindow =                    "{8FE2DF1D-E0DA-4EBE-9D5C-415D40E487B5}";
}


module TaskListViews
{
    const LPSTR All =                       "{1880202e-fc20-11d2-8bb1-00c04f8ec28c}";
    const LPSTR UserTasks =                 "{1880202f-fc20-11d2-8bb1-00c04f8ec28c}";
    const LPSTR ShortcutTasks =             "{18802030-fc20-11d2-8bb1-00c04f8ec28c}";
    const LPSTR HTMLTasks =                 "{36ac1c0d-fe86-11d2-8bb1-00c04f8ec28c}";
    const LPSTR CompilerTasks =             "{18802033-fc20-11d2-8bb1-00c04f8ec28c}";
    const LPSTR CommentTasks =              "{18802034-fc20-11d2-8bb1-00c04f8ec28c}";
    const LPSTR CurrentFileTasks =          "{18802035-fc20-11d2-8bb1-00c04f8ec28c}";
    const LPSTR CheckedTasks =              "{18802036-fc20-11d2-8bb1-00c04f8ec28c}";
    const LPSTR UncheckedTasks =            "{18802037-fc20-11d2-8bb1-00c04f8ec28c}";
}

module LogicalViewID
{
    const LPSTR Primary =                   "{00000000-0000-0000-0000-000000000000}";
    const LPSTR Any =                       "{FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF}";
//---------------------------------------------------------------------------
// The range 7651a700-06e5-11d1-8ebd-00a0c90f26ea to
// 7651a750-06e5-11d1-8ebd-00a0c90f26ea has been reserved for LOGVIEWID's
//---------------------------------------------------------------------------
    const LPSTR Debugging =                 "{7651A700-06E5-11D1-8EBD-00A0C90F26EA}";
    const LPSTR Code =                      "{7651A701-06E5-11D1-8EBD-00A0C90F26EA}";
    const LPSTR Designer =                  "{7651A702-06E5-11D1-8EBD-00A0C90F26EA}";
    const LPSTR TextView =                  "{7651A703-06E5-11D1-8EBD-00A0C90F26EA}";
// cmdidOpenWith handlers should pass this LOGVIEWID along to OpenStandardEditor to get the "Open With" dialog
    const LPSTR UserChooseView =            "{7651A704-06E5-11D1-8EBD-00A0C90F26EA}";
// LOGVIEWID_ProjectSpecific is passed by the OpenWith dialog to IVsProject::OpenItem when the user chooses the "(Project default editor)"
// entry. The project should use its special logic to open the specific editor for the project. If the item supports ViewForm/ViewCode,
// then this will be the smart DBLCLK/Open logic where the FormView is opened if appropriate, else the CodeView is opened.
    const LPSTR ProjectSpecificEditor =     "{80A3471A-6B87-433E-A75A-9D461DE0645F}";
}

module BuildOutputGroup
{
    const LPSTR SourceFiles =             "SourceFiles";
    const LPSTR Built =                   "Built";
    const LPSTR ContentFiles =            "ContentFiles";
    const LPSTR LocalizedResourceDlls =   "LocalizedResourceDlls";
    const LPSTR Documentation =           "Documentation";
    const LPSTR Symbols =                 "Symbols";
}

#ifndef PROXYSTUB_BUILD

// ...Everett DTE service objects
[uuid(f1ddc2c2-df76-4ebb-9de8-48ad2557062c)]
interface SVsSourceControl : IUnknown
{
}

[uuid(8d0aa9cc-8465-42f3-ad6e-dfde28ccc75d)]
interface SExtensionManager : IUnknown
{
}

[uuid(04a72314-32e9-48e2-9b87-a63603454f3e)]
interface SDTE : IUnknown
{
}

#endif

module DTECatID
{
    const LPSTR Solution = "{52AEFF70-BBD8-11d2-8598-006097C68E81}";
    const LPSTR SolutionBrowseObject = "{A2392464-7C22-11d3-BDCA-00C04F688E50}";
    const LPSTR MiscFilesProject = "{610d4612-d0d5-11d2-8599-006097c68e81}";
    const LPSTR MiscFilesProjectItem = "{610d4613-d0d5-11d2-8599-006097c68e81}";
    const LPSTR GenericProject = "{610d4616-d0d5-11d2-8599-006097c68e81}";
    const LPSTR Document = "{610d4611-d0d5-11d2-8599-006097c68e81}";
}

// end ...Everett DTE


module FontsAndColorsCategory
{
    const LPSTR TextOutputToolWindows = "{C34C709B-C855-459e-B38C-3021F162D3B1}";
    const LPSTR Printer = "{47724E70-AF55-48fb-A928-BB161C1D0C05}";
    const LPSTR Tooltip = "{A9A5637F-B2A8-422e-8FB5-DFB4625F0111}";
    const LPSTR StatementCompletion = "{C1614BB1-734F-4a31-BD42-5AE6275E16D2}";
    const LPSTR OutputWindow = "{9973EFDF-317D-431c-8BC1-5E88CBFD4F7F}";
    const LPSTR FindResults = "{5C48B2CB-0366-4fbf-9786-0BB37E945687}";
    const LPSTR CommandWindow = "{EE1BE240-4E81-4beb-8EEA-54322B6B1BF5}";
    const LPSTR SystemWindow = "{7E50DA68-A928-4d87-BEA4-E9F88AEC218C}";
    const LPSTR ImmediateWindow = "{6BB65C5A-2F31-4bde-9F48-8A38DC0C63E7}";
    const LPSTR DialogsAndToolWindows = "{1F987C00-E7C4-4869-8A17-23FD602268B0}";
    const LPSTR TextEditor = "{A27B4E24-A735-4d1d-B8E7-9716E1E3D8E0}";
}



#endif // def INTEROPLIB



// define error codes here
enum VSErrorCodes80
{
    // VS-specific HRESULT failure codes - start at 0x80041FE0
    //
    VS_E_MIGRATIONREQUIRESRELOAD = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1FE6),
    // The error code is returned when a solution or project file cannot be opened asynchronously.
    // The caller should attempt to open the file again without passing
    // SLNOPENOPT_LoadingAsync (for solution) or CPF_OPEN_ASYNCHRONOUSLY (for project).
    VS_E_SYNCHRONOUSOPENREQUIRED = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1FE7),
    // Returned by IVsProfileSettingsFileCollection.AddBrowseFile if the selected file is of the wrong version
    VS_E_VSSETTINGS_INVALIDVERSION = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1FE8),
    // Returned by editor invocation if the document cannot be opened safely (template, editor or logical view is untrusted)
    VS_E_DOCUMENTOPENNOTTRUSTED = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1FE9),
};

// These values are standard File Format types that can be passed as "nFormatIndex" to the
// IVsStructuredFileIO implementation of the Environment (see SID_SVsStructuredFileIO defined
// in vsshell.idl). Projects and Editors/Designers that implement IPersistFileFormat are
// allowed to use any values they like for their nFormatIndex values, but they encouraged
// to use these VSFORMATINDEX values.
enum __VSFORMATINDEX
{
    VSFORMATINDEX_UTF8    = 0,
    VSFORMATINDEX_MBCS    = 1, // Multi-Byte Character Set (a.k.a. ANSI)
    VSFORMATINDEX_UNICODE = 2,
};
typedef ULONG VSFORMATINDEX;

//----------------------------------------------------------------------------
//  interface IVsRegisterProjectDebugTargetProvider
//----------------------------------------------------------------------------
// Implemented by a project system that offers external influence over launching the debugger.
// This interface is retrieved via IServiceProvider::QueryService on the IServiceProvider
// returned from IVsProject::GetItemContext(VSITEMID_ROOT, SID_SVsRegisterProjectDebugTargetProvider, …)
// The project maintains a linked list of IVsDebugTargetProvider pointers. When a provider
// adds itself to the list, it gets the previous provider returned. The new DebugTargetProvider
// is responsible to delegate to the next in the list, if it otherwise would not provide a 
// valid debug target itself.
[
    uuid(uuid_IVsProjectDebugTargetProvider),
    version(1.0),
    pointer_default(unique)
]
interface IVsProjectDebugTargetProvider : IUnknown 
{
    HRESULT SupplyDebugTarget([out] BSTR* pbstrTarget, [out] BSTR* pbstrCommandLine);

}

[
    uuid(uuid_IVsRegisterProjectDebugTargetProvider),
    version(1.0),
    pointer_default(unique)
]
interface IVsRegisterProjectDebugTargetProvider : IUnknown 
{
    HRESULT AddDebugTargetProvider ([in] IVsProjectDebugTargetProvider *pNewDbgTrgtProvider, [out] IVsProjectDebugTargetProvider **ppNextDbgTrgtProvider);
    HRESULT RemoveDebugTargetProvider ([in] IVsProjectDebugTargetProvider *pDbgTrgtProvider);

}

// declare the service type for interop
[uuid(uuid_SVsRegisterDebugTargetProvider)]
interface SVsRegisterDebugTargetProvider : IUnknown {}

cpp_quote("#define SID_SVsRegisterDebugTargetProvider IID_SVsRegisterDebugTargetProvider")

cpp_quote("extern const __declspec(selectany) GUID GUID_BookmarkWindow =     { 0xa0c5197d, 0xac7, 0x4b63, { 0x97, 0xcd, 0x88, 0x72, 0xa7, 0x89, 0xd2, 0x33 } };")


//---------------------------------------------------------------------------
// IVsBrowseObject
//---------------------------------------------------------------------------
// Implemented by browse object of a project /project item. Used to map back to the 
// object corresponding to the browse object
[
    uuid(uuid_IVsBrowseObject),
    version(1.0),
    pointer_default(unique)
]
interface IVsBrowseObject : IUnknown
{
    HRESULT GetProjectItem([out] IVsHierarchy **pHier, [out] VSITEMID *pItemid);
}


//---------------------------------------------------------------------------
// IVsCfgBrowseObject
//---------------------------------------------------------------------------
// Implemented by browse object of a project configuration. Used to map back to the
// configuration corresponding to the browse object
[
    uuid(uuid_IVsCfgBrowseObject),
    version(1.0),
    pointer_default(unique)
]
interface IVsCfgBrowseObject : IVsBrowseObject
{
    HRESULT GetCfg([out] IVsCfg **ppCfg);
}

// project type CLSID for Solution Folder project {2150E333-8FDC-42a3-9474-1A3956D46DE8}
// cpp_quote("DEFINE_GUID(CLSID_SolutionFolderProject, 0x2150e333, 0x8fdc, 0x42a3, 0x94, 0x74, 0x1a, 0x39, 0x56, 0xd4, 0x6d, 0xe8);")
cpp_quote("extern const __declspec(selectany) CLSID CLSID_SolutionFolderProject = { 0x2150e333, 0x8fdc, 0x42a3, { 0x94, 0x74, 0x1a, 0x39, 0x56, 0xd4, 0x6d, 0xe8 } };") 

enum __VSHPROPID2
{
    /********************************************** defined in vsshell.idl
    VSHPROPID_NIL   = -1,

    // !!!! NOTE !!!!   THIS MUST BE THE SAME AS THE FIRST PROP DEFINED
    VSHPROPID_LAST                = -1000,
    VSHPROPID_Parent                  = -1000, // I4   itemid of Parent node (ITEMID_NIL if no parent)

    // These properties are defined to deterministically walk   the entire contents of the Hierarchy 
    // (or project) independent of which view   is displayed in a UIHierarchyWindow.  Hierarchies 
    // that support special views   that either show a subset of items or a superset of member 
    // items and non-member items   must implement 
    // VSHPROPID_   FirstVisibleChild/NextVisibleSibling/IsHiddenItem/IsNonMemberItem.
    VSHPROPID_FirstChild              = -1001, // INT_PTR itemid of 1st child node (ITEMID_NIL if no children)
    VSHPROPID_NextSibling             = -1002, // INT_PTR itemid of next sibling node (ITEMID_NIL if no more siblings) 

    VSHPROPID_Root                = -1003, // INT_PTR [obsolete] itemid of Root must be VSITEMID_ROOT.
    VSHPROPID_TypeGuid            = -1004, // GUID to identify type of node/hierarchy, search on GUID_ItemType
    VSHPROPID_SaveName            = -2002, // BSTR Needed so Shell (i.e. File.Save menu) can display UI.
    VSHPROPID_Caption                 = -2003, // BSTR Needed so Shell (i.e. project window) can display UI.
    VSHPROPID_IconImgList             = -2004, // I4   For icon. Handle to imagelist (Only for itemid==VSITEMID_ROOT)
    VSHPROPID_IconIndex           = -2005, // I4   For icon.  If Expandable=TRUE, then IconIndex+1 is used for open icon.
    // Hierarchy    should support IconHandle or IconImageList/IconIndex but not both.
    VSHPROPID_Expandable              = -2006, // BOOL Should Shell display the "open-this-folder" plus sign?
    VSHPROPID_ExpandByDefault         = -2011, // BOOL Should Shell expand this item?
    VSHPROPID_ProjectName             = -2012, // BSTR [obsolete] use VSHPROPID_Name instead
    VSHPROPID_Name                = -2012, // BSTR Name for project (VSITEMID_ROOT) or item
    VSHPROPID_IconHandle              = -2013, // I4   handle of an icon, UIHierarchyWindow will NOT call DestroyIcon on it
    // Hierarchy    should support IconHandle or IconImageList/IconIndex but not both.
    VSHPROPID_OpenFolderIconHandle  =   -2014, // I4   [optional] handle of an icon for an open folder, UIHierarchyWindow will NOT call DestroyIcon on it
    VSHPROPID_OpenFolderIconIndex     = -2015, // I4   [optional] for icon
    VSHPROPID_CmdUIGuid           = -2016, // GUID for cmdbars (for root only)
    VSHPROPID_SelContainer        = -2017, // UNK  [optional] Returns an ISelectionContainer for property browsing
    VSHPROPID_BrowseObject        = -2018, // DISP [optional] Returns an IDispatch for property browsing
    // Hierarchy    should support SelContainer or BrowseObject but not both.
    VSHPROPID_AltHierarchy        = -2019, // UNK  [optional] Returns an IVsHierarchy for SVsTrackSelectionEx
    VSHPROPID_AltItemid           = -2020, // I4   [optional] Returns an itemid for SVsTrackSelectionEx
    VSHPROPID_ProjectDir              = -2021, // BSTR [optional] full path to project directory (for VSITEMID_ROOT only)
    VSHPROPID_SortPriority        = -2022, // I4   [optional] Sort priority in UIHierarchyWindow. Standard projects have priority 0 (default).
    //                MiscFiles project has priority 10000, SolutionItems project has priority 9999.
    VSHPROPID_UserContext             = -2023, // UNK  [optional] IVsUserContext for project/item
    VSHPROPID_EditLabel           = -2026, // BSTR [optional] string displayed for in-place editing node caption
    VSHPROPID_ExtObject           = -2027, // DISP [optional] For ITEMID_ROOT this is the ext.object of the project (Project).
    // For other    itemids it is that item's ext object (ProjectItem), if any.
    VSHPROPID_ExtSelectedItem         = -2028, // DISP [optional] Returns a custom SelectedItem object for the given itemid.
    // If not supported,    then a default implementation will be provided.
    VSHPROPID_StateIconIndex          = -2029, // I4   For state icon index. Use VsStateIcon enumeration
    VSHPROPID_ProjectType             = -2030, // BSTR [obsolete] use VSHPROPID_TypeName instead
    VSHPROPID_TypeName            = -2030, // BSTR display name to identify type of node/hierarchy (used in title bar)
    VSHPROPID_ReloadableProjectFile =   -2031, // BOOL [obsolete] use VSHPROPID_HandlesOwnReload
    VSHPROPID_HandlesOwnReload    = -2031, // BOOL [optional] project handles unload/reload itself (otherwise environment handles)
    // (Defaults    to FALSE)
    VSHPROPID_ParentHierarchy         = -2032, // UNK  IVsHierarchy that owns this hierarchy.  Hold as UNADDREF'ed ptr in SetProperty.
    VSHPROPID_ParentHierarchyItemid =   -2033, // INT_PTR The itemid of this hierarchy in it's parent hierarchy
    VSHPROPID_ItemDocCookie       = -2034, // INT_PTR [optional] the doc cookie (VSCOOKIE) of the hierarchy item
    VSHPROPID_Expanded            = -2035, // BOOL whether the node is currently expanded in the UIHierarchyWindow, start as FALSE
    // and UIHierarchyWindow    will update
    VSHPROPID_ConfigurationProvider =   -2036, // UNK  OBSOLETE. Use IVsGetCfgProvider interface instead
    VSHPROPID_ImplantHierarchy    = -2037, // UNK  [optional] IVsHierarchy implant for this hierarchy. Hold as UNADDREF'ed ptr in SetProperty.
    // Implant can implement    IVsFilterAddProjectItemDlg and/or IVsToolboxUser.
    VSHPROPID_OwnerKey            = -2038, // BSTR [optional] owner key string that identifies the project GUID of the owning project.
    // only projects    that implement IVsOwnedProjectFactory should support SetProperty for this property.
    VSHPROPID_StartupServices         = -2040, // UNK  [optional] Returns an IVsProjectStartupServices* to add services to be 
    // started on next project load (for    VSITEMID_ROOT only)
    VSHPROPID_FirstVisibleChild   = -2041, // INT_PTR [optional] similar to FirstChild but only walks items to be displayed in UIHierarchyWindow.
    // required if hierarchy    supports multiple (subsetted or supersetted)  views of its contents.
    VSHPROPID_NextVisibleSibling      = -2042, // INT_PTR [optional] similar to NextSibling but only walks items to be displayed in UIHierarchyWindow.
    // required if hierarchy    supports multiple (subsetted or supersetted)  views of its contents. 
    VSHPROPID_IsHiddenItem        = -2043, // BOOL [optional] is item not displayed in current UIHierarchyWindow view. required if hierarchy 
    // supports multiple    (subsetted)  views of its contents.
    VSHPROPID_IsNonMemberItem         = -2044, // BOOL [optional] is item not considered a member of the hierarchy. required if hierarchy supports 
    // (supersetted)    views of its contents (e.g. ShowAllFiles displaying files in directory that are not members of the project).
    VSHPROPID_IsNonLocalStorage   = -2045, // BOOL [optional] is project storage local? IPersistFileFormat is used for
    // saving project regardless    of whether it is a local "file" or not.
    VSHPROPID_StorageType             = -2046, // BSTR [optional] non-localize string representing storage type. same as string used in VSDIR file
    // to differentiate between different location MRU lists.
    VSHPROPID_ItemSubType             = -2047, // BSTR [optional] non-localize string representing the subtype of the item.
    // It is    up to each package to agree on the meaning of this string.
    VSHPROPID_OverlayIconIndex    = -2048, // I4 [optional] Use VSOVERLAYICON enum.  Overlay for the item's main icon
    VSHPROPID_DefaultNamespace    = -2049, // BSTR [optional] string representing the items folder based namespace: rootnamespace.folder.subfolder
    VSHPROPID_IsNonSearchable         = -2051, // BOOL [optional] is item not search-and-replace-able via Find/Replace in Files. Should be true for project file itself.
    VSHPROPID_IsFindInFilesForegroundOnly   =  -2052, // BOOL [optional] if true, Find In Files runs in main thread
    VSHPROPID_CanBuildFromMemory      = -2053, // BOOL [optional] if TRUE, we dont need to prompt to save before building
    VSHPROPID_PreferredLanguageSID  =   -2054, // GUID [optional] preferred SID of (text editor) language service for project.
    // (e.g.    used to determine default language for BreakPoint dialog)
    VSHPROPID_ShowProjInSolutionPage = -2055,// BOOL [optional] used to filter project when vb/c#   call the component picker for add-reference.
    // Return VARIANT_TRUE to show the project in the list.
    VSHPROPID_AllowEditInRunMode      = -2056, // BOOL [optional] If FALSE or E_NOTIMPL, the compiler will disallow edits during run mode
    // (this    is the most common expected behavior).  TRUE allows edits.  This property enables VSA scenarios.
    VSHPROPID_IsNewUnsavedItem    = -2057, // BOOL [optional] If TRUE, this is a new unsaved item (as obtained from File.New.File) 
    // so the moniker will be a temporary name and the caption should be    used in the UI instead.
    VSHPROPID_ShowOnlyItemCaption     = -2058, // BOOL [optional] If TRUE, this is an item for which only the caption should be shown in the UI instead of the full moniker.
    VSHPROPID_ProjectIDGuid       = -2059, // GUID [optional] Identifies a project across solutions.  Generated and set when project is created.  Retrieved when project is opened.

    VSHPROPID_DesignerVariableNaming = -2060,   // I4 [optional] from the VSDESIGNER_VARIABLENAMING enumeration
    VSHPROPID_DesignerFunctionVisibility = -2061,   // I4 [optional] from the VSDESIGNER_FUNCTIONVISIBILITY enum

    VSHPROPID_HasEnumerationSideEffects =   -2062, // BOOL [optional] If TRUE, then this hierarchy will not be enumerated for FindInFiles and  similar
    // hierarchy    enumerations. (useful if enumerating might cause a login dialog or is unacceptably slow)

    VSHPROPID_DefaultEnableBuildProjectCfg = -2063, // BOOL [optional] Should   "Build" be initially checked by default in the solution cfg
    // Normally "Build" is checked by   default if the project supports IVsBuildableProjectCfg

    VSHPROPID_DefaultEnableDeployProjectCfg =   -2064, // BOOL [optional] Should "Deploy" be initially checked by default in the solution cfg
    // Normally "Deploy" is checked by default if   the project supports IVsDeployableProjectCfg

    // !!!! NOTE !!!!   THIS MUST BE THE SAME AS THE LAST PROP DEFINED
    VSHPROPID_FIRST               = -2064

    **********************************************/ 

    VSHPROPID_PropertyPagesCLSIDList    = -2065, // BSTR [optional] semi-colon delimited list of clsids of the config independent property pages
    VSHPROPID_CfgPropertyPagesCLSIDList = -2066, // BSTR [optional] semi-colon delimited list of clsids of the config dependent property pages

    VSHPROPID_ExtObjectCATID            = -2067, // GUID [optional] Intrinsic Extender CATID of the ExtObject (Automation Object) for the given IVsHierarchy Itemid. For VSITEMID_ROOT this corresponds to the type of the 'Project' object
    VSHPROPID_BrowseObjectCATID         = -2068, // GUID [optional] Intrinsic Extender CATID of the BrowseObject for the given IVsHierarchy Itemid. For VSITEMID_ROOT this corresponds to the object used to build the 'Project.Properties' collection.
    VSHPROPID_CfgBrowseObjectCATID      = -2069, // GUID [optional] Intrinsic Extender CATID of the configuration BrowseObject for the given IVsHierarchy Itemid
    VSHPROPID_AddItemTemplatesGuid      = -2070, // GUID [optional] alternate project type guid to use to get add item templates
    VSHPROPID_ChildrenEnumerated        = -2071, // BOOL [optional] returns TRUE if children have been enumerated. Typically, this is only of interest for project
    // where enumerating children can be expensive (eg. Web projects)
    VSHPROPID_StatusBarClientText       = -2072, // BSTR hierarchy scoped text for Client Text field of status bar. This text is displayed
    // while the given hierarchy is the active hierarchy. VT_EMPTY clears hierarchy scoped 
    // text and resets to global text specified by the application.
    VSHPROPID_DebuggeeProcessId         = -2073, // process id of debuggee if known, otherwise zero
    VSHPROPID_IsLinkFile                = -2074,
    VSHPROPID_KeepAliveDocument         = -2075, // BOOL [optional] TRUE if the document should be kept alive in the project regardless of opened/closed state
    VSHPROPID_SupportsProjectDesigner   = -2076, // BOOL [optional] TRUE if the project uses a Project Designer Editor instead of the property page frame to edit project properties
    VSHPROPID_IntellisenseUnknown       = -2077, // IUnknown [optional] returns the IUnknown of the Intellisense compiler used by the project system
    VSHPROPID_IsUpgradeRequired         = -2078, // BOOL [optional] TRUE if the item or any of its children either already in the process of upgrading or must be upgraded
    VSHPROPID_DesignerHiddenCodeGeneration = -2079, // I4 Indicates which code is supposed to go to the hidden designer file.  Bit flag values in __VSDESIGNER_HIDDENCODEGENERATION
    VSHPROPID_SuppressOutOfDateMessageOnBuild = -2080, // BOOL [optional] TRUE if the project does not want to participate in the "this configuration is out of date" message on Build/F5
    VSHPROPID_Container                 = -2081, // BOOL [optional] TRUE if the item is a container (it may not be expandable, but it contains items).
    // support this property if your folder is not expandable but contains items that should be include in SCC operations.
    VSHPROPID_UseInnerHierarchyIconList = -2082, // BOOL [optional] set this to TRUE in the outer hierarchy if you want the icon for an inner (nested) hierarchy root to come from the inner hierarchy image list.
                                                 // by default we're getting that icon from the outer hierarchy image list.
    VSHPROPID_EnableDataSourceWindow   = -2083, // BOOL [optional] set this to TRUE in your hierarchy to disable the Data Source Window for this project.    
    VSHPROPID_AppTitleBarTopHierarchyName  = -2084, // BSTR [optional] Gives the hierarchy a chance to put its topmost name (solution or server) into the titlebar of the app. ie Foo part of "Foo - Microsoft Visual Studio"
    VSHPROPID_DebuggerSourcePaths          = -2085, // BSTR [optional] semi-colon delimited list of paths for the debugger to look for source in
    VSHPROPID_CategoryGuid            = -2086, // GUID to identify the family/category of this non-Solution based Hierarchy (e.g. Portfolio Project Hierarchy)
    VSHPROPID_DisableApplicationSettings = -2087, // BOOL [optional] set this to TRUE in your hierarchy to disable Application Settings design time support in your project.
    VSHPROPID_ProjectDesignerEditor        = -2088, // GUID [optional] GUID of the Project Designer Editor that the project uses to edit project properties
                                                    // (VSHPROPID_SupportsProjectDesigner should return VARIANT_TRUE if a ProjectDesignerEditor GUID is returned)
                                                    // This GUID should correspond to an IVsEditorFactory that launches an editor for the Project Properties.
                                                    // A Project Designer is an editor for Project properties that is launched as a document associated with the 
                                                    // root of the project. (see IVsSpecifyProjectDesignerPages below for more info)
    VSHPROPID_PriorityPropertyPagesCLSIDList = -2089, // BSTR [optional] semi-colon delimited ordered list of clsids of the prefered property pages.
                                                    // A Project Designer that shows config independent and config dependent property pages in a 
                                                    // flat list should use this order as the prefered order for the pages. A project that uses 
                                                    // the standard property page frame can ignore this property because the property page frame
                                                    // does not mix the two type of pages in a flat list.
    VSHPROPID_NoDefaultNestedHierSorting  = -2090,  // BOOL [optional] TRUE if the hierarchy DOES NOT want nested hierarchies sorted first and items after, and sorted alphabetically (like solution folders)
    VSHPROPID_ExcludeFromExportItemTemplate = -2091,  // BOOL [optional, default is FALSE] TRUE if the project item can not be exported via export item template
    VSHPROPID_SupportedMyApplicationTypes = -2092,  // BSTR [optional] semi-colon delimited list of application-types supported for project-systems that
                                                    // support My.Application. The property-page that exposes information about My.Application can use this 
                                                    // list to determine which values appear in the application-type dropdown as selectable choices for the user.
                                                    // The current list of supported values for VB's implementation is:
                                                    //
                                                    // WindowsApp       - a WinExe with support for Windows application concepts such as My.Forms
                                                    // WindowsClassLib  - a Dll with support for Windows application concepts such as My.Forms
                                                    // CommandLineApp   - a command-line Exe
                                                    // WindowsService   - an Exe that can be run as a Windows Service
                                                    // WebControl       - a Dll with support for Web application concepts
                                                    //
                                                    // An example value that supports all types is "WindowsApp;WindowsClassLib;CommandLineApp;WindowsService;WebControl"


    // !!!! NOTE !!!!   THIS MUST BE THE SAME AS THE LAST PROP DEFINED
    // when this is extended in the next version idl, uses of it must be changed to the new value
    VSHPROPID_FIRST2               = -2092
};
typedef [public] DWORD VSHPROPID2;

enum __VSDESIGNER_HIDDENCODEGENERATION 
{
    VSDHCG_Declarations = 1,
    VSDHCG_InitMethods = 2,
    VSDHCG_EventMethods = 4
};

// Values used in VSPROPID_ProjectLoadSecurityDialogState.
enum _ProjectLoadSecurityDialogState
{
    PLSDS_ShowAgain = 1,
    PLSDS_DontShowAgainBrowse = 2,
    PLSDS_DontShowAgainFullLoad = 3,
    PLSDS_DontShowAgainUnload = 4
};
typedef DWORD ProjectLoadSecurityDialogState;

enum __VSPROPID2
{
    /********************************************** defined in vsshell.idl
    VSPROPID_LAST                          = -8000,
    VSPROPID_SolutionDirectory         = -8000, // BSTR directory where solution file is saved
    VSPROPID_SolutionFileName              = -8001, // BSTR full path to solution file
    VSPROPID_UserOptionsFileName           = -8002, // BSTR full path to user options file
    VSPROPID_SolutionBaseName              = -8003, // BSTR (Get/Set) base name of solution file
    VSPROPID_IsSolutionDirty               = -8004, // BOOL is solution file dirty
    VSPROPID_IsSolutionOpen            = -8005, // BOOL is a solution file open
    VSPROPID_ProjectCount                  = -8006, // I4 count of projects open in solution
    VSPROPID_RegisteredProjExtns           = -8007, // BSTR semicolon-separated list of all project extensions
    VSPROPID_OpenProjectFilter         = -8008, // BSTR filter/entension list used in Open Project dialog
    VSPROPID_FileDefaultCodePage           = -8009, // I4 codepage for saving files (CP_ACP/CP_WINUNICODE)
    VSPROPID_SolutionFileNameBeingLoaded = -8010,   // BSTR full path to file being opened (valid only during open)
    VSPROPID_SolutionNodeCaption           = -8011, // BSTR caption for solution node in Project Explorer
    VSPROPID_IsSolutionOpening         = -8013, // BOOL is a solution file being opened
    VSPROPID_IsSolutionSaveAsRequired      = -8014, // BOOL will saving the solution require a Save As dialog
    VSPROPID_CountOfProjectsBeingLoaded  = -8015,   // I4 count of projects in file being opened (valid only during open)
    VSPROPID_SolutionPropertyPages     = -8016, // BSTR a semi-colon delimited list of clsid's of sln level prop pages
    VSPROPID_FIRST                     = -8016
    **********************************************/ 
    VSPROPID_IsSolutionNodeHidden       = -8017, // BOOL True if the sln node is hidden in the IDE   
    VSPROPID_DeferredSaveSolution       = -8018, // BOOL is solution "zero-impact" (permanent save is performed explicitly via File.SaveAll)?
    VSPROPID_SimplifiedConfigurations   = -8019, // BOOL True if the solution is in simplified configuration mode
    VSPROPID_IsSolutionClosing          = -8020, // BOOL is a solution file being closed
    VSPROPID_IsAProjectClosing          = -8021, // IUnknown of IVsHierarchy of project being closed
    VSPROPID_IsSolutionOpeningDocs      = -8022, // BOOL is the solution re-opening the documents that were open when the solution was last closed?
    VSPROPID_IsOpenNotificationPending  = -8023, // BOOL is the OnAfterOpenSolution notification pending (is a new project being created with a new solution)?
    VSPROPID_ProjectLoadSecurityDialogState = -8024, // I4, state of the project load security dialog kept between different lang packages
    VSPROPID_SolutionUserFileCreatedOnThisComputer = -8025, // BOOL, True if the .suo file accompanying the solution file was originally created on the same
                                                            // computer it's being opened on. Check inside IVsPersistSolutionOpts.ReadUserOptions. Read only.
    VSPROPID_NewProjectDlgPreferredLanguage = -8026, // BSTR, preferred language for the New Project dialog; if there is no preferred language an empty length string is returned.
                                                     // If there is a preferred language, then the non-preferred language project types are displayed under an "Other Languages" node in the New Project dialog. The preferred language is set by the
                                                     // user's choice of development settings in the "Import and Export Settings" dialog. Any project type can designate itself as a "Language" project by registering a "DeveloperActivity" reg value
                                                     // with the string for their language (e.g. "VB", "VC#", "VC++", "VJ#") under their top-level template directories for the New Project Dialog, e.g.:
                                                     // [HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\VisualStudio\8.0\NewProjectTemplates\TemplateDirs\{FFFFFFFF-EEE-DDDD-CCCC-BBBBBBAAAAAA}\/1] "DeveloperActivity"="MYLANG"
                                                     // The Language Project can create its own Developer Settings Profile .vssettings file with the following section:
                                                     // <Category name="Environment_NewProjectDialogPreferredLanguage" Category="{77E22C0C-9F4A-4bfb-AD3A-3F3F4711E9ED}" Package="{DA9FB551-C724-11d0-AE1F-00A0C90FFFC3}" RegisteredName="Environment_NewProjectDialogPreferredLanguage">
                                                     //   <PropertyValue name="HasNewProjectDialogPreferredLanguage">true</PropertyValue>
                                                     //   <PropertyValue name="NewProjectDialogPreferredLanguage">MYLANG</PropertyValue>
                                                     // </Category>
                                                     // Occurrences of "MYLANG" would be replaced with the appropriate string for the language.

    // !!!! NOTE !!!!   THIS MUST BE THE SAME AS THE LAST PROP DEFINED
    // when this is extended in the next version idl, uses of it must be changed to the new value
    VSPROPID_FIRST2                     = -8026
};
typedef [public] DWORD VSPROPID2;

//----------------------------------------------------------------------------
// property ids for IVsCfgProvider2::GetCfgProviderProperty calls
enum __VSCFGPROPID2
{
    /********************************************** defined in vsshell.idl
    VSCFGPROPID_LAST              = -16000,  // first value should be a unique among propids
    VSCFGPROPID_Reserved1                 = -16000,
    VSCFGPROPID_Reserved2                 = -16001,
    VSCFGPROPID_SupportsCfgAdd        = -16002,
    VSCFGPROPID_SupportsCfgDelete         = -16003,
    VSCFGPROPID_SupportsCfgRename         = -16004,
    VSCFGPROPID_SupportsPlatformAdd   = -16005,
    VSCFGPROPID_SupportsPlatformDelete  =   -16006,
    VSCFGPROPID_SupportsPrivateCfgs   = -16007,
    VSCFGPROPID_IntrinsicExtenderCATID  =   -16008,
    VSCFGPROPID_FIRST             = -16008,
    **********************************************/ 

    VSCFGPROPID_HideConfigurations      = -16009,    // BOOL [optional] if true then configurations will be hidden 
    // when this project is the active selected project in the 
    // selection context.
    VSCFGPROPID_FIRST2                  = -16009
};
typedef LONG VSCFGPROPID2;

enum __VSCREATEPROJFLAGS2
{
    /********************************************** defined in vsshell.idl
    CPF_CLONEFILE       = 0x00000001,
    CPF_OPENFILE        = 0x00000002,
    CPF_OPENDIRECTORY   = 0x00000004,
    CPF_SILENT          = 0x00000008,
    CPF_OVERWRITE       = 0x00000010,
    CPF_NOTINSLNEXPLR   = 0x00000020,    // project is not shown as a normal project in Solution Explorer
    CPF_NONLOCALSTORE   = 0x00000040,    // project uses non-local storage and different save mechanism
    **********************************************/ 

    CPF_DEFERREDSAVE        = 0x00000080,    // project is "zero-impact": permanent save is performed explicitly via File.SaveAll
    CPF_OPEN_ASYNCHRONOUSLY = 0x00000100,    // project is being opened asynchronously, i.e. it is possible that not all files are on disk yet
    CPF_OPEN_STANDALONE     = 0x00000200,    // commands to open the project specified and don't look for a solution containing the project. Valid only with CPF_OPENFILE.
};
typedef DWORD VSCREATEPROJFLAGS2;

enum __VSCREATESOLUTIONFLAGS2
{
    /********************************************** defined in vsshell.idl
    CSF_SILENT                 = 0x00000001, // create the solution silently, do not query the user at all
    CSF_OVERWRITE              = 0x00000002, // overwrite existing solution if one exists with the specified name at the specified location
    CSF_TEMPORARY              = 0x00000004, // create a temporary solution--solution items cannot be added until it is saved
    CSF_DELAYNOTIFY            = 0x00000008, // delay OnAfterOpenSolution notification until after creation of first project
    **********************************************/ 

    CSF_HIDESOLUTIONNODEALWAYS = 0x00000010, // don't show the solution node
    CSF_DEFERREDSAVESOLUTION   = 0x00000020, // solution is "zero-impact": permanent save is performed explicitly via File.SaveAll
};
typedef [public] DWORD VSCREATESOLUTIONFLAGS2;

enum __VSSLNOPENOPTIONS2
{
    /********************************************** defined in vsshell.idl
    SLNOPENOPT_Silent            = 0x00000001,  // solution file is opened silently (no user feedback)
    SLNOPENOPT_AddToCurrent      = 0x00000002,  // solution file is merged into currently open solution
    SLNOPENOPT_DontConvertSLN    = 0x00000004,  // a solution file from a previous product is not opened
    **********************************************/ 
    SLNOPENOPT_LoadingAsync      = 0x00000008,  // loading solution asynchronously--mark nonexistent projects as "(loading)" rather than "(unavailable)"
};
typedef DWORD VSSLNOPENOPTIONS2;

enum __VSADDITEMFLAGS2
{
    /********************************************** defined in vsshell.idl
    VSADDITEM_AllowMultiSelect       = 0x00000001,  // multi-select
    VSADDITEM_HideNameField          = 0x00000002,  // disable the item name field
    VSADDITEM_SuggestTemplateName    = 0x00000008,  // suggest template name for item
    VSADDITEM_ShowLocationField      = 0x00000010,  // show the location field
    VSADDITEM_ShowDontShowAgain      = 0x00000040,  // show the "Don't show again" checkbox
    VSADDITEM_AllowStickyFilter      = 0x00000080,  // allow pbstrFilter[out] parameter to be returned
    VSADDITEM_AddNewItems            = 0x00000100,  // use the Add New Item dialog (mutually exclusive with VSADDITEM_AddExistingItems)
    VSADDITEM_AddExistingItems       = 0x00000200,  // use the Add Existing Item dialog (mutually exclusive with VSADDITEM_AddNewItems)
    **********************************************/ 
    VSADDITEM_NoUserTemplateFeatures = 0x00001000,  // dialog does not have 'Standard Templates/User-defined Templates' tabs or 'Online Templates' button
    /********************************************** defined in vsshell.idl
    VSADDITEM_ProjectHandlesLinks    = 0x00008000,  // project adds items as links--enables "Link" menu item
    VSADDITEM_NewDirectoryForItem    = 0x00010000,  // item is placed in new directory (location field tracks name field)
    VSADDITEM_AllowHiddenTreeView    = 0x00020000,  // allow tree view to be hidden if only one template node present
    **********************************************/ 
    VSADDITEM_ShowOpenButtonDropDown = 0x00040000,  // show drop-down menu under Open button on dialog (default is to not dropdown, see comment for VSADDITEM_NoOpenButtonDropDown)
    /********************************************** defined in vsshell.idl
    VSADDITEM_NoOpenButtonDropDown   = 0x00080000,  // don't show drop-down menu under Open button on dialog (OBSOLETE/default, use VSADDITEM_ShowOpenButtonDropDown to show dropdown)
    VSADDITEM_AllowSingleTreeRoot    = 0x00100000,  // allow the tree view to have only one root node (default is to use sub-nodes)
    VSADDITEM_ExpandSingleTreeRoot   = 0x00200000,  // ask the tree view to expand a single root node (default is to not expand it)
    VSADDITEM_ShowProjectTypesOnly   = 0x00400000,  // show only project types in the dialog (not items associated with projects)
    VSADDITEM_AllowOnlyFileSysLocs   = 0x00800000,  // allow only local file system locations in the Add Existing Item dialog (no http://)
    **********************************************/ 
};
typedef DWORD VSADDITEMFLAGS2;

enum __VSCREATEEDITORFLAGS2
{
    /********************************************** defined in vsshell.idl
    CEF_CLONEFILE    = 0x00000001,   // Mutually exclusive w/_OPENFILE
    CEF_OPENFILE     = 0x00000002,   // Mutually exclusive w/_CLONEFILE
    CEF_SILENT       = 0x00000004,   // Editor factory should create editor silently
    CEF_OPENASNEW    = 0x00000008,   // Editor factory should perform necessary fixups
    **********************************************/ 
    CEF_OPENSPECIFIC = 0x00000010,   // Editor factory must open document if possible (invoked via IVsUIShellOpenDocument::OpenSpecificEditor)
};
typedef DWORD VSCREATEEDITORFLAGS2;

enum __VSOSEFLAGS2
{
    /********************************************** defined in vsshell.idl
    OSE_RDTFLAGS_MASK           =  0x000FFFFF,
    OSE_UseOpenWithDialog       =  0x10000000,
    OSE_ChooseBestStdEditor     =  0x20000000,
    OSE_OpenAsNewFile           =  0x40000000,
    **********************************************/ 
    OSE_CheckTrustLevelOfWizard =  0x00100000,
};
typedef DWORD VSOSEFLAGS2;

enum __VSOSPEFLAGS2
{
    /********************************************** defined in vsshell.idl
    OSPE_RDTFLAGS_MASK           =  0x000FFFFF,
    OSPE_CDWFLAGS_MASK           =  0x00FFFFFF,
    OSPE_OpenAsNewFile           =  0x10000000,
    **********************************************/ 
    OSPE_CheckTrustLevelOfWizard =  0x00100000,
};
typedef DWORD VSOSPEFLAGS2;

enum __VSWIZARDTRUSTLEVEL
{
    WTL_Trusted     = 1,
    WTL_Untrusted   = 2,
    WTL_Unspecified = 3,
};
typedef DWORD VSWIZARDTRUSTLEVEL;

enum __VSEDITORTRUSTLEVEL
{
    ETL_NeverTrusted             =  0,
    ETL_AlwaysTrusted            =  1,
    ETL_HasUntrustedLogicalViews =  2,
};
typedef DWORD VSEDITORTRUSTLEVEL;

//---------------------------------------------------------------------------
// IVsDetermineWizardTrust
//---------------------------------------------------------------------------
[
    uuid(uuid_IVsDetermineWizardTrust),
    version(1.0),
    pointer_default(unique)
]
interface IVsDetermineWizardTrust : IUnknown
{
    // set state that a wizard (project or item) is about to start running.
    HRESULT OnWizardInitiated([in] LPCOLESTR pszTemplateFilename, [in] REFGUID guidProjectType);
    // set state that a wizard (project or item) has just stopped running.
    HRESULT OnWizardCompleted();
    // is a wizard currently running (between initiated and completed)?
    HRESULT IsWizardRunning([out] BOOL *pfWizardRunning);
    // what is the name of the template the wizard is running?
    HRESULT GetRunningWizardTemplateName([out] BSTR *pbstrRunningTemplate);
    // is the currently running wizard marked as trusted?
    HRESULT GetWizardTrustLevel([out] VSWIZARDTRUSTLEVEL *pdwWizardTrustLevel);
    // mark the currently running wizard as trusted.
    HRESULT SetWizardTrustLevel([in] VSWIZARDTRUSTLEVEL dwWizardTrustLevel);
};

[
    uuid(uuid_SVsDetermineWizardTrust)
]
interface SVsDetermineWizardTrust : IUnknown
{
}

cpp_quote("#define SID_SVsDetermineWizardTrust IID_SVsDetermineWizardTrust")

//---------------------------------------------------------------------------
// IVsSolutionEvents4
//---------------------------------------------------------------------------
[
    uuid(uuid_IVsSolutionEvents4),
    version(1.0),
    pointer_default(unique)
]
interface IVsSolutionEvents4 : IUnknown
{
    // fired after a project has been renamed
    HRESULT OnAfterRenameProject([in] IVsHierarchy *pHierarchy);
    // fired before a project is moved from one parent to another in the solution explorer
    HRESULT OnQueryChangeProjectParent([in] IVsHierarchy *pHierarchy, [in] IVsHierarchy *pNewParentHier, [in,out] BOOL *pfCancel);
    // fired after a project has been moved from one parent to another in the solution explorer
    HRESULT OnAfterChangeProjectParent([in] IVsHierarchy *pHierarchy);
    // fired after a project has been opened asynchronously
    HRESULT OnAfterAsynchOpenProject([in] IVsHierarchy *pHierarchy, [in] BOOL fAdded);
};

//---------------------------------------------------------------------------
// IVsFireSolutionEvents2
//---------------------------------------------------------------------------
[
    uuid(uuid_IVsFireSolutionEvents2),
    version(1.0),
    pointer_default(unique)
]
interface IVsFireSolutionEvents2 : IUnknown
{
    HRESULT FireOnAfterRenameProject([in] IVsHierarchy *pHierarchy);
    HRESULT FireOnQueryChangeProjectParent([in] IVsHierarchy *pHierarchy, [in] IVsHierarchy *pNewParentHier);
    HRESULT FireOnAfterChangeProjectParent([in] IVsHierarchy *pHierarchy);
    HRESULT FireOnAfterAsynchOpenProject([in] IVsHierarchy *pHierarchy, [in] BOOL fAdded);
};

//---------------------------------------------------------------------------
// IVsPrioritizedSolutionEvents
//
// These event have the same signature and purpose as the other solution events,
// but these events are fired with a different priority so that those notification
// sinks that must be notified before other sinks are notified can be notified first.
//
// Here is the order:
// PrioritizedOnAfter*** events are fired before the OnAfter*** events
// PrioritizedOnBefore*** events are fired after the OnBefore*** events
//
// For example, a background compiler may need to be started before other dependent
// processes start using it, and it may need to shut down after the other dependent
// process stop using it.  So the background compiler can be started up when the
// PrioritizedOnAfterOpenSolution event is fired, so that when other processes
// respond to the OnAfterOpenSolution event, the compiler is ready.  The compiler
// is shut down when the PrioritizedOnBeforeCloseSolution event is fired, so that
// when other processes respond to the OnBeforeCloseSolution event, the compiler
// is still present and available.
//---------------------------------------------------------------------------
[
    uuid(uuid_IVsPrioritizedSolutionEvents),
    version(1.0),
    pointer_default(unique)
]
interface IVsPrioritizedSolutionEvents : IUnknown
{
    HRESULT PrioritizedOnAfterOpenProject([in] IVsHierarchy *pHierarchy, [in] BOOL fAdded);
    HRESULT PrioritizedOnBeforeCloseProject([in] IVsHierarchy *pHierarchy, [in] BOOL fRemoved);
    HRESULT PrioritizedOnAfterLoadProject([in] IVsHierarchy *pStubHierarchy, [in] IVsHierarchy *pRealHierarchy);
    HRESULT PrioritizedOnBeforeUnloadProject([in] IVsHierarchy *pRealHierarchy, [in] IVsHierarchy *pStubHierarchy);
    HRESULT PrioritizedOnAfterOpenSolution([in] IUnknown *pUnkReserved, [in] BOOL fNewSolution);
    HRESULT PrioritizedOnBeforeCloseSolution([in] IUnknown *pUnkReserved);
    HRESULT PrioritizedOnAfterCloseSolution([in] IUnknown *pUnkReserved);
    HRESULT PrioritizedOnAfterMergeSolution([in] IUnknown *pUnkReserved);
    HRESULT PrioritizedOnBeforeOpeningChildren([in] IVsHierarchy *pHierarchy);
    HRESULT PrioritizedOnAfterOpeningChildren([in] IVsHierarchy *pHierarchy);
    HRESULT PrioritizedOnBeforeClosingChildren([in] IVsHierarchy *pHierarchy);
    HRESULT PrioritizedOnAfterClosingChildren([in] IVsHierarchy *pHierarchy);
    HRESULT PrioritizedOnAfterRenameProject([in] IVsHierarchy *pHierarchy);
    HRESULT PrioritizedOnAfterChangeProjectParent([in] IVsHierarchy *pHierarchy);
    HRESULT PrioritizedOnAfterAsynchOpenProject([in] IVsHierarchy *pHierarchy, [in] BOOL fAdded);
};

//----------------------------------------------------------------------------
// IVsPersistSolutionProps2
//----------------------------------------------------------------------------
// Implemented by Package that supports saving information in .SLN file.
// Interface retrieved by QI from IVsPackage.
[
    uuid(uuid_IVsPersistSolutionProps2),
    version(1.0),
    pointer_default(unique)
]
interface IVsPersistSolutionProps2 : IUnknown
{
    HRESULT OnSolutionLoadFailure([in] LPCOLESTR pszKey);
}

//---------------------------------------------------------------------------
// VSDIR flags for items and projects to indicate desired AddProject/AddItem dialog state.
//---------------------------------------------------------------------------

enum __VSDIRFLAGS2
{
    /********************************************** defined in vsshell.idl
    VSDIRFLAG_NonLocalTemplate     = 0x00000001,  // use "non-local" UI behavior and save mechanisms
    VSDIRFLAG_BlankSolution        = 0x00000002,  // create a "blank" (empty) solution--don't create a project
    VSDIRFLAG_DisableBrowseButton  = 0x00000004,  // disable the Browse button for this project/item
    VSDIRFLAG_DontAddDefExtension  = 0x00000008,  // don't append a default extension to the name provided for the item (invalid for project)
    **********************************************/ 
    VSDIRFLAG_RequiresNewFolder    = 0x00000010,  // new folder is required--creation in an existing folder is not allowed
    /********************************************** defined in vsshell.idl
    VSDIRFLAG_DisableLocationField = 0x00000020,  // disable the location field for this project/item
    **********************************************/ 
    VSDIRFLAG_SolutionTemplate     = 0x00000040,  // template is for a solution rather than a project
    VSDIRFLAG_DeferredSaveProject  = 0x00000080,  // project can be "zero-impact": permanent save is performed explicitly via File.SaveAll
    VSDIRFLAG_DontShowNameLocInfo  = 0x00000100,  // don't show the name field or the static project location info field (useful flag for webs)
    VSDIRFLAG_EnableMasterPage     = 0x00000200,  // Enable the master page checkbox (NewWebItemDlg svc)
    VSDIRFLAG_EnableCodeSeparation = 0x00000400,  // Enable the use code separation checkbox (NewWebItemDlg svc)
    VSDIRFLAG_EnableLangDropdown   = 0x00000800,  // Enable the language dropdown (NewWebItemDlg svc)
    /********************************************** defined in vsshell.idl
    VSDIRFLAG_DontInitNameField    = 0x00001000,  // don't initialize the name field for this project/item with a valid name
    VSDIRFLAG_DisableNameField     = 0x00002000,  // disable the name field for this project/item
    **********************************************/ 
};
typedef DWORD VSDIRFLAGS2;

typedef enum __VSFRAMEMODE2
{
    /********************************************** defined in vsshell.idl
    VSFM_Dock       = 0,
    VSFM_Float      = 1,
    VSFM_MdiChild   = 2,
    VSFM_FloatOnly  = 3,
    **********************************************/ 
    VSFM_AutoHide   = 4
} VSFRAMEMODE2;


enum __VSFPROPID2
{
    /********************************************** defined in vsshell.idl
    VSFPROPID_NIL                 = -1,

    VSFPROPID_LAST            = -3000,
    // The following properties are for all frame   windows
    VSFPROPID_Type            = -3000,  // I4 -> 1 == Document Frame, 2 == Tool Frame
    VSFPROPID_DocView             = -3001,  // UNK object filling client area of window
    VSFPROPID_SPFrame             = -3002,  // UNK IServiceProvider which is site object for DocView object
    VSFPROPID_SPProjContext   = -3003,  // UNK IServiceProvider provided by the owning IVsHierarchy
    //     This can be QS'ed for project context services
    VSFPROPID_Caption             = -3004,  // BSTR -> full window caption
    //VSFPROPID_                  = -3005,  // obsolete
    //VSFPROPID_                  = -3006,  // obsolete
    VSFPROPID_WindowState         = -3007,  // I4 -> see VSWINDOWSTATE above
    VSFPROPID_FrameMode       = -3008,  // I4 -> see VSFRAMEMODE above
    VSFPROPID_IsWindowTabbed      = -3009,  // I2 returns 0 if window not tabbed, 
    //            1 if window is Tabbed and is Active Tab
    //            2 if window is Tabbed and is Not Active tab
    //    Document windows always return 0
    //Note: VSFPROPID_UserContext   should now be used by all toolwindows to push context
    VSFPROPID_UserContext         = -3010,  // UNK IVsUserContext
    VSFPROPID_ViewHelper          = -3011,  // UNK Helper object can override add/override interfaces 
    //     normally implemented on the DocView object
    //     ViewHelper can implement following interfaces:
    //         IVsWindowFrameNotify
    //         IOleCommandTarget
    //         IVsToolboxUser
    //         IVsDocOutlineProvider
    //         IDocHostUIHandler
    //         IVsBackForwardNavigation
    //         IVsWindowView
    //         IVsStatusbarUser
    VSFPROPID_ShortCaption    = -3012,  // BSTR -> partial window caption (ie Foo.Txt)

    //Note: to use the default windowhelp   implementation, leave these properties unset
    //    you should only be using these properties if you are not pushing usercontext
    //    (e.g. you are a help window and don't want to blank out other user context)
    VSFPROPID_WindowHelpKeyword =   -3013,  // BSTR -> keyword to be used for cmdidWindowHelp
    VSFPROPID_WindowHelpCmdText =   -3014,  // BSTR -> command text for cmdidWindowHelp (e.g. Help on: Help Index)

    // The following properties are for all document frames
    VSFPROPID_DocCookie       = -4000,  // VT_INT_PTR -> IVsRunningDocumentTable (RDT) key
    VSFPROPID_OwnerCaption    = -4001,  // BSTR portion of caption defined by owner IVsHierarchy
    VSFPROPID_EditorCaption   = -4002,  // BSTR portion of caption defined by editor implementation
    VSFPROPID_pszMkDocument   = -4003,  // BSTR pszMkDocument passed to CreateDocumentWindow
    VSFPROPID_DocData         = -4004,      // UNK returns the AltDocData if available else the RDTDocData
    VSFPROPID_Hierarchy       = -4005,  // UNK owning IVsHierarchy
    VSFPROPID_ItemID          = -4006,      // I4  VSITEMID of document
    VSFPROPID_CmdUIGuid       = -4007,  // GUID used to control visibility of toolbars and AutoVisible tool windows
    VSFPROPID_CreateDocWinFlags =   -4008,  // I4 VSCREATEDOCWIN flags passed to CreateDocumentWindow 
    VSFPROPID_guidEditorType      = -4009,  // GUID guidEditorType uniquely identify which IVsEditorFactory created the document.
    VSFPROPID_pszPhysicalView     = -4010,  // BSTR identifies the type of window created by the IVsEditorFactory (e.g. "Form")
    VSFPROPID_InheritKeyBindings=   -4011,  // GUID most often used by an window to inherit the key bindings of the TextEditor
    //      e.g.: pFrame->SetGuidProperty(VSFPROPID_InheritKeyBindings, CMDUIGUID_TextEditor)
    VSFPROPID_RDTDocData          = -4012,  // UNK  the DocData registered in the RDT for the document in this frame
    VSFPROPID_AltDocData          = -4013,  // UNK  if this window is only editing a piece of a larger document
    //      then AltDocData is the DocData object for the piece of the document
    //      that is being edited within the window where as the RDTDocData 
    //      is the DocData object for the entire document registered in the RDT.
    //      AltDocData objects are not registered in the RDT. Document Windows
    //      that have AltDocData objects are created using CDW_fAltDocData flag.
    **********************************************/ 
    VSFPROPID_OverrideDirtyState  = -4014,  // BOOL/EMPTY -- tri-state value to control dirty star (*) in window caption 
    //      VT_EMPTY: default handling of dirty star
    //      VARIANT_TRUE: override default handling to SHOW dirty star
    //      VARIANT_FALSE: override default handling to show NO dirty star
    VSFPROPID_OLEDocObjectDocument  = -4015,  // BOOL if pane is holding OLE doc object
    VSFPROPID_ParentHwnd  = -4016,  // HWND parent of OwnerDocked window
    VSFPROPID_ParentFrame = -4017,  // IVsWindowFrame of parent container for OwnerDocked window
    VSFPROPID_ToolWindowDocCookie = -4018,  // VT_INT_PTR -> IVsRunningDocumentTable (RDT) key for document associated with a tool window (eg. Code Definition Window)
                                            // Setting this property enables both caption dirty indicator (*) management and the firing of OnBeforeDocWindowShow() RDT events
                                            // for the tool window.  It is assumed that the frame caption is set correctly, without a dirty indicator (*), before this
                                            // property is set, as setting this property will cause a caption dirty indicator (*) to be added, if the document is dirty.
                                            // Also, when this property is set, the OnBeforeDocWindowShow() RDT event is immediately fired to indicate that a new document has
                                            // been show.

    /********************************************** defined in vsshell.idl
    // The following properties are for all tool frames
    VSFPROPID_GuidPersistenceSlot     = -5000,  // GUID that uniquely identifies a tool window type.
    VSFPROPID_GuidAutoActivate    = -5001,  // GUID OBSOLETE. Do NOT use.
    VSFPROPID_CreateToolWinFlags      = -5002,  // I4 VSCREATETOOLWIN flags passed to CreateToolWindow 

    // the followin properties are for extensibility
    VSFPROPID_ExtWindowObject         = -5003,  // UNK returns the Environment's "Window" automation IDispatch object

    // The following properties are for all tool frames
    VSFPROPID_MultiInstanceToolNum  =   -5004,  // I4 ID of a multi-instance tool window
    VSFPROPID_BitmapResource          = -5006,  // I4 Resource number of bitmap in satellite dll
    VSFPROPID_BitmapIndex             = -5007,  // I4 index into strip if bitmap handle is a strip

    // UNK IVsToolbarHost   used to add toolbars to window.  Property is only valid if 
    // CTW_fToolbarHost or UIHWF_SupportToolWindowToolbars is   specfied.
    VSFPROPID_ToolbarHost             = -5008,  

    VSFPROPID_HideToolwinContainer  =   -5009,  // I2 make the toolwindow's cntr hidden when saving data file

    // !!!! NOTE !!!!   THIS MUST BE THE SAME AS THE LAST PROP DEFINED
    VSFPROPID_FIRST               = -5009,
    **********************************************/ 
};
typedef LONG VSFPROPID2;


cpp_quote("extern const __declspec(selectany) GUID GUID_ImmediateWindow =   { 0xecb7191a, 0x597b, 0x41f5, { 0x98, 0x43, 0x03, 0xa4, 0xcf, 0x27, 0x5d, 0xde } };")

enum __VSSPROPID2
{
    /********************************************** defined in vsshell.idl
    VSSPROPID_LAST              = -9000,
    VSSPROPID_StartupDir            = -9000, // BSTR directory where running executable started up
    VSSPROPID_MDIState          = -9001, // BOOL VARIANT_TRUE if IDE in MDI state, else VARIANT_FALSE
    VSSPROPID_VirtualRegistryRoot   = -9002, // BSTR registry key name (must be appended to HKLM or HKCU)
    VSSPROPID_OpenFileFilter        = -9003, // BSTR open file filter list string
    VSSPROPID_FindInFilesFilter = -9004, // BSTR find in files filter list string
    VSSPROPID_AddExistItemFilter    = -9005, // BSTR add existing item filter list string
    VSSPROPID_IsInOfficeMode        = -9006, // BOOL TRUE if environment is in Office mode
    VSSPROPID_InstallDirectory  = -9007, // BSTR directory where visual studio executable was installed
    VSSPROPID_PreBuildRunPreview    = -9008, // I4 one of PBRP_ values (PBRP_SaveChanges/PBRP_DontSaveChanges/PBRP_PromptForSave)
    VSSPROPID_IsComplexScriptAvail= -9009, //   OBSOLETE
    VSSPROPID_hinstComplexScript    = -9010, // OBSOLETE
    VSSPROPID_hinstMSO          = -9011, // I4, HINSTANCE of mso*.dll
    VSSPROPID_ViewSourceMode        = -9012, // BOOL set to TRUE if environment to be in ViewSourceMode
    VSSPROPID_RecordState           = -9013, // I4, VSRECORDSTATE enum type specifying macro recording state of env.
    VSSPROPID_Zombie                = -9014, // BOOL TRUE if env is in zombie state
    VSSPROPID_AnimationsOn      = -9015, // BOOL TRUE if env animations are on
    VSSPROPID_ProcessingPendingMessageFilterMsg =   -9016, // BOOL TRUE if Processing Pending MessageFilter Msg
    VSSPROPID_IsInteractive     = -9017, // BOOL FALSE if running non-interactive cmd line invokations e.g. /make. OBSOLETE!!! DO NOT USE!!! Use VSSPROPID_IsInCommandLineMode instead.
    VSSPROPID_DetectFileChanges = -9018, // BOOL TRUE if Editors are supposed to watch for filechanges
    VSSPROPID_OpenFromCurrDocDir    = -9019, // BOOL TRUE if Open File operation starts in current document's directory
    VSSPROPID_ReloadChangedFiles    = -9020, // I4, VSRELOADOPTION. tells editors how to respond to externally modified documents
    VSSPROPID_AppDataDir            = -9021, // BSTR application data directory
    VSSPROPID_IsInCommandLineMode   = -9022, // BOOL TRUE if environment is running as a command line tool. Do not bring up any UI in this case!!!. Opposite if VSSPROPID_IsInteractive
    VSSPROPID_ShowOutputPaneOnBuildBegin = -9023,   // BOOL TRUE if we're going to show the ouputpane when we start building
    VSSPROPID_ShowTasklistOnBuildEnd = -9024,   // BOOL TRUE if we're going to show the tasklist when we finish building
    VSSPROPID_hmsoinstMSO           = -9025, // I4, HMSOINST of mso*.dll
    VSSPROPID_ShowMiscFilesProject= -9026, //   BOOL TRUE if we're going to show the Miscellaneous Files project (so it is visible in Solution Explorer)
    VSSPROPID_ObjectMgrTypesImgList =   -9027, // I4, Handle to shell's imagelist for symbol types (class, interface, method etc). Do NOT free. Shell will free upon final shutdown
    VSSPROPID_SCCGlyphsImgList    = -9028, // I4, Handle to shell's imagelist for SCC glyphs (indexed by VsStateIcon). Do NOT free. Shell will free upon final shutdown
    VSSPROPID_SuppressMessageFilterBusyDialog   = -9029, // BOOL  If TRUE the "Component Busy/Retry/Switch" dialog is suppressed (used by VSA for break mode)
    VSSPROPID_VisualStudioProjDir   = -9030, // BSTR full path of location of 'Visual Studio Projects' directory
    VSSPROPID_PreBuildRunPreviewSaveOpts    = -9031, // I4 VSRDTSAVEOPTIONS to pass to IVsRunningDocumentTable::SaveDocuments when VSSPROPID_PreBuildRunPreview != PBRP_DontSaveChanges
    VSSPROPID_FIRST             = -9031
    **********************************************/ 
    VSSPROPID_SccProviderChanged = -9032, // VT_BOOL, Write-only. Set to TRUE when the SCC provider changes
    VSSPROPID_MainWindowSize     = -9033, // VT_UI4, Read-only. The current size of the appid main window encoded as width in LOWORD, height in HIWORD
    VSSPROPID_MainWindowPos      = -9034, // VT_UI4, Read-only. The top-left coordinate of the appid main window encoded as left in LOWORD, top=HIWORD
    VSSPROPID_IsAcademic         = -9035, // VT_BOOL, Read-only. Academic Edition property
    VSSPROPID_IsAppThemed        = -9036, // VT_BOOL, Read-only. VARIANT_TRUE if IDE is themed (using a manifest containing Microsoft.Windows.Common-Controls 6.0)
    VSSPROPID_VisualStudioDir    = -9037, // VT_BSTR, Read-only. Full path of location of 'Visual Studio' directory (under My Documents)
    VSSPROPID_VsTemplateUserZipProjectFolder = -9038, // VT_BSTR, Read-only. Full path of location for user add New Project .vstemplate files (e.g. drive>:\My Documents\Visual Studio\ProjectTemplates\)
    VSSPROPID_VsTemplateUserZipItemFolder = -9039, // VT_BSTR, Read-only. Full path of location for user added Project AddItem .vstemplate files (e.g. drive>:\My Documents\Visual Studio\ItemTemplates\)
    VSSPROPID_InstallRootDir     = -9041, // VT_BSTR, Read-only. Full path of root location of installation (e.g. drive>:\Program Files\Microsoft Visual Studio <version>\)
    VSSPROPID_SolutionExplorerSortingEnabled = -9042, // VT_BOOL. Read/write. Enables/disables sorting of solution explorer nodes.
    VSSPROPID_BuildOutOfDateProjects = -9043, // DWORD, see __BUILDOUTOFDATEPROJECTS for valid values. Can get & set the property.
    VSSPROPID_RunAfterBuildErrors = -9044, // DWORD, see __RUNAFTERBUILDERRORS for valid values. Can get & set the property.
    VSSPROPID_MainWindowVisibility = -9045, // VT_BOOL, Read-only. VARIANT_TRUE if main window is visible, VARIANT_FALSE if invisible.
    VSSPROPID_SKUEdition         = -9046, // Either a VSASKUEdition or a string. VSASKUEdition if it is a standard version, or a BSTR if a custom version.
    VSSPROPID_SubSKUEdition      = -9047, // I4 - some combination of the bits defined in VSASubSKUEdition or zero (if none).
    VSSPROPID_WaitingForSecondKeyChord = -9048, // VT_BOOL (get-only) is VS in the middle of waiting for the second key of a two-key shortcut
    VSSPROPID_SqmRegistryRoot    = -9049, // BSTR, Read-only. Registry path to the root of the SQM hive used by the AppId.
    VSSPROPID_AutohideToolFrame  = -9050, // IVsWinodwFrame of the window that is the visible tool window in the autohide frame.  Will be non NULL only when fully extended.
    VSFPROPID_ToolWindowUsesDocSelection = -9051,  // (optional) BOOL - tool window wants selection of active document restored whenever its Window is activated (ala the Document Outline Window)
    VSSPROPID_FIRST2             = -9051
};
typedef LONG VSSPROPID2;

// g_dwBuildOutOfDateProjectsOption values
enum __BUILDOUTOFDATEPROJECTS
{
    BUILDOUTOFDATEPROJECTS_YES      = 0,
    BUILDOUTOFDATEPROJECTS_NO       = 1,
    BUILDOUTOFDATEPROJECTS_PROMPT   = 2,

    // !!!! NOTE !!!!   THIS MUST BE THE SAME AS THE LAST VALUE DEFINED
    BUILDOUTOFDATEPROJECTS_MAX      = 2
};

// g_dwRunAfterBuildErrorsOption values
enum __RUNAFTERBUILDERRORS
{
    RUNAFTERBUILDERRORS_YES        = 0, 
    RUNAFTERBUILDERRORS_NO         = 1, 
    RUNAFTERBUILDERRORS_PROMPT     = 2, 

    // !!!! NOTE !!!!   THIS MUST BE THE SAME AS THE LAST VALUE DEFINED
    RUNAFTERBUILDERRORS_MAX        = 2
};

enum __VSDBGLAUNCHFLAGS2 
{
    /********************************************** defined in vsshell.idl
    DBGLAUNCH_Silent                = 0x00000001, 
    DBGLAUNCH_LocalDeploy           = 0x00000002, // passed to IVsDebuggableProjectCfg::Launch to allow optimizations
    DBGLAUNCH_NoDebug               = 0x00000004, // launch without attaching a debugger
    DBGLAUNCH_DetachOnStop          = 0x00000008, // detach instead of terminate when debugging stopped.
    DBGLAUNCH_Selected              = 0x00000010, // launch selected project instead of startup project
    DBGLAUNCH_StopDebuggingOnEnd    = 0x00000020, // when this process ends, debugging is stopped.
    DBGLAUNCH_WaitForAttachComplete = 0x00000040, // when DLO_LaunchByWebServer, wait for the attach to finish before continuing to launch other targets
    **********************************************/ 
    DBGLAUNCH_MergeEnv              = 0x00000080, // provided environment should be merged with system environment
    DBGLAUNCH_DesignTimeExprEval    = 0x00000100, // launched for design-time expression evaluation 
    DBGLAUNCH_StopAtEntryPoint      = 0x00000200, // Stop at the entrypoint (step-into)
    DBGLAUNCH_CannotDebugAlone      = 0x00000400  // this process cannot be debugged alone -- stop debugging when only processes with this flag remain

};
typedef DWORD VSDBGLAUNCHFLAGS2;


enum _DEBUG_LAUNCH_OPERATION2 
{
    /********************************************** defined in vsshell.idl
    DLO_AlreadyRunning,  // attach to a process
    //  bstrExe is the process name, or a NULL character followed by 
    //  a string indicating the hexadecimal process id

    DLO_CreateProcess,   // launch the application
    //  bstrExe is the full path to the exe,
    //  bstrArg are the arguments to pass to CreateProcess,
    //  clsidCustom specifies the single debug engine to use (NULL for default),
    //  or dwClsidCount and pclsidList specify the debug engines to use

    DLO_Custom,          // deprecated -- same as DLO_CreateProcess

    DLO_LaunchByWebServer, // Use special HTTP verb to debug
    **********************************************/ 
    //  bstrExe is the URL 

    DLO_AttachToHostingProcess = 4,  // attach to a hosting process
    // bstrExe contains the process id as in DLO_AlreadyRunning
    // pUnknown contains the IVsHostingProcessUser callback interface.

    DLO_StartDebuggingHostingProcess = 5  // start debugging 
    // bstrExe contains the process id as in DLO_AlreadyRunning
};
typedef DWORD DEBUG_LAUNCH_OPERATION2;   // different type than original

//-----------------------------------------------------------------------------
// IVsProjectSpecialFiles enums
//-----------------------------------------------------------------------------
enum __PSFFILEID2
{
    PSFFILEID_WebSettings           = -1002,
    PSFFILEID_AppManifest           = -1003,
    PSFFILEID_AppDesigner           = -1004,
    PSFFILEID_AppSettings           = -1005,
    PSFFILEID_AssemblyResource      = -1006,
    PSFFILEID_AssemblyInfo          = -1007,

    // !!!! NOTE !!!!   THIS MUST BE THE SAME AS THE LAST PROP DEFINED
    PSFFILEID_FIRST2                = -1007
};
typedef LONG PSFFILEID2;

enum __PSFFLAGS2
{
    PSFF_CheckoutIfExists   = 0x00000004
};
typedef DWORD PSFFLAGS2;

//----------------------------------------------------------------------------
// Debugger stuff
//----------------------------------------------------------------------------
enum __VSEDT_STYLE
{
    VSEDT_Reserved1 = 0x00000001
};
typedef DWORD VSEDT_STYLE;

enum __STOP_DEBUGGING_PROCESS_REASON
{
    SDPR_DETACH = 0,
    SDPR_TERMINATE = 1,
};
typedef DWORD STOP_DEBUGGING_PROCESS_REASON;


//----------------------------------------------------------------------------
// IVsEnhancedDataTip
//----------------------------------------------------------------------------
[
    uuid(uuid_IVsEnhancedDataTip),
    version(1.0),
    pointer_default(unique)
]
interface IVsEnhancedDataTip : IUnknown
{
    HRESULT Show([in] HWND hwndOwner, [in] POINT* pptTopLeft, [in] RECT* pHotRect);
    HRESULT SetExpression([in] BSTR bstrExpression);
    HRESULT GetBaseWindowHandle([out] HWND* phwnd);
    HRESULT IsErrorTip([out] BOOL* pbIsError);
    HRESULT IsOpen([out] BOOL* pbIsOpen);
}

typedef struct _VsDebugTargetInfo2
{
    DWORD cbSize;                 // size of this struct
    DEBUG_LAUNCH_OPERATION2 dlo;  // specifies how this process should be launched or attached
    VSDBGLAUNCHFLAGS2 LaunchFlags;// launch flags that were passed to IVsDebuggableProjectCfg::Launch
    BSTR bstrRemoteMachine;       // NULL for local machine, or remote machine name
    BSTR bstrExe;                 // The name of the executable
    BSTR bstrArg;                 // command line arguments to the exe (DLO_CreateProcess)
    BSTR bstrCurDir;              // current directory (DLO_CreateProcess)
    BSTR bstrEnv;                 // environment settings (DLO_CreateProcess)
    GUID guidLaunchDebugEngine;   // guid of debug engine used for launch, (DLO_CreateProcess)
    DWORD dwDebugEngineCount;     // number of debug engine guids in the array
    [size_is(dwDebugEngineCount)]
    GUID* pDebugEngines;          // array of debug engine guids, or NULL is if DebugEngineCount is zero
    GUID guidPortSupplier;        // port supplier guid
    BSTR bstrPortName;            // name of port from above supplier (NULL is fine)
    BSTR bstrOptions;             // custom options, specific to each guidLaunchDebugEngine (NULL is recommended)
    DWORD_PTR hStdInput;              // for file redirection
    DWORD_PTR hStdOutput;             // for file redirection
    DWORD_PTR hStdError;              // for file redirection
    BOOL fSendToOutputWindow;     // if TRUE, stdout and stderr will be routed to the output window
    DWORD dwProcessId;            // process id (DLO_AlreadyRunning)
    IUnknown* pUnknown;           // interface pointer - usage depends on DEBUG_LAUNCH_OPERATION
    GUID guidProcessLanguage;     // Language of the hosting process. Used to preload EE's
    DWORD dwReserved;             // reserved for future use - specify NULL
} VsDebugTargetInfo2;


//----------------------------------------------------------------------------
// IVsDebugger2
//----------------------------------------------------------------------------
// Implemented by the Debugger.
[
    uuid(uuid_IVsDebugger2),
    version(1.0),
    pointer_default(unique)
]
interface IVsDebugger2 : IUnknown
{
    HRESULT LaunchDebugTargets2([in] ULONG DebugTargetCount, [in, out, size_is(DebugTargetCount)] VsDebugTargetInfo2* pDebugTargets);
    HRESULT ConfirmStopDebugging([in] LPCOLESTR pszMessage);

    // Returns an enum for all installed debug engines
    HRESULT EnumDebugEngines([out] IVsEnumGUID **ppEnum);

    // Returns the human-readable name for a debug engine
    HRESULT GetEngineName([in] REFGUID guidEngine, [out] BSTR *pbstrName);

    // Returns S_FALSE if the specified engine is incompatible with any engine in the specified array.
    // Returns S_OK if no incompatibilities are found.
    HRESULT IsEngineCompatible([in] REFGUID guidEngine, [in] ULONG EngineCount, [in, size_is(EngineCount)] GUID * pEngineGUIDs);

    // GetStdHandlesForHostingProcess() returns the standard handles 
    // to be used by process that wishes to redirect its std handles 
    // to the debugger window. 

    HRESULT GetConsoleHandlesForProcess([in] DWORD dwPid,
        [out] ULONG64 *pdwStdInput,
        [out] ULONG64 *pdwStdOutput,
        [out] ULONG64 *pdwStdError
        );


    // The ShowSource method takes an IUnknown pointer that can be queried
    // for IDebugDocumentContext2, and brings up the corresponding source
    // file in the IDE.  This is equivalent to what happens when the user
    // double-clicks on a stack frame in the Call Stack window.
    // 
    // The BOOL parameters have the following meanings:
    // (The recommended default value for each BOOL parameter is TRUE.)
    //
    //   fMakeActive:          Make the source file window the active
    //                         window in the IDE.
    //
    //   fAlwaysMoveCaret:     Move the caret to the indicated position.
    //
    //   fPromptToFindSource:  If the file is not found, prompt the user
    //                         to find it.
    //
    //   fIgnoreIfNotFound:    If the file is not found at this time, then
    //                         the debugger should remember, and not try
    //                         to find it again in the future.
    //
    // The ppTextView parameter will reference the opened view on the
    // source, if the source was successfully shown.  This parameter
    // can be NULL, if you are not interested in this value.
    //
    HRESULT ShowSource([in] IUnknown *pUnkDebugDocContext,
        [in] BOOL fMakeActive,
        [in] BOOL fAlwaysMoveCaret,
        [in] BOOL fPromptToFindSource,
        [in] BOOL fIgnoreIfNotFound,
        [out] IVsTextView **ppTextView);

    // This method allows the caller to create a new enhanced datatip object.
    HRESULT CreateDataTip([in] BSTR bstrExpression, [in] VSEDT_STYLE dwStyle, [out]IVsEnhancedDataTip** ppDataTip);

    // This method allows the caller to find out the current symbol path and cache settings
    HRESULT GetSymbolPath([out] BSTR *pbstrSymbolPath, [out] BSTR *pbstrSymbolCachePath);

    // Get a handle to use when redirecting stdout for a winforms app. This will
    // either be the console window or the output window, depending on user settings
    HRESULT GetOutputHandleForProcess([in] DWORD dwPid, [out] ULONG64 *pOutputHandle);

    // The same as InsertBreakpointByName in IVsDebugger, but allows for control of whether 
    // intellisense is used when resolving the name.
    HRESULT InsertBreakpointByName([in] REFGUID guidLanguage, [in] LPCOLESTR pszCodeLocationText, [in] BOOL bUseIntellisense);

    // Toggle the Debugger "Use Quick Console" option 
    //
    HRESULT ToggleUseQuickConsoleOption([in] BOOL fOnOff);

    // This gets the "Use Quick Console" option setting
    //
    HRESULT GetUseQuickConsoleOptionSetting([out] BOOL* pfValue); 

    // Returns the internal debugger mode. During DTEE, the internal debugger mode may 
    // be different from the shell mode (which is what IVsDebugger::GetMode returns)
    HRESULT GetInternalDebugMode ([out] DBGMODE *pdbgmode);
}

//----------------------------------------------------------------------------
// IVsDebugProcessNotify
//----------------------------------------------------------------------------
// This interface allows the debugger to provide notifications about a 
// process being debugged when this interface is passed in the
// VsDebugTargetInfo2.pUnknown field when LaunchDebugTargets2 is called.
//
[
uuid(uuid_IVsDebugProcessNotify),
version(1.0),
pointer_default(unique)
]
interface IVsDebugProcessNotify : IUnknown
{
    HRESULT BeforeStopDebuggingProcess([in] STOP_DEBUGGING_PROCESS_REASON Reason);
}


//-----------------------------------------------------------------------------
// IVsQueryDebuggableProjectCfg
//-----------------------------------------------------------------------------
// Implemented by a project system that supports Debug Launch (F5 command).
// This interface enables a third party to programmatically ask
// a project that is elligible to be the Startup Project how it
// would instruct the debugger to perform a DebugLaunch operation.
// This interface is optional and is implemented on a project
// configuration object. It is retrieved via IVsProjectCfg2::get_CfgType.
// If cTargets is zero and pcActual is not NULL, the number of VsDebugTargetInfo2 objects
//   is returned in *pcActual.
// If cTargets is not zero, rgDebugTargetInfo must not be NULL, or E_POINTER is returned.
// The caller is responsibe for freeing alocated resources in VsDebugTargetInfo2 (BSTRS' and the GUID *pDebugEngines member
// which is CoTaskMemAlloc-ated

[
    uuid(uuid_IVsQueryDebuggableProjectCfg),
    version(1.0),
    pointer_default(unique)
]
interface IVsQueryDebuggableProjectCfg : IUnknown
{
    // Return startup options
    HRESULT QueryDebugTargets([in] VSDBGLAUNCHFLAGS grfLaunch,
        [in] ULONG cTargets,
        [in, out, size_is(cTargets)] VsDebugTargetInfo2 rgDebugTargetInfo[],
        [out, optional] ULONG *pcActual);
}


//cpp_quote("#define VS_E_MIGRATIONREQUIRESRELOAD MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1FE6)")
// errors defined above in VSErrorCodes80

// The error code is returned when a solution or project file cannot be opened asynchronously.
// The caller should attempt to open the file again without passing
// SLNOPENOPT_LoadingAsync (for solution) or CPF_OPEN_ASYNCHRONOUSLY (for project).
//cpp_quote("#define VS_E_SYNCHRONOUSOPENREQUIRED MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1FE7)")
// errors defined above in VSErrorCodes80

//This is the overlay icon that your ui hierarchy should return
//when asked for VSHPROPID_OverlayIconIndex.  This will be transparently
//drawn on top of your item's normal icon
enum __VSOVERLAYICON2
{
    /********************************************** defined in vsshell.idl
    OVERLAYICON_NONE            = 0,
    OVERLAYICON_SHORTCUT        = 1,
    OVERLAYICON_POLICY          = 2,
    OVERLAYICON_CONNECTED       = 3,
    OVERLAYICON_DISCONNECTED    = 4,
    OVERLAYICON_MAXINDEX        = 4 //should be same as last valid overlay
    **********************************************/
    OVERLAYICON_EXCLUDED        = 5,
    OVERLAYICON_NOTONDISK       = 6,
    OVERLAYICON_MAXINDEX2        = 6 //should be same as last valid overlay
};
typedef DWORD VSOVERLAYICON2;   // different type than original



// Properties ID's for IVsMenuItem::IMISetProp/IMEGetProp and for IMenuEditorSite
// to inform IVsMenuEditor::OnChange() with.
//
//                     IVsMenuItem::
//  Property         Type: IMISetProp - IMIGetProp
//-----------------------------------------------------------
enum __VSMEPROPID2
{
    /********************************************** defined in vsshell.idl
    VSMEPROPID_FIRST        = -1000,
    VSMEPROPID_NAME         = -1000, //      VT_BSTR
    VSMEPROPID_CAPTION      = -1001, //      VT_BSTR
    VSMEPROPID_CHECKED      = -1002, //      VT_BOOL
    VSMEPROPID_ENABLED      = -1003, //      VT_BOOL
    VSMEPROPID_VISIBLE      = -1004, //      VT_BOOL
    VSMEPROPID_BOLD         = -1005, //      VT_BOOL
    VSMEPROPID_ACCEL        = -1006, //      VT_I4   - (DWORD)
    VSMEPROPID_RADIOCHECK   = -1007, //      VT_BOOL
    VSMEPROPID_EXTRAPROPS   = -1008,
    VSMEPROPID_BREAK        = -1009,
    VSMEPROPID_BARBREAK     = -1010,
    VSMEPROPID_RIGHTJUSTIFY = -1011,
    VSMEPROPID_LAST         = -1011
    **********************************************/
    VSMEPROPID_ICON         = -1012,
    VSMEPROPID_LAST2        = -1012
};
typedef LONG VSMEPROPID2;


enum __COMMANDWINDOWMODE2
{
    CWM_DEFAULT = -1,       // Default mode (specified in user options)
    /********************************************** defined in vsshell.idl
    CWM_IMMEDIATE   = 0,    // Immediate mode 
    CWM_COMMAND,            // Command mode
    **********************************************/ 
};
typedef DWORD COMMANDWINDOWMODE2;   // different type than original

[
    uuid(uuid_IVsCommandWindow2),
    version(1.0),
    pointer_default(unique)
]
interface IVsCommandWindow2 : IUnknown
{
    // Sets the Command Window to   Immediate mode or Command mode.  The mode
    // argument must be either CWM_IMMEDIATE or CWM_COMMAND.    Refer to the
    // Command Line spec for descriptions   of these modes of operation.
    HRESULT SetMode([in] COMMANDWINDOWMODE2 mode);
}

//----------------------------------------------------------------------------
//  interface IVsDeferredDocView
//----------------------------------------------------------------------------
// This interface can be used to provide a doc view whose actual view is 
// retrieved after the doc data has been loaded and registered in the RDT.
// The get_DocView property will be used to provide the actual document view
// to the document window.
[
    uuid(uuid_IVsDeferredDocView),
    version(1.0),
    pointer_default(unique)
]
interface IVsDeferredDocView : IUnknown
{
    HRESULT get_DocView([out] IUnknown **ppUnkDocView);
    HRESULT get_CmdUIGuid([out] GUID *pGuidCmdId);
}


#ifdef INTEROPLIB

enum BuildableProjectCfgOpts
{
    Rebuild = 1,
    BuildSelectionOnly = 2,
    BuildActiveDocumentOnly = 4,
    Private = 0xFFFF0000    // flags private to a particular implementation
};

#endif

//----------------------------------------------------------------------------
//  interface IVsBuildableProjectCfg2
//----------------------------------------------------------------------------
// property ids for IVsBuildableProjectCfg2::GetBuildCfgProperty calls
enum __VSBLDCFGPROPID
{
    VSBLDCFGPROPID_LAST            = -16000,  // first value should be a unique among propids
    VSBLDCFGPROPID_SupportsMTBuild = -16000,  //
    VSBLDCFGPROPID_FIRST           = -16000,
};
typedef LONG VSBLDCFGPROPID;

[
    uuid(uuid_IVsBuildableProjectCfg2),
    version(1.0),
    pointer_default(unique)
]
interface IVsBuildableProjectCfg2 : IUnknown
{
    HRESULT GetBuildCfgProperty([in] VSBLDCFGPROPID propid, [out] VARIANT *pvar);
    HRESULT StartBuildEx([in] DWORD dwBuildId, [in] IVsOutputWindowPane *pIVsOutputWindowPane, [in] DWORD dwOptions);
};

//-----------------------------------------------------------------------------
// IVsPublishStatusCallback
//-----------------------------------------------------------------------------
// Implemented by the Environment.
// Used by a project system that supports publish operations.
[
    uuid(uuid_IVsPublishStatusCallback),
    version(1.0),
    pointer_default(unique)
]
interface IVsPublishableProjectStatusCallback : IUnknown
{
    HRESULT PublishBegin([in, out] BOOL *pfContinue);
    HRESULT PublishEnd([in] BOOL fSuccess);
    HRESULT Tick([in, out] BOOL *pfContinue);
}

enum __VSPUBLISHOPTS
{
    PUBOPT_PUBLISHCONTEXT     = 0x00000001,   // first value should be one,
};
typedef DWORD VSPUBLISHOPTS;

//----------------------------------------------------------------------------
//  interface IVsPublishableProjectCfg
//----------------------------------------------------------------------------
[
    uuid(uuid_IVsPublishableProjectCfg),
    version(1.0),
    pointer_default(unique)
]
interface IVsPublishableProjectCfg : IUnknown
{
    HRESULT AdvisePublishStatusCallback([in] IVsPublishableProjectStatusCallback *pIVsPublishStatusCallback, [out] VSCOOKIE *pdwCookie);
    HRESULT UnadvisePublishStatusCallback([in] VSCOOKIE dwCookie);

    HRESULT StartPublish([in] IVsOutputWindowPane *pIVsOutputWindowPane, [in] DWORD dwOptions);
    HRESULT QueryStatusPublish([out] BOOL *pfPublishDone);
    HRESULT StopPublish([in] BOOL fSync);

    HRESULT ShowPublishPrompt([out] BOOL *pfContinue);

    HRESULT QueryStartPublish([in] DWORD dwOptions, [out, optional] BOOL *pfSupported, [out, optional] BOOL *pfReady);
    HRESULT GetPublishProperty([in] VSPUBLISHOPTS propid, [out] VARIANT *pvar);    
};

typedef enum __VSSOLNBUILDUPDATEFLAGS2
{
    /* From vsshell.idl:

    // The first set is UI supression   flags; if they are set the default answer is automatically chosen.
    SBF_SUPPRESS_NONE           = 0x00000000,
    SBF_SUPPRESS_OUTOFDATE_QUERY            = 0x00000001,       // Take default answer for out of date query 
    SBF_SUPPRESS_SAVEBEFOREBUILD_QUERY  = 0x00000002,       // Take default answer for save before build query 
    SBF_SUPPRESS_CONTDEPLOYONERROR_QUERY    = 0x00000004,       // Take default answer for continue deploy query 
    SBF_SUPPRESS_CONTLAUNCHONERROR_QUERY    = 0x00000008,       // Take default answer for continue launch query 
    SBF_SUPPRESS_MASK                       = 0x000000FF,
    // This set of flags is used to control which   operations the solution update manager will
    // perform as   part of its operation.  
    SBF_OPERATION_NONE          = 0x00000000,       // No build operations are to be performed
    SBF_OPERATION_BUILD         = 0x00010000,       // Perform build (may be ORed with other flags)
    SBF_OPERATION_DEPLOY            = 0x00020000,       // Deploy solution (may be ORed with other flags)
    SBF_OPERATION_LAUNCH            = 0x00040000,       // Launch the application without the debugger involved
    SBF_OPERATION_LAUNCHDEBUG       = 0x00080000,       // Launch the application for debugging
    SBF_OPERATION_CLEAN         = 0x00100000,       // Remove built objects
    SBF_OPERATION_SELECTION     = 0x00200000,       // Operate on the current shell selection context
    SBF_OPERATION_FORCE_UPDATE      = 0x00400000,       // Force a rebuild on the project, even if it is not out of
    // date; for SBF_OPERATION_BUILD, projects will recompile
    // results even if they are not out of date; for
    // SBF_OPERATION_DEPLOY, the content will be re-copied to the
    // deployment target even if it is known not to be out of
    // date at the target.
    SBF_OPERATION_MASK                  = 0xFFFF0000,
    */
    SBF_OPERATION_PUBLISHUI      = 0x00800000,       // Publish solution (may be ORed with other flags)
    SBF_OPERATION_PUBLISH        = 0x01000000,       // Publish solution (may be ORed with other flags)
} VSSOLNBUILDUPDATEFLAGS2;

//----------------------------------------------------------------------------
//  interface IVsParseCommandLine2
//----------------------------------------------------------------------------
// Implemented by the Environment.
// This is a helper service used by IOleCommandTarget implementations for commands
// that take arguments and switches

cpp_quote("#define PCL_AUTO_SWITCHES       -2")
cpp_quote("#define PCL_AUTO_SWITCHVALUES   -3")

[
    uuid(uuid_IVsParseCommandLine2),
    version(1.0),
    pointer_default(unique)
]
interface IVsParseCommandLine2 : IUnknown
{

    HRESULT GetACParamOrSwitch([out] int* piACIndex, [out] int* piACStart, 
        [out] int* pcchACLength, [out] BSTR* pbstrCurSwitch, [out, retval] BSTR* pbstrACParam);

};

//----------------------------------------------------------------------------
//  interface IVsCommandWindowsCollection
//----------------------------------------------------------------------------
// Implemented by the Environment. 
// This is a service provided to manage the Command Windows in the shell.

[
    uuid(uuid_IVsCommandWindowsCollection),
    version(1.0),
    pointer_default(unique)
]
interface IVsCommandWindowsCollection : IUnknown
{
    // Create a new Command Window in the specified mode
    HRESULT Create(
        [in]    COMMANDWINDOWMODE2 mode,
        [in]    DWORD dwToolWindowId,       // -1 indicates to have the service choose an id
        [in]    BOOL fShow,
        [out]   UINT * puCookie
        );

    // Open an existing Command Window (creates a new one if necessary)
    HRESULT OpenExistingOrCreateNewCommandWindow(
        [in]    COMMANDWINDOWMODE2 mode,
        [in]    BOOL fShow,
        [out]   UINT * puCookie
        );

    // Retrieve a Command Window's interface from a cookie value
    HRESULT GetCommandWindowFromCookie(
        [in]    UINT uCookie,
        [out]   IUnknown ** ppunkCmdWindow
        );

    // Retrieve a Command Window interface for the specified mode
    HRESULT GetCommandWindowFromMode(
        [in]    COMMANDWINDOWMODE2 mode,
        [out]   IUnknown ** ppunkCmdWindow
        );

    // Indicate that a Command Window is running (or not running) a command
    HRESULT SetRunningCommandWindowCommand(
        [in]    UINT uCookie,
        [in]    BOOL fCmdWin
        );

    // Determine if output needs to be rendered for the specified window
    // Note: This is only valid for window in the CWM_SYSTEM mode, all 
    // other mode return S_FALSE.
    HRESULT IsOutputWaiting(
        [in]    UINT uCookie
        );

    // Close the specified window
    HRESULT Close(
        [in]    UINT uCookie
        );

    // Close all Command Windows
    HRESULT CloseAllCommandWindows();

};

// declare the service type for interop
[uuid(uuid_SVsCommandWindowsCollection)]
interface SVsCommandWindowsCollection : IUnknown {}

cpp_quote("#define SID_SVsCommandWindowsCollection IID_SVsCommandWindowsCollection")


// PVsBackgroundTask_Function_Pointer - type defintion
// Implemented by modules that need to execute tasks in the background
cpp_quote("typedef void (__cdecl * PVsBackgroundTask_Proc)(DWORD_PTR pvParam, HANDLE hThreadTerminationEvent);")
cpp_quote("typedef PVsBackgroundTask_Proc PVsBackgroundTask_Function_Pointer;")

enum __VSBACKGROUNDTASKPRIORITY
{
    VSBACKGROUNDTASKPRIORITY_STANDARD   = 0,        // Implemented in VS8.0
    VSBACKGROUNDTASKPRIORITY_IMMEDIATE  = 1,        // Not implemented
    VSBACKGROUNDTASKPRIORITY_OTHER      = 2,        // Placeholder for enum expansion
};
typedef DWORD VSBACKGROUNDTASKPRIORITY;

//----------------------------------------------------------------------------
//  interface IVsThreadPool
//----------------------------------------------------------------------------
// Implemented by the Environment. 
// This is a service provided to manage background operations in the shell.

[
    uuid(uuid_IVsThreadPool),
    version(1.0),
    pointer_default(unique) // pointers can be NULL
]
interface IVsThreadPool : IUnknown
{
    // Schedule a task to run
    HRESULT ScheduleTask (
        [in] DWORD_PTR pTaskProc,  // shell explicitly casts this pointer to a PVsBackgroundTask_Function_Pointer before calling
        [in] DWORD_PTR pvParam,
        [in] VSBACKGROUNDTASKPRIORITY  priority        // should be VSBACKGROUNDTASKPRIORITY_STANDARD in VS8.0
        );

    // Schedule a task & a handle to wait on before running the task
    HRESULT ScheduleWaitableTask (
        [in] DWORD_PTR hWait,               // HANDLE to wait upon
        [in] DWORD_PTR pTaskProc,  // shell explicitly casts this pointer to a PVsBackgroundTask_Function_Pointer before calling
        [in] DWORD_PTR pvParam
        );

    // Remove a handle (& task) from the list of waitable tasks
    HRESULT UnscheduleWaitableTask (
        [in] DWORD_PTR hWait        // HANDLE to remove
        );
};


// declare the service type for interop
[uuid(uuid_SVsThreadPool)]
interface SVsThreadPool : IUnknown {}

cpp_quote("#define SID_SVsThreadPool IID_SVsThreadPool")

typedef struct _VSNSEBROWSEINFOW
{
    DWORD     lStructSize;
    LPCOLESTR pszNamespaceGUID;   // namespace extension GUID as string
    LPCOLESTR pszTrayDisplayName; // display name for the namespace extension in dialog tray
    LPCOLESTR pszProtocolPrefix;  // prefix for namespace extension URLs (e.g. msss://)
    BOOL      fOnlyShowNSEInTray; // if set, only namespace extension icon shown in dialog tray
} VSNSEBROWSEINFOW;

typedef struct _VSSAVETREEITEM
{
    VSRDTSAVEOPTIONS grfSave;
    VSCOOKIE docCookie;                 // either docCookie or pHier/itemid should be specified
    IVsHierarchy *pHier;
    VSITEMID itemid;
} VSSAVETREEITEM;

//---------------------------------------------------------------------------
// IVsShell2
//---------------------------------------------------------------------------
// Additional shell services
//---------------------------------------------------------------------------
[
    uuid(uuid_IVsShell2),
    version(1.0)
]
interface IVsShell2 : IUnknown
{
    HRESULT LoadPackageStringWithLCID([in] REFGUID guidPackage, [in] ULONG resid, [in] LCID lcid, [out, retval] BSTR *pbstrOut);
}

//---------------------------------------------------------------------------
// IVsUIShell2
//---------------------------------------------------------------------------
// Additional shell services
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// New VsColorService to be used with IVsUIShell2:GetVSSysColorEx
//---------------------------------------------------------------------------
typedef enum __tagVSSYSCOLOREX
{
    /********************************************** defined in vsshell.idl
    VSCOLOR_LIGHT            = -1,  // *DO NOT USE*
    VSCOLOR_MEDIUM           = -2,  // *DO NOT USE*
    VSCOLOR_DARK             = -3,  // *DO NOT USE*
    VSCOLOR_LIGHTCAPTION     = -4,  // *DO NOT USE*
    VSCOLOR_LAST             = -4,  // must be set to the last color above
    ***********************************************************************/

    VSCOLOR_ACCENT_BORDER                                   = -5,
    VSCOLOR_ACCENT_DARK                                     = -6,
    VSCOLOR_ACCENT_LIGHT                                    = -7,
    VSCOLOR_ACCENT_MEDIUM                                   = -8,
    VSCOLOR_ACCENT_PALE                                     = -9,
    VSCOLOR_COMMANDBAR_BORDER                               = -10,
    VSCOLOR_COMMANDBAR_DRAGHANDLE                           = -11,
    VSCOLOR_COMMANDBAR_DRAGHANDLE_SHADOW                    = -12,
    VSCOLOR_COMMANDBAR_GRADIENT_BEGIN                       = -13,
    VSCOLOR_COMMANDBAR_GRADIENT_END                         = -14,
    VSCOLOR_COMMANDBAR_GRADIENT_MIDDLE                      = -15,
    VSCOLOR_COMMANDBAR_HOVER                                = -16,
    VSCOLOR_COMMANDBAR_HOVEROVERSELECTED                    = -17,
    VSCOLOR_COMMANDBAR_HOVEROVERSELECTEDICON                = -18,
    VSCOLOR_COMMANDBAR_HOVEROVERSELECTEDICON_BORDER         = -19,
    VSCOLOR_COMMANDBAR_SELECTED                             = -20,
    VSCOLOR_COMMANDBAR_SHADOW                               = -21,
    VSCOLOR_COMMANDBAR_TEXT_ACTIVE                          = -22,
    VSCOLOR_COMMANDBAR_TEXT_HOVER                           = -23,
    VSCOLOR_COMMANDBAR_TEXT_INACTIVE                        = -24,
    VSCOLOR_COMMANDBAR_TEXT_SELECTED                        = -25,
    VSCOLOR_CONTROL_EDIT_HINTTEXT                           = -26,
    VSCOLOR_CONTROL_EDIT_REQUIRED_BACKGROUND                = -27,
    VSCOLOR_CONTROL_EDIT_REQUIRED_HINTTEXT                  = -28,
    VSCOLOR_CONTROL_LINK_TEXT                               = -29,
    VSCOLOR_CONTROL_LINK_TEXT_HOVER                         = -30,
    VSCOLOR_CONTROL_LINK_TEXT_PRESSED                       = -31,
    VSCOLOR_CONTROL_OUTLINE                                 = -32,
    VSCOLOR_DEBUGGER_DATATIP_ACTIVE_BACKGROUND              = -33,
    VSCOLOR_DEBUGGER_DATATIP_ACTIVE_BORDER                  = -34,
    VSCOLOR_DEBUGGER_DATATIP_ACTIVE_HIGHLIGHT               = -35,
    VSCOLOR_DEBUGGER_DATATIP_ACTIVE_HIGHLIGHTTEXT           = -36,
    VSCOLOR_DEBUGGER_DATATIP_ACTIVE_SEPARATOR               = -37,
    VSCOLOR_DEBUGGER_DATATIP_ACTIVE_TEXT                    = -38,
    VSCOLOR_DEBUGGER_DATATIP_INACTIVE_BACKGROUND            = -39,
    VSCOLOR_DEBUGGER_DATATIP_INACTIVE_BORDER                = -40,
    VSCOLOR_DEBUGGER_DATATIP_INACTIVE_HIGHLIGHT             = -41,
    VSCOLOR_DEBUGGER_DATATIP_INACTIVE_HIGHLIGHTTEXT         = -42,
    VSCOLOR_DEBUGGER_DATATIP_INACTIVE_SEPARATOR             = -43,
    VSCOLOR_DEBUGGER_DATATIP_INACTIVE_TEXT                  = -44,
    VSCOLOR_DESIGNER_BACKGROUND                             = -45,
    VSCOLOR_DESIGNER_SELECTIONDOTS                          = -46,
    VSCOLOR_DESIGNER_TRAY                                   = -47,
    VSCOLOR_DESIGNER_WATERMARK                              = -48,
    VSCOLOR_EDITOR_EXPANSION_BORDER                         = -49,
    VSCOLOR_EDITOR_EXPANSION_FILL                           = -50,
    VSCOLOR_EDITOR_EXPANSION_LINK                           = -51,
    VSCOLOR_EDITOR_EXPANSION_TEXT                           = -52,
    VSCOLOR_ENVIRONMENT_BACKGROUND                          = -53,
    VSCOLOR_ENVIRONMENT_BACKGROUND_GRADIENTBEGIN            = -54,
    VSCOLOR_ENVIRONMENT_BACKGROUND_GRADIENTEND              = -55,
    VSCOLOR_FILETAB_BORDER                                  = -56,
    VSCOLOR_FILETAB_CHANNELBACKGROUND                       = -57,
    VSCOLOR_FILETAB_GRADIENTDARK                            = -58,
    VSCOLOR_FILETAB_GRADIENTLIGHT                           = -59,
    VSCOLOR_FILETAB_SELECTEDBACKGROUND                      = -60,
    VSCOLOR_FILETAB_SELECTEDBORDER                          = -61,
    VSCOLOR_FILETAB_SELECTEDTEXT                            = -62,
    VSCOLOR_FILETAB_TEXT                                    = -63,
    VSCOLOR_FORMSMARTTAG_ACTIONTAG_BORDER                   = -64,
    VSCOLOR_FORMSMARTTAG_ACTIONTAG_FILL                     = -65,
    VSCOLOR_FORMSMARTTAG_OBJECTTAG_BORDER                   = -66,
    VSCOLOR_FORMSMARTTAG_OBJECTTAG_FILL                     = -67,
    VSCOLOR_GRID_HEADING_BACKGROUND                         = -68,
    VSCOLOR_GRID_HEADING_TEXT                               = -69,
    VSCOLOR_GRID_LINE                                       = -70,
    VSCOLOR_HELP_HOWDOI_PANE_BACKGROUND                     = -71,
    VSCOLOR_HELP_HOWDOI_PANE_LINK                           = -72,
    VSCOLOR_HELP_HOWDOI_PANE_TEXT                           = -73,
    VSCOLOR_HELP_HOWDOI_TASK_BACKGROUND                     = -74,
    VSCOLOR_HELP_HOWDOI_TASK_LINK                           = -75,
    VSCOLOR_HELP_HOWDOI_TASK_TEXT                           = -76,
    VSCOLOR_HELP_SEARCH_FRAME_BACKGROUND                    = -77,
    VSCOLOR_HELP_SEARCH_FRAME_TEXT                          = -78,
    VSCOLOR_HELP_SEARCH_BORDER                              = -79,
    VSCOLOR_HELP_SEARCH_FITLER_TEXT                         = -80,
    VSCOLOR_HELP_SEARCH_FITLER_BACKGROUND                   = -81,
    VSCOLOR_HELP_SEARCH_FITLER_BORDER                       = -82,
    VSCOLOR_HELP_SEARCH_PROVIDER_UNSELECTED_BACKGROUND      = -83,
    VSCOLOR_HELP_SEARCH_PROVIDER_UNSELECTED_TEXT            = -84,
    VSCOLOR_HELP_SEARCH_PROVIDER_SELECTED_BACKGROUND        = -85,
    VSCOLOR_HELP_SEARCH_PROVIDER_SELECTED_TEXT              = -86,
    VSCOLOR_HELP_SEARCH_PROVIDER_ICON                       = -87,
    VSCOLOR_HELP_SEARCH_RESULT_LINK_SELECTED                = -88,
    VSCOLOR_HELP_SEARCH_RESULT_LINK_UNSELECTED              = -89,
    VSCOLOR_HELP_SEARCH_RESULT_SELECTED_BACKGROUND          = -90,
    VSCOLOR_HELP_SEARCH_RESULT_SELECTED_TEXT                = -91,
    VSCOLOR_HELP_SEARCH_BACKGROUND                          = -92,
    VSCOLOR_HELP_SEARCH_TEXT                                = -93,
    VSCOLOR_HELP_SEARCH_PANEL_RULES                         = -94, // unused.
    VSCOLOR_MDICLIENT_BORDER                                = -95,
    VSCOLOR_PANEL_BORDER                                    = -96,
    VSCOLOR_PANEL_GRADIENTDARK                              = -97,
    VSCOLOR_PANEL_GRADIENTLIGHT                             = -98,
    VSCOLOR_PANEL_HOVEROVERCLOSE_BORDER                     = -99,
    VSCOLOR_PANEL_HOVEROVERCLOSE_FILL                       = -100,
    VSCOLOR_PANEL_HYPERLINK                                 = -101,
    VSCOLOR_PANEL_HYPERLINK_HOVER                           = -102,
    VSCOLOR_PANEL_HYPERLINK_PRESSED                         = -103,
    VSCOLOR_PANEL_SEPARATOR                                 = -104,
    VSCOLOR_PANEL_SUBGROUPSEPARATOR                         = -105,
    VSCOLOR_PANEL_TEXT                                      = -106,
    VSCOLOR_PANEL_TITLEBAR                                  = -107,
    VSCOLOR_PANEL_TITLEBAR_TEXT                             = -108,
    VSCOLOR_PANEL_TITLEBAR_UNSELECTED                       = -109,
    VSCOLOR_PROJECTDESIGNER_BACKGROUND_GRADIENTBEGIN        = -110,
    VSCOLOR_PROJECTDESIGNER_BACKGROUND_GRADIENTEND          = -111,
    VSCOLOR_PROJECTDESIGNER_BORDER_OUTSIDE                  = -112,
    VSCOLOR_PROJECTDESIGNER_BORDER_INSIDE                   = -113,
    VSCOLOR_PROJECTDESIGNER_CONTENTS_BACKGROUND             = -114,
    VSCOLOR_PROJECTDESIGNER_TAB_BACKGROUND_GRADIENTBEGIN    = -115,
    VSCOLOR_PROJECTDESIGNER_TAB_BACKGROUND_GRADIENTEND      = -116,
    VSCOLOR_PROJECTDESIGNER_TAB_SELECTED_INSIDEBORDER       = -117,
    VSCOLOR_PROJECTDESIGNER_TAB_SELECTED_BORDER             = -118,
    VSCOLOR_PROJECTDESIGNER_TAB_SELECTED_HIGHLIGHT1         = -119,
    VSCOLOR_PROJECTDESIGNER_TAB_SELECTED_HIGHLIGHT2         = -120,
    VSCOLOR_PROJECTDESIGNER_TAB_SELECTED_BACKGROUND         = -121,
    VSCOLOR_PROJECTDESIGNER_TAB_SEP_BOTTOM_GRADIENTBEGIN    = -122,
    VSCOLOR_PROJECTDESIGNER_TAB_SEP_BOTTOM_GRADIENTEND      = -123,
    VSCOLOR_PROJECTDESIGNER_TAB_SEP_TOP_GRADIENTBEGIN       = -124,
    VSCOLOR_PROJECTDESIGNER_TAB_SEP_TOP_GRADIENTEND         = -125,
    VSCOLOR_SCREENTIP_BORDER                                = -126,
    VSCOLOR_SCREENTIP_BACKGROUND                            = -127,
    VSCOLOR_SCREENTIP_TEXT                                  = -128,
    VSCOLOR_SIDEBAR_BACKGROUND                              = -129,
    VSCOLOR_SIDEBAR_GRADIENTDARK                            = -130,
    VSCOLOR_SIDEBAR_GRADIENTLIGHT                           = -131,
    VSCOLOR_SIDEBAR_TEXT                                    = -132,
    VSCOLOR_SMARTTAG_BORDER                                 = -133,
    VSCOLOR_SMARTTAG_FILL                                   = -134,
    VSCOLOR_SMARTTAG_HOVER_BORDER                           = -135,
    VSCOLOR_SMARTTAG_HOVER_FILL                             = -136,
    VSCOLOR_SMARTTAG_HOVER_TEXT                             = -137,
    VSCOLOR_SMARTTAG_TEXT                                   = -138,
    VSCOLOR_SNAPLINES                                       = -139,
    VSCOLOR_SNAPLINES_PADDING                               = -140,
    VSCOLOR_SNAPLINES_TEXTBASELINE                          = -141,
    VSCOLOR_SORT_BACKGROUND                                 = -142,
    VSCOLOR_SORT_TEXT                                       = -143,
    VSCOLOR_TASKLIST_GRIDLINES                              = -144,
    VSCOLOR_TITLEBAR_ACTIVE                                 = -145,
    VSCOLOR_TITLEBAR_ACTIVE_GRADIENTBEGIN                   = -146,
    VSCOLOR_TITLEBAR_ACTIVE_GRADIENTEND                     = -147,
    VSCOLOR_TITLEBAR_ACTIVE_TEXT                            = -148,
    VSCOLOR_TITLEBAR_INACTIVE                               = -149,
    VSCOLOR_TITLEBAR_INACTIVE_GRADIENTBEGIN                 = -150,
    VSCOLOR_TITLEBAR_INACTIVE_GRADIENTEND                   = -151,
    VSCOLOR_TITLEBAR_INACTIVE_TEXT                          = -152,
    VSCOLOR_TOOLBOX_BACKGROUND                              = -153,
    VSCOLOR_TOOLBOX_DIVIDER                                 = -154,
    VSCOLOR_TOOLBOX_GRADIENTDARK                            = -155,
    VSCOLOR_TOOLBOX_GRADIENTLIGHT                           = -156,
    VSCOLOR_TOOLBOX_HEADINGACCENT                           = -157,
    VSCOLOR_TOOLBOX_HEADINGBEGIN                            = -158,
    VSCOLOR_TOOLBOX_HEADINGEND                              = -159,
    VSCOLOR_TOOLBOX_ICON_HIGHLIGHT                          = -160,
    VSCOLOR_TOOLBOX_ICON_SHADOW                             = -161,
    VSCOLOR_TOOLWINDOW_BACKGROUND                           = -162,
    VSCOLOR_TOOLWINDOW_BORDER                               = -163,
    VSCOLOR_TOOLWINDOW_BUTTON_DOWN                          = -164,
    VSCOLOR_TOOLWINDOW_BUTTON_DOWN_BORDER                   = -165,
    VSCOLOR_TOOLWINDOW_BUTTON_HOVER_ACTIVE                  = -166,
    VSCOLOR_TOOLWINDOW_BUTTON_HOVER_ACTIVE_BORDER           = -167,
    VSCOLOR_TOOLWINDOW_BUTTON_HOVER_INACTIVE                = -168,
    VSCOLOR_TOOLWINDOW_BUTTON_HOVER_INACTIVE_BORDER         = -169,
    VSCOLOR_TOOLWINDOW_TEXT                                 = -170,
    VSCOLOR_TOOLWINDOW_TAB_SELECTEDTAB                      = -171,
    VSCOLOR_TOOLWINDOW_TAB_BORDER                           = -172,
    VSCOLOR_TOOLWINDOW_TAB_GRADIENTBEGIN                    = -173,
    VSCOLOR_TOOLWINDOW_TAB_GRADIENTEND                      = -174,
    VSCOLOR_TOOLWINDOW_TAB_TEXT                             = -175,
    VSCOLOR_TOOLWINDOW_TAB_SELECTEDTEXT                     = -176,
    VSCOLOR_WIZARD_ORIENTATIONPANEL_BACKGROUND              = -177,
    VSCOLOR_WIZARD_ORIENTATIONPANEL_TEXT                    = -178,

    // NOTE: This must be the same as the last property defined above.
    VSCOLOR_LASTEX                                          = -178

} __VSSYSCOLOREX;

typedef int VSSYSCOLOREX;



typedef enum __tagGRADIENTTYPE
{
    VSGRADIENT_FILETAB                                      = 1,
    VSGRADIENT_PANEL_BACKGROUND                             = 2,
    VSGRADIENT_SHELLBACKGROUND                              = 3,
    VSGRADIENT_TOOLBOX_HEADING                              = 4,
    VSGRADIENT_TOOLTAB                                      = 5,
    VSGRADIENT_TOOLWIN_ACTIVE_TITLE_BAR                     = 6,
    VSGRADIENT_TOOLWIN_INACTIVE_TITLE_BAR                   = 7,
    VSGRADIENT_TOOLWIN_BACKGROUND                           = 8

} __GRADIENTTYPE;

typedef DWORD GRADIENTTYPE;


[
    uuid(uuid_IVsGradient),
    version(1.0),
    pointer_default(unique)
]
interface IVsGradient : IUnknown
{
    HRESULT DrawGradient([in] HWND hwnd, [in] HDC hdc, [in] RECT * gradientRect, [in] RECT * sliceRect);
    HRESULT GetGradientVector([in] int cVector, [in,out, size_is(cVector)] COLORREF* rgVector);
};

enum __VSCURSORTYPE
{
    VSCURSOR_APPSTARTING        = 1,
    VSCURSOR_COLUMNSPLIT_EW     = 2,
    VSCURSOR_COLUMNSPLIT_NS     = 3,
    VSCURSOR_CONTROL_COPY       = 4,
    VSCURSOR_CONTROL_DELETE     = 5,
    VSCURSOR_CONTROL_MOVE       = 6,
    VSCURSOR_CROSS              = 7,
    VSCURSOR_DRAGDOCUMENT_MOVE  = 8,
    VSCURSOR_DRAGDOCUMENT_NOEFFECT = 9,
    VSCURSOR_DRAGSCRAP_COPY     = 10,
    VSCURSOR_DRAGSCRAP_MOVE     = 11,
    VSCURSOR_DRAGSCRAP_SCROLL   = 12,
    VSCURSOR_HAND               = 13,
    VSCURSOR_IBEAM              = 14,
    VSCURSOR_ISEARCH            = 15,
    VSCURSOR_ISEARCH_UP         = 16,
    VSCURSOR_MACRO_RECORD_NO    = 17,
    VSCURSOR_NO                 = 18,
    VSCURSOR_NOMOVE_2D          = 19,
    VSCURSOR_NOMOVE_HORIZ       = 20,
    VSCURSOR_NOMOVE_VERT        = 21,
    VSCURSOR_PAN_EAST           = 22,
    VSCURSOR_PAN_NE             = 23,
    VSCURSOR_PAN_NORTH          = 24,
    VSCURSOR_PAN_NW             = 25,
    VSCURSOR_PAN_SE             = 26,
    VSCURSOR_PAN_SOUTH          = 27,
    VSCURSOR_PAN_SW             = 28,
    VSCURSOR_PAN_WEST           = 29,
    VSCURSOR_POINTER            = 30,
    VSCURSOR_POINTER_REVERSE    = 31,
    VSCURSOR_SIZE_NS            = 32,
    VSCURSOR_SIZE_EW            = 33,
    VSCURSOR_SIZE_NWSE          = 34,
    VSCURSOR_SIZE_NESW          = 35,
    VSCURSOR_SIZE_ALL           = 36,
    VSCURSOR_SPLIT_EW           = 37,
    VSCURSOR_SPLIT_NS           = 38,
    VSCURSOR_UPARROW            = 39,
    VSCURSOR_WAIT               = 40
};
typedef DWORD VSCURSORTYPE;

// non-standard VS-specific OFN flags
//cpp_quote("#define OFN_ALLOWONLYFILESYSLOCS 0x80000000")  //defined in vsshell.idl
cpp_quote("#define OFN_NOADDALLFILESFILTER  0x40000000")

typedef enum tagBWIImagePos
{
  BWI_IMAGE_POS_LEFT  = 0x00, // Bitmask values 
  BWI_IMAGE_POS_RIGHT = 0x01,
  BWI_IMAGE_ONLY      = 0x02
} __BWI_IMAGE_POS;

typedef DWORD BWI_IMAGE_POS;


typedef struct tagVSDRAWITEMSTRUCT {
    UINT        CtlType;
    UINT        CtlID;
    UINT        itemID;
    UINT        itemAction;
    UINT        itemState;
    HWND        hwndItem;
    HDC         hDC;
    RECT        rcItem;
    ULONG_PTR   itemData;
} VSDRAWITEMSTRUCT;


[
  uuid(uuid_IVsImageButton), 
  version(1.0),
  pointer_default(unique)
]
interface IVsImageButton : IUnknown
{
    HRESULT Draw([in] VSDRAWITEMSTRUCT* pDrawItemStruct, [in] BOOL fHot);
}


[
    uuid(uuid_IVsUIShell2),
    version(1.0)
]
interface IVsUIShell2 : IUnknown
{
    // bring up the MSO Open dialog to obtain an open file name.
    HRESULT GetOpenFileNameViaDlgEx([in,out] VSOPENFILENAMEW *pOpenFileName, [in] LPCOLESTR pszHelpTopic);

    // bring up the MSO Save As dialog to obtain a save file name.
    HRESULT GetSaveFileNameViaDlgEx([in,out] VSSAVEFILENAMEW *pSaveFileName, [in] LPCOLESTR pszHelpTopic);

    // bring up the MSO Browse dialog to obtain a directory name (possibly in a namespace extension).
    HRESULT GetDirectoryViaBrowseDlgEx(
        [in,out] VSBROWSEINFOW *pBrowse,
        [in] LPCOLESTR pszHelpTopic,
        [in] LPCOLESTR pszOpenButtonLabel,          // caption text for "Open" button
        [in] LPCOLESTR pszCeilingDir,               // limit browsing to below this location
        [in] VSNSEBROWSEINFOW *pNSEBrowseInfo);     // [optional] namespace extension information

    // Handle the saving of one or more documents via the "Save changes to following items?" dialog.
    // This method displays the dialog to the user and handles the saving of items the user chooses.
    // Items to be saved can be identified by the RunningDocumentTable docCookie or by 
    // pHier/itemid. This method is useful in scenarios where a single document window manages
    // edits to multiple documents. Such a case would use a VSFPROPID_ViewHelper to listen for the
    // IVsWindowFrameNotify2::OnClose event. When OnClose is called with
    // *pgrfSaveOptions==FRAMECLOSE_PromptSave, then SaveItemsViaDlg should be called to save the 
    // list of items, and OnClose should set *pgrfSaveOptions==FRAMECLOSE_NoSave on return to 
    // indicate that all necessary saving has already been performed.
    HRESULT SaveItemsViaDlg([in] UINT cItems, [in, size_is(cItems)] VSSAVETREEITEM rgSaveItems[]);

    //new method for the high definition VsColors
    HRESULT GetVSSysColorEx([in]  VSSYSCOLOREX  dwSysColIndex,
        [out] DWORD       *pdwRGBval);

    HRESULT CreateGradient([in] GRADIENTTYPE gradientType, [out] IVsGradient ** pGradient);

    HRESULT GetVSCursor([in] VSCURSORTYPE cursor, [out] HCURSOR* phIcon);

    HRESULT IsAutoRecoverSavingCheckpoints([out] BOOL *pfARSaving);

    // This method will handle calling LoadMungedDlgTemplate and handle the shell modal state
    // It will also automaticly configure the help button to be placed in the title
    // bar where context help is normaly displayed.  It may not be used in conjunction with
    // the ATL dialog template because it does its own subclassing of the dialog procedure.
    HRESULT VsDialogBoxParam([in] HINSTANCE hinst, [in] DWORD dwId, [in] DLGPROC lpDialogFunc, [in] LPARAM lp);

    HRESULT CreateIconImageButton([in] HWND hwnd, [in] HICON hicon, [in] BWI_IMAGE_POS bwiPos, [out] IVsImageButton** ppImageButton);
    HRESULT CreateGlyphImageButton([in] HWND hwnd, [in] WCHAR chGlyph, [in] int xShift, [in] int yShift, [in] BWI_IMAGE_POS bwiPos, [out] IVsImageButton** ppImageButton);
}


//---------------------------------------------------------------------------
// SVsMainWindowDropTarget
//---------------------------------------------------------------------------
//
// This service implements IDropTarget interface. It is the drag/drop handler
// for the main window of the IDE. This drag/drop handler handles the CF_HDROP
// format that is used to drag files from the file system (Windows Explorer)
// and other sources that offer files. All windows that do not otherwise register
// for drag/drop (::RegisterDragDrop) will inherit this handler for free.
// Those that register for drag/drop itself will not inherit this file opening.
//
// NOTE: THIS IS A CHANGE FROM VS 7.0/7.1 -- In these earlier versions the VS
// IDE used the WS_EX_ACCEPTFILES window style on its main window to handle
// opening files via the WM_DROPFILES mechanism. This had the undesireable 
// effect of merging unrelated drag/drop behaviors together on a single window.
// A window that otherwise returned S_OK/DROPEFFECT_NONE from IDropTarget::
// DragEnter/DragOver would not actually get a "NoDrop" cursor but instead
// would get the "Copy" cursor indicating that the file will be opened. On 
// a window like the Solution Explorer this was very confusing behavior for 
// the user. (One way to override this default behavior in VS 7.0/7.1 is to
// return E_FAIL/DROPEFFECT_NONE from DragEnter or DragOver, but this is unnatural.
//
// Any window that register for drag/drop itself but still wants to inherit
// the default handling for CF_HDROP must QueryService for this object and 
// explicitly delegate to it in their implementation of IDropTarget. 
// For example, the standard Text Editor wants to allow the user to open files
// by dragging to the Text Editor View. It prioritizes handling CF_HDROP 
// over CF_TEXT or any other format. The delegation to this MainWindowDropTarget
// from DragEnter, DragOver, DragLeave, and Drop will look like the following:
//    STDMETHODIMP CEditView::DragEnter(IDataObject *pIDataObject, DWORD grfKeyState,
//                                      POINTL pt, DWORD *pdwEffect)
//    {
//        HRESULT hr = S_OK;
//        DWORD dwEffectSave = *pdwEffect;
//        CComPtr<IDropTarget> pMainDropTarget;
//        if (SUCCEEDED(m_pSP->QueryService(SID_SVsMainWindowDropTarget, IID_IDropTarget, (LPVOID*)&pMainDropTarget)))
//        if (pMainDropTarget)
//        {
//            hr = pMainDropTarget->DragEnter(pIDataObject, grfKeyState, pt, pdwEffect);
//            if (SUCCEEDED(hr) && *pdwEffect != DROPEFFECT_NONE)
//                return S_OK;
//        }
//        // restore the original pdwEffect. on input it indicates the allowed drop effects
//        *pdwEffect = dwEffectSave;
//        ... do what you would other do ...

// declare the service type for interop
[uuid(uuid_SVsMainWindowDropTarget)]
interface SVsMainWindowDropTarget : IUnknown {}

cpp_quote("#define SID_SVsMainWindowDropTarget IID_SVsMainWindowDropTarget")


//---------------------------------------------------------------------------
// IVsSupportItemHandoff2
//---------------------------------------------------------------------------
// Normally only implemented by Miscellaneous Files project.
// Interface retrieved by QI from IVsHierarchy.
// OnBeforeHandoffItem gives the receiver project a chance to do any necessary
// processing of the document to be handed off (primarily save of an untitled
// document to the directory of the destination project). e.g. This is used
// by the Environment's implementation of the cmdidMoveFileToProject<N> commands.
[
    uuid(uuid_IVsSupportItemHandoff2),
    version(1.0),
    pointer_default(unique)
]
interface IVsSupportItemHandoff2 : IUnknown
{
    HRESULT OnBeforeHandoffItem(
        [in] VSITEMID itemid,            // itemid in project where document will be removed
        [in] IVsProject3 *pProjDest);    // project to which document will be transferred
}

//---------------------------------------------------------------------------
// IVsLaunchPadOutputParser
//---------------------------------------------------------------------------
// Implemented by the caller of IVsLaunchPad2::ExecCommandEx in order to parse tool output lines for
// task list item or navigation information. The launch pad calls ParseOutputStringForInfo. If task
// item text is returned, the launch pad creates a task list item using the information returned. If
// only filename and line number information is returned, the launch pad adds the line to the output
// window and uses the filename and line number as the navigation information for the output line.
[
    uuid(uuid_IVsLaunchPadOutputParser),
    version(1.0),
    pointer_default(unique)
]
interface IVsLaunchPadOutputParser : IUnknown
{
    HRESULT ParseOutputStringForInfo(
        [in] LPCOLESTR pszOutputString,   // one line of output text
        [out, optional] BSTR *pbstrFilename,        // fully-qualified file name for task list item (may be NULL)
        [out, optional] ULONG *pnLineNum,           // file line number for task list item (may be NULL)
        [out, optional] ULONG *pnPriority,          // priority for task list item (may be NULL)
        [out, optional] BSTR *pbstrTaskItemText,    // description text for task list item (may be NULL)
        [out, optional] BSTR *pbstrHelpKeyword);    // help keyword for task list item (may be NULL)
}

typedef enum
{
    /*
    LPF_PipeStdoutToOutputWindow = 0x1,
    LPF_PipeStdoutToTaskList     = 0x2,
    LPF_ClearOutputWindow        = 0x4,  // clears the specified pane of the output window before spawning the tool
    LPF_PauseAfterExecution      = 0x8,  // wait for keypress to close process spawned in external command window
    */
    LPF_TreatOutputAsUnicode     = 0x10,
} _LAUNCHPAD_FLAGS2;
typedef DWORD LAUNCHPAD_FLAGS2;

//---------------------------------------------------------------------------
// IVsLaunchPad2
//---------------------------------------------------------------------------
// Implemented by the Environment.
// Interface retrieved by QI after calling IVsLaunchPadFactory::CreateLaunchPad.
// This interface is used to launch a console app.  It is useful when a project 
// needs to spawn command line tools and batch files as part of its build process,
// and needs the ability to parse the tool output for task list item information.
[
    uuid(uuid_IVsLaunchPad2),
    version(1.0),
    pointer_default(unique)
]
interface IVsLaunchPad2 : IUnknown
{
    HRESULT ExecCommandEx(
        [in] LPCOLESTR pszApplicationName,            // passed on to CreateProcess (see Win32 API for details)
        [in] LPCOLESTR pszCommandLine,                // passed on to CreateProcess (see Win32 API for details)
        [in] LPCOLESTR pszWorkingDir,                 // may be NULL, passed on to CreateProcess (see Win32 API for details)
        [in] LAUNCHPAD_FLAGS2 lpf,                    // control flags (see vsshell.idl)
        [in] IVsOutputWindowPane *pOutputWindowPane,  // if LPF_PipeStdoutToOutputWindow, pane in the output window to pipe output to
        [in] ULONG nTaskItemCategory,                 // if LPF_PipeStdoutToTaskList is specified
        [in] ULONG nTaskItemBitmap,                   // if LPF_PipeStdoutToTaskList is specified
        [in] LPCOLESTR pszTaskListSubcategory,        // if LPF_PipeStdoutToTaskList is specified
        [in] IVsLaunchPadEvents *pVsLaunchPadEvents,  // callback for cancellation (may be NULL)
        [in] IVsLaunchPadOutputParser *pOutputParser, // callback for parsing of information from output (may be NULL)
        [out, optional] DWORD *pdwProcessExitCode,              // value return by process (may be NULL)
        [out, optional] BSTR *pbstrOutput);                     // all output generated (may be NULL)
}


//---------------------------------------------------------------------------
// IVsOpenProjectOrSolutionDlg
//---------------------------------------------------------------------------
//Called to open a Solution or Project using the standard open dlgs
//---------------------------------------------------------------------------
enum __VSPROJSLNDLGFLAGS
{
    PSDF_OpenSolutionDialog         = 0x00000001, // 
    PSDF_OpenProjectDialog          = 0x00000002, //
    PSDF_AddExistingProjectDialog   = 0x00000004, // 
    PSDF_DefaultToAllProjectsFilter = 0x00000008, // 
    PSDF_DirectoryPicker            = 0x00000010, // Puts dialog in directory picker mode. Used to open directory based projects.
};
typedef DWORD VSPROJSLNDLGFLAGS;

[
    uuid(uuid_IVsOpenProjectOrSolutionDlg),
    version(1.0),
    pointer_default(unique)
]
interface IVsOpenProjectOrSolutionDlg : IUnknown
{
    HRESULT OpenProjectOrSolutionViaDlg([in] VSPROJSLNDLGFLAGS grfProjSlnDlgFlags, 
        [in] LPCOLESTR pwzStartDirectory,     // start directory
        [in] LPCOLESTR pwzDialogTitle,        // dlg title. Leave NULL for default title
        [in] REFGUID rguidProjectType);       // specifies the project type to use with PSDF_DirectoryPicker
}

// declare the service type for interop
[uuid(uuid_SVsOpenProjectOrSolutionDlg)]
interface SVsOpenProjectOrSolutionDlg : IUnknown {}

cpp_quote("#define SID_SVsOpenProjectOrSolutionDlg IID_SVsOpenProjectOrSolutionDlg")

//---------------------------------------------------------------------------
// IVsCreateAggregateProject
//---------------------------------------------------------------------------
//
//---------------------------------------------------------------------------
[
    uuid(uuid_IVsCreateAggregateProject),
    version(1.0),
    pointer_default(unique)
]
interface IVsCreateAggregateProject : IUnknown
{
    // Just like IVsSolution::CreateProject except the first param is a list of guids in a string that
    // specifies all the project types to aggregate together to create a single project
    HRESULT CreateAggregateProject(
        [in] LPCOLESTR               pszProjectTypeGuids,
        [in] LPCOLESTR               pszFilename,
        [in] LPCOLESTR               pszLocation,
        [in] LPCOLESTR               pszName,
        [in] VSCREATEPROJFLAGS       grfCreateFlags,
        [in] REFIID                  iidProject,
        [out, iid_is(iidProject)]    void **ppvProject); 
}

[uuid(uuid_SVsCreateAggregateProject)]
interface SVsCreateAggregateProject : IUnknown
{}

cpp_quote("#define SID_SVsCreateAggregateProject IID_SVsCreateAggregateProject")

//---------------------------------------------------------------------------
// IVsAggregatableProject
//---------------------------------------------------------------------------
//Implemented by a project that supports aggregation
//---------------------------------------------------------------------------
[
    uuid(uuid_IVsAggregatableProject),
    version(1.0),
    pointer_default(unique)
]
interface IVsAggregatableProject : IUnknown
{
    // Allows the project aggregator to pass the inner IUnknown of the project you're aggregating to you.
    HRESULT SetInnerProject([in] IUnknown *punkInner);

    // Called   by the owner to tell the owned project to do all it's initialisation.
    // The owned project should do all its CreateProject work   in here.
    // The cookie   parameter is just the cookie which the owned project passed back in PreCreateForOwner. This allows the
    // owned project to create its project object
    HRESULT InitializeForOuter(
        [in] LPCOLESTR               pszFilename,
        [in] LPCOLESTR               pszLocation,
        [in] LPCOLESTR               pszName,
        [in] VSCREATEPROJFLAGS       grfCreateFlags,
        [in] REFIID                  iidProject,
        [out, iid_is(iidProject)]    void **ppvProject,
        [out] BOOL                   *pfCanceled);

    // Called after all objects in the aggregation was called on InitializeForOuter.
    // At this point the Aggregation can be considered fully functional.
    // Here would be the place for flavor to do initialization with external packages/objects
    // that needs to receive an interface pointers from the aggregation.
    // Flavors should call inner->OnAggregationComplete() in their implementation on OnAggregationComplete
    HRESULT OnAggregationComplete();

    // gets and sets the list of project type guids that make up this aggregate project\
    // Note: If you are not the inner most project, you should delegate this call to
    // your inner project.
    HRESULT GetAggregateProjectTypeGuids([out] BSTR *pbstrProjTypeGuids);
    HRESULT SetAggregateProjectTypeGuids([in] LPCOLESTR lpstrProjTypeGuids);
};

//---------------------------------------------------------------------------
// IVsAggregatableProjectFactory
//---------------------------------------------------------------------------
//Implemented by a projecttype that supports aggregation
//---------------------------------------------------------------------------
[
    uuid(uuid_IVsAggregatableProjectFactory),
    version(1.0),
    pointer_default(unique)
]
interface IVsAggregatableProjectFactory : IUnknown
{
    // returns a string containing a list of project type guids to be aggregated together to
    // create an instance of this project. It should minimally return 1 guid which is the project
    // type guid for itself. This method is expected to get this list of guids from the specified file
    HRESULT GetAggregateProjectType([in] LPCOLESTR pszFilename, [out] BSTR  *pbstrProjTypeGuid);

    // Called  by the owner/outer so that the owned/inner project can create an aggregatable
    // version of  itself, using punkOwner as the controlling IUnknown.
    // The owned project should only create its project object instance here.   All the heavy
    // initialization  work should occur in IVsAggregatableProject::InitializeForOwner. That ensures the owner/outer project will work
    // work correctly  during the owned/inner initialization.
    // The owned project must  return its inner IUnknown
    HRESULT PreCreateForOuter([in] IUnknown *punkOuter, [out] IUnknown **ppunkProject);
};

//---------------------------------------------------------------------------
// IVsParentProject2
//---------------------------------------------------------------------------
// [optional] Implemented by a project that supports creation of nested projects.
//---------------------------------------------------------------------------
[
    uuid(uuid_IVsParentProject2),
    version(1.0),
    pointer_default(unique)
]
interface IVsParentProject2 : IUnknown
{
    // This method provides a way for callers to add a nested project to a project (for example, a solution folder) in the same way
    // that it is done through the UI.  The parameters are the same as those for IVsSolution::CreateProject, so if the project supports
    // IVsParentProject2, IVsParentProject2::CreateNestedProject can be called, and if not, IVsSolution::CreateProject can be called.
    HRESULT CreateNestedProject([in] VSITEMID itemidLoc, [in] REFGUID rguidProjectType, [in] LPCOLESTR lpszMoniker, [in] LPCOLESTR lpszLocation,
        [in] LPCOLESTR lpszName, [in] VSCREATEPROJFLAGS grfCreateFlags, [in] REFGUID rguidProjectID, [in] REFIID iidProject, [out, iid_is(iidProject)] void **ppProject);
    // This method provides a way for callers to add the contents of a solution to a project (for example, a solution folder) in the same way
    // that it is done through the UI.  The parameters are the same as those for IVsSolution::OpenSolutionFile, so if the project supports
    // IVsParentProject2, IVsParentProject2::CreateNestedProject can be called, and if not, IVsSolution::CreateProject can be called.
    HRESULT AddNestedSolution([in] VSITEMID itemidLoc, [in] VSSLNOPENOPTIONS grfOpenOpts, [in] LPCOLESTR pszFilename);
};

//---------------------------------------------------------------------------
// Specifyes the persistent location for IVsBuildPropertyStorage and IPersistXMLFragment
//---------------------------------------------------------------------------
enum _PersistStorageType
{
    PST_PROJECT_FILE = 1,
    PST_USER_FILE    = 2
};
typedef DWORD PersistStorageType;

//---------------------------------------------------------------------------
// IVsBuildPropertyStorage
//---------------------------------------------------------------------------
// Used to access property values from XMAKE section of project file
[
    uuid(uuid_IVsBuildPropertyStorage),
    version(1.0),
    pointer_default(unique)
]
interface IVsBuildPropertyStorage : IUnknown
{
    HRESULT GetPropertyValue( [in] LPCOLESTR pszPropName, [in, unique] LPCOLESTR pszConfigName, [in] PersistStorageType storage, [out, retval] BSTR* pbstrPropValue);
    HRESULT SetPropertyValue( [in] LPCOLESTR pszPropName, [in, unique] LPCOLESTR pszConfigName, [in] PersistStorageType storage, [in] LPCOLESTR pszPropValue);
    HRESULT RemoveProperty( [in] LPCOLESTR pszPropName, [in, unique] LPCOLESTR pszConfigName, [in] PersistStorageType storage);
    HRESULT GetItemAttribute( [in] VSITEMID item, [in] LPCOLESTR pszAttributeName, [out] BSTR *pbstrAttributeValue);
    HRESULT SetItemAttribute( [in] VSITEMID item, [in] LPCOLESTR pszAttributeName, [in] LPCOLESTR pszAttributeValue);
};

// Flags used in IVsProjectBuildSystem.GetBuildSystemKind. Flag values 0x0001-0x8000 are reserved for Visual Studio use
enum _BuildSystemKindFlags
{
    BSK_MSBUILD = 1 // indicates that the build system stores files in the MSBuild format
};
typedef DWORD BuildSystemKindFlags;

//---------------------------------------------------------------------------
// IVsProjectBuildSystem
//---------------------------------------------------------------------------
// Used to access MSBuild system objects
[
    uuid(uuid_IVsProjectBuildSystem),
    version(1.0),
    pointer_default(unique)
]
interface IVsProjectBuildSystem : IUnknown
{
    HRESULT SetHostObject( [in] LPCOLESTR pszTargetName, [in] LPCOLESTR pszTaskName, [in] IUnknown* punkHostObject);

    // These methods are used to force the build system into "batch mode".  That is,
    // any changes/properties set between StartBatchEdit() and EndBatchEdit() will not
    // be committed to the IDE compilers until EndBatchEdit() is called.
    HRESULT StartBatchEdit();
    HRESULT EndBatchEdit();
    HRESULT CancelBatchEdit();

    HRESULT BuildTarget( [in] LPCOLESTR pszTargetName, [out, retval] VARIANT_BOOL* pbSuccess );

    // Used to determine the kind of build system, in VS 2005 there's only one defined kind: MSBuild
    HRESULT GetBuildSystemKind([out, retval] BuildSystemKindFlags* pBuildSystemKind);
};

//---------------------------------------------------------------------------
// IPersistXMLFragment
//---------------------------------------------------------------------------
// Implemented by flavor object . Used to map persist non XMake (non build related)
// flavor specific data.
//

[
    uuid(uuid_IPersistXMLFragment),
    version(1.0),
    pointer_default(unique)
]
interface IPersistXMLFragment: IUnknown
{
    // Called to initialize the project extension properies and other data
    HRESULT InitNew([in] REFGUID guidFlavor, [in] PersistStorageType storage);

    HRESULT IsFragmentDirty([in] PersistStorageType storage, [out] BOOL *pfDirty);

    // Base project system will load the apropriate piece of XML from project and user file related to the given Flavor GUID and call the Flavors to depersit its data
    HRESULT Load([in] REFGUID guidFlavor, [in] PersistStorageType storage, [in]  LPCOLESTR pszXMLFragment);

    // Base project system will ask the flavors to build their XML sections and save them in Project/User file
    HRESULT Save([in] REFGUID guidFlavor, [in] PersistStorageType storage, [out] BSTR *pbstrXMLFragment, [in] BOOL fClearDirty);

};


//------------------------------------------------------------------
// IVsProjectFlavorCfg
//------------------------------------------------------------------
// Implemented by a project flavor.
// These objects are instantiated via the IVsProjectFlavorCfgProvider
// interface.
// This interface is implemented by a project flavor's configuration object
// in order to enhance the base project configuration object implementation.
// The object that implements this interface should also implement
// IPersistXMLFragment to manage the persistance of its state into the
// project file.
[
    uuid(uuid_IVsProjectFlavorCfg),
    version(1.0),
    pointer_default(unique)
]
interface IVsProjectFlavorCfg : IUnknown
{
    // iidCfg can be any of the standard Cfg interfaces
    // (e.g. IVsDeployableProjectCfg, IVsDebuggableProjectCfg).
    HRESULT get_CfgType([in] REFIID iidCfg, [out, iid_is(iidCfg)] void **ppCfg);
    HRESULT Close(void);
}

//------------------------------------------------------------------
// IVsProjectFlavorCfgOutputGroups
//------------------------------------------------------------------
// Implemented by project flavors if they whant to control Output groups content
// The base project ask for IVsProjectFlavorCfgOutputGroups via IVsProjectFlavorCfg::get_CfgType
//
[
    uuid(uuid_IVsProjectFlavorCfgOutputGroups),
    version(1.0),
    pointer_default(unique)
]
interface IVsProjectFlavorCfgOutputGroups : IUnknown
{
    HRESULT CustomizeOutputGroup( [in] IVsOutputGroup *pIn,  [out] IVsOutputGroup **pOut);
}

//------------------------------------------------------------------
// IVsProjectFlavorCfgProvider
//------------------------------------------------------------------
// Implemented by a project flavor.
// This interface is retrieve by QueryInterface from the IVsProjectFlavor
// object.
// This interface functions as the factory for project flavor's configuration
// objects. The base project system will ask the project flavor to create a // IVsProjectFlavorCfg object corresponding to each one of its configuration
// objects. The ProjectFlavorCfg objects can implement IPersistXMLFragment to
// manage persistence into the project file. The base project system will
// call Init/Load/Save as appropriate. The ProjectFlavorCfg object can hold
// an addref'ed pointer to the base project's IVsCfg object.
[
    uuid(uuid_IVsProjectFlavorCfgProvider),
    version(1.0),
    pointer_default(unique)
]
interface IVsProjectFlavorCfgProvider : IUnknown
{
    HRESULT CreateProjectFlavorCfg([in] IVsCfg *pBaseProjectCfg, [out] IVsProjectFlavorCfg **ppFlavorCfg);
}

enum __UPDATE_REFERENCE_REASON
{
    URR_PROJECT_OPEN,
    URR_BUILD,
    URR_START_DEBUG,
    URR_REFERENCEPATH_CHANGED,
    URR_REFERENCE_ADDED,
    URR_REFERENCE_REMOVED,
    URR_EXPLICIT_USER_ACTION
};

typedef DWORD UPDATE_REFERENCE_REASON;

//------------------------------------------------------------------
// IVsProjectFlavorReferences
// Gives the flavor mechanism to control certain aspects of project reference handling.
//------------------------------------------------------------------
[
    uuid(uuid_IVsProjectFlavorReferences),
    version(1.0),
    pointer_default(unique)
]
interface IVsProjectFlavorReferences : IUnknown
{
    // Called before adding a refernece into a flavored project. Allow the flavor reject some particular reference
    HRESULT QueryAddProjectReference([in] IUnknown *pReferencedProject, [out, retval] BOOL *pbCanAdd);

    // Called before other project attempts to aquire reference to a flavor. Flavor can deny being referenced
    HRESULT QueryCanBeReferenced([in] IUnknown *pReferencingProject, [out, retval] BOOL *pbAllowReferenced);

    // Called before update reference is executed. Flavor may hint against updating the references.
    HRESULT QueryRefreshReferences([in] UPDATE_REFERENCE_REASON reason, [out, retval] BOOL *pbUpdate);
}


//---------------------------------------------------------------------------
// VSTRANSACCELEXFLAGS
//---------------------------------------------------------------------------

// Flags for IVsFilterKeys2::TranslateAcceleratorEx
enum __VSTRANSACCELEXFLAGS
{
    VSTAEXF_Default                = 0x00000000,  // rgrguidKeyBindingScopes are
    // pre-pended to currently active
    // key binding scopes and command
    // is fired.
    VSTAEXF_NoFireCommand          = 0x00000001,  // do not fire the command through command routing.
    VSTAEXF_IgnoreActiveKBScopes   = 0x00000002,  // rgrguidKeyBindingScopes are
    // used INSTEAD of currently active
    // key binding scopes
    VSTAEXF_UseTextEditorKBScope   = 0x00000004,  // Translate keys using TextEditor key bindings.
    // equivalent to passing CMDUIGUID_TextEditor,
    // CMDSETID_StandardCommandSet97, and guidKeyDupe
    // for scopes and the VSTAEXF_IgnoreActiveKBScopes flag.
    // NOTE: use this flag instead of passing any GUIDS
    // (i.e. cKeyBindingScopes must be 0)
    VSTAEXF_UseGlobalKBScope       = 0x00000008,  // Translate keys using Global key bindings.
    // equivalent to passing CMDSETID_StandardCommandSet97
    // and guidKeyDupe for scopes and the
    // VSTAEXF_IgnoreActiveKBScopes flag.
    // NOTE: use this flag instead of passing any GUIDS
    // (i.e. cKeyBindingScopes must be 0)
    VSTAEXF_AllowModalState       = 0x00000010,   // By default this function cannot be called when
    // the shell is in a modal state, since command routing
    // is inherently dangerous.  However if you must access
    // this in a modal state, specify this flag, but keep in
    // mind that many commands will cause unpredictable 
    // behavior if fired.
};
typedef DWORD VSTRANSACCELEXFLAGS;

//---------------------------------------------------------------------------
// IVsFilterKeys2
//---------------------------------------------------------------------------
// Implemented by the Environment.
// Interface for clients to perform advanced keyboard message translation
[
    uuid(uuid_IVsFilterKeys2),
    version(1.0),
    pointer_default(unique)
]
interface IVsFilterKeys2 : IUnknown
{
    // Called to determine what command the specified Windows message will be
    // translated into given a specified set of active keybinding scopes,
    // and optionally to fire the cmd through standard command routing.  For 
    // example, to use the text editor's key bindings CMDUIGUID_TextEditor would 
    // be passed. If the msg did/will translate to a
    // command, this method returns *fCmdTranslated==TRUE and fills the out 
    // params with the commands guid/id pair.  If the msg did/will not translate 
    // to a command, this method returns *fCmdTranslated==FALSE, and sets the 
    // out params to zeros.
    //
    // If VSTAEXF_IgnoreActiveKBScopes is not specified, then the currently active
    // scopes are searched after those specified by the caller through 
    // cKeyBindingScopes/rgguidKeyBindingScopes.
    //
    HRESULT TranslateAcceleratorEx(
        [in] LPMSG pMsg, 
        [in] VSTRANSACCELEXFLAGS dwFlags, 
        [in] DWORD cKeyBindingScopes,
        [in, size_is(cKeyBindingScopes)] const GUID rgguidKeyBindingScopes[],
        [out] GUID *pguidCmd, 
        [out] DWORD *pdwCmd,
        [out] BOOL *fCmdTranslated,
        [out] BOOL *pfKeyComboStartsChord
        );
};

enum __UserSettingsFlags
{
    USF_None                 = 0x00000000,
    USF_ResetOnImport        = 0x00000001,
    USF_DisableOptimizations = 0x00000002
};
typedef DWORD UserSettingsFlags;

enum __VSSETTINGSERRORTYPES
{
    vsSettingsErrorTypeSuccess      = 0x00000000,   // 
    vsSettingsErrorTypeError        = 0x00000001,   // 
    vsSettingsErrorTypeWarning      = 0x00000002,   // 
    vsSettingsErrorTypeRestart      = 0x00000004,   // 
    vsSettingsErrorTypeNotInstalled = 0x00000008,   // 
    vsSettingsErrorTypeMask         = 0x0000000F,   // 
};
typedef DWORD VSSETTINGSERRORTYPES;

//---------------------------------------------------------------------------
// IVsSettingsReader
//---------------------------------------------------------------------------
// Implemented by the IDE.
// Interface to allow client packages to read settings from their category
// of the vssettings file.
//
// This interface is available as a parameter passed to IVsUserSettings.ImportSettings()
//
[
    uuid(uuid_IVsSettingsReader),
    version(1.0),
    pointer_default(unique)
]
interface IVsSettingsReader : IUnknown
{
    HRESULT ReadSettingString([in] LPCOLESTR pszSettingName, [out, retval] BSTR *pbstrSettingValue);
    HRESULT ReadSettingLong([in] LPCOLESTR pszSettingName, [out, retval] long *plSettingValue);
    HRESULT ReadSettingBoolean([in] LPCOLESTR pszSettingName, [out, retval] BOOL *pfSettingValue);
    //pSettingValue must be allocated and passed in
    //passing NULL for pSettingValue will cause *plDataLength to be returned with the necessary size of the input buffer
    HRESULT ReadSettingBytes([in] LPCOLESTR pszSettingName, [in, out] BYTE *pSettingValue, [out] long *plDataLength, [in] long lDataMax);
    HRESULT ReadSettingAttribute([in] LPCOLESTR pszSettingName,[in] LPCOLESTR pszAttributeName, [out, retval] BSTR *pbstrSettingValue);
    HRESULT ReadSettingXml([in] LPCOLESTR pszSettingName, [out, retval] IUnknown **ppIXMLDOMNode);
    HRESULT ReadSettingXmlAsString([in] LPCOLESTR pszSettingName, [out, retval] BSTR *pbstrXML);
    HRESULT ReadCategoryVersion([out] int *pnMajor, [out] int *pnMinor, [out] int *pnBuild, [out] int *pnRevision);
    HRESULT ReadFileVersion([out] int *pnMajor, [out] int *pnMinor, [out] int *pnBuild, [out] int *pnRevision);
    HRESULT ReportError([in] LPCOLESTR pszError, VSSETTINGSERRORTYPES dwErrorType);
};

//---------------------------------------------------------------------------
// IVsSettingsWriter
//---------------------------------------------------------------------------
// Implemented by the IDE.
// Interface to allow client packages to write settings into their category
// of the vssettings file.
//
// This interface is available as a parameter passed to IVsUserSettings.ImportSettings()
//
[
    uuid(uuid_IVsSettingsWriter),
    version(1.0),
    pointer_default(unique)
]
interface IVsSettingsWriter : IUnknown
{
    HRESULT WriteSettingString([in] LPCOLESTR pszSettingName, [in] LPCOLESTR pszSettingValue);
    HRESULT WriteSettingLong([in] LPCOLESTR pszSettingName, [in] long lSettingValue);
    HRESULT WriteSettingBoolean([in] LPCOLESTR pszSettingName, [in] BOOL fSettingValue);
    HRESULT WriteSettingBytes([in] LPCOLESTR pszSettingName, [in, size_is(lDataLength)] BYTE *pSettingValue, long lDataLength);
    HRESULT WriteSettingAttribute([in] LPCOLESTR pszSettingName, [in] LPCOLESTR pszAttributeName, [in] LPCOLESTR pszSettingValue);
    HRESULT WriteSettingXml([in] IUnknown *pIXMLDOMNode);
    HRESULT WriteSettingXmlFromString([in] LPCOLESTR szXML);
    HRESULT WriteCategoryVersion([in] int nMajor, [in] int nMinor, [in] int nBuild, [in] int nRevision);
    HRESULT ReportError([in] LPCOLESTR pszError, [in] VSSETTINGSERRORTYPES dwErrorType);
};


//---------------------------------------------------------------------------
// IVsUserSettings
//---------------------------------------------------------------------------
// Implemented by client packages.
// Interface to allow the IDE to request that a settings category imports/exports its settings.
//
// This interface must be made available via a QueryInterface call on the IVsPackage object.
//
[
    uuid(uuid_IVsUserSettings),
    version(1.0),
    pointer_default(unique)
]
interface IVsUserSettings : IUnknown
{
    HRESULT ExportSettings([in] LPCOLESTR pszCategoryGUID, [in] IVsSettingsWriter *pSettings);
    HRESULT ImportSettings([in] LPCOLESTR pszCategoryGUID, [in] IVsSettingsReader *pSettings, [in] UserSettingsFlags flags, [in, out] BOOL *pfRestartRequired);
};


// declare the service type for interop
[uuid(uuid_SVsSettingsReader)]
interface SVsSettingsReader : IUnknown {}

cpp_quote("#define SID_SVsSettingsReader IID_SVsSettingsReader")


//---------------------------------------------------------------------------
// IVsUserSettingsQuery
//---------------------------------------------------------------------------
// Implemented by client packages.
// Interface to allow the IDE to find out whether a category requires an export of its settings.
//
// This interface must be made available via a QueryInterface call on the IVsPackage object.
//
[
    uuid(uuid_IVsUserSettingsQuery),
    version(1.0),
    pointer_default(unique)
]
interface IVsUserSettingsQuery : IUnknown
{
    HRESULT NeedExport([in] LPCOLESTR szCategoryGUID, [out] BOOL *pfNeedExport);
};


interface IVsProfileSettingsFileInfo;
interface IVsProfileSettingsFileCollection;
interface IVsProfileSettingsTree;
interface IVsProfileDataManager;
interface IVsProfilesManagerUI;


//Note: we use this list for sorting the filelist in the UI
//      keep the list ordered such that lower numbers have the highest priority
enum __VSPROFILELOCATIONS
{
    PFL_LocationNone            = 0x00000000, // used only for init
    PFL_InstallDir              = 0x00000001, // File resides in the installation directory
    PFL_SettingsDir             = 0x00000002, // File resides in the user's default settings directory
    PFL_Other                   = 0x00000004, // Custom file that the user has browsed to
    PFL_AutoSave                = 0x00000008, // Add the current autosave file
    PFL_All                     = 0xFFFFFFFF, // Custom file that the user has browsed to
};
typedef DWORD VSPROFILELOCATIONS;

enum __VSPROFILETEAMSETTINGSFLAGS
{
    PTSF_CHECKFORUPDATE     = 0x00000000, // Import from the teamsettings file if it is newer than remember
    PTSF_UPDATEALWAYS       = 0x00000001, // Force an import from the teamsettings file
};
typedef DWORD VSPROFILETEAMSETTINGSFLAGS;

enum __VSPROFILETEAMSETTINGSCHANGEDFLAGS
{
    PTSCF_TEAMFILE_NOCHANGE = 0x00000000, // The team file setting has not been touched
    PTSCF_TEAMFILE_CHANGED  = 0x00000001, // The team file has been changed from its previous value
    PTSCF_TEAMFILE_SAME     = 0x00000002, // The team file setting has been updated, but the value is the same as before
};
typedef DWORD VSPROFILETEAMSETTINGSCHANGEDFLAGS;

enum __VSPROFILECATEGORYSECURITY
{
    PCSEC_SAFE              = 0x00000000, // The settings in this cateogy are safe
    PCSEC_THREAT_VS         = 0x00000001, // The settings in this category could threaten the VS user experience
    PCSEC_THREAT_MACHINE    = 0x00000002, // The settings in this category could threaten the machine, or user data
};
typedef DWORD VSPROFILECATEGORYSECURITY;

enum __VSPROFILECATEGORYSENSITIVITY
{
    PCSEN_SAFE      = 0x00000000, // The settings in this category contain no sensitive information
    PCSEN_PRIVACY   = 0x00000001, // The settings in this category could compromise a user's privacy
};
typedef DWORD VSPROFILECATEGORYSENSITIVITY;

enum __VSPROFILEGETFILENAME
{
    PGFN_EXPORT         = 0x00000001, // Use the default export root file name
    PGFN_SAVECURRENT    = 0x00000002, // Use the default current settings root file name
    PGFN_AUTOSAVE       = 0x00000004, // Use the default autosave root file name
};
typedef DWORD VSPROFILEGETFILENAME;

enum __VSSETTINGSCOMPLETIONSTATUS
{
    vsSettingsCompletionStatusNotStarted    = 0x00000000,   // 
    vsSettingsCompletionStatusIncomplete    = 0x00000001,   // 
    vsSettingsCompletionStatusComplete      = 0x00000002,   //
    vsSettingsCompletionStatusStateMask     = 0x0000000F,   //
    vsSettingsCompletionStatusSuccess       = 0x00000000,   //
    vsSettingsCompletionStatusWarnings      = 0x00000010,   //
    vsSettingsCompletionStatusErrors        = 0x00000020,   //
    vsSettingsCompletionStatusSuccessMask   = 0x000000F0,   //
};
typedef DWORD VSSETTINGSCOMPLETIONSTATUS;


//---------------------------------------------------------------------------
// IVsProfileSettingsFileInfo
//---------------------------------------------------------------------------
// Implemented by the IDE.
// This is an internal interface used to allow communication between native and
// managed code in the IDE.
//
[
    uuid(uuid_IVsProfileSettingsFileInfo),
    version(1.0),
    pointer_default(unique)
]
interface IVsProfileSettingsFileInfo : IUnknown
{
    HRESULT GetFilePath([out] BSTR *pbstrFilePath);
    HRESULT GetFileLocation([out] VSPROFILELOCATIONS *pfileLocation);
    HRESULT GetFriendlyName([out] BSTR *pbstrFriendlyName);
    HRESULT GetDescription([out] BSTR *pbstrDescription);

    HRESULT GetSettingsForImport([out] IVsProfileSettingsTree **ppSettingsTree);
};


//---------------------------------------------------------------------------
// IVsProfileSettingsFileCollection
//---------------------------------------------------------------------------
// Implemented by the IDE.
// This is an internal interface used to allow communication between native and
// managed code in the IDE.
//
[
    uuid(uuid_IVsProfileSettingsFileCollection),
    version(1.0),
    pointer_default(unique)
]
interface IVsProfileSettingsFileCollection : IUnknown
{
    HRESULT GetCount([out] int *pCount);
    HRESULT GetSettingsFile([in] int index, [out] IVsProfileSettingsFileInfo **ppFileInfo);
    HRESULT AddBrowseFile([in] BSTR bstrFilePath, [out] IVsProfileSettingsFileInfo **ppFileInfo); //Add a file to the file collection
};


//---------------------------------------------------------------------------
// IVsProfileSettingsTree
//---------------------------------------------------------------------------
// Implemented by the IDE.
// This is an internal interface used to allow communication between native and
// managed code in the IDE.
//
[
    uuid(uuid_IVsProfileSettingsTree),
    version(1.0),
    pointer_default(unique)
]
interface IVsProfileSettingsTree : IUnknown
{
    HRESULT GetChildCount([out] int *pCount);
    HRESULT GetChild([in] int index, [out] IVsProfileSettingsTree **ppChildTree);
    HRESULT GetEnabledChildCount([out] int *pCount);

    HRESULT GetDisplayName([out] BSTR *pbstrName);
    HRESULT GetDescription([out] BSTR *pbstrDescription);

    HRESULT GetCategory([out] BSTR *pbstrCategory);
    HRESULT GetRegisteredName([out] BSTR *pbstrRegisteredName);
    HRESULT GetNameForID([out] BSTR *pbstrNameForID);
    HRESULT GetFullPath([out] BSTR *pbstrFullPath);
    HRESULT GetPackage([out] BSTR *pbstrPackage);
    HRESULT GetIsAutomationPropBased([out] BOOL *pfAutoProp);

    HRESULT GetEnabled([out] BOOL *pfEnabled);
    HRESULT SetEnabled([in] BOOL fEnabled, [in] BOOL fIncludeChildren);

    HRESULT GetVisible([out] BOOL *pfVisible); //Nodes with placeholder nodes are invisible
    HRESULT GetAlternatePath([out] BSTR *pbstrAlternatePath); //The name of parent node for this node's placeholder node

    HRESULT GetIsPlaceholder([out] BOOL *pfPlaceholder); //Is this a placeholder node
    HRESULT GetRepresentedNode([out] IVsProfileSettingsTree **ppRepresentedNode); //A placeholder node has a represented node

    HRESULT GetSecurityLevel([out] VSPROFILECATEGORYSECURITY *pSecurityLevel);
    HRESULT GetSensitivityLevel([out] VSPROFILECATEGORYSENSITIVITY *pSensitivityLevel);

    HRESULT FindChildTree([in] BSTR bstrNameSearch, [out] IVsProfileSettingsTree **ppChildTree);

    HRESULT AddChildTree([in] IVsProfileSettingsTree *pChildTree); //Add the given tree as a child tree
    HRESULT RevisePlacements([in] IVsProfileSettingsTree *pTreeRoot, [in] IVsProfileSettingsTree *pTreeRootBasis, [in] BSTR bstrCurrentParent); //If this tree has an alternate root specified, then add self as a child in that tree
};


//---------------------------------------------------------------------------
// IVsSettingsErrorInformation
//---------------------------------------------------------------------------
// Implemented by the IDE.
// This is an internal interface used to allow communication between native and
// managed code in the IDE.
//
[
    uuid(uuid_IVsSettingsErrorInformation),
    version(1.0),
    pointer_default(unique)
]
interface IVsSettingsErrorInformation : IUnknown
{
    HRESULT GetCompletionStatus([out, retval] VSSETTINGSCOMPLETIONSTATUS *pdwCompletionStatus);

    HRESULT GetErrorCount([out, retval] int *pnErrors);
    HRESULT GetErrorInfo([in] int nErrorIndex, [out] VSSETTINGSERRORTYPES *pdwErrorType, [out] BSTR *pbstrError);
};


//---------------------------------------------------------------------------
// IVsProfileDataManager
//---------------------------------------------------------------------------
// Implemented by the IDE.
// Interface allows the settings features to be driven programatically. This is
// predominantly used as an internal interface to allow communication between
// native and managed code in the IDE.
//
// This interface is available via QueryService(SVsProfileDataManager)
//
[
    uuid(uuid_IVsProfileDataManager),
    version(1.0),
    pointer_default(unique)
]
interface IVsProfileDataManager : IUnknown
{
    //The path of the vssettings file chosen on first launch, or the last file the user reset to
    HRESULT LastResetPoint([out] BSTR *pbstrResetFilename);

    HRESULT GetSettingsFiles([in] VSPROFILELOCATIONS fileLocations, [out] IVsProfileSettingsFileCollection **ppCollection);
    HRESULT GetDefaultSettingsLocation([out] BSTR *pbstrSettingsLocation);
    HRESULT GetUniqueExportFileName([in] VSPROFILEGETFILENAME flags, [out] BSTR *pbstrExportFile);
    HRESULT GetSettingsFileExtension([out] BSTR *pbstrSettingsFileExtension);

    HRESULT GetSettingsForExport([out] IVsProfileSettingsTree **ppSettingsTree);

    HRESULT ExportSettings([in] BSTR bstrFilePath, [in] IVsProfileSettingsTree *pSettingsTree, [out] IVsSettingsErrorInformation **ppsettingsErrorInformation);
    HRESULT ImportSettings([in] IVsProfileSettingsTree *pSettingsTree, [out] IVsSettingsErrorInformation **ppsettingsErrorInformation);
    HRESULT ResetSettings([in] IVsProfileSettingsFileInfo *pFileInfo, [out] IVsSettingsErrorInformation **ppsettingsErrorInformation);
    HRESULT ExportAllSettings([in] BSTR bstrFilePath, [out] IVsSettingsErrorInformation **ppsettingsErrorInformation);
    HRESULT AutoSaveAllSettings([out] IVsSettingsErrorInformation **ppsettingsErrorInformation);

    HRESULT CheckUpdateTeamSettings([in] VSPROFILETEAMSETTINGSFLAGS dwFlags);
    HRESULT ReportTeamSettingsChanged([in] VSPROFILETEAMSETTINGSCHANGEDFLAGS dwFlags);

    HRESULT ShowProfilesUI();
};

// declare the service type for interop
[uuid(uuid_SVsProfileDataManager)]
interface SVsProfileDataManager : IUnknown {}

cpp_quote("#define SID_SVsProfileDataManager IID_SVsProfileDataManager")

//---------------------------------------------------------------------------
// IVsDeferredSaveProject
//---------------------------------------------------------------------------
// Implemented by a project that supports being a "zero-impact" project.
// The flags in the VSDIR file for the project must include VSDIRFLAG_DeferredSaveProject.
// This means that the project name will be automatically generated, as will the location,
// which will be at some temporary location (imitating the "in-memory" project experience).
// Then, when the project is created, CPF_DEFERREDSAVE is passed as one of the grfCreateFlags
// to IVsProjectFactory::CreateProject and/or IVsAggregatableProject::InitializeForOuter.
// The solution will be limited to containing one project, and nothing will be considered
// "dirty" while the solution/project are "zero-impact".
// When the user chooses to save the project permanently, he will use File.SaveAll, which
// will present him with a file browser with which he is to choose the new filename/location
// for his project file.  Once he chooses the filename, SaveProjectToLocation is called and
// the project must save itself to the specified filename and save all its other contents to
// the folder where the filename was specified.  At this point, the solution/project will no
// longer be considered "zero-impact" and normal solution/project operations will be available.
//---------------------------------------------------------------------------
[
    uuid(uuid_IVsDeferredSaveProject),
    version(1.0),
    pointer_default(unique)
]
interface IVsDeferredSaveProject : IUnknown
{
    // tells the project to save itself and all its contents to the specified location on disk.
    HRESULT SaveProjectToLocation([in] LPCOLESTR pszProjectFilename);
}

enum __VSCREATENEWPROJVIADLGEXFLAGS
{
    VNPVDE_ALWAYSNEWSOLUTION    = 0x00000001, // new solution is always created (no Add To Solution and Close Solution radio buttons)
    VNPVDE_OVERRIDEBROWSEBUTTON = 0x00000002, // browse button functionality is overridden (requires IVsBrowseProjectLocation interface)
    VNPVDE_ALWAYSADDTOSOLUTION  = 0x00000004, // project is always added to solution (Add New Project dialog is used)
    VNPVDE_ADDNESTEDTOSELECTION = 0x00000008, // project is added nested to currently selected project if supported
    VNPVDE_USENEWWEBSITEDLG     = 0x00000010, // Uses the New WebSite flavor of the dialog
};
typedef DWORD VSCREATENEWPROJVIADLGEXFLAGS;

//---------------------------------------------------------------------------
// IVsBrowseProjectLocation
//---------------------------------------------------------------------------
[
    uuid(uuid_IVsBrowseProjectLocation),
    version(1.0),
    pointer_default(unique)
]
interface IVsBrowseProjectLocation : IUnknown
{
    // This method will bring up a browse dialog for finding the location of a new project.
    HRESULT BrowseProjectLocation([in] LPCOLESTR pszStartDirectory, [out] BSTR *pbstrProjectLocation);
};

enum __VSSAVEDEFERREDSAVEFLAGS
{
    VSDSF_HIDEADDTOSOURCECONTROL = 0x00000001, // hide the "Add Solution to Source Control" checkbox on the Save dialog
};
typedef DWORD VSSAVEDEFERREDSAVEFLAGS;

//---------------------------------------------------------------------------
// IVsSolution3
//---------------------------------------------------------------------------
[
    uuid(uuid_IVsSolution3),
    version(1.0),
    pointer_default(unique)
]
interface IVsSolution3 : IUnknown
{
    // This method will bring up the New Project dialog with the specified title and restricted to the
    // specified template directory, as well as expanding and selecting the specified tree and list nodes.
    HRESULT CreateNewProjectViaDlgEx([in] LPCOLESTR pszDlgTitle,
        [in] LPCOLESTR pszTemplateDir,
        [in] LPCOLESTR pszExpand,
        [in] LPCOLESTR pszSelect,
        [in] LPCOLESTR pszHelpTopic,
        [in] VSCREATENEWPROJVIADLGEXFLAGS cnpvdeFlags,
        [in] IVsBrowseProjectLocation *pBrowse);
    // This method will generate a unique UI name for the project whose hierarchy is passed in.
    // This is necessary in the case where there are two projects in the solution with the same
    // name, but which reside in different solution folders.  The solution will generate a name
    // by prepending as many of the parent folder names as necessary to make the name unique.
    HRESULT GetUniqueUINameOfProject([in] IVsHierarchy *pHierarchy, [out] BSTR *pbstrUniqueName);
    // This method will check the solution to see if the solution is in the deferred-save state,
    // and if it is, it will prompt with a MessageBox-like dialog for confirmation then a Save
    // dialog will appear.  If fCloseSolution is set to TRUE, the solution will be closed after
    // it is saved; also the user will be given the option of discarding his changes.  If
    // fCloseSolution is set to FALSE, the solution will not be closed after it is saved.
    // The two string are Message and Title: this is just like MessageBox.  The buttons on the
    // 'messagebox' are Save, Discard and Cancel.  If fCloseSolution is FALSE, Discard will not
    // appear.  The default button is always Save.
    HRESULT CheckForAndSaveDeferredSaveSolution([in] BOOL fCloseSolution, [in] LPCOLESTR pszMessage, [in] LPCOLESTR pszTitle, [in] VSSAVEDEFERREDSAVEFLAGS grfFlags);
    // This method will tell the solution to update the internal filenames it is keeping for a project.  This is
    // used, for example, when a web project is upgraded so the solution knows the correct path to the upgraded web.
    HRESULT UpdateProjectFileLocationForUpgrade([in] LPCOLESTR pszCurrentLocation, [in] LPCOLESTR pszUpgradedLocation);
};


//---------------------------------------------------------------------------
// IVsConfigurationManagerDlg
//---------------------------------------------------------------------------
// Used to display the configuration manager dialog.
[
    uuid(uuid_IVsConfigurationManagerDlg),
    version(1.0),
    pointer_default(unique)
]
interface IVsConfigurationManagerDlg : IUnknown
{
    // Show the configuration manager dialog. The dialog is responsible for choosing an appropriate parent window.
    HRESULT ShowConfigurationManagerDlg();
};

// declare the service type for interop
[uuid(uuid_SVsConfigurationManagerDlg)]
interface SVsConfigurationManagerDlg : IUnknown {}

cpp_quote("#define SID_SVsConfigurationManagerDlg IID_SVsConfigurationManagerDlg")

//---------------------------------------------------------------------------
// IVsUpdateSolutionEvents3
//---------------------------------------------------------------------------
// Events informing about active solution configuration changes
[
    uuid(uuid_IVsUpdateSolutionEvents3),
    version(1.0),
    pointer_default(unique)
]
interface IVsUpdateSolutionEvents3 : IUnknown
{
    //fired before the active solution config is changed (pOldActiveSlnCfg can be NULL).
    HRESULT OnBeforeActiveSolutionCfgChange([in] IVsCfg *pOldActiveSlnCfg, [in] IVsCfg *pNewActiveSlnCfg);

    //fired after the active solution config is changed (pOldActiveSlnCfg can be NULL).
    HRESULT OnAfterActiveSolutionCfgChange([in] IVsCfg *pOldActiveSlnCfg, [in] IVsCfg *pNewActiveSlnCfg);
};

// Flag passed into IVsSolutionBuildManager3::AreProjectsUpToDate() as well as 
// IVsSolutionBuildManager::QueryStartUpToDateCheck() and IVsSolutionBuildManager::
// StartUpToDateCheck() to indicate that the operation is done for purposes of 
// DTEE (design time expression evaluation, as called from the debugger's immediate
// or watch windows) build as opposed to regular build.
typedef enum _vsuptodatecheckflags
{
    VSUTDCF_DTEEONLY        = 0x00000001
} VsUpToDateCheckFlags;

//---------------------------------------------------------------------------
// IVsSolutionBuildManager3
//---------------------------------------------------------------------------
// Provides access to IVsUpdateSolutionEvents3 events.
[
    uuid(uuid_IVsSolutionBuildManager3),
    version(1.0),
    pointer_default(unique)
]
interface IVsSolutionBuildManager3 : IUnknown
{
    HRESULT AdviseUpdateSolutionEvents3([in] IVsUpdateSolutionEvents3 *pIVsUpdateSolutionEvents3, [out] VSCOOKIE   *pdwCookie);
    HRESULT UnadviseUpdateSolutionEvents3([in]   VSCOOKIE dwCookie);

    // S_OK if all projects are up to date, or S_FALSE if one or more projects are not
    HRESULT AreProjectsUpToDate(DWORD dwOptions);

    // Returns S_OK if the currently selected hierarchy is the same as when we started the last
    // DTEE session. Returns S_FALSE if the hierarchy has changed.
    HRESULT HasHierarchyChangedSinceLastDTEE();

    // Check what operation the SolutionBuildManager is performing.  BuildManager operations are
    // identified by values taken from the SBF_OPERATION_MASK portion of the 
    // VSSOLNBUILDUPDATEFLAGS enum. This can be used by a implementer of IVsBuildableProjectCfg
    // to know whether a Build vs. Build/Deploy vs. Build/Deploy/LaunchDebug vs. Build/Deploy/Launch
    // (no debug) operation is being performed. In addition if the operation is performed on the selected
    // project(s) then SBF_OPERATION_SELECTION is specified; otherwise the operation is being 
    // performed on the entire Solution.
    HRESULT QueryBuildManagerBusyEx([out] DWORD *pdwBuildManagerOperation /* VSSOLNBUILDUPDATEFLAGS */);
};


//---------------------------------------------------------------------------
// IVsSingleFileGeneratorFactory
//---------------------------------------------------------------------------
[
    uuid(uuid_IVsSingleFileGeneratorFactory)
]
interface IVsSingleFileGeneratorFactory : IUnknown
{
    // Get the default generator prog-id given a filename
    HRESULT GetDefaultGenerator([in] LPCOLESTR wszFilename,
        [out, retval] BSTR* pbstrGenProgID);

    // Instantiation
    HRESULT CreateGeneratorInstance([in] LPCOLESTR wszProgId,
        [out] BOOL* pbGeneratesDesignTimeSource,
        [out] BOOL* pbGeneratesSharedDesignTimeSource,
        [out] BOOL* pbUseTempPEFlag,
        [out] IVsSingleFileGenerator** ppGenerate);

    HRESULT GetGeneratorInformation([in] LPCWSTR wszProgID, 
        [out] BOOL* pbGeneratesDesignTimeSource,
        [out] BOOL* pbGeneratesSharedDesignTimeSource,
        [out] BOOL* pbUseTempPEFlag,
        [out] GUID* pguidGenerator);

};


//---------------------------------------------------------------------------
// IVsStartPageDownload
//---------------------------------------------------------------------------
// Implemented by the Start Page Download service.  Allows the Start Page client to 
// kick a downloading service for the Start Page on a background thread
// This should only be used internally by the Start Page implementation!
[
    uuid(uuid_IVsStartPageDownload),
    version(1.0),
    pointer_default(unique)
]
interface IVsStartPageDownload : IUnknown {
      HRESULT StartDownloadService(void);
      HRESULT StopDownloadService(void);
};

[
    uuid(uuid_SVsStartPageDownload)
]
interface SVsStartPageDownload : IUnknown {
};
cpp_quote("#define SID_SVsStartPageDownload IID_SVsStartPageDownload")



// MEINIT dwFlag values
enum __VSMEINIT2
{
    /********************************************** defined in vsshell.idl
    MD_ACCELSUPPORT         = 0x00000001,   // first value should be one,
    MD_VISIBLESUPPORT       = 0x00000002,   // following values should use
    MD_BOLDSUPPORT          = 0x00000004,   // consecutive powers of two
    MD_CONTEXTMENU          = 0x00000008,   //
    MD_RADIOCHECKSUPPORT    = 0x00000010,   //
    MD_COMMANDIDSUPPORT     = 0x00000020,   // << Means NO Control names!  Like VC
    MD_VIEWCODESUPPORT      = 0x00000040,   // Supports the ViewCode cmd
    MD_NOPROPERTIESSUPPORT  = 0x00000080,   // Does not support the Properties cmd
    MD_TEXTLIMIT            = 0x00000100,   // Use the MEINIT dwTextLimit field
    MD_TOPLEVELSEPSUPPORT   = 0x00000200,   // Allow separators on the top-level menu
    MD_EDITIDSNOTEDITNAMES  = 0x00000400,   // Menu item "Edit Names" is displayed as "Edit ID's"
    MD_NAMELIMIT            = 0x00000800,   // Use the MEINIT dwNameLimit field
    MD_NOUNDOSUPPORT        = 0x00001000,   // Do not store undo information, even if passed an undo manager
    MD_BOTTOMDOCKED         = 0x00002000,   // this menu should dock on the bottom and popups should cascade upward.
    MD_BREAKSUPPORT         = 0x00004000,   // Supports the break and barbreak flags on menu items
    MD_RIGHTJUSTIFYSUPPORT  = 0x00008000    // Supports the right justification of menu bar items (moves all to the right of the bar)
    **********************************************/ 
    MD_ITEMICONSUPPORT      = 0x00010000
};
typedef DWORD VSMEINIT2;

enum __MENUEDITOR_TRANSACTION
{
    MENUEDITOR_TRANSACTION_DISCARD=-1, // discard the current transaction
    MENUEDITOR_TRANSACTION_ALL, // force a reset
    MENUEDITOR_TRANSACTION_CUT,
    MENUEDITOR_TRANSACTION_PASTE,
    MENUEDITOR_TRANSACTION_COPY,
    MENUEDITOR_TRANSACTION_DELETE
};
typedef DWORD MENUEDITOR_TRANSACTION;

//---------------------------------------------------------------------------
// interface IVsMenuEditorTransactionEvents
//
// this interface is designed to assist the form designer in 
// processing their own undo redo stack
//---------------------------------------------------------------------------
[
    uuid(uuid_IVsMenuEditorTransactionEvents),
    version(1.0),
    pointer_default(unique)
]

interface IVsMenuEditorTransactionEvents : IUnknown
{
    HRESULT BeginTransaction([in] MENUEDITOR_TRANSACTION trans);
    HRESULT EndTransaction([in] MENUEDITOR_TRANSACTION trans);
};


//---------------------------------------------------------------------------
// IVsThreadedWaitDialog
//---------------------------------------------------------------------------
// Implemented by the IDE.
// Interface allows a modal dialog to be displayed on a background thread to
// allow the IDE to appear responsive even when the foreground thread is busy
// with an extended operationl
//
// Available via QueryService(SVsThreadedWaitDialog)
//

// Flags passed to StartWaitDialog
enum __VSTWDFLAGS
{
    VSTWDFLAGS_NOFLAGS       = 0x00000000,
    VSTWDFLAGS_CANCELLABLE   = 0x00000001, // should we show the Cancel button?
    VSTWDFLAGS_TOPMOST       = 0x00000002  // should we force the window above all others?
};
typedef DWORD VSTWDFLAGS;

[
    uuid(uuid_IVsThreadedWaitDialog),
    version(1.0),
    pointer_default(unique)
]
interface IVsThreadedWaitDialog : IUnknown
{
    HRESULT StartWaitDialog(
        [in]  BSTR       bstrWaitCaption, 
        [in]  BSTR       bstrWaitMessage, 
        [in]  BSTR       bstrIfTruncateAppend, //can be NULL
        [in]  VSTWDFLAGS dwFlags,
        [in]  VARIANT    varStatusBmpAnim,     //optional: should be a VT_INT_PTR containing a valid BMP, or VT_NULL
        [in]  BSTR       bstrStatusBarText);   //can be NULL

    HRESULT EndWaitDialog(BOOL *pfCancelled);

    HRESULT GiveTimeSlice(
        [in]  BSTR bstrUpdatedWaitMessage,  //can be NULL
        [in]  BSTR bstrIfTruncateAppend,    //can be NULL, should be a short string e.g. L"..." or L"...\""
        [in]  BOOL fDisableCancel,          //if the operation becomes uncancel-able, disable the button
        [out] BOOL *pfCancelled);
};

// declare the service type for interop
[uuid(uuid_SVsThreadedWaitDialog)]
interface SVsThreadedWaitDialog : IUnknown {}

cpp_quote("#define SID_SVsThreadedWaitDialog IID_SVsThreadedWaitDialog")


//---------------------------------------------------------------------------
// IVsProfilesManagerUI
//---------------------------------------------------------------------------
// Implemented by the IDE.
// This is an internal interface used to allow communication between native and
// managed code in the IDE.
//
// Available via QueryService(SVsProfilesManagerUI)
//
[
    uuid(uuid_IVsProfilesManagerUI),
    version(1.0),
    pointer_default(unique)
]
interface IVsProfilesManagerUI : IUnknown
{
    HRESULT ShowProfilesUI([in] IVsProfileDataManager *pDataManager);
};

// declare the service type for interop
[uuid(uuid_SVsProfilesManagerUI)]
interface SVsProfilesManagerUI : IUnknown {}

cpp_quote("#define SID_SVsProfilesManagerUI IID_SVsProfilesManagerUI")


//---------------------------------------------------------------------------
// IVsXMLMemberDataCallBack
//---------------------------------------------------------------------------

enum __XMLMEMBERDATA_TAGTYPE
{
    XMLMEMBERDATA_TAGTYPE_CREF
};
typedef DWORD XMLMEMBERDATA_TAGTYPE;

[
    uuid(uuid_IVsXMLMemberDataCallBack)
]
interface IVsXMLMemberDataCallBack : IUnknown
{
    HRESULT GetDisplayNameForTag( 
        [in] XMLMEMBERDATA_TAGTYPE nTagType, 
        [in] LPCOLESTR wszBufferIn, 
        [out] BSTR* pbstrBufferOut);
};

//---------------------------------------------------------------------------
// IVsXMLMemberDataRegisterCallBack
//---------------------------------------------------------------------------
[
    uuid(uuid_IVsXMLMemberDataRegisterCallBack)
]
interface IVsXMLMemberDataRegisterCallBack : IUnknown
{
    HRESULT RegisterCallBack([in] IVsXMLMemberDataCallBack* pIVsXMLMemberDataCallBack);
    HRESULT UnregisterCallBack();
};


//---------------------------------------------------------------------------
// IVsXMLMemberData3
//---------------------------------------------------------------------------
// This is just a handy wrapper over the XML for a given member.  It extracts
// text from the XML (honoring tags like <see>, <paramref>, etc.) for things
// of interest.  If the tag for whatever is asked for doesn't exist, the
// text returned is empty and the function returns S_FALSE.
//---------------------------------------------------------------------------

enum __XMLMEMBERDATA_OPTIONS
{
    XMLMEMBERDATA_OPTIONS_NONE              = 0x0000,   // No options set.
    XMLMEMBERDATA_OPTIONS_PRESERVE_NEWLINES = 0x0001    // Keep newlines.
};
typedef DWORD XMLMEMBERDATA_OPTIONS;

[
    uuid(uuid_IVsXMLMemberData3)
]
interface IVsXMLMemberData3 : IUnknown
{
    HRESULT     SetOptions([in] XMLMEMBERDATA_OPTIONS options);
    HRESULT     GetSummaryText ([out] BSTR *pbstrSummary);
    HRESULT     GetParamCount ([out] long *piParams);
    HRESULT     GetParamTextAt ([in] long iParam, [out] BSTR *pbstrName, [out] BSTR *pbstrText);
    HRESULT     GetReturnsText ([out] BSTR *pbstrReturns);
    HRESULT     GetRemarksText ([out] BSTR *pbstrRemarks);
    HRESULT     GetExceptionCount ([out] long *piExceptions);
    HRESULT     GetExceptionTextAt ([in] long iException, [out] BSTR *pbstrType, [out] BSTR *pbstrText);
    HRESULT     GetFilterPriority ([out] long *piFilterPriority);
    HRESULT     GetCompletionListText ([out] BSTR *pbstrCompletionList);
    HRESULT     GetCompletionListTextAt ([in] long iParam, [out] BSTR *pbstrCompletionList);
    HRESULT     GetPermissionSet ([out] BSTR *pbstrPermissionSetXML);
    HRESULT     GetTypeParamCount ([out] long *piTypeParams);
    HRESULT     GetTypeParamTextAt ([in] long iTypeParam, [out] BSTR *pbstrName, [out] BSTR *pbstrText);
};


//------------------------------------------------------------------------------
// Object Browser, Class View and Find Symbol related
//------------------------------------------------------------------------------

// Library Manager List Types (Symbol Provider List Types)
enum _LIB_LISTTYPE2
{
    LLT_NIL                         = 0x000000,

    //LLT_HIERARCHY                 = 0x000001, // Taken from LIB_LISTTYPE in vsshell.idl
    //LLT_NAMESPACES                = 0x000002, // Taken from LIB_LISTTYPE in vsshell.idl
    //LLT_CLASSES                   = 0x000004, // Taken from LIB_LISTTYPE in vsshell.idl
    //LLT_MEMBERS                   = 0x000008, // Taken from LIB_LISTTYPE in vsshell.idl
    //LLT_PHYSICALCONTAINERS        = 0x000010, // Taken from LIB_LISTTYPE in vsshell.idl
    //LLT_PACKAGE                   = 0x000010, // Old name for LLT_PHYSICALCONTAINERS (Taken from LIB_LISTTYPE in vsshell.idl)

    LLT_MEMBERHIERARCHY             = 0x000020, // Member hierarchy list type (Object Browser places lists of this type in the member pane)

    //LLT_DEFEREXPANSION            = 0x100000, // Taken from LIB_LISTTYPE in vsshell.idl
};
typedef DWORD           LIB_LISTTYPE2;
typedef LIB_LISTTYPE2   LIBCAT_LISTTYPE2;
cpp_quote("#define COUNT_LIBCAT_LISTTYPE 6")

// Library flags returned from IVsLibrary::GetLibFlags()
enum _LIB_FLAGS2
{
    //LF_PROJECT                    = 0x0001,   // Taken from LIB_FLAGS in vsshell.idl
    //LF_GLOBAL                     = 0x0002,   // Taken from LIB_FLAGS in vsshell.idl
    //LF_EXPANDABLE                 = 0x0004,   // Taken from LIB_FLAGS in vsshell.idl
    //LF_HIDEINLIBPICKER            = 0x0008,   // Taken from LIB_FLAGS in vsshell.idl

    LF_SUPPORTSPROJECTREFERENCES        =  0x0010,   // Supports exposing project references
    LF_SUPPORTSFILTERING                =  0x0020,   // Supports filtering (VSOBSO_FILTERING flag in VSOBSEARCHCRITERIA2)
    LF_SUPPORTSFILTERINGWITHEXPANSION   =  0x0040,   // Library supports search with expansion (VSOBSO_EXPANDCHILDREN flag in VSOBSEARCHCRITERIA2), implies LF_SUPPORTSFILTERING
    LF_SUPPORTSCALLBROWSER              =  0x0080,   // Supports Call Browser Calls To or Calls From
    LF_SUPPORTSLISTREFERENCES           =  0x0100,   // Can find symbol usages and present results as a flat list (VSOBSO_LISTREFERENCES flag in VSOBSEARCHCRITERIA2)
    LF_SUPPORTSALWAYSUPDATE             =  0x0400,   // Supports always update (even for find symbol results)
    LF_SUPPORTSBASETYPES                =  0x0800,   // Supports exposing base types
    LF_SUPPORTSDERIVEDTYPES             =  0x1000,   // Supports exposing derived types
    LF_SUPPORTSINHERITEDMEMBERS         =  0x2000,   // Supports exposing inherited members
    LF_SUPPORTSPRIVATEMEMBERS           =  0x4000,   // Supports exposing private members
    LF_SUPPORTSCLASSDESIGNER            =  0x8000,   // Supports class designer
    LF_SHOWFULLNAMESINFINDSYMBOLRESULTS = 0x10000,   // Requests to show fully qualified names in find symbol results.
};
typedef DWORD LIB_FLAGS2;

// List flags returned from IVsObjectList::GetCapabilities()
enum _LIB_LISTCAPABILITIES2
{
    //LLC_NONE              = 0x0000,   // Taken from LIB_LISTCAPABILITIES in vsshell.idl
    //LLC_HASBROWSEOBJ      = 0x0001,   // Taken from LIB_LISTCAPABILITIES in vsshell.idl
    //LLC_HASDESCPANE       = 0x0002,   // Taken from LIB_LISTCAPABILITIES in vsshell.idl
    //LLC_HASSOURCECONTEXT  = 0x0004,   // Taken from LIB_LISTCAPABILITIES in vsshell.idl
    //LLC_HASCOMMANDS       = 0x0008,   // Taken from LIB_LISTCAPABILITIES in vsshell.idl
    //LLC_ALLOWDRAGDROP     = 0x0010,   // Taken from LIB_LISTCAPABILITIES in vsshell.idl
    //LLC_ALLOWRENAME       = 0x0020,   // Taken from LIB_LISTCAPABILITIES in vsshell.idl
    //LLC_ALLOWDELETE       = 0x0040,   // Taken from LIB_LISTCAPABILITIES in vsshell.idl
    //LLC_ALLOWSCCOPS       = 0x0080,   // Taken from LIB_LISTCAPABILITIES in vsshell.idl

    LLC_ALLOWELEMENTSEARCH  = 0x0100,   // IVsObjectList2::GetList2() allows search starting at given element
};
typedef DWORD LIB_LISTCAPABILITIES2;

// Search option flags in VSOBSEARCHCRITERIA2 (passed to IVsLibrary2::GetList2() and IVsObjectList2::GetList2())
enum _VSOBSEARCHOPTIONS2
{
    //VSOBSO_NONE                       = 0x0000,   // Taken from VSOBSEARCHOPTIONS in vsshell.idl
    //VSOBSO_CASESENSITIVE              = 0x0001,   // Taken from VSOBSEARCHOPTIONS in vsshell.idl
    //VSOBSO_LOOKINREFS                 = 0x0002,   // Taken from VSOBSEARCHOPTIONS in vsshell.idl

    VSOBSO_FILTERING                    = 0x0100,   // filtering in CV and OB
    VSOBSO_EXPANDCHILDREN               = 0x0200,   // Comes together with VSOBSO_FILTERING if a library supports LF_SUPPORTSFILTERINGWITHEXPANSION

    VSOBSO_CALLSTO                      = 0x0400,   // Obtain Calls To symbol specified in VSOBSEARCHCRITERIA2
    VSOBSO_CALLSFROM                    = 0x0800,   // Obtain Calls From symbol specified in VSOBSEARCHCRITERIA2

    VSOBSO_LISTREFERENCES               = 0x1000    // search results should contain references (usages) as a top level flat list (used for Find All References)
};

typedef DWORD VSOBSEARCHOPTIONS2;

interface IVsNavInfo;

// Search options struct (passed to IVsLibrary2::GetList2() and IVsObjectList2::GetList2())
typedef struct _VSOBSEARCHCRITERIA2
{
    LPCOLESTR           szName;
    VSOBSEARCHTYPE      eSrchType;
    VSOBSEARCHOPTIONS2  grfOptions;
    DWORD               dwCustom;
    IVsNavInfo*         pIVsNavInfo;          
} VSOBSEARCHCRITERIA2;

// NavigationInfo node struct (passed to IVsObjectList2::GetNavigationInfo2() and IVsObjectList2::LocateNavigationInfo2())
typedef struct _VSOBNAVNAMEINFONODE2
{
    WCHAR                           *pszName;
    LIB_LISTTYPE2                   lltName;
    struct _VSOBNAVNAMEINFONODE2    *pNext;
} VSOBNAVNAMEINFONODE2;

// NavigationInfo struct (passed to IVsObjectList2::LocateNavigationInfo2())
typedef struct _VSOBNAVIGATIONINFO3
{
    GUID                            *pguidLib;
    WCHAR                           *pszLibName;
    VSOBNAVNAMEINFONODE2            *pName;
    DWORD                            dwCustom;  
} VSOBNAVIGATIONINFO3;

// Library Manager List Element Categories (Symbol Provider List Element Attribute Domains)
enum _LIB_CATEGORY2
{
    LC_NIL                      = 0,

    //LC_MEMBERTYPE             = 1,    // Taken from LIB_CATEGORY in vsshell.idl
    //LC_MEMBERACCESS           = 2,    // Taken from LIB_CATEGORY in vsshell.idl
    //LC_CLASSTYPE              = 3,    // Taken from LIB_CATEGORY in vsshell.idl
    //LC_CLASSACCESS            = 4,    // Taken from LIB_CATEGORY in vsshell.idl
    //LC_ACTIVEPROJECT          = 5,    // Taken from LIB_CATEGORY in vsshell.idl
    //LC_LISTTYPE               = 6,    // Taken from LIB_CATEGORY in vsshell.idl
    //LC_VISIBILITY             = 7,    // Taken from LIB_CATEGORY in vsshell.idl
    //LC_MODIFIER               = 8,    // Taken from LIB_CATEGORY in vsshell.idl
    //LC_NODETYPE               = 9,    // Taken from LIB_CATEGORY in vsshell.idl

    LC_PHYSICALCONTAINERTYPE    = 10,   // Physical Container element type
    LC_HIERARCHYTYPE            = 11,   // Hierarchy element type
    LC_MEMBERINHERITANCE        = 12,   // Member inheritance
    LC_SEARCHMATCHTYPE          = 13,   // search match type (OM supports it, libraries are not required to implement)
    LC_Last2                    = LC_SEARCHMATCHTYPE
};
typedef LONG    LIB_CATEGORY2;
cpp_quote("#define COUNT_LIB_CATEGORY2 13")

// Class (Type) Type
enum _LIBCAT_CLASSTYPE2
{
    //LCCT_NSPC         = 0x000001, // Taken from LIBCAT_CLASSTYPE in vsshell.idl
    //LCCT_CLASS        = 0x000002, // Taken from LIBCAT_CLASSTYPE in vsshell.idl
    //LCCT_INTERFACE    = 0x000004, // Taken from LIBCAT_CLASSTYPE in vsshell.idl
    //LCCT_STRUCT       = 0x000008, // Taken from LIBCAT_CLASSTYPE in vsshell.idl
    //LCCT_UNION        = 0x000010, // Taken from LIBCAT_CLASSTYPE in vsshell.idl
    //LCCT_ENUM         = 0x000020, // Taken from LIBCAT_CLASSTYPE in vsshell.idl
    //LCCT_TYPEDEF      = 0x000040, // Taken from LIBCAT_CLASSTYPE in vsshell.idl
    //LCCT_MODULE       = 0x000080, // Taken from LIBCAT_CLASSTYPE in vsshell.idl
    //LCCT_INTRINSIC    = 0x000100, // Taken from LIBCAT_CLASSTYPE in vsshell.idl
    //LCCT_DELEGATE     = 0x000200, // Taken from LIBCAT_CLASSTYPE in vsshell.idl
    //LCCT_EXCEPTION    = 0x000400, // Taken from LIBCAT_CLASSTYPE in vsshell.idl
    //LCCT_MAP          = 0x000800, // Taken from LIBCAT_CLASSTYPE in vsshell.idl
    //LCCT_GLOBAL       = 0x001000, // Taken from LIBCAT_CLASSTYPE in vsshell.idl
    //LCCT_ERROR        = 0x002000, // Taken from LIBCAT_CLASSTYPE in vsshell.idl

    LCCT_TEMPLATE       = 0x004000, // Template class
    LCCT_GENERIC        = 0x008000, // Generic class
    LCCT_ITERATOR       = 0x010000  // Iterator class
};
typedef DWORD LIBCAT_CLASSTYPE2;
cpp_quote("#define COUNT_LIBCAT_CLASSTYPE2 17")

// Member Type
enum _LIBCAT_MEMBERTYPE2
{
    //LCMT_METHOD       = 0x000001, // Taken from LIBCAT_MEMBERTYPE in vsshell.idl
    //LCMT_FUNCTION     = 0x000002, // Taken from LIBCAT_MEMBERTYPE in vsshell.idl
    //LCMT_OPERATOR     = 0x000004, // Taken from LIBCAT_MEMBERTYPE in vsshell.idl
    //LCMT_PROPERTY     = 0x000008, // Taken from LIBCAT_MEMBERTYPE in vsshell.idl
    //LCMT_FIELD        = 0x000010, // Taken from LIBCAT_MEMBERTYPE in vsshell.idl
    //LCMT_VARIABLE     = 0x000020, // Taken from LIBCAT_MEMBERTYPE in vsshell.idl
    //LCMT_EVENT        = 0x000040, // Taken from LIBCAT_MEMBERTYPE in vsshell.idl
    //LCMT_CONSTANT     = 0x000080, // Taken from LIBCAT_MEMBERTYPE in vsshell.idl
    //LCMT_ENUMITEM     = 0x000100, // Taken from LIBCAT_MEMBERTYPE in vsshell.idl
    //LCMT_TYPEDEF      = 0x000200, // Taken from LIBCAT_MEMBERTYPE in vsshell.idl
    //LCMT_MAPITEM      = 0x000400, // Taken from LIBCAT_MEMBERTYPE in vsshell.idl
    //LCMT_DECLARATION  = 0x000800, // Taken from LIBCAT_MEMBERTYPE in vsshell.idl
    //LCMT_MACRO        = 0x001000, // Taken from LIBCAT_MEMBERTYPE in vsshell.idl
    //LCMT_ERROR        = 0x002000, // Taken from LIBCAT_MEMBERTYPE in vsshell.idl

    LCMT_TEMPLATE       = 0x004000, // Template method
    LCMT_GENERIC        = 0x008000, // Generic method
};
typedef DWORD LIBCAT_MEMBERTYPE2;
cpp_quote("#define COUNT_LIBCAT_MEMBERTYPE2 16")

// Physical Container Type
enum _LIBCAT_PHYSICALCONTAINERTYPE
{
    LCPT_GLOBAL             = 0x0001,   // Global physical container type
    LCPT_PROJECTREFERENCE   = 0x0002,   // Project Reference physical container type
    LCPT_PROJECT            = 0x0004    // Project physical container type
};
typedef DWORD LIBCAT_PHYSICALCONTAINERTYPE;
cpp_quote("#define COUNT_LIBCAT_PHYSICALCONTAINERTYPE 3")

// Hierarchy Element Type
enum _LIBCAT_HIERARCHYTYPE
{
    LCHT_UNKNOWN            = 0x0001,   // Unknown (Generic) hierarchy element type
    LCHT_FOLDER             = 0x0002,   // Folder hierarchy element type
    LCHT_BASESANDINTERFACES = 0x0004,   // "Bases and Interfaces" hierarchy element type
    LCHT_PROJECTREFERENCES  = 0x0008,   // "Project References" hierarchy element type
    LCHT_DERIVEDTYPES       = 0x0010,   // "Derived Types" hierarchy element type
    LCHT_INFO               = 0x0020    // "Info" hierarchy element type
};
typedef DWORD LIBCAT_HIERARCHYTYPE;
cpp_quote("#define COUNT_LIBCAT_HIERARCHYTYPE 5")

// Member Inheritance
enum _LIBCAT_MEMBERINHERITANCE
{
    LCMI_IMMEDIATE          = 0x0001,   // Immediate member of class (type)
    LCMI_OVERRIDABLE        = 0x0002,   // Overridable (virtual), but not overridden,  member of parent class (type)
    LCMI_OVERRIDEREQUIRED   = 0x0004,   // Override required (pure virtual), but not overridden, member of parent class (type)
    LCMI_OVERRIDDEN         = 0x0008,   // Overridden (virtual or pure virtual) member of parent class (type)
    LCMI_NOTOVERRIDABLE     = 0x0010,   // Not overridable member of parent class (type)
    LCMI_INHERITED          = 0x0020    // Inherited member of class (type)
};
typedef DWORD LIBCAT_MEMBERINHERITANCE;
cpp_quote("#define COUNT_LIBCAT_MEMBERINHERITANCE 6")

// Member Inheritance
enum _LIBCAT_SEARCHMATCHTYPE
{
    LSMT_WHOLEWORD              = 0x0001,
    LSMT_WHOLEWORD_NO_CASE      = 0x0002,
    LSMT_LEAF_WHOLEWORD         = 0x0004,
    LSMT_LEAF_WHOLEWORD_NO_CASE = 0x0008,
    LSMT_PART_WHOLEWORD         = 0x0010,
    LSMT_PART_WHOLEWORD_NO_CASE = 0x0020,
    LSMT_PRESTRING              = 0x0040,
    LSMT_PRESTRING_NO_CASE      = 0x0080,
    LSMT_LEAF_PRESTRING         = 0x0100,
    LSMT_LEAF_PRESTRING_NO_CASE = 0x0200,
    LSMT_PART_PRESTRING         = 0x0400,
    LSMT_PART_PRESTRING_NO_CASE = 0x0800,
    LSMT_SUBSTRING              = 0x1000,
    LSMT_SUBSTRING_NO_CASE      = 0x2000,
    LSMT_NO_MATCH               = 0x4000
};

typedef DWORD LIBCAT_SEARCHMATCHTYPE;
cpp_quote("#define COUNT_LIBCAT_SEARCHMATCHTYPE 15")

// IVsObjectList2 List Element Properties
enum _VSOBJLISTELEMPROPID
{
    VSOBJLISTELEMPROPID_FIRST               = 1,
    VSOBJLISTELEMPROPID_HELPKEYWORD         = 1,            // VT_BSTR
    VSOBJLISTELEMPROPID_COMPONENTPATH       = 2,            // VT_BSTR
    VSOBJLISTELEMPROPID_CODEDEFVIEWCONTEXT  = 3,            // VT_UNKNOWN
    VSOBJLISTELEMPROPID_SUPPORTSCALLSTO     = 4,            // VT_BOOLEAN
    VSOBJLISTELEMPROPID_SUPPORTSCALLSFROM   = 5,            // VT_BOOLEAN
    VSOBJLISTELEMPROPID_FULLNAME            = 6,            // VT_BSTR
    VSOBJLISTELEMPROPID_LEAFNAME            = 7,            // VT_BSTR
    VSOBJLISTELEMPROPID_NAME_FOR_RENAME     = 8,            // VT_BSTR
    VSOBJLISTELEMPROPID_LAST                = 8,
};
typedef LONG VSOBJLISTELEMPROPID;

// NavInfo related interfaces

// IVsNavInfoNode
[
    uuid(uuid_IVsNavInfoNode), 
    version(1.0),
    pointer_default(unique)
]

interface IVsNavInfoNode : IUnknown
{
    HRESULT get_Type([out] DWORD * pllt); // LIB_LISTTYPE2 + registered types when we have them (not in VS 2005)
    HRESULT get_Name([out] BSTR * pbstrName); //Name should be unique for the list, might be different from the display text, if object was renamed get_Name should return its new name
};


// IVsEnumNavInfoNodes
[
    uuid(uuid_IVsEnumNavInfoNodes), 
    version(1.0),
    pointer_default(unique)
]
interface IVsEnumNavInfoNodes : IUnknown
{
    HRESULT Next([in]   ULONG celt, [out, size_is(celt), length_is(*pceltFetched)] IVsNavInfoNode **rgelt, [out] ULONG *pceltFetched);
    HRESULT Skip([in]   ULONG celt);
    HRESULT Reset(void);
    HRESULT Clone([out] IVsEnumNavInfoNodes **ppenum);
};


//IVsNavInfo

[
    uuid(uuid_IVsNavInfo), 
    version(1.0),
    pointer_default(unique)
]
interface IVsNavInfo : IUnknown
{
    HRESULT GetLibGuid([out] GUID * pGuid);
    HRESULT GetSymbolType([out] DWORD * pdwType);  // LIB_LISTTYPE2 + registered types when we have them (not in VS 2005)
    HRESULT EnumPresentationNodes([in] DWORD dwFlags, [out] IVsEnumNavInfoNodes ** ppEnum); // flags can be those for CV or OB
    HRESULT EnumCanonicalNodes([out] IVsEnumNavInfoNodes ** ppEnum); 
}

// SymbolDescriptionNode
typedef struct tagSymbolDescriptionNode
{
    DWORD      dwType; // LIB_LISTTYPE2 
    LPCOLESTR  pszName;
} SYMBOL_DESCRIPTION_NODE;


// Replacement for IVsObjectBrowserDescription2 interface
[
    uuid(uuid_IVsObjectBrowserDescription3),
    version(1.0),
    pointer_default(unique)
]
interface IVsObjectBrowserDescription3 : IUnknown
{
    HRESULT AddDescriptionText3([in] LPCWSTR pText, [in] VSOBDESCRIPTIONSECTION obdSect, [in] IVsNavInfo *pHyperJump);
    HRESULT ClearDescriptionText();
};

// IVsObjectList2 interface
//
// This interface is a replacement for the IVsObjectList interface.
//
// A list which implements this interface must also implement IVsLiteTreeList, the
// interface from which this interface effectively inherits.
//
// The GetText(), GetTipText() and GetSourceContext() methods return strings which are owned
// by the underlying list.  The underlying list is expected to keep a returned string "alive"
// until the next request for a string, or until the list is released.  Underlying lists which
// would prefer to return strings with ownership should implement IVsSimpleObjectList2 instead
// of IVsObjectList2 (this interface).  IVsSimpleObjectList2 has the GetTextWithOwnership(),
// GetTipTextWithOwnership() and GetSourceContextWithOwnership() methods which return strings
// with ownership.
//
// It is recommended that managed list implementations implement IVsSimpleObjectList2 instead
// of IVsObjectList2 (this interface), as managed GetText(), GetTipText() and GetSourceContext()
// implementations will leak CoTaskMemAlloc'ed string buffers.
[
    uuid(uuid_IVsObjectList2),
    version(1.0),
    pointer_default(unique)
]
interface IVsObjectList2 : IUnknown
{
    //--------------------------------------------------------------------------
    // Methods taken from IVsLiteTreeList 
    //--------------------------------------------------------------------------

    HRESULT GetFlags([out] VSTREEFLAGS *pFlags);
    HRESULT GetItemCount([out] ULONG* pCount);
    HRESULT GetExpandedList([in] ULONG Index, [out] BOOL *pfCanRecurse, [out] IVsLiteTreeList **pptlNode);
    HRESULT LocateExpandedList([in] IVsLiteTreeList* ExpandedList, [out] ULONG *iIndex);
    HRESULT OnClose([out] VSTREECLOSEACTIONS *ptca);
    HRESULT GetText([in] ULONG Index, [in] VSTREETEXTOPTIONS tto, [out, string] const WCHAR **ppszText);
    HRESULT GetTipText([in] ULONG Index, [in] VSTREETOOLTIPTYPE eTipType, [out, string] const WCHAR **ppszText); 
    HRESULT GetExpandable([in] ULONG Index, [out] BOOL *pfExpandable);
    [local] HRESULT GetDisplayData([in] ULONG Index, [out] VSTREEDISPLAYDATA *pData);
    HRESULT UpdateCounter([out] ULONG *pCurUpdate,  [out] VSTREEITEMCHANGESMASK *pgrfChanges);
    HRESULT GetListChanges([in,out] ULONG *pcChanges, [in, size_is(*pcChanges)] VSTREELISTITEMCHANGE *prgListChanges);
    HRESULT ToggleState([in] ULONG Index, [out] VSTREESTATECHANGEREFRESH *ptscr);

    //--------------------------------------------------------------------------
    // Methods taken from IVsObjectList (with some replacements)
    //--------------------------------------------------------------------------

    // Get list capabilities
    // This method is replacing
    //HRESULT GetCapabilities([out]  LIB_LISTCAPABILITIES *pCapabilities);
    HRESULT GetCapabilities2([out]  LIB_LISTCAPABILITIES2 *pgrfCapabilities);

    // Get IVsObjectList2 interface for sub-list for given element index and list type
    // This method is replacing
    //HRESULT GetList([in] ULONG Index, [in] LIB_LISTTYPE ListType, [in] LIB_LISTFLAGS Flags, [in] VSOBSEARCHCRITERIA *pobSrch, [out] IVsObjectList **ppList);
    HRESULT GetList2([in] ULONG Index, [in] LIB_LISTTYPE2 ListType, [in] LIB_LISTFLAGS Flags, [in] VSOBSEARCHCRITERIA2 *pobSrch, [out, retval] IVsObjectList2 **ppIVsObjectList2);

    // Get category field (attribute value) for given list element
    // Gets category fields (attribute values) supported by list, if given NIL list element index ((ULONG)(-1))
    // Returns E_FAIL if given category not supported
    // This method is replacing
    //HRESULT GetCategoryField([in] ULONG Index, [in] LIB_CATEGORY Category, [out,retval] DWORD* pField);
    HRESULT GetCategoryField2([in] ULONG Index, [in] LIB_CATEGORY2 Category, [out,retval] DWORD *pfCatField);

    // Get whether given list element is expandable, excluding from consideration given list types
    // This method is replacing
    //HRESULT GetExpandable2([in] ULONG Index, [in] LIB_LISTTYPE ListTypeExcluded, [out] BOOL *pfExpandable);
    HRESULT GetExpandable3([in] ULONG Index, [in] LIB_LISTTYPE2 ListTypeExcluded, [out] BOOL *pfExpandable);

    // Get NavigationInfo for given list element
    // This method is replacing
    //HRESULT GetNavigationInfo([in] ULONG Index, [in, out] VSOBNAVIGATIONINFO2 *pobNav);
    HRESULT GetNavigationInfo2([in] ULONG Index, [in, out] VSOBNAVIGATIONINFO3 *pobNav);

    // Locate list element for given NavigationInfo
    // This method is replacing
    //HRESULT LocateNavigationInfo([in] VSOBNAVIGATIONINFO2 *pobNav, [in] VSOBNAVNAMEINFONODE *pobName, [in] BOOL fDontUpdate, [out] BOOL *pfMatchedName, [out] ULONG *pIndex);
    HRESULT LocateNavigationInfo2([in] VSOBNAVIGATIONINFO3 *pobNav, [in] VSOBNAVNAMEINFONODE2 *pobName, [in] BOOL fDontUpdate, [out] BOOL *pfMatchedName, [out] ULONG *pIndex);

    HRESULT GetBrowseObject([in] ULONG Index, [out] IDispatch **ppdispBrowseObj);
    HRESULT GetUserContext([in] ULONG Index, [out] IUnknown **ppunkUserCtx);
    HRESULT ShowHelp([in] ULONG Index);
    HRESULT GetSourceContext([in] ULONG Index, [out, string] const WCHAR **pszFileName, [out] ULONG *pulLineNum);
    HRESULT CountSourceItems([in] ULONG Index, [out] IVsHierarchy **ppHier, [out] VSITEMID *pitemid, [out, retval] ULONG *pcItems);
    HRESULT GetMultipleSourceItems([in] ULONG Index, [in] VSGSIFLAGS grfGSI, [in] ULONG cItems, [out, size_is(cItems)] VSITEMSELECTION rgItemSel[]);
    HRESULT CanGoToSource([in] ULONG Index, [in] VSOBJGOTOSRCTYPE SrcType, [out] BOOL *pfOK);
    HRESULT GoToSource([in] ULONG Index, [in] VSOBJGOTOSRCTYPE SrcType);
    HRESULT GetContextMenu([in] ULONG Index, [out] CLSID *pclsidActive, [out] LONG *pnMenuId, [out] IOleCommandTarget **ppCmdTrgtActive);
    HRESULT QueryDragDrop([in] ULONG Index, [in] IDataObject *pDataObject, [in] DWORD grfKeyState, [in, out]DWORD * pdwEffect);
    HRESULT DoDragDrop([in] ULONG Index, [in] IDataObject * pDataObject, [in] DWORD grfKeyState, [in, out]DWORD * pdwEffect);
    HRESULT CanRename([in] ULONG Index, [in] LPCOLESTR pszNewName, [out] BOOL *pfOK);
    HRESULT DoRename([in] ULONG Index, [in] LPCOLESTR pszNewName, [in] VSOBJOPFLAGS grfFlags);
    HRESULT CanDelete([in] ULONG Index, [out] BOOL *pfOK);
    HRESULT DoDelete([in] ULONG Index, [in] VSOBJOPFLAGS grfFlags);
    // this method is going to be removed
    HRESULT FillDescription([in] ULONG Index, [in] VSOBJDESCOPTIONS grfOptions, [in] IVsObjectBrowserDescription2 *pobDesc);
    // Used to add the description pane text in OBject Browser. Also an alternate
    // mechanism for providing tooltips (ODO_TOOLTIPDESC is set in that case)
    // This method is replacing
    //HRESULT FillDescription([in] ULONG Index, [in] VSOBJDESCOPTIONS grfOptions, [in] IVsObjectBrowserDescription2 *pobDesc);
    HRESULT FillDescription2([in] ULONG Index, [in] VSOBJDESCOPTIONS grfOptions, [in] IVsObjectBrowserDescription3 *pobDesc);         

    HRESULT EnumClipboardFormats([in] ULONG Index, [in] VSOBJCFFLAGS grfFlags, [in] ULONG  celt, [in, out, size_is(celt)] VSOBJCLIPFORMAT rgcfFormats[], [out, optional] ULONG *pcActual);
    HRESULT GetClipboardFormat([in] ULONG Index, [in] VSOBJCFFLAGS grfFlags, [in] FORMATETC *pFormatetc, [in] STGMEDIUM *pMedium);
    HRESULT GetExtendedClipboardVariant([in] ULONG Index, [in] VSOBJCFFLAGS grfFlags, [in] const VSOBJCLIPFORMAT *pcfFormat, [out] VARIANT *pvarFormat);

    //--------------------------------------------------------------------------
    // Methods new to IVsObjectList2
    //--------------------------------------------------------------------------

    HRESULT GetProperty([in] ULONG Index, [in] VSOBJLISTELEMPROPID propid, [out] VARIANT *pvar);
    HRESULT GetNavInfo([in] ULONG Index, [out] IVsNavInfo ** ppNavInfo);
    HRESULT GetNavInfoNode([in] ULONG Index, [out] IVsNavInfoNode ** ppNavInfoNode);
    HRESULT LocateNavInfoNode([in] IVsNavInfoNode * pNavInfoNode, [out] ULONG * pulIndex);
};

// IVsSimpleObjectList2 interface
//
// A list which implements this interface need not implement IVsLiteTreeList, the
// interface from which this interface indirectly inherits.
//
// This interface is a simplified version of the IVsObjectList2 interface.
// A few of the IVsObjectList2 methods have been removed or modified.  The removed
// methods are methods effectively inherited from IVsLiteTreeList which are unused.
// The modified methods include GetText(), GetTipText(), GetSourceContext() and
// GetList2().  GetText(), GetTipText() and GetSourceContext() are replaced with
// GetTextWithOwnership(), GetTipTextWithOwnership() and GetSourceContextWithOwnership(),
// respectively, to allow the return of strings with ownership. GetList2() has been
// modified to return IVsSimpleObjectList2 (this interface) pointers rather than
// IVsObjectList2 pointers.
//
// It is recommended that managed list implementations implement IVsSimpleObjectList2
// (this interface) instead of IVsObjectList2, as managed IVsObjectList2::GetText(),
// IVsObjectList2::GetTipText() and IVsObjectList2::GetSourceContext() implementations
// will leak CoTaskMemAlloc'ed string buffers.
[
    uuid(uuid_IVsSimpleObjectList2),
    version(1.0),
    pointer_default(unique)
]
interface IVsSimpleObjectList2 : IUnknown
{
    HRESULT GetFlags([out] VSTREEFLAGS *pFlags);
    HRESULT GetCapabilities2([out]  LIB_LISTCAPABILITIES2 *pgrfCapabilities);
    HRESULT UpdateCounter([out] ULONG *pCurUpdate);
    HRESULT GetItemCount([out] ULONG* pCount);
    [local] HRESULT GetDisplayData([in] ULONG Index, [out] VSTREEDISPLAYDATA *pData);
    HRESULT GetTextWithOwnership([in] ULONG Index, [in] VSTREETEXTOPTIONS tto, [out] BSTR *pbstrText);
    HRESULT GetTipTextWithOwnership([in] ULONG Index, [in] VSTREETOOLTIPTYPE eTipType, [out] BSTR *pbstrText); 
    HRESULT GetCategoryField2([in] ULONG Index, [in] LIB_CATEGORY2 Category, [out,retval] DWORD *pfCatField);
    HRESULT GetBrowseObject([in] ULONG Index, [out] IDispatch **ppdispBrowseObj);
    HRESULT GetUserContext([in] ULONG Index, [out] IUnknown **ppunkUserCtx);
    HRESULT ShowHelp([in] ULONG Index);
    HRESULT GetSourceContextWithOwnership([in] ULONG Index, [out] BSTR *pbstrFileName, [out] ULONG *pulLineNum);
    HRESULT CountSourceItems([in] ULONG Index, [out] IVsHierarchy **ppHier, [out] VSITEMID *pitemid, [out, retval] ULONG *pcItems);
    HRESULT GetMultipleSourceItems([in] ULONG Index, [in] VSGSIFLAGS grfGSI, [in] ULONG cItems, [out, size_is(cItems)] VSITEMSELECTION rgItemSel[]);
    HRESULT CanGoToSource([in] ULONG Index, [in] VSOBJGOTOSRCTYPE SrcType, [out] BOOL *pfOK);
    HRESULT GoToSource([in] ULONG Index, [in] VSOBJGOTOSRCTYPE SrcType);
    HRESULT GetContextMenu([in] ULONG Index, [out] CLSID *pclsidActive, [out] LONG *pnMenuId, [out] IOleCommandTarget **ppCmdTrgtActive);
    HRESULT QueryDragDrop([in] ULONG Index, [in] IDataObject *pDataObject, [in] DWORD grfKeyState, [in, out]DWORD * pdwEffect);
    HRESULT DoDragDrop([in] ULONG Index, [in] IDataObject * pDataObject, [in] DWORD grfKeyState, [in, out]DWORD * pdwEffect);
    HRESULT CanRename([in] ULONG Index, [in] LPCOLESTR pszNewName, [out] BOOL *pfOK);
    HRESULT DoRename([in] ULONG Index, [in] LPCOLESTR pszNewName, [in] VSOBJOPFLAGS grfFlags);
    HRESULT CanDelete([in] ULONG Index, [out] BOOL *pfOK);
    HRESULT DoDelete([in] ULONG Index, [in] VSOBJOPFLAGS grfFlags);
    HRESULT FillDescription2([in] ULONG Index, [in] VSOBJDESCOPTIONS grfOptions, [in] IVsObjectBrowserDescription3 *pobDesc);         
    HRESULT EnumClipboardFormats([in] ULONG Index, [in] VSOBJCFFLAGS grfFlags, [in] ULONG  celt, [in, out, size_is(celt)] VSOBJCLIPFORMAT rgcfFormats[], [out, optional] ULONG *pcActual);
    HRESULT GetClipboardFormat([in] ULONG Index, [in] VSOBJCFFLAGS grfFlags, [in] FORMATETC *pFormatetc, [in] STGMEDIUM *pMedium);
    HRESULT GetExtendedClipboardVariant([in] ULONG Index, [in] VSOBJCFFLAGS grfFlags, [in] const VSOBJCLIPFORMAT *pcfFormat, [out] VARIANT *pvarFormat);
    HRESULT GetProperty([in] ULONG Index, [in] VSOBJLISTELEMPROPID propid, [out] VARIANT *pvar);
    HRESULT GetNavInfo([in] ULONG Index, [out] IVsNavInfo ** ppNavInfo);
    HRESULT GetNavInfoNode([in] ULONG Index, [out] IVsNavInfoNode ** ppNavInfoNode);
    HRESULT LocateNavInfoNode([in] IVsNavInfoNode * pNavInfoNode, [out] ULONG * pulIndex);
    HRESULT GetExpandable3([in] ULONG Index, [in] LIB_LISTTYPE2 ListTypeExcluded, [out] BOOL *pfExpandable);
    HRESULT GetList2([in] ULONG Index, [in] LIB_LISTTYPE2 ListType, [in] LIB_LISTFLAGS Flags, [in] VSOBSEARCHCRITERIA2 *pobSrch, [out, retval] IVsSimpleObjectList2 **ppIVsSimpleObjectList2);
    HRESULT OnClose([out] VSTREECLOSEACTIONS *ptca);
};

// Lists of Physical Containers (LLT_PHYSICALCONTAINERS) should implement this interface
// and provide for VSCOMPONENTSELECTORDATA for all its items
[
    uuid(uuid_IVsBrowseContainersList),
    version(1.0),
    pointer_default(unique)
]
interface IVsBrowseContainersList : IUnknown
{
    HRESULT GetContainerData([in] ULONG ulIndex, [out] VSCOMPONENTSELECTORDATA * pData); 
    HRESULT FindContainer([in] VSCOMPONENTSELECTORDATA * pData, [out] ULONG * pulIndex);
};

// IVsLibrary2 interface
//
// This interface is a replacement for the IVsLibrary interface.
//
// The GetSeparatorString() method returns a string which is owned by the underlying library.
// The underlying library is expected to keep a returned string "alive" until the next request
// for a string, or until the library is released.  Underlying libraries which would prefer to
// return strings with ownership should implement IVsSimpleLibrary2 instead of IVsLibrary2
// (this interface).  IVsSimpleLibrary2 has the GetSeparatorStringWithOwnership() method which
// returns a string with ownership.  Note that IVsSimpleLibrary2  also has the GetGuid() method
// which populates a given GUID buffer rather than returning a pointer to a library owned GUID.
//
// It is recommended that managed library implementations implement IVsSimpleLibrary2 instead
// of IVsLibrary2 (this interface), as managed IVsLibrary2::GetSeparatorString GetSourceContext()
// implementations will leak CoTaskMemAlloc'ed string buffers and managed IVsLibrary2::GetGuid()
// implementations require working with IntPtr's.
[
    uuid(uuid_IVsLibrary2),
    version(1.0),
    pointer_default(unique)
]
interface IVsLibrary2 : IUnknown
{
    //--------------------------------------------------------------------------
    // Methods taken from IVsLibrary
    //--------------------------------------------------------------------------

    // Get category fields (attribute values) supported by library's list elements
    // Returns E_FAIL if given category not supported
    // This method is replacing
    //HRESULT GetSupportedCategoryFields([in] LIB_CATEGORY Category, [out, retval] DWORD *pCatField);
    HRESULT GetSupportedCategoryFields2([in] LIB_CATEGORY2 Category, [out, retval] DWORD *pgrfCatField);

    // Get IVsObjectList2 interface for root list for given list type
    // This method is replacing
    //HRESULT GetList([in] LIB_LISTTYPE ListType,  [in] LIB_LISTFLAGS Flags, [in] VSOBSEARCHCRITERIA *pobSrch, [out, retval] IVsObjectList **ppList);
    HRESULT GetList2([in] LIB_LISTTYPE2 ListType,  [in] LIB_LISTFLAGS Flags, [in] VSOBSEARCHCRITERIA2 *pobSrch, [out, retval] IVsObjectList2 **ppIVsObjectList2);

    HRESULT GetLibList([in] LIB_PERSISTTYPE lptType, [out, retval] IVsLiteTreeList **ppList);

    // Get library flags
    // This method is replacing
    //HRESULT GetLibFlags([out, retval] LIB_FLAGS *pfFlags);
    HRESULT GetLibFlags2([out, retval] LIB_FLAGS2 *pgrfFlags);

    HRESULT UpdateCounter([out] ULONG *pCurUpdate);
    HRESULT GetGuid([out] const GUID **ppguidLib);
    HRESULT GetSeparatorString([out, string] LPCWSTR *pszSeparator);
    HRESULT LoadState([in] IStream *pIStream, [in] LIB_PERSISTTYPE lptType);
    HRESULT SaveState([in] IStream *pIStream, [in] LIB_PERSISTTYPE lptType);
    HRESULT GetBrowseContainersForHierarchy([in] IVsHierarchy *pHierarchy, [in] ULONG celt, [in, out, size_is(celt)] VSBROWSECONTAINER rgBrowseContainers[], [out, optional] ULONG *pcActual);
    HRESULT AddBrowseContainer([in] PVSCOMPONENTSELECTORDATA pcdComponent, [in, out] LIB_ADDREMOVEOPTIONS *pgrfOptions, [out, optional] BSTR *pbstrComponentAdded);
    HRESULT RemoveBrowseContainer([in] DWORD dwReserved, [in] LPCWSTR pszLibName);

    //--------------------------------------------------------------------------
    // Methods new to IVsLibrary2
    //--------------------------------------------------------------------------

    HRESULT CreateNavInfo([in, size_is(ulcNodes)] SYMBOL_DESCRIPTION_NODE rgSymbolNodes[], [in] ULONG ulcNodes, [out] IVsNavInfo ** ppNavInfo);
};

// IVsSimpleLibrary2 interface
//
// This interface is a simplified version of the IVsLibrary2 interface. A few of the
// IVsLibrary2 methods have been removed or modified.  The removed methods are methods
// effectively inherited from IVsLibrary which are unused.  The modified methods include
// GetSeparatorString() and GetGuid().  GetSeparatorString() is replaced with
// GetSeparatorStringWithOwnership() to allow the return of strings with ownership.
// GetGuid() has been modified to populate a given GUID buffer.
//
// It is recommended that managed list implementations implement IVsSimpleLibrary2
// (this interface) instead of IVsLibrary2, as managed IVsLibrary2::GetSeparatorString()
// implementations will leak CoTaskMemAlloc'ed string buffers and managed IVsLibrary2::GetGuid()
// implementations require working with IntPtr's..
//
// Note that libraries that implement IVsSimpleLibrary2 register themselves using
// IVsObjectManager2::RegisterSimpleLibrary().
[
    uuid(uuid_IVsSimpleLibrary2),
    version(1.0),
    pointer_default(unique)
]
interface IVsSimpleLibrary2 : IUnknown
{
    HRESULT GetSupportedCategoryFields2([in] LIB_CATEGORY2 Category, [out, retval] DWORD *pgrfCatField);
    HRESULT GetList2([in] LIB_LISTTYPE2 ListType,  [in] LIB_LISTFLAGS Flags, [in] VSOBSEARCHCRITERIA2 *pobSrch, [out, retval] IVsSimpleObjectList2 **ppIVsSimpleObjectList2);
    HRESULT GetLibFlags2([out, retval] LIB_FLAGS2 *pgrfFlags);
    HRESULT UpdateCounter([out] ULONG *pCurUpdate);
    HRESULT GetGuid([out] GUID *pguidLib);
    HRESULT GetSeparatorStringWithOwnership([out] BSTR *pbstrSeparator);
    HRESULT LoadState([in] IStream *pIStream, [in] LIB_PERSISTTYPE lptType);
    HRESULT SaveState([in] IStream *pIStream, [in] LIB_PERSISTTYPE lptType);
    HRESULT GetBrowseContainersForHierarchy([in] IVsHierarchy *pHierarchy, [in] ULONG celt, [in, out, size_is(celt)] VSBROWSECONTAINER rgBrowseContainers[], [out, optional] ULONG *pcActual);
    HRESULT AddBrowseContainer([in] PVSCOMPONENTSELECTORDATA pcdComponent, [in, out] LIB_ADDREMOVEOPTIONS *pgrfOptions, [out] BSTR *pbstrComponentAdded);
    HRESULT RemoveBrowseContainer([in] DWORD dwReserved, [in] LPCWSTR pszLibName);
    HRESULT CreateNavInfo([in, size_is(ulcNodes)] SYMBOL_DESCRIPTION_NODE rgSymbolNodes[], [in] ULONG ulcNodes, [out] IVsNavInfo ** ppNavInfo);
};


// IVsLibrary2Ex - extension for libraries, which allow add/remove browse components and 
// might give NavInfo pointing to a not loaded component as a hyperjump in OB Details Pane
[      
    uuid(D9C7D24D-7ED2-4a9d-93D1-450426CB27DF),
    version(1.0),
    pointer_default(unique)
]
interface IVsLibrary2Ex : IUnknown
{
    // Libraries receive notifications that profile settings changed through this method.
    HRESULT ProfileSettingsChanged();

    HRESULT GetNavInfoContainerData([in] IVsNavInfo * pNavInfo, [out] VSCOMPONENTSELECTORDATA * pcsdComponent);
    
    // Give library idle time
    HRESULT DoIdle();

    // Used to give the library the hint whether the given physical container is unchanging
    // As an example, the .NET library is given the hint that the .NET framework containers are unchanging
    HRESULT SetContainerAsUnchanging([in] VSCOMPONENTSELECTORDATA *pcsdComponent, [in] BOOL fUnchanging);
};


// IVsEnumLibraries2
[
    uuid(uuid_IVsEnumLibraries2), 
    version(1.0),
    pointer_default(unique)
]
interface IVsEnumLibraries2 : IUnknown
{
    HRESULT Next([in]   ULONG celt, [out, size_is(celt), length_is(*pceltFetched)] IVsLibrary2 **rgelt, [out] ULONG *pceltFetched);
    HRESULT Skip([in]   ULONG celt);
    HRESULT Reset(void);
    HRESULT Clone([out] IVsEnumLibraries2 **ppenum);
};

interface IVsSelectedSymbols;
interface IVsBrowseComponentSet;
interface IVsSimpleBrowseComponentSet;
interface IVsCombinedBrowseComponentSet;

// IVsObjectManager2 - Replacement for IVsObjectManager interface
// The old interface is depricated and it is recommended to use this new one to register
// Libraries instead of LibraryManagers.

enum _BROWSE_COMPONENT_SET_TYPE
{
    BCST_EXCLUDE_LIBRARIES   = 0x0000,
    BCST_INCLUDE_LIBRARIES   = 0x0001  
};

typedef DWORD BROWSE_COMPONENT_SET_TYPE;

[
    uuid(uuid_IVsObjectManager2),
    version(1.0),
    pointer_default(unique)
]
interface IVsObjectManager2 : IUnknown
{
    HRESULT RegisterLibrary([in] IVsLibrary2 * pLib, [out] VSCOOKIE* pdwCookie);
    HRESULT RegisterSimpleLibrary([in] IVsSimpleLibrary2 * pLib, [out] VSCOOKIE* pdwCookie);
    HRESULT UnregisterLibrary([in] VSCOOKIE dwCookie);
    HRESULT EnumLibraries([out]IVsEnumLibraries2 ** ppEnum);
    HRESULT FindLibrary([in] REFGUID guidLibrary, [out] IVsLibrary2 **ppLib);

    // helpers to deal with NavInfos and DataObjects coming from Class View, Object Browser and other nav tools
    HRESULT GetListAndIndex([in] IVsNavInfo * pNavInfo, [in] DWORD dwFlags, [out] IVsObjectList2 ** ppList, [out] ULONG * pIndex);
    HRESULT ParseDataObject([in]IDataObject * pIDataObject, [out] IVsSelectedSymbols ** ppSymbols);
    
    // Creates an empty set for specified libraries. 
    HRESULT CreateSimpleBrowseComponentSet([in] BROWSE_COMPONENT_SET_TYPE Type, [in, size_is(ulcLibs)] const GUID rgguidLibs[], [in] ULONG ulcLibs, [out, retval] IVsSimpleBrowseComponentSet ** ppSet); 
    // Creates a set automatically populated with project references and keeps them in sync
    // pProject should implement VSProject
    HRESULT CreateProjectReferenceSet([in] IUnknown * pProject, [out, retval] IVsSimpleBrowseComponentSet ** ppSet);
    // Creates an empty set, which can be populated with other sets 
    HRESULT CreateCombinedBrowseComponentSet([out, retval] IVsCombinedBrowseComponentSet ** ppCombinedSet);
};

// VS browse libraries

// VB
// {414AC972-9829-4B6A-A8D7-A08152FEB8AA}
cpp_quote("DEFINE_GUID(GUID_VB_BrowseLibrary, 0x414AC972, 0x9829, 0x4B6A, 0xA8, 0xD7, 0xA0, 0x81, 0x52, 0xFE, 0xB8, 0xAA);")

// CSharp
// {58f1bad0-2288-45b9-ac3a-d56398f7781d}
cpp_quote("DEFINE_GUID(GUID_CSharp_BrowseLibrary, 0x58f1bad0, 0x2288, 0x45b9, 0xac, 0x3a, 0xd5, 0x63, 0x98, 0xf7, 0x78, 0x1d);")

// JSharp
// {7B1DC85B-E430-4187-8177-EF97DD390D9A}
cpp_quote("DEFINE_GUID(GUID_VJSharp_BrowseLibrary, 0x7B1DC85B, 0xE430, 0x4187, 0x81, 0x77, 0xEF, 0x97, 0xDD, 0x39, 0x0D, 0x9A);")

// VC
// {6C1AC90E-09FC-4f23-90FF-87F8CFC2A445}
cpp_quote("DEFINE_GUID(GUID_VC_BrowseLibrary, 0x6c1ac90e, 0x09fc, 0x4f23, 0x90, 0xff, 0x87, 0xf8, 0xcf, 0xc2, 0xa4, 0x45);")

// BSC
// {26E73A17-0D6C-4a33-B833-22C76C50949F}
cpp_quote("DEFINE_GUID(GUID_BSC_BrowseLibrary, 0x26e73a17, 0x0d6c, 0x4a33, 0xb8, 0x33, 0x22, 0xc7, 0x6c, 0x50, 0x94, 0x9f);")

// .Net
// {1ec72fd7-c820-4273-9a21-777a5c522e03}
cpp_quote("DEFINE_GUID(GUID_Assembly_BrowseLibrary, 0x1ec72fd7, 0xc820, 0x4273, 0x9a, 0x21, 0x77, 0x7a, 0x5c, 0x52, 0x2e, 0x03);")

// COM
// {18E32C04-58BA-4a1e-80DE-1C291634166A}
cpp_quote("DEFINE_GUID(GUID_TypeLib_BrowseLibrary, 0x18e32c04, 0x58ba, 0x4a1e, 0x80, 0xde, 0x1c, 0x29, 0x16, 0x34, 0x16, 0x6a);")

// Folders 
// {DC534E0E-EFBE-4d0c-8A25-98BF029F15F8}
cpp_quote("DEFINE_GUID(GUID_Folder_BrowseLibrary, 0xdc534e0e, 0xefbe, 0x4d0c, 0x8a, 0x25, 0x98, 0xbf, 0x2, 0x9f, 0x15, 0xf8);")

// Resource View
// {D22514E7-23AF-4723-B6E5-E17D27626D34}
cpp_quote("DEFINE_GUID(GUID_ResourceView_BrowseLibrary, 0xD22514E7, 0x23AF, 0x4723, 0xB6, 0xE5, 0xE1, 0x7D, 0x27, 0x62, 0x6D, 0x34);")

#ifdef INTEROPLIB
module BrowseLibraryGuids80
{
    // VS browse libraries
    const LPSTR VB           =  "{414AC972-9829-4B6A-A8D7-A08152FEB8AA}";
    const LPSTR CSharp       =  "{58f1bad0-2288-45b9-ac3a-d56398f7781d}";
    const LPSTR VJSharp      =  "{7B1DC85B-E430-4187-8177-EF97DD390D9A}";
    const LPSTR VC           =  "{6C1AC90E-09FC-4f23-90FF-87F8CFC2A445}";
    const LPSTR BSC          =  "{26E73A17-0D6C-4a33-B833-22C76C50949F}";
    const LPSTR Assembly     =  "{1ec72fd7-c820-4273-9a21-777a5c522e03}";
    const LPSTR TypeLib      =  "{18E32C04-58BA-4a1e-80DE-1C291634166A}";   
    const LPSTR Folder       =  "{DC534E0E-EFBE-4d0c-8A25-98BF029F15F8}";
    const LPSTR ResourceView =  "{D22514E7-23AF-4723-B6E5-E17D27626D34}";
}
#endif // INTEROPLIB


// BrowseComponentSet list options to modify behavior provided by a real library
enum _BROWSE_COMPONENT_SET_OPTIONS
{
    BCSO_NO_REMOVE                       = 0x0001,   // IVsObjectList2::CanDelete will always return FALSE
    BCSO_NO_RENAME                       = 0x0002,   // IVsObjectList2::CanRename will always return FALSE
    BCSO_NO_DRAG_DROP                    = 0x0004,   // IVsObjectList2::QueryDragDrop will always return FALSE
    BCSO_PROJECT_REFERENCES              = 0x0008,   // IVsObjectList2::GetCategoryField2 will return LCPT_PROJECTREFERENCE for LC_PHYSICALCONTAINERTYPE category. This is needed to show/hide project references class view functionality
};

cpp_quote("#define BCSO_NO_EDIT  (BCSO_NO_REMOVE | BCSO_NO_RENAME | BCSO_NO_DRAG_DROP)")

typedef DWORD BROWSE_COMPONENT_SET_OPTIONS;

// IVsBrowseComponentSet 
// generic interface to get data from a set of components

[
    uuid(uuid_IVsBrowseComponentSet), 
    version(1.0),
    pointer_default(unique)
]
interface IVsBrowseComponentSet : IUnknown
{
    HRESULT put_ComponentsListOptions([in] BROWSE_COMPONENT_SET_OPTIONS dwOptions);
    HRESULT get_ComponentsListOptions([out, retval] BROWSE_COMPONENT_SET_OPTIONS * pdwOptions);

    HRESULT put_ChildListOptions([in] BROWSE_COMPONENT_SET_OPTIONS dwOptions);
    HRESULT get_ChildListOptions([out, retval] BROWSE_COMPONENT_SET_OPTIONS * pdwOptions);
    
    // gives/searches combined data for all project references (for OB)
    // it also can combine the resulting list with pExtraListToCombineWith [optional]
    HRESULT GetList2([in] LIB_LISTTYPE2 ListType,  [in] LIB_LISTFLAGS Flags, [in] VSOBSEARCHCRITERIA2 *pobSrch, [in] IVsObjectList2 * pExtraListToCombineWith/* can be NULL*/, [out, retval] IVsObjectList2 **ppIVsObjectList2);
    // this allows a library to give correct info about all its children (including this set)
    HRESULT GetSupportedCategoryFields2([in] LIB_CATEGORY2 Category, [out, retval] DWORD *pgrfCatField);
    // symbol nodes should include root NavInfo nodes and the resulting NavInfo will have it as a root
    HRESULT CreateNavInfo([in] REFGUID guidLib /* can be GUID_NULL*/, [in, size_is(ulcNodes)] SYMBOL_DESCRIPTION_NODE rgSymbolNodes[], [in] ULONG ulcNodes, [out, retval] IVsNavInfo ** ppNavInfo);
    // in case somebody is interested if set has been changed
    HRESULT UpdateCounter([out] ULONG *pCurUpdate); 
};


// IVsSimpleBrowseComponentSet 
// interface to populate a set of components
[
    uuid(uuid_IVsSimpleBrowseComponentSet), 
    version(1.0),
    pointer_default(unique)
]
interface IVsSimpleBrowseComponentSet : IVsBrowseComponentSet
{
    // RootNavInfo defines the object to show this set of components under. All NavInfos returned from 
    // set lists will start with this NavInfo (that is its nodes and lib guid).
    HRESULT put_RootNavInfo([in] IVsNavInfo * pRootNavInfo);
    HRESULT get_RootNavInfo([out, retval] IVsNavInfo ** pRootNavInfo);
    
    HRESULT put_Owner([in] IUnknown *  pOwner); // in project references pOwner is VsProject
    HRESULT get_Owner([out, retval] IUnknown ** ppOwner); 
    
    HRESULT FindComponent([in] REFGUID guidLib /* can be GUID_NULL*/, [in] VSCOMPONENTSELECTORDATA * pcsdComponent, [out]IVsNavInfo ** ppRealLibNavInfo, [out] VSCOMPONENTSELECTORDATA * pcsdExistingComponent); 
    HRESULT AddComponent([in] REFGUID guidLib /* can be GUID_NULL*/, [in] VSCOMPONENTSELECTORDATA * pcsdComponent, [out]IVsNavInfo ** ppRealLibNavInfo, [out] VSCOMPONENTSELECTORDATA * pcsdAddedComponent);
    HRESULT RemoveComponent([in] IVsNavInfo * pRealLibNavInfo);
    HRESULT RemoveAllComponents();
};

// IVsCombinedBrowseComponentSet
// combines multiple component sets and gives/searches deduplicated list of components 
// (can be used for project references presentation in OB as a top level list)
[
    uuid(uuid_IVsCombinedBrowseComponentSet), 
    version(1.0),
    pointer_default(unique)
]
interface IVsCombinedBrowseComponentSet : IVsBrowseComponentSet 
{
    HRESULT AddSet([in] IVsSimpleBrowseComponentSet * pSet);
    HRESULT GetSetCount([in] ULONG * pulCount);
    HRESULT GetSetAt([in] ULONG ulIndex, [out, retval] IVsSimpleBrowseComponentSet ** ppSet);
    HRESULT RemoveSetAt([in] ULONG ulIndex);
    HRESULT RemoveAllSets();
    HRESULT RemoveOwnerSets([in] IUnknown * pOwner);
};


// IVsSelectedSymbol
[
    uuid(uuid_IVsSelectedSymbol),
    version(1.0),
    pointer_default(unique)
]
interface IVsSelectedSymbol : IUnknown
{
    HRESULT GetNavInfo([out] IVsNavInfo **ppNavInfo);
    HRESULT GetName([out] BSTR *pbstrName);
};

// IVsEnumSelectedSymbols
[
    uuid(uuid_IVsEnumSelectedSymbols),
    version(1.0),
    pointer_default(unique)
]
interface IVsEnumSelectedSymbols : IUnknown
{
    HRESULT Next([in]   ULONG celt, [out, size_is(celt), length_is(*pceltFetched)] IVsSelectedSymbol **rgpIVsSelectedSymbol, [out] ULONG *pceltFetched);
    HRESULT Skip([in]   ULONG celt);
    HRESULT Reset(void);
    HRESULT Clone([out] IVsEnumSelectedSymbols **ppIVsEnumSelectedSymbols);
};

// IVsSelectedSymbols
[
    uuid(uuid_IVsSelectedSymbols),
    version(1.0),
    pointer_default(unique)
]
interface IVsSelectedSymbols : IUnknown
{
    HRESULT GetCount([out] ULONG *pcItems);
    HRESULT GetItem([in] ULONG iItem, [out] IVsSelectedSymbol **ppIVsSelectedSymbol);
    HRESULT EnumSelectedSymbols([out] IVsEnumSelectedSymbols **ppIVsEnumSelectedSymbols);
    HRESULT GetItemTypes([out] DWORD *pgrfTypes);
};

//new interface for CV and OB, as a replacement for IVsClassView and IVsObjectBrowser (the CV and OB services will continue to have different SIDs)
[
    uuid(uuid_IVsNavigationTool),
    version(1.0),
    pointer_default(unique)
]
interface IVsNavigationTool : IUnknown
{
    HRESULT NavigateToSymbol([in] REFGUID guidLib, [in, size_is(ulcNodes)] SYMBOL_DESCRIPTION_NODE rgSymbolNodes[], [in] ULONG ulcNodes);
    HRESULT NavigateToNavInfo([in] IVsNavInfo * pNavInfo);
    HRESULT GetSelectedSymbols([out] IVsSelectedSymbols **ppIVsSelectedSymbols);
};

// to get IVsNavigationTool and IVsSelectedSymbols use
// SID_SVsClassView service - for class view
// SID_SVsObjBrowser service  - for object browser



//-----------------------------------------------------------------------------
// IVsFindSymbol
//-----------------------------------------------------------------------------
// Implemented by the Environment on the Find Symbol (replacement for IVsObjectSearch)

[
    uuid(uuid_IVsFindSymbol),
    version(1.0),
    pointer_default(unique)
]
interface IVsFindSymbol : IUnknown
{
    // guidScope here can be only one of GUID_VsSymbolScope_*
    HRESULT GetUserOptions([out] GUID * pguidScope, [out] VSOBSEARCHCRITERIA2 *pobSrch);
    HRESULT SetUserOptions([in] REFGUID guidScope, [in] const VSOBSEARCHCRITERIA2 *pobSrch);
    // guidSymbolScope here can be one of GUID_VsSymbolScope_* or a library guid. 
    HRESULT DoSearch([in] REFGUID guidSymbolScope, [in] const VSOBSEARCHCRITERIA2 *pobSrch);
};

// Find Symbol events
[      
    uuid(uuid_IVsFindSymbolEvents),
    version(1.0)
]
interface IVsFindSymbolEvents : IUnknown
{
    HRESULT OnUserOptionsChanged([in] REFGUID guidSymbolScope, [in] const VSOBSEARCHCRITERIA2 *pobSrch);
};

// use SID_SVsObjectSearch service to get IVsFindSymbol and IConnectionPointContainer


// VS Symbol Scopes
// {A5A527EA-CF0A-4abf-B501-EAFE6B3BA5C6}
cpp_quote("DEFINE_GUID(GUID_VsSymbolScope_All, 0xa5a527ea, 0xcf0a, 0x4abf, 0xb5, 0x1, 0xea, 0xfe, 0x6b, 0x3b, 0xa5, 0xc6);")

// {41FD0B24-8D2B-48c1-B1DA-AACF13A5570F}
cpp_quote("DEFINE_GUID(GUID_VsSymbolScope_OBSelectedComponents, 0x41fd0b24, 0x8d2b, 0x48c1, 0xb1, 0xda, 0xaa, 0xcf, 0x13, 0xa5, 0x57, 0xf);")

// {C2146638-C2FE-4c1e-A49D-64AE971EEF39}
cpp_quote("DEFINE_GUID(GUID_VsSymbolScope_FSSelectedComponents, 0xc2146638, 0xc2fe, 0x4c1e, 0xa4, 0x9d, 0x64, 0xae, 0x97, 0x1e, 0xef, 0x39);")

// {3168518C-B7C9-4e0c-BD51-E3321CA7B4D8}
cpp_quote("DEFINE_GUID(GUID_VsSymbolScope_Frameworks, 0x3168518c, 0xb7c9, 0x4e0c, 0xbd, 0x51, 0xe3, 0x32, 0x1c, 0xa7, 0xb4, 0xd8);")

// {B1BA9461-FC54-45b3-A484-CB6DD0B95C94}
cpp_quote("DEFINE_GUID(GUID_VsSymbolScope_Solution, 0xb1ba9461, 0xfc54, 0x45b3, 0xa4, 0x84, 0xcb, 0x6d, 0xd0, 0xb9, 0x5c, 0x94);")


#ifdef INTEROPLIB
module SymbolScopeGuids80
{
    // VS Symbol Scopes
    const LPSTR All =                   "{A5A527EA-CF0A-4ABF-B501-EAFE6B3BA5C6}";
    const LPSTR OBSelectedComponents =  "{41FD0B24-8D2B-48C1-B1DA-AACF13A5570F}";
    const LPSTR FSSelectedComponents =  "{C2146638-C2FE-4C1E-A49D-64AE971EEF39}";
    const LPSTR Frameworks =            "{3168518C-B7C9-4E0C-BD51-E3321CA7B4D8}";
    const LPSTR Solution =              "{B1BA9461-FC54-45B3-A484-CB6DD0B95C94}";
}
#endif // INTEROPLIB


//----------------------------------------------------------------------------
// interface IVsCallBrowser (Call Browser service)
//----------------------------------------------------------------------------
// Implemented by the Environment.
// Used by VsPackages that want to manipulate CallBrowser.

enum __VSCALLBROWSERMODE
{
    CBM_CALLSTO             = 0,
    CBM_CALLSTO_NEWWINDOW   = 1,
    CBM_CALLSFROM           = 2,
    CBM_CALLSFROM_NEWWINDOW = 3
};
typedef LONG CALLBROWSERMODE;

[
    uuid(uuid_IVsCallBrowser),
    version(1.0),
    pointer_default(unique)
]
interface IVsCallBrowser : IUnknown
{
    HRESULT SetRootAtSymbol([in] CALLBROWSERMODE cbMode, [in] REFGUID guidLib, [in, size_is(ulcNodes)] SYMBOL_DESCRIPTION_NODE rgSymbolNodes[], [in] ULONG ulcNodes);
    HRESULT SetRootAtNavInfo([in] CALLBROWSERMODE cbMode, [in] IVsNavInfo * pNavInfo);

    // Currently there is a limit on the number of Call Browser instances opened simultaneously.
    // This function sets pfOK = TRUE if can create new instance of Call Browser. 
    HRESULT CanCreateNewInstance([out] BOOL *pfOK);
};

// Call Browser service.
[
    uuid(uuid_SVsCallBrowser)
]
interface SVsCallBrowser : IUnknown
{
}

cpp_quote("#define SID_SVsCallBrowser IID_SVsCallBrowser")

// Primary Call Browser tool window GUID
// {5415EA3A-D813-4948-B51E-562082CE0887}
cpp_quote("extern const __declspec(selectany) GUID GUID_CallBrowser = { 0x5415ea3a, 0xd813, 0x4948, { 0xb5, 0x1e, 0x56, 0x20, 0x82, 0xce, 0x8, 0x87 } };")

// multiinstance (secondary) Call Browser tool windows GUID
// {F78BCC56-71F7-4e7d-8215-F690CAE4F452}
cpp_quote("extern const __declspec(selectany) GUID GUID_CallBrowserSecondary = { 0xf78bcc56, 0x71f7, 0x4e7d, { 0x82, 0x15, 0xf6, 0x90, 0xca, 0xe4, 0xf4, 0x52 } };")



// replacement for IVsComponentSelectorDlg - new interface allows to prepopulate selected components

enum __VSCOMPSELFLAGS2
{
    VSCOMSEL2_MultiSelectMode              = 0x00000001,  // allow selection of multiple components
    VSCOMSEL2_ShowSelectedList             = 0x00000080,  // list of selected components is visible. Ignored in single select mode
    VSCOMSEL2_ShowAllPagesOfSpecifiedTypes = 0x00000100,  // Add pages, which are not specified in rgcstiTabInitializers, but produce the same components (have the same ComponentType string value in the registry). 
};

typedef DWORD VSCOMPSELFLAGS2;

[
    uuid(uuid_IVsComponentSelectorDlg2),
    version(1.0),
    pointer_default(unique)
]
interface IVsComponentSelectorDlg2 : IUnknown
{
    HRESULT ComponentSelectorDlg2([in]   VSCOMPSELFLAGS2 grfFlags,         // VSCOMSEL_* flags
        [in]      IVsComponentUser *pUser,         // interface on which AddComponent will be called
        [in]      ULONG cComponents,
        [in, size_is(cComponents)] PVSCOMPONENTSELECTORDATA rgpcsdComponents[], //prepopulation of Selected Components
        [in]      LPCOLESTR lpszDlgTitle,          // dialog caption (NULL == "Component Selector")
        [in]      LPCOLESTR lpszHelpTopic,         // F1 help topic (NULL == "VS.ComponentPicker")
        [in, out] ULONG * pxDlgSize,   // 0 to use default
        [in, out] ULONG * pyDlgSize,   // 0 to use default
        [in]      ULONG cTabInitializers,          // number of tabs
        [in, size_is(cTabInitializers)] VSCOMPONENTSELECTORTABINIT rgcstiTabInitializers[], // tabs in show order and their initialization info
        [in, out] GUID *  pguidStartOnThisTab,     // tab to show when the dialog starts up
        [in]      LPCOLESTR pszBrowseFilters,      // list of filters to use in 'Browse...' dialog
        [in, out] BSTR *pbstrBrowseLocation);      // directory (initial/return value) to start the 'Browse...' dialog in

};

[
    uuid(uuid_SVsComponentSelectorDlg2)
]
interface SVsComponentSelectorDlg2 : IUnknown
{
}

cpp_quote("#define SID_SVsComponentSelectorDlg2 IID_SVsComponentSelectorDlg2")

// Component Selector page GUIDs

// GUID_BrowseFilesPage {2483F435-673D-4fa3-8ADD-B51442F65349}
cpp_quote("DEFINE_GUID(GUID_BrowseFilesPage, 0x2483f435, 0x673d, 0x4fa3, 0x8a, 0xdd, 0xb5, 0x14, 0x42, 0xf6, 0x53, 0x49);")

// GUID_MRUPage  {19B97F03-9594-4c1c-BE28-25FF030113B3}
cpp_quote("DEFINE_GUID(GUID_MRUPage, 0x19b97f03, 0x9594, 0x4c1c, 0xbe, 0x28, 0x25, 0xff, 0x3, 0x1, 0x13, 0xb3);")

// the following are defined in vsshell.idl

// GUID_COMPlusPage --    {9A341D95-5A64-11d3-BFF9-00C04F990235}
//cpp_quote("DEFINE_GUID(GUID_COMPlusPage,    0x9a341d95, 0x5a64, 0x11d3, 0xbf, 0xf9, 0x00, 0xc0, 0x4f, 0x99, 0x02, 0x35);")
// GUID_COMClassicPage -- {9A341D96-5A64-11d3-BFF9-00C04F990235}
//cpp_quote("DEFINE_GUID(GUID_COMClassicPage, 0x9a341d96, 0x5a64, 0x11d3, 0xbf, 0xf9, 0x00, 0xc0, 0x4f, 0x99, 0x02, 0x35);")
// GUID_SolutionPage --   {9A341D97-5A64-11d3-BFF9-00C04F990235}
//cpp_quote("DEFINE_GUID(GUID_SolutionPage,   0x9a341d97, 0x5a64, 0x11d3, 0xbf, 0xf9, 0x00, 0xc0, 0x4f, 0x99, 0x02, 0x35);")


#ifdef INTEROPLIB

module ComponentSelectorGuids80
{
    const LPSTR BrowseFilesPage = "{2483F435-673D-4fa3-8ADD-B51442F65349}";
    const LPSTR MRUPage = "{19B97F03-9594-4c1c-BE28-25FF030113B3}";
    // the following are defined in vsshell.idl
    const LPSTR COMPlusPage = "{9A341D95-5A64-11d3-BFF9-00C04F990235}";
    const LPSTR COMClassicPage = "{9A341D96-5A64-11d3-BFF9-00C04F990235}";
    const LPSTR SolutionPage = "{9A341D97-5A64-11d3-BFF9-00C04F990235}";
}
#endif // INTEROPLIB


// New interface for retrieving macro values from a project system 
[
    uuid(uuid_IVsBuildMacroInfo),
    version(1.0),
    pointer_default(unique)
]
interface IVsBuildMacroInfo : IUnknown
{
    HRESULT GetBuildMacroValue([in]  BSTR bstrBuildMacroName, [out] BSTR *pbstrBuildMacroValue); 
};


//------------------------------------------------------------------------------
// Preview Changes Tool Window
//------------------------------------------------------------------------------

// This is the check-state of an item.
enum __PREVIEWCHANGESITEMCHECKSTATE
{
    PCCS_None = 0,              // Item doesn't have a checkbox channel
    PCCS_Unchecked = 1,         // Item and all its descendants are unchecked.
    PCCS_PartiallyChecked = 2,  // Some descendants of this item are checked and some others are unchecked.
    PCCS_Checked = 3            // Item and all its descendants are checked.
};
typedef LONG PREVIEWCHANGESITEMCHECKSTATE;

// IVsPreviewChangesList interface
//
// This interface is implemented on lists of items which represent the changes tree
// in the Preview Changes dialog.
//
// A list which implements this interface must also implement IVsLiteTreeList, the
// interface from which this interface effectively inherits.
//
// The GetText() and GetTipText() methods return strings which are owned by the
// underlying list.  The underlying list is expected to keep a returned string "alive"
// until the next request for a string, or until the list is released.  Underlying lists
// which would prefer to return strings with ownership should implement IVsSimplePreviewChangesList
// instead of IVsPreviewChangesList (this interface).  IVsSimplePreviewChangesList has
// the GetTextWithOwnership() and GetTipTextWithOwnership() methods which return
// strings with ownership.
//
// It is recommended that managed list implementations implement IVsSimplePreviewChangesList
// instead of IVsPreviewChangesList (this interface), as managed GetText() and GetTipText()
// implementations will leak CoTaskMemAlloc'ed string buffers.
[
    uuid(uuid_IVsPreviewChangesList),
    version(1.0),
    pointer_default(unique)
]
interface IVsPreviewChangesList : IUnknown
{
    //--------------------------------------------------------------------------
    // Methods "inherited" from IVsLiteTreeList
    //--------------------------------------------------------------------------

    HRESULT GetFlags([out] VSTREEFLAGS *pFlags);
    HRESULT GetItemCount([out] ULONG* pCount);
    HRESULT GetExpandedList([in] ULONG Index, [out] BOOL *pfCanRecurse, [out] IVsLiteTreeList **pptlNode);
    HRESULT LocateExpandedList([in] IVsLiteTreeList* ExpandedList, [out] ULONG *iIndex);
    HRESULT OnClose([out] VSTREECLOSEACTIONS *ptca);
    HRESULT GetText([in] ULONG Index, [in] VSTREETEXTOPTIONS tto, [out, string] const WCHAR **ppszText);
    HRESULT GetTipText([in] ULONG Index, [in] VSTREETOOLTIPTYPE eTipType, [out, string] const WCHAR **ppszText); 
    HRESULT GetExpandable([in] ULONG Index, [out] BOOL *pfExpandable);
    [local] HRESULT GetDisplayData([in] ULONG Index, [out] VSTREEDISPLAYDATA *pData);
    HRESULT UpdateCounter([out] ULONG *pCurUpdate,  [out] VSTREEITEMCHANGESMASK *pgrfChanges);
    HRESULT GetListChanges([in,out] ULONG *pcChanges, [in, size_is(*pcChanges)] VSTREELISTITEMCHANGE *prgListChanges);
    HRESULT ToggleState([in] ULONG Index, [out] VSTREESTATECHANGEREFRESH *ptscr);

    //--------------------------------------------------------------------------
    // Methods extending IVsLiteTreeList
    //--------------------------------------------------------------------------

    // Request source for list element to be hung off text view
    HRESULT OnRequestSource([in] ULONG Index, [in] IUnknown *pIUnknownTextView);
};

// IVsSimplePreviewChangesList interface.
//
// This interface is implemented on lists of items which represent the changes tree
// in the Preview Changes dialog.
//
// A list which implements this interface need not implement IVsLiteTreeList, the
// interface from which this interface indirectly inherits.
//
// This interface is a simplified version of the IVsPreviewChangesList interface.
// A few of the IVsPreviewChangesList methods have been removed or modified.  The removed
// methods are methods effectively inherited from IVsLiteTreeList which are unused.
// The modified methods include GetText(), GetTipText(), GetExpandedList() and
// LocateExpandedList().  GetText() and GetTipText() are replaced with GetTextWithOwnership()
// and GetTipTextWithOwnership(), respectively, to allow the return of strings with ownership.
// GetExpandedList() and LocateExpandedList() have been modified to take and return
// IVsSimplePreviewChangesList (this interface) pointers rather than IVsLiteTreeList pointers.
//
// It is recommended that managed list implementations implement IVsSimplePreviewChangesList
// (this interface) instead of IVsPreviewChangesList, as managed IVsPreviewChangesList::GetText()
// and IVsPreviewChangesList::GetTipText() implementations will leak CoTaskMemAlloc'ed string buffers.
[
    uuid(uuid_IVsSimplePreviewChangesList),
    version(1.0),
    pointer_default(unique)
]
interface IVsSimplePreviewChangesList : IUnknown
{
    HRESULT GetItemCount([out] ULONG* pCount);
    [local] HRESULT GetDisplayData([in] ULONG Index, [out] VSTREEDISPLAYDATA *pData);
    HRESULT GetTextWithOwnership([in] ULONG Index, [in] VSTREETEXTOPTIONS tto, [out] BSTR *pbstrText);
    HRESULT GetTipTextWithOwnership([in] ULONG Index, [in] VSTREETOOLTIPTYPE eTipType, [out] BSTR *pbstrText); 
    HRESULT GetExpandable([in] ULONG Index, [out] BOOL *pfExpandable);
    HRESULT GetExpandedList([in] ULONG Index, [out] BOOL *pfCanRecurse, [out] IVsSimplePreviewChangesList **ppIVsSimplePreviewChangesList);
    HRESULT LocateExpandedList([in] IVsSimplePreviewChangesList *pIVsSimplePreviewChangesListChild, [out] ULONG *piIndex);
    HRESULT ToggleState([in] ULONG Index, [out] VSTREESTATECHANGEREFRESH *ptscr);
    HRESULT OnRequestSource([in] ULONG Index, [in] IUnknown *pIUnknownTextView);
    HRESULT OnClose([out] VSTREECLOSEACTIONS *ptca);
};

// Preview changes warning level
enum __PREVIEWCHANGESWARNINGLEVEL
{
    PCWL_None = 0,
    PCWL_Information = 1,
    PCWL_Warning = 2,
    PCWL_Error = 3
};
typedef LONG PREVIEWCHANGESWARNINGLEVEL;

// IVsPreviewChangesEngine interface (implemented by refactoring engine)
[
    uuid(uuid_IVsPreviewChangesEngine),
    version(1.0),
    pointer_default(unique)
]
interface IVsPreviewChangesEngine : IUnknown
{
    // Get dialog title text
    HRESULT GetTitle([out] BSTR *pbstrTitle);
    // Get dialog description text (tree view description text) 
    HRESULT GetDescription([out] BSTR *pbstrDescription);
    // Get dialog text view description text 
    HRESULT GetTextViewDescription([out] BSTR *pbstrTextViewDescription);
    // Get dialog warning text and level
    HRESULT GetWarning([out] BSTR *pbstrWarning, [out] PREVIEWCHANGESWARNINGLEVEL *ppcwlWarningLevel);
    // Get dialog help context (defaults to "VS.PreviewChanges")
    HRESULT GetHelpContext([out] BSTR *pbstrHelpContext);
    // Get dialog confirmation button text 
    HRESULT GetConfirmation([out] BSTR *pbstrConfirmation);
    // Get root changes list
    HRESULT GetRootChangesList([out] IUnknown **ppIUnknownPreviewChangesList);
    // Apply changes
    HRESULT ApplyChanges();
};

// IVsPreviewChangesService interface (implemented by preview changes service)
[
    uuid(uuid_IVsPreviewChangesService),
    version(1.0),
    pointer_default(unique)
]
interface IVsPreviewChangesService : IUnknown
{
    // Preview Changes (calling back to given refactoring engine)
    HRESULT PreviewChanges([in] IVsPreviewChangesEngine *pIVsPreviewChangesEngine);
};

[
    uuid(uuid_SVsPreviewChangesService)
]
interface SVsPreviewChangesService : IUnknown
{
}

cpp_quote("#define SID_SVsPreviewChangesService IID_SVsPreviewChangesService")


//----------------------------------------------------------------------------
// interface IVsCodeDefViewContext (Code Definition View context)
//----------------------------------------------------------------------------
// Passed to IVsCodeDefView::SetContext()
[
    uuid(uuid_IVsCodeDefViewContext),
    version(1.0),
    pointer_default(unique)
]
interface IVsCodeDefViewContext : IUnknown
{
    HRESULT GetCount([out] ULONG *pcItems);
    HRESULT GetSymbolName([in] ULONG iItem, [out] BSTR *pbstrSymbolName);
    HRESULT GetFileName([in] ULONG iItem, [out] BSTR *pbstrFileName);
    HRESULT GetLine([in] ULONG iItem, [out] ULONG *piLine);
    HRESULT GetCol([in] ULONG iItem, [out] ULONG *piCol);
};

//----------------------------------------------------------------------------
// interface IVsCodeDefView (Code Definition Window service)
//----------------------------------------------------------------------------
// Implemented by the Environment.
//
// This interface is available on the SID_SVsCodeDefView service.  It is used
// by VsPackages that want to manipulate the Code Definition Window.  It can
// be used to show and hide the Code Definition tool window, to check whether
// the tool window is currently visible and to alter the context presented by
// the tool window.  Context is set using the SetContext() method. For the
// most part, the last context set wins.  The exception is when the tool
// window is active, at which time SetContext() has no effect.  This is a
// failsafe to avoid having events (selection, etc.) in the tool window push
// a new context to the tool window itself.  The expectation is that
// VsPackages will use the IsCodeDefView() method to check whether a given
// IVsTextView is owned by the Code Definition tool window and avoid pushing
// context to the tool window itself.
//
// On idle, the Code Definition tool window gets and presents the most
// recently pushed context.  It doesn't do this on every idle, but instead
// after a refresh delay time.  A VSPackage can obtain the refresh delay time
// using the GetRefreshDelay() method, using it to optimize pushing context.
//
// A VsPackage can force idle time processing using the ForceIdleProcessing()
// method.  It is expected that this method only be called on the main UI
// thread.

[
    uuid(uuid_IVsCodeDefView),
    version(1.0),
    pointer_default(unique)
]
interface IVsCodeDefView : IUnknown
{
    HRESULT ShowWindow();
    HRESULT HideWindow();
    HRESULT IsVisible();
    HRESULT SetContext([in] IVsCodeDefViewContext *pIVsCodeDefViewContext);
    HRESULT GetRefreshDelay([out] ULONG *pcMilliseconds);
    HRESULT ForceIdleProcessing();
    HRESULT IsCodeDefView([in] IVsTextView *pIVsTextView, [out] BOOL *pfIsCodeDefView);
};

//----------------------------------------------------------------------------
// interface IVsSupportCodeDefView
//----------------------------------------------------------------------------
// Implemented by a doc data to indicate that it supports Code Def View.
// Presense of this interface on a doc data indicates that the doc data
// supports Code Def View; so, this interface has no methods.  The shell
// provided text buffer (CLSID_VsTextBuffer) implements this interface,
// and therefore supports Code Def View.
[
    uuid(uuid_IVsSupportCodeDefView)
]
interface IVsSupportCodeDefView : IUnknown
{
}

[
    uuid(uuid_SVsCodeDefView)
]
interface SVsCodeDefView : IUnknown
{
}

cpp_quote("#define SID_SVsCodeDefView IID_SVsCodeDefView")


//----------------------------------------------------------------------------
// interface IVsCoTaskMemFreeMyStrings
//----------------------------------------------------------------------------
// Implementing this interface on an object indicates to the object consumer
// that strings returned by methods on other interfaces on the object should
// be freed by the caller using ::CoTaskMemFree().  This is necessary because
// some older interfaces have contracts where strings are returned without
// ownership.  Some implementations of these interfaces may choose to, or in
// some cases are forced to, return strings with ownership. The methods whose
// contract is to return strings without ownership return strings using
// parameters of type const WCHAR **.  These include:
//
// IVsLiteTreeList::GetText()
// IVsLiteTreeList::GetTipText()
// IVsObjectList::GetSourceContext()
// IVsLibraryMgr::GetNameAt()
// IVsLibrary::GetSeparatorString()
// IVsCompletionSet::GetDisplayText()
// IVsFullTextScanner::FullTextRead()
// IVsTextScanner::Read()
// IVsDropdownBarClient::GetEntryText()
// IVsPersistentTextImage::Image_FullTextRead()
// IVsLangSpecificSyntax::GetText() [OBSOLETE]
//
// The managed interop for these methods treats the const WCHAR ** parameters
// as out strings, so managed implementations of these methods hand out strings
// with ownership.  In order to indicate to the caller that the handed out
// strings should be freed, managed implementations of these methods should also
// implement IVsCoTaskMemFreeMyStrings (this interface).
[
    uuid(uuid_IVsCoTaskMemFreeMyStrings)
]
interface IVsCoTaskMemFreeMyStrings : IUnknown
{
}

//----------------------------------------------------------------------------
// IVsRunningDocumentTable
//----------------------------------------------------------------------------
// Implemented by the Environment.
// Used by projects and editors to coordinate open documents.

typedef enum __VSRDTFLAGS2
{
    /*********************** defined in vsshell.idl
    RDT_NoLock              = 0x00000000,      // can be used with FindAndLockDocument(RDT_NoLock,...,&docCookie) to get DocCookie w/o taking a lock
    RDT_ReadLock            = 0x00000001,
    RDT_EditLock            = 0x00000002,
    RDT_RequestUnlock       = 0x00000004,
    RDT_LOCKMASK            = 0x00000007,

    RDT_DontSaveAs          = 0x00000008,
    RDT_NonCreatable        = 0x00000010,
    RDT_DontSave            = 0x00000020,
    RDT_DontAutoOpen        = 0x00000040,
    RDT_CaseSensitive       = 0x00000080,
    RDT_CantSave            = RDT_DontSave | RDT_DontSaveAs,
    RDT_VirtualDocument     = 0x00001000,
    RDT_ProjSlnDocument     = 0x00002000,
    RDT_PlaceHolderDoc      = 0x00004000,
    RDT_CanBuildFromMemory  = 0x00008000,
    RDT_DontAddToMRU        = 0x00010000,
    RDT_DOCMASK             = 0xFFFFF0F8,  // allow __VSCREATEDOCWIN flags in doc mask

    RDT_Unlock_NoSave       = 0x00000100,
    RDT_Unlock_SaveIfDirty  = 0x00000200,
    RDT_Unlock_PromptSave   = 0x00000400,
    ***********************/
    RDT_Lock_WeakEditLock   = 0x00000800,
    /*********************** defined in vsshell.idl
    RDT_SAVEMASK            = 0x00000F00,
    ***********************/
    RDT_LOCKUNLOCKMASK      = 0x00000F00,
} _VSRDTFLAGS2;
typedef DWORD VSRDTFLAGS2;

enum __VSRDTSAVEOPTIONS2
{
    /*
    RDTSAVEOPT_SaveIfDirty      = 0x00000000,  // save only if dirty (this is the default)
    RDTSAVEOPT_PromptSave       = 0x00000001,  // prompt user whether to save
    RDTSAVEOPT_ForceSave        = 0x00000002,  // force save even if not dirty
    RDTSAVEOPT_SaveNoChildren   = 0x00000004,  // save only the root of the hierarchy passed in, don't include its children
    RDTSAVEOPT_SaveOnlyChildren = 0x00000008,  // save only children of the hierarchy passed in, don't include hierarchy itself
    RDTSAVEOPT_ActivateDocOnErr = 0x00000010,  // activates the editor window of a doc if it errors on save*/
    RDTSAVEOPT_SkipNewUnsaved   = 0x00000020,  // indicates that new unsaved files (created via File.New File) should be skipped
    RDTSAVEOPT_SaveAllButThis   = 0x00000040,  // the supplied document token indicates the exception and everything but it will be saved normaly
    /*RDTSAVEOPT_DocClose         = 0x00010000,  // indicates save is a result of a document close*/
    RDTSAVEOPT_FSaveAs          = 0x20000000,  //determine if we should bring up a SaveAs dialog - IMPORTANT: this value must be kept 
    //in sync with the internal flag RDTSAVEOPT_FSAVEAS defined in d:\vs7vnext\env\msenv\core\vsrdtbl.h !!!
    /*RDTSAVEOPT_Reserved         = 0xFFFF0000,  // reserved internal bits*/
};
typedef DWORD VSRDTSAVEOPTIONS2;

[
    uuid(uuid_IVsRunningDocumentTable2),
    version(1.0),
    pointer_default(unique)
]
interface IVsRunningDocumentTable2 : IUnknown
{
    // CloseDocuments
    // Closes all DocumentWindows and IVsDocumentLockHolders for a specified document or all documents that belong to an IVsHierarchy. Similar
    // to IVsSolution::CloseSolutionElements but is useable also by non-Solution hierarchies, whereas CloseSolutionElements only works for
    // solution-related documents (i.e. solution, projects, project items, etc.).  Calling CloseDocuments(grfSave, pHierarchy, VSDOCCOOKIE_NIL)
    // will only close the documents that belong to pHierarchy as opposed to CloseSolutionElements which will do this and also remove the project
    // referenced by pHierarchy from the solution (i.e. RemoveProject).  You can pass either a pHierarchy or a docCookie but not both.
    HRESULT CloseDocuments([in] FRAMECLOSE grfSaveOptions, [in] IVsHierarchy *pHierarchy, [in] VSCOOKIE docCookie);
    
    // Prompt (if appropriate) to close a document that is open in an incompatible editor. This method will close the document if the user says OK.
    // This method shows the same prompt that is normally shown when VS_E_INCOMPATIBLEDOCDATA is returned from IVsEditorFactory::CreateEditorInstance.
    // This method determines whether the specified document is in the running document table.
    // If the document is in the table and has edit locks, it prompts the user to close the document. 
    // If user chooses not to close, then it returns OLE_E_PROMPTSAVECANCELLED/*pfFoundAndClosed==FALSE.
    // If the document is in the table and has only read locks, it closes the document without prompting.
    // If the document is not in the table, it just returns NOERROR/*pfFoundAndClosed==FALSE. 
    // If the document is actually closed by this method, then it returns NOERROR/*pfFoundAndClosed==TRUE.
    HRESULT QueryCloseRunningDocument([in] LPCOLESTR pszMkDocument, [out] BOOL *pfFoundAndClosed);

    // FindAndLockDocumentEx is similar to FindAndLockDocument but also allows the specification of a preferred hierarchy/itemid pair for the document in
    // case an RDT_EditLock is desired and the document is currently registered with only a RDT_ReadLock with no hierarchy/itemid assigned. In this case
    // FindAndLockDocument would have returned E_UNEXPECTED. This method will not register the document in the RDT if it is not currently registered.
    HRESULT FindAndLockDocumentEx([in] VSRDTFLAGS grfRDTLockType, [in] LPCOLESTR pszMkDocument, [in] IVsHierarchy *pHierPreferred, [in] VSITEMID itemidPreferred,
        [out] IVsHierarchy **ppHierActual, [out] VSITEMID *pitemidActual, [out] IUnknown **ppunkDocDataActual, [out] VSCOOKIE *pdwCookie);

    // FindOrRegisterAndLockDocument handles all cases to add a lock to a document whether the document is already registered or not. This is a convenience
    // method that combines the functionality of RegisterAndLockDocument and FindAndLockDocumentEx. RegisterAndLockDocument returns an error if the document
    // is already registered. FindAndLockDocumentEx returns an error if it is not registered. In the case where an RDT_EditLock is desired and the document
    // is currently registered only with a RDT_ReadLock with no pHier/itemid assigned, this function will assign the preferred pHier/itemid to the document.
    HRESULT FindOrRegisterAndLockDocument([in] VSRDTFLAGS grfRDTLockType, [in] LPCOLESTR pszMkDocument, [in] IVsHierarchy *pHierPreferred, [in] VSITEMID itemidPreferred,
        [in] IUnknown *punkDocData, [out] IVsHierarchy **ppHierActual, [out] VSITEMID *pitemidActual, [out] IUnknown **ppunkDocDataActual, [out] VSCOOKIE *pdwCookie);
 }

//----------------------------------------------------------------------------
// IVsRunningDocTableEvents4
//----------------------------------------------------------------------------
// The event is called before a document is locked in RDT for the very first time. 
// The event can be used for example by SCCI to download a document immediately, 
// while the rest of the project content is being retrieved asynchronously.
[
    uuid(uuid_IVsRunningDocTableEvents4),
    version(1.0)
]
interface IVsRunningDocTableEvents4 : IUnknown
{
    HRESULT OnBeforeFirstDocumentLock([in] IVsHierarchy* pHier, [in] VSITEMID itemid, [in] LPCOLESTR pszMkDocument);
    HRESULT OnAfterSaveAll(void); // Fired after SaveAll command is executed. Parties that have user state not managed via a document in the RDT can use this event to know to save their state.
    HRESULT OnAfterLastDocumentUnlock([in] IVsHierarchy* pHier, [in] VSITEMID itemid, [in] LPCOLESTR pszMkDocument, [in] BOOL fClosedWithoutSaving);
};


cpp_quote("extern const __declspec(selectany) GUID UICONTEXT_NotBuildingAndNotDebugging =  { 0x48ea4a80, 0xf14e, 0x4107, { 0x88, 0xfa, 0x8d, 0x0, 0x16, 0xf3, 0xb, 0x9c } };")
cpp_quote("extern const __declspec(selectany) GUID UICONTEXT_SolutionOrProjectUpgrading =  { 0xef4f870b, 0x7b85, 0x4f29, { 0x9d, 0x15, 0xce, 0x1a, 0xbf, 0xbe, 0x73, 0x3b } };")
cpp_quote("extern const __declspec(selectany) GUID UICONTEXT_DataSourceWindowSupported =   { 0x95c314c4, 0x660b, 0x4627, { 0x9f, 0x82, 0x1b, 0xaf, 0x1c, 0x76, 0x4b, 0xbf } };")
cpp_quote("extern const __declspec(selectany) GUID UICONTEXT_DataSourceWindowAutoVisible = { 0x2e78870d, 0xac7c, 0x4460, { 0xa4, 0xa1, 0x3f, 0xe3, 0x7d, 0x00, 0xef, 0x81 } };")
cpp_quote("extern const __declspec(selectany) GUID UICONTEXT_ToolboxInitialized =          { 0xdc5db425, 0xf0fd, 0x4403, { 0x96, 0xa1, 0xf4, 0x75, 0xcd, 0xba, 0x9e, 0xe0 } };")
cpp_quote("extern const __declspec(selectany) GUID UICONTEXT_SolutionExistsAndNotBuildingAndNotDebugging =  { 0xd0e4deec, 0x1b53, 0x4cda, { 0x85, 0x59, 0xd4, 0x54, 0x58, 0x3a, 0xd2, 0x3b } };")

[
    uuid(uuid_IVsToolboxDataProviderRegistry),
    version(1.0)
]
interface IVsToolboxDataProviderRegistry : IUnknown
{
    HRESULT RegisterDataProvider  ([in]IVsToolboxDataProvider* pDP, [out, retval]VSCOOKIE* pdwProvider);
    HRESULT UnregisterDataProvider([in]VSCOOKIE dwProvider);
};

[
    uuid(uuid_SVsToolboxDataProviderRegistry)
]
interface SVsToolboxDataProviderRegistry : IUnknown
{
}
cpp_quote("#define SID_SVsToolboxDataProviderRegistry IID_SVsToolboxDataProviderRegistry")


[
    uuid(uuid_IVsFontAndColorCacheManager),
    version(1.0)
]
interface IVsFontAndColorCacheManager : IUnknown
{
    HRESULT CheckCache    ([in] REFGUID rguidCategory, [out] BOOL *pfHasData);
    HRESULT ClearCache    ([in] REFGUID rguidCategory);
    HRESULT RefreshCache  ([in] REFGUID rguidCategory);
    HRESULT CheckCacheable([in] REFGUID rguidCategory, [out] BOOL *pfCacheable);
    HRESULT ClearAllCaches();
};

[
    uuid(uuid_SVsFontAndColorCacheManager)
]
interface SVsFontAndColorCacheManager : IUnknown
{
}
cpp_quote("#define SID_SVsFontAndColorCacheManager IID_SVsFontAndColorCacheManager")


// IVSUpgradeLogger
//
// Upgrade logger used by implementers of IVSProjectUpgradeViaFactory to report errors and informational
// messages.
enum __VSUL_ERRORLEVEL
{
    VSUL_INFORMATIONAL = 0x00000000
    ,VSUL_WARNING       = 0x00000001
    ,VSUL_ERROR         = 0x00000002
    ,VSUL_STATUSMSG     = 0x00000003
    ,VSUL_PROJECT_HYPERLINK = 0x00000004
};
typedef DWORD VSUL_ERRORLEVEL;

[
    uuid(uuid_IVsUpgradeLogger),
    version(1.0),
    pointer_default(unique)
]
interface IVsUpgradeLogger : IUnknown
{
    HRESULT LogMessage(
        [in] VSUL_ERRORLEVEL   ErrorLevel 
        ,[in] BSTR              bstrProject
        ,[in] BSTR              bstrSource
        ,[in] BSTR              bstrDescription
        );
    HRESULT Flush();
};

// declare the service type for interop
[uuid(uuid_SVsUpgradeLogger)]
interface SVsUpgradeLogger : IUnknown {}

cpp_quote("#define SID_SVsUpgradeLogger IID_SVsUpgradeLogger")
cpp_quote("#define SID_IVsUpgradeLogger IID_SVsUpgradeLogger")    // Obsolete -- use SID_SVsUpgradeLogger instead


// IVsFileUpgrade
//
// This interface should be used to do any kind of file upgrade that needs to happen as part of
// project upgrade.
//
// Implementation detail:  These methods will NOT be called from IVsProjectUpgradeViaFactory.
// For source control reasons, the project will delay calling these until the project is fully
// opened.  The prject should iterate through the files in the project, identify those files
// requiring an upgrade, check those files out of source code control, then upgrade each one.
//
[
    uuid(uuid_IVsFileUpgrade),
    version(1.0),
    pointer_default(unique)
]
interface IVsFileUpgrade : IUnknown
{
    HRESULT UpgradeFile(
        [in]  BSTR               bstrProjectName
        ,[in]  BSTR               bstrFileName
        ,[in]  BOOL               bNoBackup
        ,[in]  IVsUpgradeLogger * pLogger
        ,[out] BOOL             * pUpgradeRequired
        );
    HRESULT UpgradeFile_CheckOnly(
        [in]  BSTR               bstrProjectName
        ,[in]  BSTR               bstrFileName
        ,[in]  BOOL               bNoBackup
        ,[in]  IVsUpgradeLogger * pLogger
        ,[out] BOOL             * pUpgradeRequired
        );
};


// IVsProjectUpgradeViaFactory
//
// This interface is implemented by the project factory (or at least QI’able from IVsProjectFactory).
// IVSProjectUpgradeViaFactory is called by the solution, before the project is opened.  This provides
// a level of abstraction and keeps knowledge of previous file formats out of the project implementation.
//
// This new interface is optional; but recommended for all Microsoft implemented projects.  Third party
// projects should be encouraged to support the new upgrade method.  This is the only mechanism to support
// copy upgrade.
//
// IVSProjectUpgrade will be called whether upgrade via factory is implemented or called.  This approach
// allows IVSProjectUpgradeViaFactory to implement the copy and project only portions of the upgrade, and
// delegate the rest of the work to be done in-place (at possibly the new location). 
//
// All implementations that return either PUVFF_SXSBACKUP or PUVFF_COPYBACKUP should also return
// PUVFF_BACKUPSUPPORTED.  This allows aggregated project systems to AND together capabilites.  VS will
// interpret a value of 0x80 as being 'multiple projects support mutually exclusive backup types'.  This
// allows us to differentiate between that and 'no backup options available'.
//
// By default, copy backup occurs in a subfolder of the solution.  There are times where this is undesireable.
// In those cases UpgradeProject_CheckOnly can return PUVFF_USE_ALT_BACKUP_LOCATION.  This will default to
// using a subfolder under the user's default project location folder.  This alternate location should be 
// avoided if possible, as it presents greater limitations regarding backup filename length.
//
enum __VSPPROJECTUPGRADEVIAFACTORYFLAGS
{
     PUVFF_SXSBACKUP      = 0x00000020
    ,PUVFF_COPYBACKUP     = 0x00000040  
    ,PUVFF_BACKUPSUPPORTED = 0x00000080  
    ,PUVFF_USE_ALT_BACKUP_LOCATION = 0x00000100  
};
typedef DWORD VSPUVF_FLAGS;

[
    uuid(uuid_IVsProjectUpgradeViaFactory),
    version(1.0),
    pointer_default(unique)
]
interface IVsProjectUpgradeViaFactory : IUnknown
{
    HRESULT UpgradeProject(
        [in]  BSTR               bstrFileName
        ,[in]  VSPUVF_FLAGS       fUpgradeFlag                          //only one may be specified
        ,[in]  BSTR               bstrCopyLocation                      //location of the copy upgrade OR the backup copy location
        ,[out] BSTR *             pbstrUpgradedFullyQualifiedFileName   //copy upgrade will have a different path - others may change the project name
        ,[in]  IVsUpgradeLogger * pLogger
        ,[out] BOOL             * pUpgradeRequired
        ,[out] GUID             * pguidNewProjectFactory                //If a different prj factory should be used to create the upgraded proj, the guid should be returned here
        );
    HRESULT UpgradeProject_CheckOnly(
        [in]  BSTR                bstrFileName
        ,[in]  IVsUpgradeLogger * pLogger
        ,[out] BOOL             * pUpgradeRequired
        ,[out] GUID             * pguidNewProjectFactory                //If a different prj factory should be used to create the upgraded proj, the guid should be returned here
        ,[out] VSPUVF_FLAGS     * pUpgradeProjectCapabilityFlags        //Some kinds of projects may support different backup styles
        );
    HRESULT GetSccInfo(
        [in]  BSTR               bstrProjectFileName
        ,[out] BSTR*              pbstrSccProjectName
        ,[out] BSTR*              pbstrSccAuxPath
        ,[out] BSTR*              pbstrSccLocalPath
        ,[out] BSTR*              pbstrProvider);
};

//---------------------------------------------------------------------------
// IVsProjectUpgradeViaFactory2
//
// The new IVsProjectUpgradeViaFactory architecture requires two calls: the first call
// to check the project to see if upgrade is required, the second to actually perform
// the upgrade.  In some cases, this requires the factory to open the project file
// twice.  For performance reasons, it may be desirable to cache the 'open' required in
// the UpgradeProject_CheckOnly.  Then when no upgrade is required, a portion of the
// 'open' has already taken place and the project will be able to finish opening faster.
// This leaves an opportunity for the cached 'open' to be orphaned: cancelled upgrade.
// 
// Any project system that caches information as part of UpgradeProject_CheckOnly should
// implement this interface to clean up cached items associated with the given project
// file.
//
// NOTE: This method may be called even if the project does NOT require upgrade.  This
// is because a different project in the solution MAY require upgrade, thus the
// possibility of a cancelled upgrade exists even though the specific project does not
// require upgrade.
[
    uuid(uuid_IVsProjectUpgradeViaFactory2),
    version(1.0),
    pointer_default(unique)
]
interface IVsProjectUpgradeViaFactory2 : IUnknown
{
    HRESULT OnUpgradeProjectCancelled(
        [in]  BSTR               bstrFileName
        );
};

//---------------------------------------------------------------------------
// IVsSolutionEventsProjectUpgrade
//
// This event set can be advised for via IVsSolution::AdviseSolutionEvents.
// Third Parties that add/manage items inside projects they don't implement may need to participate
// in the Project Upgrade process. This event is fired after the project implementation has completed
// its upgrade operations and the project is created. It will fire after OnAfterOpenSolution,
// OnAfterOpenProject, or OnAfterLoadProject events depending on the scenario.
// Third parties should carefully manage the file back process. In the case of a side-by-side backup
// (PUVFF_SXSBACKUP) where backup files are placed  along side existing files with a ".old" file
// extension, then existing backup files that are older than stUpgradeTime can be assumed to be stale
// files that can be overwritten.
//---------------------------------------------------------------------------
[
    uuid(uuid_IVsSolutionEventsProjectUpgrade),
    version(1.0),
    pointer_default(unique)
]
interface IVsSolutionEventsProjectUpgrade : IUnknown
{
    HRESULT OnAfterUpgradeProject([in] IVsHierarchy *pHierarchy, // project being upgraded
        [in] VSPUVF_FLAGS fUpgradeFlag,                          // PUVFF_COPYUPGRADE or PUVFF_SXSBACKUP or PUVFF_COPYBACKUP (only one will be specified)
        [in] BSTR bstrCopyLocation,                              // location of the copy upgrade (PUVFF_COPYUPGRADE) or the backup copy location (PUVFF_COPYBACKUP)
        [in] SYSTEMTIME stUpgradeTime,                           // time upgrade operation began (used to coordinate backup file writing)
        [in] IVsUpgradeLogger *pLogger);                         // upgrade log that messages can be logged to
};

//---------------------------------------------------------------------------
// IVsActivityLog
//
// Implemented by the Environment.
// Used by parties that want to add events to the IDE Activity Log. This log
// is active when the shell receives the /log switch, or when an environment
// variable ("VSLogActivity") is set. The log is intended to record high
// level information for the purpose of quickly tracking down and routing 
// problems. This is not a tracing tool, and only key events should be logged.
// When logging is turned on, the implementation will log an event in response
// to each method on this interface. When logging is not turned on, the
// implementation for each method is a fast no-op.
//---------------------------------------------------------------------------

typedef enum __tagACTIVITYLOG_ENTRYTYPE
{
    ALE_ERROR       = 1,  // Indicates a severe error, failure of major shell functionality
    ALE_WARNING     = 2,  // Indicates a warning or ignorable error
    ALE_INFORMATION = 3   // Indicates information that is not an error (e.g. SKU information)
} __ACTIVITYLOG_ENTRYTYPE;

typedef DWORD ACTIVITYLOG_ENTRYTYPE;

[
    uuid(uuid_IVsActivityLog),
    version(1.0),
    pointer_default(unique)
]
interface IVsActivityLog : IUnknown
{
    HRESULT LogEntry(
        [in] ACTIVITYLOG_ENTRYTYPE actType,  // type of log entry
        [in] LPCOLESTR pszSource,            // name of the package making the call
        [in] LPCOLESTR pszDescription);      // the text of the event

    HRESULT LogEntryGuid(
        [in] ACTIVITYLOG_ENTRYTYPE actType,  // type of log entry
        [in] LPCOLESTR pszSource,            // name of the package making the call
        [in] LPCOLESTR pszDescription,       // the text of the event
        [in] GUID guid);                     // a guid to store in the event record

    HRESULT LogEntryHr(
        [in] ACTIVITYLOG_ENTRYTYPE actType,  // type of log entry
        [in] LPCOLESTR pszSource,            // name of the package making the call
        [in] LPCOLESTR pszDescription,       // the text of the event
        [in] HRESULT hr);                    // an HRESULT to store in the event record

    HRESULT LogEntryGuidHr(
        [in] ACTIVITYLOG_ENTRYTYPE actType,  // type of log entry
        [in] LPCOLESTR pszSource,            // name of the package making the call
        [in] LPCOLESTR pszDescription,       // the text of the event
        [in] GUID guid,                      // a guid to store in the event record
        [in] HRESULT hr);                    // an HRESULT to store in the event record

    HRESULT LogEntryPath(
        [in] ACTIVITYLOG_ENTRYTYPE actType,  // type of log entry
        [in] LPCOLESTR pszSource,            // name of the package making the call
        [in] LPCOLESTR pszDescription,       // the text of the event
        [in] LPCOLESTR pszPath);             // a full file path to store in the event record

    HRESULT LogEntryGuidPath(
        [in] ACTIVITYLOG_ENTRYTYPE actType,  // type of log entry
        [in] LPCOLESTR pszSource,            // name of the package making the call
        [in] LPCOLESTR pszDescription,       // the text of the event
        [in] GUID guid,                      // a guid to store in the event record
        [in] LPCOLESTR pszPath);             // a full file path to store in the event record

    HRESULT LogEntryHrPath(
        [in] ACTIVITYLOG_ENTRYTYPE actType,  // type of log entry
        [in] LPCOLESTR pszSource,            // name of the package making the call
        [in] LPCOLESTR pszDescription,       // the text of the event
        [in] HRESULT hr,                     // an HRESULT to store in the event record
        [in] LPCOLESTR pszPath);             // a full file path to store in the event record

    HRESULT LogEntryGuidHrPath(
        [in] ACTIVITYLOG_ENTRYTYPE actType,  // type of log entry
        [in] LPCOLESTR pszSource,            // name of the package making the call
        [in] LPCOLESTR pszDescription,       // the text of the event
        [in] GUID guid,                      // a guid to store in the event record
        [in] HRESULT hr,                     // an HRESULT to store in the event record
        [in] LPCOLESTR pszPath);             // a full file path to store in the event record
}

// declare the service type for interop
[uuid(uuid_SVsActivityLog)]
interface SVsActivityLog : IUnknown {}

cpp_quote("#define SID_SVsActivityLog IID_SVsActivityLog")

//---------------------------------------------------------------------------
// IVsPersistDocData3
//---------------------------------------------------------------------------
[
    uuid(uuid_IVsPersistDocData3),
    version(1.0),
    pointer_default(unique)
]
interface IVsPersistDocData3 : IUnknown
{
    // HandsOffDocDataStorage tells the DocData object to release any hold it has on its storage (e.g. release and file system locks on its file).
    // Following a call to HandsOffDocDataStorage either the document is closed (as result of reloading a changed project or solution file),
    // or the document is reloaded via a call to IVsPersistDocData->ReloadDocData or IVsPersistHierarchyItem2->ReloadItem if the storage 
    // of the DocData object has been changed (e.g. a new version of the file retrieved from Source Code Control)
    // or HandsOnDocDataStorage will be called if the storage is not modified since the call to HandsOffDocDataStorage or if the reload is not 
    // safe because the in-memory DocData is dirty.
    // While the DocData object is in HandsOff mode, most calls to the DocData object are expected to fail.
    // DocData functions that are expected to work in HandsOff mode are IsDocDataReloadable and IsDocDataDirty; 
    // they will be used to determine whether DocData can be safely reloaded after the file was modified on disk.
    HRESULT HandsOffDocDataStorage(void);
    HRESULT HandsOnDocDataStorage(void);
};


// Enable a window frame to send notifications to anyone who wants to be notified of IVsWindowFrameNotify* events
[
    uuid(uuid_IVsWindowFrame2),
    version(1.0),
    pointer_default(unique)
]
interface IVsWindowFrame2 : IUnknown
{
    // This api will detect IVsWindowFrameNotify, IVsWindowFrameNotify2, and IVsWindowFrameNotify3
    HRESULT Advise([in] IVsWindowFrameNotify *pNotify, [out] VSCOOKIE   *pdwCookie);
    HRESULT Unadvise([in] VSCOOKIE dwCookie);

    // ActivateOwnerDockedWindow gives focus to a child IVsWindowFrame and ensures that its Selection
    // is active. This method is only intended to be used by a parent container for an OwnerDocked 
    // window (see VSFPROPID_ParentHwnd/VSFPROPID_ParentFrame) in order to forward focus in to the
    // currently active child “OwnerDocked” window. For normal, top-level document and tool windows
    // IVsWindowFrame::Show should be called to activate the window. 
    HRESULT ActivateOwnerDockedWindow(void);
}


// extend the property page interface to be able to retrieve properties on the page
enum __VSPPPID
{
    VSPPPID_FIRST     = 1,
    VSPPPID_PAGENAME  = 1,
    VSPPPID_LAST      = 1
};

typedef DWORD VSPPPID;

[
    uuid(uuid_IVsPropertyPage2),
    version(1.0),
    pointer_default(unique)
]
interface IVsPropertyPage2 : IUnknown
{
    HRESULT GetProperty([in] VSPPPID propid, [out] VARIANT *pvar);
    HRESULT SetProperty([in] VSPPPID propid, [in]  VARIANT   var);
}







enum __FRAMESHOW2
{/*
    FRAMESHOW_Hidden                = 0,    // obsolete, use WinHidden
    FRAMESHOW_WinHidden         = 0,    // window (tabbed or otherwise) is hidden
    FRAMESHOW_WinShown          = 1,    // a non-tabbed window is made visible
    FRAMESHOW_TabActivated      = 2,    // a tabbed window is activated (made visible)
    FRAMESHOW_TabDeactivated        = 3,    // a tabbed window is deactivated
    FRAMESHOW_WinRestored           = 4,    // window is restored to normal state
    FRAMESHOW_WinMinimized      = 5,    // window is minimized
    FRAMESHOW_WinMaximized      = 6,    // window is maximized
    FRAMESHOW_WinClosed         = 7,    // window is closed and persisted
    FRAMESHOW_DestroyMultInst       = 8,    // multi instance toolwindow destroyed
    FRAMESHOW_AutoHideSlideBegin    = 9,    // autohidden window is about to slide into view
    */
    FRAMESHOW_BeforeWinHidden         = 10,    // Before the Hide of single instance toolwindows
    FRAMESHOW_AutoHideSlideEnd    = 11        // autohidden window is finished its slide into view
};
typedef BOOL FRAMESHOW2;


// this interface replaces the previous versions and extends OnMove and OnSize so that an additional query
// to retrieve the size and position are not necessary
[
    uuid(uuid_IVsWindowFrameNotify3),
    version(1.0),
    pointer_default(unique)
]
interface IVsWindowFrameNotify3 : IUnknown
{
    HRESULT OnShow([in] FRAMESHOW2 fShow);
    HRESULT OnMove([in] int x, [in] int y, [in] int w, [in] int h);
    HRESULT OnSize([in] int x, [in] int y, [in] int w, [in] int h);
    HRESULT OnDockableChange([in] BOOL fDockable, [in] int x, [in] int y, [in] int w, [in] int h);
    HRESULT OnClose([in, out]   FRAMECLOSE *pgrfSaveOptions);
}



//----------------------------------------------------------------------------
// IVsPackageDynamicToolOwnerEx
//----------------------------------------------------------------------------
// In order for a package to successfully use this interface the package must
// be registered with a "SupportsDynamicToolOwner" key.  This enables tool windows
// that are visible in a window layout persistance to be hidden by the owning package.  
// If the tool is persisted as visible and this key exists on its package regstration,
// its package will be loaded so that this call can be made.  Subsequent sessions
// will not cause the package to be loaded if the tool was not shown again in
// the previous session because the window layout will have been persisted with
// it being hidden.  Without the "SupportsDynamicToolOwner" registration, the tool
// may be initialy visible due to the delay loading system.
// 
// This primerily affects tools that have the CTW_fForceCreate flag that causes them
// to be loaded by the shell on startup or during mode switches.  Secondarily this
// also affects tools that have dynamic visibility via UI context.
//
// This interface extends the previous version IVsPackageDynamicToolOwner by including
// a parameter for the multi instance ID.  The Ex version can control which or how
// many instances may be shown where the non Ex version is only capable of asking
// if that kind of tool may be shown regardless of the instance ID.
[
    uuid(uuid_IVsPackageDynamicToolOwnerEx),
    version(1.0),
    pointer_default(unique)
]
interface IVsPackageDynamicToolOwnerEx : IUnknown
{
    // This method allows   the Package to use dynamic logic to control
    // whether the ToolWindow   should be shown or hidden. This method is
    // called   by the Environment when the user switches which window view
    //set   (or mode) is active, e.g. Design, Debugging, FullScreen, etc.
    HRESULT QueryShowTool([in] REFGUID rguidPersistenceSlot, [in] DWORD dwID, [out] BOOL *pfShowTool);
}


//---------------------------------------------------------------------------
// IVsContextualIntellisenseFilter
//---------------------------------------------------------------------------
[
    uuid(uuid_IVsContextualIntellisenseFilter),
    version(1.0),
    pointer_default(unique)
]
interface IVsContextualIntellisenseFilter : IUnknown
{
    HRESULT Initialize([in] IVsHierarchy* pHierarchy);
    HRESULT IsTypeVisible([in] LPCOLESTR szTypeName, [out] BOOL* pfVisible);
    HRESULT IsMemberVisible([in] LPCOLESTR szMemberSignature, [out] BOOL* pfVisible);
    HRESULT Close();
}


//---------------------------------------------------------------------------
// IVsContextualIntellisenseFilterProvider
//---------------------------------------------------------------------------
[
    uuid(uuid_IVsContextualIntellisenseFilterProvider),
    version(1.0),
    pointer_default(unique)
]
interface IVsContextualIntellisenseFilterProvider : IUnknown
{
    HRESULT GetFilter([in] IVsHierarchy* pHierarchy, [out] IVsContextualIntellisenseFilter** ppFilter);
}

// Optionally implemented by toolbox users (IVsToolboxUser) and QI'd for by the toolbox.  Only the
// currently active toolbox user will recieve these notifications.
[
    uuid(uuid_IVsToolboxActiveUserHook),
    version(1.0),
    pointer_default(unique)
]
interface IVsToolboxActiveUserHook : IUnknown
{
    // This method is called when an item is copied or dragged from the clipboard.
    HRESULT InterceptDataObject([in] IDataObject *pIn, [out] IDataObject **ppOut);

    // This method is called whenever the selected toolbox item changes.
    HRESULT ToolboxSelectionChanged([in] IDataObject *pSelected);
}


//-------------------------------------------------------------------------------------------------
// IVsDefaultToolboxTabState
//
// This is optionally implemented by implementors of IVsToolboxUser.  It allows a designer to
// specify the default state of any toolbox tabs it cares about.  The first time* that designer is
// instantiated, GetDefaultTabExpansion will be called for each visible tab in the toolbox.  On
// subsequent instantiations, the most recent tab state for that designer will be cached and
// restored (so that user changes are not lost).
//
// *"first time" means the first time ever or the first time after a toolbox reset -- not the first
// time during a particular IDE session.
//-------------------------------------------------------------------------------------------------
[
    uuid(uuid_IVsDefaultToolboxTabState),
    version(1.0),
    pointer_default(unique)
]
interface IVsDefaultToolboxTabState : IUnknown
{
    // Gets the default state of a given tab.  The tab is specified by unique ID -- see IVsToolbox3
    // for more methods dealing with unique IDs.  If this method fails, the toolbox sets the tab
    // state according to its own internal logic.  Otherwise, the state is determined by the value
    // of *pfExpanded.
    HRESULT GetDefaultTabExpansion([in] LPCOLESTR pszTabID, [out] BOOL* pfExpanded);
}


enum __VSPROFILEPATHRESOLVERFLAGS
{
    VSPPR_None               = 0x00000000, // Use the standard behavior
    VSPPR_OnlyForProfiles    = 0x00000001  // the IVsPathResolution code will just copy the inparam to the 
    //outparam with no conversion if we're not in the middle of reading or writing a vssettings file.  
    //(This allows automation interfaces to use the same input/output as previous versions when called 
    //from automation code).
};
typedef DWORD VSPROFILEPATHRESOLVERFLAGS;


//---------------------------------------------------------------------------
// IVsPathVariableResolver
//---------------------------------------------------------------------------
// Implemented by the IDE.
// This interface allows filepaths to be encoded/decoded to allow settings to be 
// stored in a machine independent format with the vssettings files.
//
// Available via QueryService(SVsPathVariableResolver)
//
[
    uuid(uuid_IVsPathVariableResolver),
    version(1.0),
    pointer_default(unique)
]
interface IVsPathVariableResolver : IUnknown
{
    //The code for EncodePath() will look at strPath to see if it begins with one of the following paths:
    //    - our install directory
    //    - user app data
    //    - (possibly others in the future)
    //If the code finds a match, it will replace it with:
    //    - %VS_INSTALL_DIRECTORY%
    //    - %USER_APPDATA%
    //    - (possibly others in the future)
    HRESULT ResolvePath([in] LPCOLESTR strEncodedPath, [in] VSPROFILEPATHRESOLVERFLAGS dwFlags, [out] BSTR *pbstrPath);
    HRESULT EncodePath([in] LPCOLESTR strPath, [in] VSPROFILEPATHRESOLVERFLAGS dwFlags, [out] BSTR *pbstrEncodedPath);
};

// declare the service type for interop
[uuid(uuid_SVsPathVariableResolver)]
interface SVsPathVariableResolver : IUnknown {}

cpp_quote("#define SID_SVsPathVariableResolver IID_SVsPathVariableResolver")


//---------------------------------------------------------------------------
// interface IVsProjectFactory2
//---------------------------------------------------------------------------

enum __VSASYNCHOPENPROJECTTYPE
{
    AOPT_SYNCHRONOUS    = 0x0000,   // None of the flags are set - the project can be opened only synchronously 
    AOPT_ASYNCHRONOUS   = 0x0001,   // The project system supports the special "loading" state and 
    // needs only the project file to be successfully opened
};
typedef DWORD VSASYNCHOPENPROJECTTYPE;

[
    uuid(uuid_IVsProjectFactory2),
    version(1.0)
]
interface IVsProjectFactory2 : IUnknown
{
    // Returns the type of an asycnhronous open that the project supports. 
    // If the interface or the method is not implemented 
    // then the project should be assumed to be of AOPT_SYNCHRONOUS type
    HRESULT GetAsynchOpenProjectType
        (
        [out, retval] VSASYNCHOPENPROJECTTYPE* pType
        );
};

//---------------------------------------------------------------------------
// interface IVsAsynchOpenFromSccProjectEvents
//---------------------------------------------------------------------------
// The interface can be implemented by projects that support asynchronous open.
// Whether a project supports this mode or not can be detected by calling 
// IVsProjectFactory2::GetAsynchOpenProjectType. 
// The interface allows a project to configure asynchronous downloading 
// of its content and receive events while the content is being retrieved.
[
    uuid(uuid_IVsAsynchOpenFromSccProjectEvents),
    version(1.0)
]
interface IVsAsynchOpenFromSccProjectEvents : IUnknown
{
    // Called after one or more have been downloaded for a project.
    HRESULT OnFilesDownloaded
        (
        [in] int cFiles,                                        // Number of files: should be > 0
        [in, size_is(cFiles)] const LPCOLESTR rgpszFullPaths[]  // Array of paths. Cannot be NULL
    );

    // Called when all project content has been downloaded.
    HRESULT OnLoadComplete();

    // Called when downloading of project content failed.
    HRESULT OnLoadFailed();
}

//---------------------------------------------------------------------------
// interface IVsAsynchOpenFromScc
//---------------------------------------------------------------------------
[
    uuid(uuid_IVsAsynchOpenFromScc),
    version(1.0)
]
// The interface allows to manage asynchronous opening of projects from Source Control.
interface IVsAsynchOpenFromScc : IUnknown
{
    // Allows to determine whether the given project must be loaded asynchronously.
    HRESULT LoadProjectAsynchronously
        (
        [in] LPCOLESTR lpszProjectPath,
        [out] BOOL *pReturnValue
        );

    // When a solution is being opened asynchronously, calling this method allows to load the specified project.
    // The project's content is still going to be retrieved asynchronously.
    HRESULT LoadProject([in] LPCOLESTR lpszProjectPath);
    // Allows to find out whether the content of the given hierarchy 
    // is currently being asynchronously retrieved from SourceControl
    HRESULT IsLoadingContent
        (
        [in] IVsHierarchy *pHierarchy,  // The solution or project hierarchy to check the current mode for
        [out] BOOL *pfIsLoading     // TRUE if the hierarchy's content is still being retrieved from SourceControl repository
        );
};

//----------------------------------------------------------------------------
// IVsHierarchyDeleteHandler2
//----------------------------------------------------------------------------
// This interface is optional and is retrieved via QI from IVsHierarchy.  This interface extends
// IVsHierarchyDeleteHandler and need only be supported if the hierarchy wants to issue its own
// deletion prompt in order to give more/different information than the standard shell message.
//
// The following are the 2 major scenarios and behavior:
//
// 1) If all the selected items belong to one project: the shell builds the "reduced" list of items,
// then calls ShowSpecificDeleteRemoveMessage (if the hierarchy supports IVsHierarchyDeleteHandler2).
// The project then shows its own message if it so desires, and returns whether it wants the standard
// message shown. If the project wants the standard message, it gets shown, then the shell calls
// IVsDeleteHierarchyHandler::DeleteItem as usual. The project must show the correct message UI--if
// dwDelItemOps == DELITEMOP_DeleteFromStorage | DELITEMOP_RemoveFromProject, then the message must
// contain buttons for Remove and Delete--and the selected operation must be returned to the shell.
// If the project returns TRUE in pfShowStandardMessage, any value in pdwDelItemOp will be ignored.
//
// 2) If the selected items belong to multiple projects: the shell build the "reduced" list of items, then
// shows the standard message for multiple project selection, then calls ShowMultiSelDeleteOrRemoveMessage
// on any hierarchy that supports IVsHierarchyDeleteHandler2.  At this point, the operation has already been
// chosen (whether Delete or Remove) and the projects are simply confirming the action.  If the projects
// allow the operation to continue (by returning FALSE in the pfCancelOperation parameter), the shell then
// calls IVsDeleteHierarchyHandler::DeleteItem as usual.

[
    uuid(uuid_IVsHierarchyDeleteHandler2),
    version(1.0),
    pointer_default(unique)
]
interface IVsHierarchyDeleteHandler2 : IUnknown
{
    HRESULT ShowSpecificDeleteRemoveMessage(
        [in] DWORD dwDelItemOps,                        // can be DELITEMOP_DeleteFromStorage | DELITEMOP_RemoveFromProject
        [in] ULONG cDelItems,                           // number of items in rgDelItems
        [in, size_is(cDelItems)] VSITEMID rgDelItems[], // array of itemids being deleted from the project
        [out] BOOL *pfShowStandardMessage,              // set to TRUE to cause shell to ignore pdwDelItemOp and show standard message, else FALSE
        [out] VSDELETEITEMOPERATION *pdwDelItemOp);     // return DELITEMOP_DeleteFromStorage or DELITEMOP_RemoveFromProject if delete/remove allowed
    HRESULT ShowMultiSelDeleteOrRemoveMessage(
        [in] VSDELETEITEMOPERATION dwDelItemOp,         // can be DELITEMOP_DeleteFromStorage or DELITEMOP_RemoveFromProject
        [in] ULONG cDelItems,                           // number of items in rgDelItems
        [in, size_is(cDelItems)] VSITEMID rgDelItems[], // array of itemids being deleted from the project
        [out] BOOL *pfCancelOperation);                 // set to TRUE to cause shell to cancel entire delete/remove operation, else FALSE
}
// Implemented by the environment (service SID_SVsToolbox).  Provides additional functionality
// beyond IVsToolbox[2] defined in vsshell.idl.
[
    uuid(uuid_IVsToolbox3),
    version(1.0),
    pointer_default(unique)
]
interface IVsToolbox3 : IUnknown
{
    // Sets a unique ID for the given toolbox tab.  Tab names are already required to be unique,
    // but may vary based on locale (because they should be localized strings).  The ID must be
    // locale-invariant.  It is recommended that you use the English name of your tab as the tab
    // ID, if possible.
    HRESULT SetIDOfTab([in] LPCOLESTR lpszTabName, [in] LPCOLESTR lpszTabID);

    // Retrieves the unique ID of the given toolbox tab.
    HRESULT GetIDOfTab([in] LPCOLESTR lpszTabName, [out] BSTR *pbstrTabID);

    // Given a tab ID, returns the localized name.
    HRESULT GetTabOfID([in] LPCOLESTR lpszTabID, [out] BSTR *pbstrTabName);

    // Returns the unique ID of the "General" tab, so packages that want to select that tab don't
    // have to hard-code the ID or attempt to look it up in a resource table.
    HRESULT GetGeneralTabID([out] BSTR* pbstrTabID);

    // Returns the unique ID for the given item.  If the item is not found in the toolbox, an error
    // is returned.  If the item is found but has no ID, *pbstrID is set to NULL.
    HRESULT GetItemID([in] IDataObject* pDO, [out] BSTR* pbstrID);

    // Returns the name of the given item.  If the item is not found in the toolbox, an error is
    // returned.
    HRESULT GetItemDisplayName([in] IDataObject* pDO, [out] BSTR* pbstrName);

    // Returns the time at which the toolbox contents were last modified in any way.  This
    // includes reordering and renaming items & tabs in addition to adding and removing them.
    HRESULT GetLastModifiedTime([out] SYSTEMTIME *pst);
};


// Property names used by GetItemTipInfo() to populate the property bag.
const LPCOLESTR lpszToolboxTipFieldName          = L"Name";
const LPCOLESTR lpszToolboxTipFieldVersion       = L"Version";
const LPCOLESTR lpszToolboxTipFieldCompany       = L"Company";
const LPCOLESTR lpszToolboxTipFieldComponentType = L"ComponentType";
const LPCOLESTR lpszToolboxTipFieldDescription   = L"Description";

// Implemented by data providers and queried for by the toolbox.
[
    uuid(uuid_IVsToolboxDataProvider2),
    version(1.0),
    pointer_default(unique)
]
interface IVsToolboxDataProvider2 : IUnknown
{
    // Returns the GUID of the package to which this data provider belongs.
    HRESULT GetPackageGUID([out] GUID* pguidPkg);

    // Returns the unique ID of this data provider.  This is an arbitrary GUID of your choice
    // (i.e., it does not need to be used anywhere else).
    HRESULT GetUniqueID([out] GUID* pguidID);

    // Returns the human-readable (localized) name of this provider.
    HRESULT GetDisplayName([out] BSTR* pbstrName);

    // The data provider can set the content of an item's tip window by calling pStrings->Write().
    // The following strings are recognized:
    //     "Name", which is displayed in bold.
    //     "Version", which should be a series of numbers separated by periods (e.g. "1.2.34").
    //     "Company".
    //     "ComponentType", which should be something like "Managed .NET Control" or "COM Component".
    //     "Description", which should be one or two sentences, on the order of 100 characters.
    // Any, all, or none of these strings may be supplied.  lpszCurrentName is the current display
    // name of the item as it exists on the toolbox (which may be different from its original name
    // if the user has renamed it).  The provider may want to set the "Name" field to a different
    // value of its choosing, but in most cases "Name" should be set to lpszCurrentName.
    HRESULT GetItemTipInfo([in] IDataObject *pDO, [in] LPCOLESTR lpszCurrentName, [in] IPropertyBag *pStrings);

    // This string contains any extra information needed to reconstruct the item on import from a
    // profile.  The data must be portable and non-localized so that it can be transferred between
    // instances of VS in a profile.  The data does not need to be sufficient to install the
    // control on the system, but it should be sufficient to identify the control and add it to the
    // toolbox if it is already installed on the system.
    HRESULT GetProfileData([in] IDataObject *pDO, [out] BSTR *pbstrData);

    // Given a data object, returns a unique ID.  This should be a relatively short string that can
    // be used to identify the item in a locale-independent manner.  If possible, you should use
    // the English name of the item as the unique ID.
    HRESULT GetItemID([in] IDataObject *pDO, [out] BSTR *pbstrID);

    // Recreates an item that was stored in a profile.  Each data provider should be able to
    // recreate any type of item it knows about.  If a profile contains an item that no currently
    // installed data provider is able to successfully recreate, it is assumed that either the
    // item is a control not installed on the current system, or that the data provider that would
    // normally know about that control has not been installed on the system.  In either case, the
    // item is not imported from the profile.
    HRESULT ReconstituteItem([in] LPCOLESTR lpszCurrentName, [in] LPCOLESTR lpszID, [in] LPCOLESTR lpszData, [out] IDataObject **ppDO, [out] TBXITEMINFO *ptif);
}

//----------------------------------------------------------------------------
//  interface IVsResourceManager
//----------------------------------------------------------------------------
// Implemented by the Environment. 
// This is a service to load managed and unmanaged resources from Satellite DLLs.
// If no specific LCID is desired for the culture, a value of 0 will select the LCID that the user selected when the application was executed.
// This interface should not be used in a background thread.
[
    uuid(uuid_IVsResourceManager),
    version(1.0),
    pointer_default(unique)
]
interface IVsResourceManager : IUnknown
{
    HRESULT LoadResourceString([in] REFGUID guidPackage, [in] int culture, [in, string] LPCOLESTR pszResourceName, [out, retval] BSTR *pbstrValue);
    [local] HRESULT LoadResourceBitmap([in] REFGUID guidPackage, [in] int culture, [in, string] LPCOLESTR pszResourceName, [out, retval] HBITMAP *hbmpValue);
    [local] HRESULT LoadResourceIcon([in] REFGUID guidPackage, [in] int culture, [in, string] LPCOLESTR pszResourceName, [in] int cx, [in] int cy, [out, retval] HICON *hicoValue);
    // The format of the name of a blob resource is "ID:FORM" where ID is the resource ID.  In a native resource,
    //       the 'FORM' is used to identify the category of resource.  In a managed resource the 'FORM' of the data is not used.
    //     Ex: "101:RT_BITMAP"
    //     Ex: "401:MYCUSTOMDATA"
    // The buffer returned by LoadResourceBlob is allocated by CoTaskMemAlloc and must be freed by the caller with CoTaskMemFree.
    HRESULT LoadResourceBlob([in] REFGUID guidPackage, [in] int culture, [in, string] LPCOLESTR pszResourceName, [out] BYTE **pBytes, [out] long *lAllocated);

    HRESULT LoadResourceString2([in, string] LPCOLESTR pszAssemblyPath, [in] int culture, [in, string] LPCOLESTR pszResourceName, [out, retval] BSTR *pbstrValue);
    [local] HRESULT LoadResourceBitmap2([in, string] LPCOLESTR pszAssemblyPath, [in] int culture, [in, string] LPCOLESTR szResourceName, [out, retval] HBITMAP *hbmpValue);
    [local] HRESULT LoadResourceIcon2([in, string] LPCOLESTR pszAssemblyPath, [in] int culture, [in, string] LPCOLESTR pszResourceName, [in] int cx, [in] int cy, [out, retval] HICON *hicoValue);
    // The buffer returned by LoadResourceBlob2 is allocated by CoTaskMemAlloc and must be freed by the caller with CoTaskMemFree.
    HRESULT LoadResourceBlob2([in, string] LPCOLESTR pszAssemblyPath, [in] int culture, [in, string] LPCOLESTR pszResourceName, [out] BYTE **pBytes, [out] long *lAllocated);

    HRESULT GetSatelliteAssemblyPath([in, string] LPCOLESTR assemblyPath, [in] int lcid, [out, retval] BSTR *pbstrPath);
};

// declare the service type for interop
[uuid(uuid_SVsResourceManager)]
interface SVsResourceManager : IUnknown {}

cpp_quote("#define SID_SVsResourceManager IID_SVsResourceManager")

//---------------------------------------------------------------------------
// IVsAddNewWebProjectItemDlg
//---------------------------------------------------------------------------
// Implemented by the Environment and can be QI'd from the SID_SVsAddProjectItemDlg
// service. Used by web project implementations to display the AddItem dialog with
// only a listview control and specific web related controls. This version implicitly
// sets the following VSADDITEMFLAGS - the remainder can be assumed to be reset:
// When the user presses OK, the dialog will QI the IVsProject interface for IVsWebProject
// and will call IVsWebProjet::AddItem
//VSADDITEM_SuggestTemplateName    = 0x00000008,  // suggest template name for item
//VSADDITEM_AddNewItems            = 0x00000100,  // use the Add New Item dialog (mutually exclusive with VSADDITEM_AddExistingItems)
//VSADDITEM_AllowHiddenTreeView    = 0x00020000,  // allow tree view to be hidden if only one template node present

// These flags can be passed as an input parameter to the dialog to preset these
// options (only valid if lpszSelect is set to some value). They also passed to
// IVsWebProject::AddNewWebItem() when the user clicks OK.
enum __VSADDNEWWEBITEMOPTIONS
{
    VSADDWEBITEM_SelectMaster            = 0x00000001,  // Set if "Select master page" is checked
    VSADDWEBITEM_SeparateCodeFile        = 0x00000002,  // Set if "Place code in separate disable the item name field
    VSADDWEBITEM_SelectMasterIsValid     = 0x80000000,  // Set if the SelectMaster valid is valid for the selected template
    VSADDWEBITEM_SeparateCodeFileIsValid = 0x40000000,  // Set if the SeparateCodeFile is valid for the selected template
    VSADDWEBITEM_IsValidMask             = 0xF0000000,  // Masks the IsValid bits
};
typedef DWORD VSADDNEWWEBITEMOPTIONS;

[
    uuid(uuid_IVsAddNewWebProjectItemDlg),
    version(1.0),
    pointer_default(unique)
]
interface IVsAddNewWebProjectItemDlg : IUnknown
{
    HRESULT AddNewWebProjectItemDlg(
        [in] VSITEMID itemidLoc,          // item to add into
        [in] REFGUID rguidProject,        // guid of project
        [in] IVsProject *pProject,        // project interface
        [in] LPCOLESTR pszDlgTitle,       // Dialog caption (can be null)
        [in] LPCOLESTR lpszHelpTopic,     // name of help topic (NULL == "vs.add[new|existing]item")
        [in] LPCOLESTR lpszLanguage,      // directory (language) to select by default
        [in] LPCOLESTR lpszSelect,        // item to select
        [in] VSADDNEWWEBITEMOPTIONS options); // options to set on the dialog
}

//----------------------------------------------------------------------------
// IVsWebProject
//----------------------------------------------------------------------------
// Implemented by web project objects that want to use the IVsAddWebProjectItemDlg.
// Interface retrieved by QI from IVsHierarchy\IVsProject

[
    uuid(uuid_IVsWebProject),
    version(1.0),
    pointer_default(unique)
]
interface IVsWebProject : IUnknown
{
    HRESULT AddNewWebItem([in] VSITEMID itemidLoc,      // Folder to add the item to
        [in] VSADDITEMOPERATION dwAddItemOperation,     // Add item operation: only VSADDITEMOP_CLONEFILE and
        // VSADDITEMOP_RUNWIZARD are valid
        [in] LPCOLESTR pszItemName,                     // Name of the item
        [in] LPCOLESTR pszFileTemplate,                 // Path to the template the user selected
        [in] VSADDNEWWEBITEMOPTIONS options,            // The options checked on the dialog for the item
        [in] LPCOLESTR pszSelectedLanguage,             // String selected from the languages dropdown (can be null)
        [in] HWND hwndDlgOwner,
        [out, retval] VSADDRESULT * pResult);
}

//----------------------------------------------------------------------------
// IVsUIHierarchyWindow2
//----------------------------------------------------------------------------
// Expands IVsUIHierarchyWindow

enum __VSHIERITEMATTRIBUTE
{
    VSHIERITEMATTRIBUTE_Bold    = 1,
};
typedef DWORD VSHIERITEMATTRIBUTE;


[
    uuid(uuid_IVsUIHierarchyWindow2),
    version(1.0),
    pointer_default(unique)
]
interface IVsUIHierarchyWindow2 : IVsUIHierarchyWindow
{
    HRESULT SetItemAttribute([in] IVsUIHierarchy* pUIH, [in] VSITEMID itemid, [in] VSHIERITEMATTRIBUTE attribute, [in] VARIANT value);
}


//----------------------------------------------------------------------------
// IVsProjectDataConnection
//----------------------------------------------------------------------------
// Debugger will use it to get the project DB connection

[
    uuid(uuid_IVsProjectDataConnection),
    version(1.0),
    pointer_default(unique)
]
interface IVsProjectDataConnection : IUnknown
{
    HRESULT GetProjectSqlConnection([out] IUnknown **pConnection);
}




interface IVsTaskProvider3;
interface IVsTaskItem3;

// Scrolling behavior for IVsTaskList2.SelectItems.
typedef enum __tagVSTASKLISTSELECTIONSCROLLPOS
{
    TSSP_NOSCROLL        = 0,   // Don't scroll the tasklist at all.
    TSSP_CENTERCARET     = 1,   // Position the caret item in the center.
    TSSP_CARETATTOP      = 2,   // Position the caret item at the top (first visible item).
    TSSP_CARETATBOTTOM   = 3,   // Position the caret item at the bottom (last visible item).
    TSSP_MINSCROLL       = 4,   // Scroll the minimum distance required for the caret item to be visible.
    TSSP_SHOWALL         = 5,   // Show the caret item and as many of the other selected items as possible.
} __VSTASKLISTSELECTIONSCROLLPOS;

typedef DWORD VSTASKLISTSELECTIONSCROLLPOS;

// Selection behavior for IVsTaskList2.SelectItems.
typedef enum __tagVSTASKLISTSELECTIONTYPE
{
    TST_REPLACESEL  = 0,    // Any previously selected items will be unselected before the new selection is applied.
    TST_EXTENDSEL   = 1,    // The selection will be extended from the current caret item to include the new selection, as if the user had shift+clicked.
    TST_ADDTOSEL    = 2,    // The new items will be individually added to the previous selection, as if the user had ctrl+clicked.
} __VSTASKLISTSELECTIONTYPE;

typedef DWORD VSTASKLISTSELECTIONTYPE;


// Implemented by the shell.  QI between IVsTaskList and IVsTaskList2 (in either direction) is
// guaranteed to succeed.
[
    uuid(uuid_IVsTaskList2),
    version(1.0),
    pointer_default(unique)
]
interface IVsTaskList2 : IUnknown
{
    // --------------------------------------------------------------------------------------------
    // Selection methods: in order to handle commands, the task providers will need to know which
    // tasks are currently selected.

    // Returns the count of selected items, which may be anywhere from zero to the total count of
    // items in the task list.
    HRESULT GetSelectionCount([out] int* pnItems);

    // Returns the item that currently has the caret.  This item is always among the selected
    // items.  If no item has the caret, this method will return NULL.
    HRESULT GetCaretPos([out] IVsTaskItem** ppItem);

    // Returns an enumerator that will enumerate all the selected items, in order from last
    // selected to first selected.
    HRESULT EnumSelectedItems([out] IVsEnumTaskItems** ppEnum);

    // Selects zero or more items.  Pass in zero for nItems to remove the selection entirely.
    // All non-filtered items in pItems will be selected and the last one will become the caret
    // item.  Filtered items are ignored.
    HRESULT SelectItems([in] int nItems, [in, size_is(nItems)] IVsTaskItem* pItems[], [in] VSTASKLISTSELECTIONTYPE tsfSelType, [in] VSTASKLISTSELECTIONSCROLLPOS tsspScrollPos);

    // --------------------------------------------------------------------------------------------

    // Scrolls if necessary to make the task visible, selects it, and enters edit mode with the
    // focus on the specified field.  If the task does not belong to the active provider or the
    // specified field is not a visible, editable field, the method will fail.
    HRESULT BeginTaskEdit([in] IVsTaskItem* pItem, [in] int iFocusField);

    // Returns the currently active task provider.
    HRESULT GetActiveProvider([out] IVsTaskProvider** ppProvider);

    // Selects the provider currently displayed in the tasklist.  NOTE: this should not be done
    // automatically (e.g. in response to a build or run action), but only when explicitly
    // requested by the user.  Users get annoyed when we switch things like this automatically.
    HRESULT SetActiveProvider([in] REFGUID rguidProvider);

    // --------------------------------------------------------------------------------------------
    // Task management

    // Refreshes all cached information for the given tasks.  Tasks which do not yet exist in the
    // list will be added.
    HRESULT RefreshOrAddTasks([in] VSCOOKIE vsProviderCookie, [in] int nTasks, [in, size_is(nTasks)] IVsTaskItem* prgTasks[]);

    // Removes the given tasks from the tasklist.
    HRESULT RemoveTasks([in] VSCOOKIE vsProviderCookie, [in] int nTasks, [in, size_is(nTasks)] IVsTaskItem* prgTasks[]);

    // Refreshes all tasks from all registered providers.  This is a potentially time-consuming
    // operation.
    HRESULT RefreshAllProviders();
}

// Column definition returned from IVsTaskProvider3.GetColumn.
typedef struct _VSTASKCOLUMN
{
    int     iField;                 // Field index designated by the task provider.
    BSTR    bstrHeading;            // Text in header.  May be NULL to indicate an image.
    int     iImage;                 // Image in header (an index into the provider's image list).  Only used if bstrHeading == NULL.
    BOOL    fShowSortArrow;         // Whether a sort arrow is shown in the header when the list is sorted by this column.
    BOOL    fAllowUserSort;         // Whether the user is allowed to sort by clicking on this column's header.
    BOOL    fVisibleByDefault;      // Whether this column is visible by default.
    BOOL    fAllowHide;             // Whether the user is allowed to change this column's visibility.
    BOOL    fSizeable;              // Whether the column may be resized by the user.
    BOOL    fMoveable;              // Whether the column may be dragged to another position by the user.
    int     iDefaultSortPriority;   // Priority value (0 is first, then 1, 2, ...) if this column is sorted by default; -1 otherwise.
    BOOL    fDescendingSort;        // Sort in descending order (default is ascending).
    int     cxMinWidth;             // The minimum column width, in pixels.  Only used if fSizeable or fDynamicSize is set.
    int     cxDefaultWidth;         // The default column width, in pixels.
    BOOL    fDynamicSize;           // Whether the task list is allowed to resize the column automatically to make content fit better.
    BSTR    bstrCanonicalName;      // Non-localized name, must be unique within this provider's column list.
    BSTR    bstrLocalizedName;      // Localized name for human consumption.
    BSTR    bstrTip;                // Tooltip for column header.
    BOOL    fFitContent;            // Column will be automatically resized to fit whenever its content changes.
} VSTASKCOLUMN;

// Value flags returned by IVsTaskProvider3.GetProviderFlags.
enum __VSTASKPROVIDERFLAGS
{
    TPF_ALWAYSVISIBLE   = 0x00000001,   // Provider is always visible in dropdown even if it has no tasks.
    TPF_NOAUTOROUTING   = 0x00000002,   // Don't automatically route this provider's tasks to predefined buckets based on their categories.
};
typedef DWORD VSTASKPROVIDERFLAGS;

// Predefined provider GUIDs that may be returned by IVsTaskProvider3.GetSurrogateProviderGUID or
// IVsTaskItem3.GetSurrogateProviderGUID.

// {5A2D2729-ADFF-4a2e-A44F-55EBBF5DF64B}
cpp_quote("DEFINE_GUID(GUID_Comment_TaskProvider, 0x5a2d2729, 0xadff, 0x4a2e, 0xa4, 0x4f, 0x55, 0xeb, 0xbf, 0x5d, 0xf6, 0x4b);")

#ifdef INTEROPLIB
module TaskProviderGuids
{
    const LPSTR Comments = "{5A2D2729-ADFF-4a2e-A44F-55EBBF5DF64B}";
}
#endif // INTEROPLIB

// Implemented by packages that add content to the task list.  Implementors of IVsTaskProvider3
// MUST also implement IVsTaskProvider, but the reverse is not true.  Also, if you implement this
// interface, your tasks must implement IVsTaskItem3.
[
    uuid(uuid_IVsTaskProvider3),
    version(1.0),
    pointer_default(unique)
]
interface IVsTaskProvider3 : IUnknown
{
    // Returns the behavior flags for this provider.
    HRESULT GetProviderFlags([out] VSTASKPROVIDERFLAGS* tpfFlags);

    // Returns a localized human-readable name for this data provider.
    HRESULT GetProviderName([out] BSTR* pbstrName);

    // Returns a unique ID for this provider.  This is used to persist & restore per-provider
    // data managed by the task list, such as user customizations of column width & order.  If it
    // is not practical to assign a GUID to this provider (e.g. the provider is dynamically created
    // at run-time and the identity cannot be preserved across VS sessions), you may return
    // GUID_NULL.  However, you should be aware that certain functionality (such as UI settings
    // persistence and the IVsTaskList2.SetActiveProvider method) will not work in that case.
    HRESULT GetProviderGuid([out] GUID* pguidProvider);

    // If a provider implements this method, all its tasks will be listed under the surrogate
    // provider in the list, as if they belong to the surrogate provider.
    HRESULT GetSurrogateProviderGuid([out] GUID* pguidProvider);

    // Returns a group GUID and toolbar ID indicating which toolbar should be displayed when this
    // provider is active.  Set pguidGroup and pdwID to GUID_NULL and 0, respectively, to indicate
    // that this provider has no toolbar.  If you do provide a toolbar, you must include the
    // provider dropdown as the first group, by including this line in your CTC file:
    //     guidSHLMainMenu:IDG_VS_TASKLIST_PROVIDERLIST,                <your toolbar's group>:<your toolbar menu ID>,                 0x0100;
    // See vscommon\appid\inc\ShellCmdPlace.ctc for examples.
    HRESULT GetProviderToolbar([out] GUID* pguidGroup, [out] DWORD* pdwID);

    // --------------------------------------------------------------------------------------------
    // Column methods: this is where the task provider defines its columns and their attributes.

    // Returns the total number of columns supported by this provider, including columns that are
    // not visible by default.
    HRESULT GetColumnCount([out] int* pnColumns);

    // Gets the definition of an indexed column (0 <= iColumn < nColumns).
    HRESULT GetColumn([in] int iColumn, [out] VSTASKCOLUMN* pColumn);

    // --------------------------------------------------------------------------------------------
    // Events

    // Called when the user begins editing a task in-place.  Providers may want to avoid scrolling
    // the tasklist or changing the selection during editing, since these actions can force in-
    // place edit mode to be canceled abruptly.
    HRESULT OnBeginTaskEdit([in] IVsTaskItem* pItem);

    // Called when the user finishes editing a task in-place.  fCommitChanges indicates whether the
    // user chose to commit the changes or discard them.  This method may set *pfAllowChanges to
    // FALSE to disallow the user from exiting edit mode.  If fCommitChanges is TRUE, the changes
    // will have already been persisted down to the task item.
    HRESULT OnEndTaskEdit([in] IVsTaskItem* pItem, [in] BOOL fCommitChanges, [out] BOOL* pfAllowChanges);
}

// Value types returned by IVsTaskItem3.GetColumnValue.
typedef enum __tagVSTASKVALUETYPE
{
    TVT_NULL        = 0,
    TVT_TEXT        = 1,    // Arbitrary text.
    TVT_LINKTEXT    = 2,    // Text with underlined links displayed between '@' characters (the delimiters are not displayed).
    TVT_BASE10      = 3,    // A number displayed in decimal notation.
    TVT_IMAGE       = 4,    // An indexed image in the image list provided by the task provider.
} __VSTASKVALUETYPE;

typedef DWORD VSTASKVALUETYPE;

// Value flags returned by IVsTaskItem3.GetColumnValue.
enum __VSTASKVALUEFLAGS
{
    TVF_EDITABLE        = 0x00000001,   // This value can be changed by the user.
    TVF_ENUM            = 0x00000002,   // The value is not arbitrary, but may only be one of a limited set of strings provided by the task item.
    TVF_BINARY_STATE    = 0x00000004,   // This is an enum with only two possible states.  The user can switch the state by a similar UI action to clicking a checkbox.
    TVF_HORZ_RIGHT      = 0x00000008,   // The value is aligned against the right edge of the column.
    TVF_HORZ_CENTER     = 0x00000010,   // The value is horizontally centered in the column.
    TVF_STRIKETHROUGH   = 0x00000020,   // The value is drawn with a strikethrough font style.
    TVF_FILENAME        = 0x00000040,   // This textual value will be treated as a file name.
};
typedef DWORD VSTASKVALUEFLAGS;

// Task item interface for new column-agnostic architecture.  Implementors of this interface MUST
// also implement IVsTaskItem, but only the following methods will be used:
//     CanDelete
//     HasHelp
//     NavigateTo
//     NavigateToHelp
//     OnFilterTask
//     OnDeleteTask
// All others are obsolete when IVsTaskItem3 is implemented.
[
    uuid(uuid_IVsTaskItem3),
    version(1.0),
    pointer_default(unique)
]
interface IVsTaskItem3 : IUnknown
{
    // Gets the provider that owns this item.
    HRESULT GetTaskProvider([out] IVsTaskProvider3** ppProvider);

    // Returns a string naming or describing the task.  Used for accessibiity.
    HRESULT GetTaskName([out] BSTR* pbstrName);

    // --------------------------------------------------------------------------------------------
    // Column methods: these allow each task to define a value for each column.

    // Returns the value of this task for a given column.  If *ptvtType == TVT_IMAGE, pvarValue is
    // interpreted as a numeric index into the imagelist provided by the task provider.
    // pbstrAccessibilityName is the descriptive text exposed to accessibility for this value.  If
    // *ptvtType != TVT_IMAGE, it may be left blank; in that case, the text of the value itself
    // will be used.
    HRESULT GetColumnValue([in] int iField, [out] VSTASKVALUETYPE* ptvtType, [out] VSTASKVALUEFLAGS* ptvfFlags, [out] VARIANT* pvarValue, [out] BSTR* pbstrAccessibilityName);

    // Returns the tip text for the given field.  If this method fails or returns an empty string,
    // the task list will use the text of the item itself (if any) or the accessibility name as the
    // tip text.
    HRESULT GetTipText([in] int iField, [out] BSTR* pbstrTipText);

    // When the user edits a task, this method is called for each edited column once the edit is
    // committed.  The type of pvarValue will be the same as the type returned from GetColumnValue.
    HRESULT SetColumnValue([in] int iField, [in] VARIANT* pvarValue);

    // During a call to IVsTaskList.RefreshTasks, the task item's values will be re-queried unless
    // this method returns FALSE.
    HRESULT IsDirty([out] BOOL* pfDirty);

    // --------------------------------------------------------------------------------------------
    // Enum methods: for values that may be set to a limited number of defined values.  For
    // example, a "Priority" value might only allow "high", "medium", and "low".

    // Given a column field, returns the number of possible values this task may have for that
    // column.
    HRESULT GetEnumCount([in] int iField, [out] int* pnValues);

    // Given a column field and value index, returns the indexed value for this task and column.
    // pbstrAccessibilityName is the descriptive text exposed to accessibility for this value.  If
    // *ptvtType != TVT_IMAGE, it may be left blank; in that case, the text of the value itself
    // will be used.
    HRESULT GetEnumValue([in] int iField, [in] int iValue, [out] VARIANT* pvarValue, [out] BSTR* pbstrAccessibilityName);

    // --------------------------------------------------------------------------------------------
    // Events

    // If the user clicks on an underlined link in a value of type TVT_LINKTEXT, this method is
    // called with the column field and the link index (the first link in a given value is link 0).
    // The task item should take whatever action is appropriate.
    HRESULT OnLinkClicked([in] int iField, [in] int iLinkIndex);

    // --------------------------------------------------------------------------------------------

    // This method returns the text that will be placed on the status bar when the task is
    // successfully navigated to.
    HRESULT GetNavigationStatusText([out] BSTR* pbstrText);

    // If the user starts editing the task in a way that does not select a specific field, this
    // method specifies the field in which editing will begin.
    HRESULT GetDefaultEditField([out] int* piField);

    // If the task implements this method, it will be listed under the surrogate provider in the
    // list, as if it belongs to the surrogate provider.  This overrides the surrogate provider
    // specified by IVsTaskProvider.GetSurrogateProviderGuid, if any.
    HRESULT GetSurrogateProviderGuid([out] GUID* pguidProvider);
}

// Implemented by the shell.  This interface contains additional methods for the new Build Error
// List, which also implements IVsTaskList.
[
    uuid(uuid_IVsErrorList),
    version(1.0),
    pointer_default(unique)
]
interface IVsErrorList : IUnknown
{
    // Activates the window and makes it visible.
    HRESULT BringToFront();

    // Forces the error toggle "on", so that errors are visible in the list.  Warnings and
    // informational messages are not affected.
    HRESULT ForceShowErrors();
}

[
    uuid(uuid_SVsErrorList)
]
interface SVsErrorList : IUnknown
{
}
cpp_quote("#define SID_SVsErrorList IID_SVsErrorList")

// GUIDs used in calling IVsShell::CreateToolWindow()
cpp_quote("extern const __declspec(selectany) GUID GUID_ErrorList = { 0xd78612c7, 0x9962, 0x4b83, { 0x95, 0xd9, 0x26, 0x80, 0x46, 0xda, 0xd2, 0x3a } };")
cpp_quote("extern const __declspec(selectany) GUID GUID_PropertySheetManager = { 0x6B8E94B5, 0x0949, 0x4d9c, { 0xA8, 0x1F, 0xC1, 0xB9, 0xB7, 0x44, 0x18, 0x5C} };")
cpp_quote("extern const __declspec(selectany) GUID GUID_CodeDefWin =  { 0x588470cc, 0x84f8, 0x4a57, { 0x9a, 0xc4, 0x86, 0xbc, 0xa0, 0x62, 0x5f, 0xf4 } };")


// Error item types returned by IVsErrorItem.GetCategory.
typedef enum __tagVSERRORCATEGORY
{
    EC_ERROR    = 0,
    EC_WARNING  = 1,
    EC_MESSAGE  = 2,
} __VSERRORCATEGORY;

typedef DWORD VSERRORCATEGORY;


// Implemented by error list items (in addition to IVsTaskItem).
[
    uuid(uuid_IVsErrorItem),
    version(1.0),
    pointer_default(unique)
]
interface IVsErrorItem : IUnknown
{
    // If this error item corresponds to a hierarchy item (e.g. a file in a project), this method
    // returns the hierarchy to which it belongs.
    HRESULT GetHierarchy([out] IVsHierarchy** ppProject);

    // Returns the category of this item: error, warning, or informational message.
    HRESULT GetCategory([out] VSERRORCATEGORY* pCategory);
}


[
    uuid(uuid_IVsWindowPaneCommitFilter),
    version(1.0),
    pointer_default(unique)
]
interface IVsWindowPaneCommitFilter : IUnknown
{
    HRESULT IsCommitCommand([in] REFGUID pguidCmdGroup, [in] DWORD dwCmdID, [out] BOOL *pfCommitCommand);
};

//-----------------------------------------------------------------------------
// IPreferPropertyPagesWithTreeControl
//-----------------------------------------------------------------------------
// Implemented by a Browse object that also implements ISpecifyPropertyPages.
// If this interface is supported then the Property Page Frame will display
// a tree control instead of tabs to allow switching between the different 
// property pages.
[
    uuid(uuid_IPreferPropertyPagesWithTreeControl),
    version(1.0),
    pointer_default(unique)
]
interface IPreferPropertyPagesWithTreeControl : IUnknown
{
};

//-----------------------------------------------------------------------------
// IVsSpecifyProjectDesignerPages
//-----------------------------------------------------------------------------
// Implemented by a project system that supports editing Project Properties via
// an editor (referred to as a Project Designer) instead of via Property Pages
// displayed in the PropertyPage Frame. Such a project never wants its Project
// Property Pages to appear in the PropertyPage Frame. This is accomplished by 
// deliberately not implementing ISpecifyPropertyPages interface on the Browse 
// object of the Project (as returned by VSHPROPID_BrowseObject) and its 
// configuration Browse objects. This interface is identical in shape to
// the standard ISpecifyPropertyPages interface but has a different IID. This
// interface should be implemented on the Browse object of the Project 
// and its configuration Browse objects that want to offer PropertyPages to their
// project specific Project Designer (assuming that it wants to use IPropertyPages
// as part of its implementation). 
// A project that uses a Project Designer will implement the following properties:
//     VSHPROPID_SupportsProjectDesigner (BOOL) -- return VARIANT_TRUE
//     VSHPROPID_ProjectDesignerEditor (GUID) -- guid of the Project Designer editor
// A Project Designer is an editor for Project properties that is launched as a document 
// associated with the root of the project. The Project Designer Editor is launched via 
// the following call:
//   pIVsProject2->ReopenItem(VSITEMID_ROOT, guidProjectDesignerEditor, L"", 
//                            clsidInitialPage, DOCDATAEXISTING_UNKNOWN, &srpWindowFrame)
//
// NOTE: The CLSID of the initial IPropertyPage to activate is passed as the 
// rguidLogicalView parameter to ReopenItem. If there is no preferred inital page
// then GUID_NULL (same as LOGVIEWID_PRIMARY) is passed. When opening the Project
// Designer document window (e.g. in its implementation of IVsProject2::ReopenItem),
// the project implementation should associate the DocumentWindow with the 
// parent IVsHierarchy/parent itemid of its root node (VSHPROPID_ParentHierarchy/
// VSHPROPID_ParentItemid). This will normally be an itemid of the Solution. 
// This implementation might look something like:
//        if ((itemid == VSITEMID_ROOT) && (rguidEditorType == GUID_ProjectDesignerEditor))
//        {
//            hr = pVsUIShellOpenDoc->OpenSpecificEditor(0,
//                    GetProject()->GetProjectFile(),
//                    GUID_ProjectDesignerEditor,
//                    NULL,
//                    rguidLogicalView,               // Pass the guid of the property page if you want to change the initial page
//                    L"%2",                          // The Project Designer title is just the name if the item in the parent hierarchy.
//                    m_pParentUIHierarchy,
//                    m_dwParentHierarchyItemid,
//                    punkDocDataExisting,
//                    m_srpServiceProvider,
//                    &srpWindowFrame);
//             ...
//         }

[
    uuid(uuid_IVsSpecifyProjectDesignerPages),
    version(1.0),
    pointer_default(unique)
]
interface IVsSpecifyProjectDesignerPages : IUnknown
{
    HRESULT GetProjectDesignerPages([out] CAUUID *pPages);
};

cpp_quote("#define VS_OUTPUTGROUP_CNAME_SGenFiles         L\"XmlSerializer\"")

//-----------------------------------------------------------------------------
// IVsDeployDependency2
//-----------------------------------------------------------------------------
// Implemented by a project system that supports producing build outputs. 
// These are dependencies of the IVsOutputGroup, required for deployment.
[
    uuid(uuid_IVsDeployDependency2),
    version(1.0),
    pointer_default(unique)
]
interface IVsDeployDependency2 : IUnknown
{
    HRESULT get_Property([in] LPCOLESTR szProperty, [out] VARIANT* pvar);
};

//-----------------------------------------------------------------------------
// IVsOutputGroup2
//-----------------------------------------------------------------------------
// extends IVsOutputGroup, look at vsshell.idl for description of IVsOutputGroup
[
    uuid(uuid_IVsOutputGroup2),
    version(1.0),
    pointer_default(unique)
]
interface IVsOutputGroup2 : IVsOutputGroup
{
    HRESULT get_KeyOutputObject([out] IVsOutput2 **ppKeyOutput);
    HRESULT get_Property([in] LPCOLESTR pszProperty, [out] VARIANT* pvar);
}

// Values returned from IVsFontAndColorUtilities.GetColorType.
enum __VSCOLORTYPE
{
    CT_INVALID          = 0,    // The color is invalid, or not set.
    CT_RAW              = 1,    // This COLORREF is a literal RGB value.
    CT_COLORINDEX       = 2,    // This COLORREF contains an encoded COLORINDEX.
    CT_SYSCOLOR         = 3,    // This COLORREF contains an encoded system color (COLOR_*)
    CT_VSCOLOR          = 4,    // This COLORREF contains an encoded VSCOLOR value.
    CT_AUTOMATIC        = 5,    // This is the "automatic" color.
    CT_TRACK_FOREGROUND = 6,    // This color is the same as the foreground of another item.
    CT_TRACK_BACKGROUND = 7,    // This color is the same as the background of another item.
};
typedef LONG VSCOLORTYPE;

// Values passed to IVsFontAndColorUtilities.EncodeTrackedItem.
enum __VSCOLORASPECT
{
    CA_FOREGROUND   = 0,
    CA_BACKGROUND   = 1,
};
typedef LONG VSCOLORASPECT;

// Implemented by the environment from service SID_SVsFontAndColorStorage.
[
    uuid(uuid_IVsFontAndColorUtilities),
    version(1.0),
    pointer_default(unique)
]
interface IVsFontAndColorUtilities : IUnknown
{
    // Color methods -- these deal with encoding and decoding of indexed color values in a
    // COLORREF.

    // Returns an encoded value (*not* raw RGB) that represents the given color index.
    HRESULT EncodeIndexedColor([in] COLORINDEX idx, [out] COLORREF* pcrResult);

    // Returns an encoded value (*not* raw RGB) that represents the given system color.  iSysColor
    // is a value that would be passed to GetSysColor.
    HRESULT EncodeSysColor([in] int iSysColor, [out] COLORREF* pcrResult);

    // Returns an encoded value (*not* raw RGB) that represents the given vscolor.  vsColor is a
    // value that would be passed to IVsShell2.GetVSSysColorEx.
    HRESULT EncodeVSColor([in] VSSYSCOLOREX vsColor, [out] COLORREF* pcrResult);

    // Returns an encoded value (*not* raw RGB) that represents either the foreground or background
    // of a colorable item identified by the given index.
    HRESULT EncodeTrackedItem([in] int iItemToTrack, [in] VSCOLORASPECT aspect, [out] COLORREF* pcrResult);

    // Returns a color value for which GetColorType will return CT_INVALID.
    HRESULT EncodeInvalidColor([out] COLORREF* pcrResult);

    // Returns a color value for which GetColorType will return CT_AUTOMATIC.
    HRESULT EncodeAutomaticColor([out] COLORREF* pcrResult);

    // Given a color value which may be raw RGB or encoded, returns the type of its encoding.  The
    // high byte of raw RGB values must be zero for this method to operate correctly.
    HRESULT GetColorType([in] COLORREF crSource, [out] VSCOLORTYPE* pctType);

    // Given an index-encoded color value (as returned from EncodeIndexedColor), returns the color
    // index it represents.
    HRESULT GetEncodedIndex([in] COLORREF crSource, [out] COLORINDEX* pIdx);

    // Given a syscolor-encoded color value (as returned from EncodeSysColor), returns the color
    // index it represents.
    HRESULT GetEncodedSysColor([in] COLORREF crSource, [out] int* piSysColor);

    // Given a vscolor-encoded color value (as returned from EncodeVSColor), returns the color
    // index it represents.
    HRESULT GetEncodedVSColor([in] COLORREF crSource, [out] VSSYSCOLOREX* pVSColor);

    // Given a color value representing an aspect of a colorable item (as returned from
    // EncodeTrackedItem), returns the aspect and item index it represents.
    HRESULT GetTrackedItemIndex([in] COLORREF crSource, [out] VSCOLORASPECT* pAspect, [out] int* piItem);

    // Given a color index (as returned from GetEncodedIndex), returns the raw RGB value it
    // represents.
    HRESULT GetRGBOfIndex([in] COLORINDEX idx, [out] COLORREF* pcrResult);

    // Given a colorable item and its fonts & colors category, returns the raw RGB values for its
    // foreground and background.
    HRESULT GetRGBOfItem([in] AllColorableItemInfo* pInfo, [in] REFGUID rguidCategory, [out] COLORREF* pcrForeground, [out] COLORREF* pcrBackground);

    // Given a (possibly) encoded colorref, decodes it and returns the raw RGB value.  crAutoColor
    // is only used if crSource is type CT_AUTOMATIC.  Likewise, rguidCategory is only used if
    // crSource is type CT_TRACK_FOREGROUND or CT_TRACK_BACKGROUND.
    HRESULT GetRGBOfEncodedColor([in] COLORREF crSource, [in] COLORREF crAutoColor, [in] REFGUID rguidCategory, [out] COLORREF* pcrResult);

    // Font methods.

    // Call this after you create a FontInfo structure to initialize its members to default values.
    // This is necessary so that when you call FreeFontInfo later, it doesn't try to free an
    // uninitialized pointer.
    HRESULT InitFontInfo([in, out] FontInfo* pInfo);

    // Call this when you're done with a FontInfo structure.  This method will free all allocated
    // memory and set the fields to default values.
    HRESULT FreeFontInfo([in, out] FontInfo* pInfo);

    // Call this to copy one FontInfo structure to another.  This method takes care of all
    // allocations to make sure memory is managed properly.  Note that you must call InitFontInfo
    // on pDest before calling this method.
    HRESULT CopyFontInfo([in, out] FontInfo* pDest, [in] const FontInfo* pSource);

    // Item info methods.

    // Call this after you create an AllColorableItemInfo structure to initialize its members to
    // default values.  This is necessary so that when you call FreeItemInfo later, it doesn't try
    // to free an uninitialized pointer.
    HRESULT InitItemInfo([in, out] AllColorableItemInfo* pInfo);

    // Call this when you're done with an AllColorableItemInfo structure.  This method will free
    // all allocated memory and set the fields to default values.
    HRESULT FreeItemInfo([in, out] AllColorableItemInfo* pInfo);

    // Call this to copy one AllColorableItemInfo structure to another.  This method takes care of
    // all allocations to make sure memory is managed properly.  Note that you must call
    // InitItemInfo on pDest before calling this method.
    HRESULT CopyItemInfo([in, out] AllColorableItemInfo* pDest, [in] const AllColorableItemInfo* pSource);
}

// {1F987C00-E7C4-4869-8A17-23FD602268B0}
cpp_quote("extern const __declspec(selectany) GUID GUID_DialogsAndToolWindowsFC = { 0x1f987c00, 0xe7c4, 0x4869, { 0x8a, 0x17, 0x23, 0xfd, 0x60, 0x22, 0x68, 0xb0 } };")

// {A27B4E24-A735-4d1d-B8E7-9716E1E3D8E0}
cpp_quote("extern const __declspec(selectany) GUID GUID_TextEditorFC = { 0xa27b4e24, 0xa735, 0x4d1d, { 0xb8, 0xe7,  0x97,  0x16,  0xe1,  0xe3,  0xd8,  0xe0 } };")

// Implemented by the environment (QI from IVsOutputWindow).
[
    uuid(uuid_IVsOutputWindow2),
    version(1.0),
    pointer_default(unique)
]
interface IVsOutputWindow2 : IUnknown
{
    // Returns the GUID of the currently active pane.  Returns GUID_NULL if there is no active
    // pane.
    HRESULT GetActivePaneGUID([out] GUID* pguidPane);
}

//-----------------------------------------------------------------------------
// IVsDebuggableProjectCfg2
//-----------------------------------------------------------------------------
// Implemented by a project system that supports Debug Launch (F5 command). The
// additional method BeforeDebugLaunch provides additional support for project
// systems that require notification prior to the actual call to DebugLaunch()
// to start debugging.
//
// At debug start time, solution build manager calls OnBeforeLaunch on each project
// that supports this interface first. Then it iterates through all the projecs
// again to do the actual call to IVsDebuggableProjectCfg::DebugLaunch.
// 
// Project systems are not required to support this interface. If they do not
// the solution build manager will still call IVsDebuggableProjectCfg::DebugLaunch.
//
// The VB, C# and J# project systems use this method as part of their 
// implementation of the hosting process. At DebugLaunch time in a multi-start scenario it is 
// possible the hosting process is stopped at a debugger event and it cannot answer
// RPC calls. As a result, the VB, C# and J# project systems require this OnBeforeDebugLaunch 
// notification in advance to make any required RPC calls to the hosting process before 
// the process(es) are stopped in the debugger.
//
[
    uuid(uuid_IVsDebuggableProjectCfg2),
    version(1.0),
    pointer_default(unique)
]
interface IVsDebuggableProjectCfg2 : IVsDebuggableProjectCfg
{
    HRESULT OnBeforeDebugLaunch([in] VSDBGLAUNCHFLAGS grfLaunch);
}


// IVsProvideUserContext2
//
// This interface allows an object to expose a user context together with
// a priority. Its use is an extensibility point with the new SEID "Elements
// of Selection." For any element of selection added by third-parties, when
// its corresponding value changes, the application context will be updated
// with the context that is retrieved from this interface on that value. The
// context system will attempt to QI the new value for this interface, as well
// as IVsProvideUserContext and IVsUserContext. 
[
    uuid(uuid_IVsProvideUserContext2),
    object,
    version(1.0)
]
interface IVsProvideUserContext2 : IUnknown
{
    // retrieve an IVsUserContext from the object, together with a hint about what
    // the priority of the contents are. the valid values for iPriority are given
    // in context.idl: VSUC_Priority_None through VSUC_Priority_Highest.
    HRESULT GetUserContextEx([out] IVsUserContext ** ppctx, [out] int * iPriority);
};


////-----------------------------------------------------------------------------
//// IVsExtensibility3
////-----------------------------------------------------------------------------
//// This interface defn looks like a merging of IVsExtensibility & IVsExtensibility,
////   then placed here because those two interfaces have the IDL attribute restricted.
////   That attribute keeps this interface from appearing in the PIAs, and therefore
////   you cannot call it from managed code. Duplicating this here will make the 
////   interface appear in the IAs for VSIP, and callable from managed code.
[ 
  uuid(uuid_IVsExtensibility3), 
  version(1.0),
  pointer_default(unique)
]
interface IVsExtensibility3 : IUnknown
{
  [id(1)] HRESULT GetProperties([in] IUnknown *pParent, [in] IDispatch *pdispPropObj, [out] IDispatch **ppProperties);
  [id(2)] HRESULT RunWizardFile([in] BSTR bstrWizFilename, [in] long hwndOwner, [in] SAFEARRAY (VARIANT)* vContextParams, [out, retval] long *pResult);
  //[id(3)] HRESULT Get_TextBuffer([in] IUnknown *pVsTextStream, [in] IUnknown *pParent, [out, retval] IUnknown **ppTextBuffer);
  [id(4)] HRESULT EnterAutomationFunction(void);
  [id(5)] HRESULT ExitAutomationFunction(void);
  [id(6)] HRESULT IsInAutomationFunction([out, retval] BOOL *pfInAutoFunc);
  [id(7)] HRESULT GetUserControl([out] VARIANT_BOOL *fUserControl);
  [id(8)] HRESULT SetUserControl([in] VARIANT_BOOL fUserControl);
  [id(9)] HRESULT SetUserControlUnlatched([in] VARIANT_BOOL fUserControl);
  [id(10)] HRESULT LockServer([in] VARIANT_BOOL);
  [id(11)] HRESULT GetLockCount([out, retval] long *pCount);
  [id(12)] HRESULT TestForShutdown([out, retval] VARIANT_BOOL *fShutdown);
  [id(13)] HRESULT GetGlobalsObject([in] VARIANT ExtractFrom, [out, retval] IUnknown **ppGlobals);
  [id(14)] HRESULT GetConfigMgr([in] IUnknown *pIVsProject, [in] DWORD_PTR itemid, [out, retval] IUnknown **ppCfgMgr);
    [id(16)] HRESULT FireMacroReset();
  [id(17)] HRESULT GetDocumentFromDocCookie([in] LONG_PTR lDocCookie, [out, retval] IUnknown **ppDoc);
  [id(18)] HRESULT IsMethodDisabled([in] const GUID *pGUID, [in] long dispid);
  [id(19)] HRESULT SetSuppressUI([in] VARIANT_BOOL In);
  [id(20)] HRESULT GetSuppressUI([in, out] VARIANT_BOOL *pOut);
  [id(21)] HRESULT FireProjectsEvent_ItemAdded([in] IUnknown *Project);
  [id(22)] HRESULT FireProjectsEvent_ItemRemoved([in] IUnknown *Project);
  [id(23)] HRESULT FireProjectsEvent_ItemRenamed([in] IUnknown *Project, [in] BSTR OldName);
  [id(24)] HRESULT FireProjectItemsEvent_ItemAdded([in] IUnknown *ProjectItem);
  [id(25)] HRESULT FireProjectItemsEvent_ItemRemoved([in] IUnknown *ProjectItem);
  [id(26)] HRESULT FireProjectItemsEvent_ItemRenamed([in] IUnknown *ProjectItem, [in] BSTR OldName);
  //[id(27)] HRESULT BuildUIHierarchyFromTree([in] OLE_HANDLE hwnd, [in] IUnknown *pParent, [out, retval] IUnknown **ppUIHierarchy);
  //[id(28)] HRESULT FireCodeModelEvent([in] DISPID dispid, [in] IUnknown *pElement, [in] DWORD changeKind);
  [id(29)] HRESULT IsFireCodeModelEventNeeded([in, out] VARIANT_BOOL *vbNeeded);
  [id(30)] HRESULT RunWizardFileEx([in] BSTR bstrWizFilename, [in] long hwndOwner, [in] SAFEARRAY (VARIANT)* vContextParams, [in] SAFEARRAY (VARIANT)* vCustomParams, [out, retval] long *pResult);
  [id(31)] HRESULT FireCodeModelEvent3([in] DISPID dispid, [in] IDispatch *pParent, [in] IUnknown *pElement, [in] long changeKind);
};

[ 
  uuid(uuid_IVsGlobalsCallback2),
  version(1.0),
  pointer_default(unique)
]
interface IVsGlobalsCallback2 : IUnknown
{
  HRESULT WriteVariablesToData([in] LPCOLESTR pVariableName, [in] VARIANT *varData);
  HRESULT ReadData([in] IUnknown *pGlobals);
  HRESULT ClearVariables();
  HRESULT VariableChanged();
  HRESULT CanModifySource();
  HRESULT GetParent(IDispatch **ppOut);
};


////-----------------------------------------------------------------------------
//// IVsGlobals2
////-----------------------------------------------------------------------------
//// See the description on IVsExtensibility3 for why this interface is here.
[ 
  uuid(uuid_IVsGlobals2), 
  version(1.0),
  pointer_default(unique)
]
interface IVsGlobals2 : IUnknown
{
  HRESULT Load();
  HRESULT Save();
  HRESULT Empty();
};

////-----------------------------------------------------------------------------
//// IVsProfferCommands3
////-----------------------------------------------------------------------------
//// See the description on IVsExtensibility3 for why this interface is here.
[
  uuid(uuid_IVsProfferCommands3), 
  version(1.0),
  pointer_default(unique)
]
interface IVsProfferCommands3 : IUnknown
{
    HRESULT AddNamedCommand ([in] const GUID *pguidPackage, [in] const GUID *pguidCmdGroup, [in, string] const LPCOLESTR pszCmdNameCanonical,
                             [out] DWORD *pdwCmdId, [in, string] const LPCOLESTR pszCmdNameLocalized,
                             [in, string] const LPCOLESTR pszBtnText, [in, string] const LPCOLESTR pszCmdTooltip,
                             [in, string] const LPCOLESTR pszSatelliteDLL, [in] DWORD dwBitmapResourceId, [in] DWORD dwBitmapImageIndex,
                             [in] DWORD dwCmdFlagsDefault, [in] DWORD cUIContexts, [in, size_is(cUIContexts)] const GUID *rgguidUIContexts);

    HRESULT RemoveNamedCommand ([in, string] const LPCOLESTR pszCmdNameCanonical);

    HRESULT RenameNamedCommand ([in, string] const LPCOLESTR pszCmdNameCanonical, [in, string] const LPCOLESTR pszCmdNameCanonicalNew,
                                [in, string] const LPCOLESTR pszCmdNameLocalizedNew);

    HRESULT AddCommandBarControl ([in, string] const LPCOLESTR pszCmdNameCanonical, [in] IDispatch *pCmdBarParent, [in] DWORD dwIndex,
                                  [in] DWORD dwCmdType, [out] IDispatch **ppCmdBarCtrl);

    HRESULT RemoveCommandBarControl ([in] IDispatch *pCmdBarCtrl);

    HRESULT AddCommandBar ([in, string] const LPCOLESTR pszCmdBarName, [in] DWORD dwType, [in] IDispatch *pCmdBarParent, [in] DWORD dwIndex, [out] IDispatch **ppCmdBar);

    HRESULT RemoveCommandBar ([in] IDispatch *pCmdBar);

    HRESULT FindCommandBar ([in] IUnknown *pToolbarSet, [in] const GUID *pguidCmdGroup, [in] DWORD dwMenuId, [out, retval] IDispatch **ppdispCmdBar);
    HRESULT AddNamedCommand2 ([in] const GUID *pguidPackage, [in] const GUID *pguidCmdGroup, [in, string] const LPCOLESTR pszCmdNameCanonical,
                            [out] DWORD *pdwCmdId, [in, string] const LPCOLESTR pszCmdNameLocalized,
                            [in, string] const LPCOLESTR pszBtnText, [in, string] const LPCOLESTR pszCmdTooltip,
                            [in, string] const LPCOLESTR pszSatelliteDLL, [in] DWORD dwBitmapResourceId, [in] DWORD dwBitmapImageIndex,
                            [in] DWORD dwCmdFlagsDefault, [in] DWORD cUIContexts, [in, size_is(cUIContexts)] const GUID *rgguidUIContexts, [in] DWORD dwUIElementType);
};

//--------------------------------------------------------------------------------------------
// IVsHierarchyRefactorNotify
//
// This interface is optionally implemented by an IVsHierarchy-implementer in
//  order for a language-service to notify the hierarchy of refactoring 
//  operations (such as symbolic-rename and parameter-reordering). It is expected
//  that if the hierarchy has generated code (e.g. supports IVsSingleFileGenerator's
//  or build-providers) then it will QI the code-generator for IVsRefactorNotify or look
//  up a service that implements IVsRefactorNotify from a registry location and pass 
//  the notification along to that object to either allow it to incorporate the refactoring 
//  operation back into the designer file or give that object a chance to stop the operation 
//  and return feedback to the user via IErrorInfo.
//
// In order to successfully carry out the full refactoring operation, the 
//  IVsHierarchy-implementer is responsible for checking out the files passed in to this 
//  interface as well as those returned from corresponding calls to IVsRefactorNotify methods. 
//
// The IVsHierarchy-implementer is also responsible for raising UI when the operation fails 
//  (e.g. an IVsRefactorNotify-implementer purposefully returns a failure HRESULT+error message
//  to indicate that it does not support any given refactoring operation).
//
//
// The expected flow of operation is as follows:
//
//   1. User invokes symbolic-rename (or any other refactoring operation).
//
//   2. Language-service figures out which code files the operation will affect.
//
//   3. Language-service calls IVsHierarchyRefactorNotify.OnBefore* to tell the hierarchy which 
//      files are going to be affected.
//
//   4. Hierarchies that support generated code determine whether any of the affected files
//      are generated from some other source (e.g. a designer file).
//
//   5. If there are generated files, the hierarchy fetches the IVsRefactorNotify implementer
//      (how is determined by each IVsHiearrchy-implementer – VB/C#/J# does it by QI'ing 
//      the IVsSingleFileGenerator for IVsRefactorNotify, Web Projects do it by QS'ing for 
//      a service that implements the interface). Once the hierarchy has a reference to
//      an IVsRefactorNotify-implementer, it then passes along the equivalent OnBefore* 
//      notification to the IVsRefactorNotify implementer. It does this for each generated file.
//
//   6. IVsRefactorNotify implementers can either stop the operation by returning a failure 
//      HRESULT and setting an ErrorInfo (via IVsUIShell::SetErrorInfo), or they can decide 
//      what designer file(s) the operation will affect and return the set of files to the 
//      caller via the out array of VSITEMIDs. It is worth noting that the 
//      IVsRefactorNotify-implementer should not update the designer file(s) at this point. 
//      The files need to be updated during the second call to the On* method (e.g. 
//      OnGlobalSymbolRenamed). The OnBefore* call is present in order to allow the operation
//      to check out the full list of files required as a unit as well as to allow for
//      the entire operation to be halted before any changes are made if the user decides
//      not to complete it if one of the code-generators can’t consume the refactor operation.
//
//   7. If the IVsRefactorNotify-implementer returns a failure, the hierarchy should alert the
//      user of the error, after which the hierarchy can either continue the operation (see 
//      next step) or return a cancel HRESULT to the language-service in order to halt the refactor
//      operation ["cancel" HRESULTs are E_ABORT, OLE_E_PROMPTSAVECANCELLED,  
//      OLECMDERR_E_CANCELED or HR_E_CSHARP_USER_CANCEL(same as OLECMDERR_E_CANCELED)].
//
//   8. If all IVsRefactorNotify-implementers return successfully or the caller asks the hierarchy
//      to prompt the user to continue on failure and the user chooses to continue, the hierarchy 
//      is responsible for checking out the entire set of affected files (those reported by the 
//      language-service as well as those returned from the IVsRefactorNotify implementers).
//      Note that the IVsHierarchyRefactorNotify-implementer should only check out the
//      designer file if the IVsRefactorNotify-implementer returned it in the out-array 
//      because there may be some refactor-operations that don’t require the designer file
//      to actually make any change (e.g. if a namespace that is stored outside of the designer
//      file chages).
//
//   9. After checking out, the hierarchy returns from the OnBefore* call to the language-service.
//
//  10. The language-service carries out the refactoring operation.
//
//  11. The language-service then calls the hierarchy's On* method (e.g. OnGlobalSymbolRenamed)
//      and the hierarchy notifies all IVsRefactorNotify implementers by calling the
//      equivalent On* method on IVsRefactorNotify, during which time the implementer is
//      expected to make the equivalent refactoring change in the designer file so that the next 
//      time it is asked to generate code, the user's refactoring operation remains intact.
//
//--------------------------------------------------------------------------------------------

[
  uuid(uuid_IVsHierarchyRefactorNotify), 
  version(1.0),
  pointer_default(unique)
]
interface IVsHierarchyRefactorNotify : IUnknown
{
    // Called when a symbol is about to be renamed -- to disallow the rename, return a failure HRESULT.
    //  Note that the "symbol" may actually be more than one occurrence of the same-named symbol if 
    //  the given language allows overloading such as:
    //      void SomeMethod() {}
    //      void SomeMethod(int i) {}
    //
    HRESULT OnBeforeGlobalSymbolRenamed(
        [in] ULONG cItemsAffected,                                  // number of files this rename affected
        [in, size_is(cItemsAffected)] VSITEMID rgItemsAffected[],   // array of itemids identifying which files were affected
        [in] ULONG cRQNames,                                        // count of RQNames passed in. This count can be greater than 1 when an overloaded symbol is being renamed.
        [in, size_is(cRQNames)] LPCOLESTR rglpszRQName[],           // RQName-syntax string that identifies the symbol(s) being renamed.
        [in] LPCOLESTR lpszNewName,                                 // name that the symbol identified by rglpszRQName is being changed to
        [in] BOOL promptContinueOnFail);                            // pass TRUE if the project-system should allow the user the choice of continuing even if a generator returns an error
                                                                    //  indicating that it will not be able to carry out the rename operation.

    // Called after a symbol has been renamed. Note that the "symbol" may actually be more than one
    //  occurrence of the same-named symbol if the given language allows overloading:
    //      void SomeMethod() {}
    //      void SomeMethod(int i) {}
    //
    HRESULT OnGlobalSymbolRenamed(
        [in] ULONG cItemsAffected,                                  // number of files this rename affected
        [in, size_is(cItemsAffected)] VSITEMID rgItemsAffected[],   // array of itemids identifying which files were affected
        [in] ULONG cRQNames,                                        // count of RQNames passed in. This count can be greater than 1 when an overloaded symbol is being renamed.
        [in, size_is(cRQNames)] LPCOLESTR rglpszRQName[],           // RQName-syntax string that identifies the symbol(s) being renamed.
        [in] LPCOLESTR lpszNewName);                                // name that the symbol identified by rglpszRQName is being changed to

    // Called when a method is about to have its params reordered -- to disallow the reorder, return a failure HRESULT.
    //
    HRESULT OnBeforeReorderParams(
        [in] VSITEMID itemid,                                   // item containing the definition which is being reordered
        [in] LPCOLESTR lpszRQName,                              // RQName-syntax string that identifies the method whose params are being reordered
        [in] ULONG cParamIndexes,                               // number of parameters in rgParamIndexes
        [in, size_is(cParamIndexes)] ULONG rgParamIndexes[],    // array of param indexes where the index in this array is the index to which the
                                                                //  param is moving, and the value at that index is where the parameter was before the
                                                                //  reordering (e.g. x(a,b,c) --> x(b,a,c) would be {1,0,2} because the index 0 in this
                                                                //  array appeared at index 1 prior, index 1 in this array was at index 0, and
                                                                //  index 2 was at index 2 prior. 
        [in] BOOL promptContinueOnFail);                        // pass TRUE if the project-system should allow the user the choice of continuing even if a generator returns an error
                                                                //  indicating that it will not be able to carry out the reorder operation.

    // Called after a method has had its params reordered.
    //
    HRESULT OnReorderParams(
        [in] VSITEMID itemid,                                   // item containing the definition which is being reordered
        [in] LPCOLESTR lpszRQName,                              // RQName-syntax string that identifies the method whose params are being reordered
        [in] ULONG cParamIndexes,                               // number of parameters in rgParamIndexes
        [in, size_is(cParamIndexes)] ULONG rgParamIndexes[]);   // array of param indexes where the index in this array is the index to which the
                                                                //  param is moving, and the value at that index is where the parameter was before the
                                                                //  reordering (e.g. x(a,b,c) --> x(b,a,c) would be {1,0,2} because the index 0 in this
                                                                //  array appeared at index 1 prior, index 1 in this array was at index 0, and
                                                                //  index 2 was at index 2 prior. 

    // Called when a method is about to have its params removed -- to disallow the remove, return a failure HRESULT.
    //
    HRESULT OnBeforeRemoveParams(
        [in] VSITEMID itemid,                                   // item containing the definition that is having params removed
        [in] LPCOLESTR lpszRQName,                              // RQName-syntax string that identifies the method having params removed
        [in] ULONG cParamIndexes,                               // number of parameters in rgPararmIndexes
        [in, size_is(cParamIndexes)] ULONG rgParamIndexes[],    // array of param indexes where each value indicates the index of the parameter being removed
        [in] BOOL promptContinueOnFail);                        // pass TRUE if the project-system should allow the user the choice of continuing even if a generator returns an error
                                                                // indicating that it will not be able to carry out the remove operation.

    // Called after a method has had its params removed.
    //
    HRESULT OnRemoveParams(
        [in] VSITEMID itemid,                                   // item containing the definition that is having params removed
        [in] LPCOLESTR lpszRQName,                              // RQName-syntax string that identifies the method having params removed
        [in] ULONG cParamIndexes,                               // number of parameters in rgPararmIndexes
        [in, size_is(cParamIndexes)] ULONG rgParamIndexes[]);   // array of param indexes where each value indicates the index of the parameter being removed

    // Called when a method is about to have params added -- to disallow the add, return a failure HRESULT.
    //
    HRESULT OnBeforeAddParams(
        [in] VSITEMID itemid,                               // item containing the definition that is having params added
        [in] LPCOLESTR lpszRQName,                          // RQName-syntax string that identifies the method having params added
        [in] ULONG cParams,                                 // number of parameters in rgszRQTypeNames, rgszParamNames and rgszDefaultValues
        [in, size_is(cParams)] ULONG rgszParamIndexes[],    // the indexes of the new parameters
        [in, size_is(cParams)] LPCOLESTR rgszRQTypeNames[], // RQName-syntax strings that identify the types of the new parameters
        [in, size_is(cParams)] LPCOLESTR rgszParamNames[],  // the names of the parameters
        [in] BOOL promptContinueOnFail);                    // pass TRUE if the project-system should allow the user the choice of continuing even if a generator returns an error
                                                            //  indicating that it will not be able to carry out the add operation.

    // Called after a method has had its params added.
    //
    HRESULT OnAddParams(
        [in] VSITEMID itemid,                               // item containing the definition that is having params added
        [in] LPCOLESTR lpszRQName,                          // RQName-syntax string that identifies the method having params added
        [in] ULONG cParams,                                 // number of parameters in rgszRQTypeNames, rgszParamNames and rgszDefaultValues
        [in, size_is(cParams)] ULONG rgszParamIndexes[],    // the indexes of the new parameters
        [in, size_is(cParams)] LPCOLESTR rgszRQTypeNames[], // RQName-syntax strings that identify the types of the new parameters
        [in, size_is(cParams)] LPCOLESTR rgszParamNames[]); // the names of the parameters
}

//--------------------------------------------------------------------------------------------
// IVsRefactorNotify 
//
// This interface is optionally implemented by an IVsSingleFileGenerator-implementer or
//  a stand-alone object that registers in a project-specific way in order to know when 
//  refactoring operations (such as symbolic-rename and parameter-reordering) occur. If you 
//  implement this interface and can preserve the intent of the refactoring operation in the 
//  designer-file that created the code-file that is being changed, you should carry out the 
//  change to the designer-file during the OnXXX calls. The OnBeforeXXX calls are present to 
//  give you support for canceling the operation (by returning a failure HRESULT and using 
//  IErrorInfo to communicate the reason why back to the user) and also allowing you to 
//  communicate the need to check out additional files if your generator needs to modify any files
//  to preserve the user’s refactor intent. Note that if you need to change your designer-file 
//  because of the refactor operation, you should return your designer-file in the 
//  prgAdditionalCheckoutVSITEMIDs array. The project system will not check out the designer 
//  file unless you, the IVsRefactorNotify-implementer return in in the out-array.
//
// For more details on the overall flow of operations as it pertains to IVsRefactorNotify, 
//  see the comments above IVsHierarchyRefactorNotify.
//
//The language-service identifies the symbol being changed by passing a string using RQName
//  syntax (RQName stands for Refactor-Qualified Name). The RQName syntax BNF description is
//  as follows:
//
// 
// rq_name := rq_ns | rq_agg | rq_membvar | rq_event | rq_meth | rq_prop
// 
// rq_ns := "Ns" "(" rq_sym_name_list ")"
// 
// rq_agg := "Agg" "(" rq_sym_name_list ")"
// 
// rq_membvar := "Membvar" "(" rq_agg "," rq_sym_name ")"
// 
// rq_event := "Event" "(" rq_agg "," rq_sym_name ")"
// 
// rq_meth := "Meth" "(" rq_agg "," rq_sym_name "," rq_typevarcount "," rq_params ")"
// 
// rq_prop := "Prop" "(" rq_agg "," rq_sym_name "," rq_typevarcount "," rq_params ")"
// 
// rq_params := "Params" "(" rq_param_list ")"
// 
// rq_param_list := rq_param |
//                  rq_param "," rq_param_list
// 
// rq_param := "Param" "(" rq_type_sig ")"
// 
// rq_type_sig := rq_aggtype_sig | 
//                rq_array_sig | 
//                rq_pointer_sig | 
//                rq_param_mod_sig | 
//                rq_typevar_sig | 
//                rq_void_sig | 
//                rq_error_sig | 
//                rq_null_sig
// 
// rq_aggtype_sig := "AggType" "(" rq_agg "," rq_typeparams ")"
// 
// rq_typeparams := "TypeParams" "(" rq_type_sig_list ")"
// 
// rq_type_sig_list := rq_type_sig |
//                     rq_type_sig "," rq_type_sig_list
// 
// rq_array_sig := "Array" "(" rq_rank "," rq_type_sig ")"
// 
// rq_pointer_sig := "Pointer" "(" rq_type_sig ")"
// 
// rq_param_mod_sig := "Ref" "(" rq_type_sig ")" |
//                     "Out" "(" rq_type_sig ")"
// 
// rq_typevar_sig := "TyVar" "(" rq_simple_name ")"
// 
// rq_void_sig := "Void"
// 
// rq_error_sig := "Error" "(" rq_text ")"
// 
// rq_null_sig := "Null"
// 
// rq_sym_name_list := rq_sym_name |
//                     rq_sym_name "," rq_sym_name_list
// 
// rq_sym_name := rq_aggname | rq_nsname | rq_membvarname | rq_methpropname | rq_intfexplname
// 
// rq_nsname := "NsName" "(" rq_simple_name ")"
// 
// rq_aggname := "AggName" "(" rq_simple_name "," rq_typevarcount ")"
// 
// rq_membvarname := "MembvarName" "(" rq_simple_name ")"
// 
// rq_methpropname := rq_methname | rq_propname | rq_eventname
// 
// rq_methname := "MethName" "(" rq_simple_name ")"
// 
// rq_propname := "PropName" "(" rq_simple_name ")"
// 
// rq_eventname := "EventName" "(" rq_simple_name ")"
// 
// rq_intfexplname := "IntfExplName" "(" rq_type_sig "," rq_methpropname ")"
// 
// rq_typevarcount := "TypeVarCnt" "(" rq_number ")"
// 
// rq_simple_name = rq_text
// 
// rq_rank := rq_number
// 
// rq_number := [0-9]+
// 
// rq_text := [any character except ".", "," "(" and ")"]
// 
// 
// Example:
// 
// using System;
// using System.Collections.Generic;
// using System.Text;
// 
// namespace ConsoleApplication				//1
// {
// 	interface ITest<T>				//2
// 	{
// 		void Foo(T t);				//3
// 	}
// 
// 	delegate void MyDel();				//4
// 
// 	class Program : ITest<int>
// 	{
// 		const int i = 5;			//5
// 		string s;				//6
// 		event MyDel e;				//7
// 		static void Main(string[] args)		//8
// 		{
// 		}
// 		void ITest<int>.Foo(int t)		//9
// 		{
// 		}
// 		int this[int i] { get { return 1; } }	//10
// 	}
// }
// 
// namespace Foo.Bar.Blah					//11
// {
// }
// 
// 
// 1: Ns(NsName(ConsoleApplication))
//
// 2: Agg(NsName(ConsoleApplication),AggName(ITest,TypeVarCnt(1)))
//
// 3: Meth(Agg(NsName(ConsoleApplication),AggName(ITest,TypeVarCnt(1))),MethName(Foo),TypeVarCnt(0),Params(Param(TyVar(T))))
//
// 4: Agg(NsName(ConsoleApplication),AggName(MyDel,TypeVarCnt(0)))
//
// 5: Membvar(Agg(NsName(ConsoleApplication),AggName(Program,TypeVarCnt(0))),MembvarName(i))
//
// 6: Membvar(Agg(NsName(ConsoleApplication),AggName(Program,TypeVarCnt(0))),MembvarName(s))
//
// 7: Event(Agg(NsName(ConsoleApplication),AggName(Program,TypeVarCnt(0))),EventName(e))
//
// 8: Meth(Agg(NsName(ConsoleApplication),AggName(Program,TypeVarCnt(0))),MethName(Main),TypeVarCnt(0),Params(Param(Array(1,AggType(Agg(NsName(System),AggName(String,TypeVarCnt(0))),TypeParams())))))
//
// 9: Meth(Agg(NsName(ConsoleApplication),AggName(Program,TypeVarCnt(0))),IntfExplName(AggType(Agg(NsName(ConsoleApplication),AggName(ITest,TypeVarCnt(1))),TypeParams(AggType(Agg(NsName(System),AggName(Int32,TypeVarCnt(0))),TypeParams()))),MethName(Foo)),
//
// 10: Prop(Agg(NsName(ConsoleApplication),AggName(Program,TypeVarCnt(0))),PropName($Item$),TypeVarCnt(0),Params(Param(AggType(Agg(NsName(System),AggName(Int32,TypeVarCnt(0))),TypeParams()))))
//
// 11: Ns(NsName(Foo),NsName(Bar),NsName(Blah))
//--------------------------------------------------------------------------------------------
[
    uuid(uuid_IVsRefactorNotify), 
    version(1.0),
    pointer_default(unique)
]
interface IVsRefactorNotify : IUnknown
{
    // Called when a symbol is about to be renamed -- to disallow the rename, return a failure HRESULT
    //  and set an error-info (via SetErrorInfo) for the IVsHierarchy-implementer to be able to retrieve the
    //  error message to display to the user. Note that the "symbol" may actually be more than one
    //  occurrence of the same-named symbol if the given language allows overloading:
    //      void SomeMethod() {}
    //      void SomeMethod(int i) {}
    //
    HRESULT OnBeforeGlobalSymbolRenamed(
        [in] IVsHierarchy *pHier,                                   // hierarchy of the designer-owned item associated with the code-file that the language service changed
        [in] VSITEMID itemid,                                       // itemid of the designer-owned item associated with the code-file that the language service changed
        [in] ULONG cRQNames,                                        // count of RQNames passed in. This count can be greater than 1 when an overloaded symbol is being renamed.
        [in, size_is(cRQNames)] LPCOLESTR rglpszRQName[],           // RQName-syntax string that identifies the symbol(s) renamed
        [in] LPCOLESTR lpszNewName,                                 // name that the symbol identified by rglpszRQName is being changed to
        [out, retval] SAFEARRAY(VSITEMID)* prgAdditionalCheckoutVSITEMIDs);  // array of VSITEMID's if the RefactorNotify implementer needs to check out any files other than
																	//  the generated-code file to be able to carry out the refactor operation (e.g. the designer-owned file).

    // Called after a symbol has been renamed. Note that the "symbol" may actually be more than one
    //  occurrence of the same-named symbol if the given language allows overloading:
    //      void SomeMethod() {}
    //      void SomeMethod(int i) {}
    //
    HRESULT OnGlobalSymbolRenamed(
        [in] IVsHierarchy *pHier,                           // hierarchy of the designer-owned item associated with the code-file that the language service changed
        [in] VSITEMID itemid,                               // itemid of the designer-owned item associated with the code-file that the language service changed
        [in] ULONG cRQNames,                                // count of RQNames passed in. This count can be greater than 1 when an overloaded symbol is being renamed.
        [in, size_is(cRQNames)] LPCOLESTR rglpszRQName[],   // RQName-syntax string that identifies the symbol(s) renamed
        [in] LPCOLESTR lpszNewName);                        // name that the symbol identified by rglpszRQName is being changed to

    // Called when a method is about to have its params reordered -- to disallow the reorder, return a failure HRESULT
    //  and set an error-info (via SetErrorInfo) for the IVsHierarchy-implementer to be able to retrieve the
    //  error message to display to the user.
    //
    HRESULT OnBeforeReorderParams(
        [in] IVsHierarchy *pHier,                                   // hierarchy of the designer-owned item associated with the code-file that the language service changed
        [in] VSITEMID itemid,                                       // itemid of the designer-owned item associated with the code-file that the language service changed
        [in] LPCOLESTR lpszRQName,                                  // RQName-syntax string that identifies the method whose params are being reordered
        [in] ULONG cParamIndexes,                                   // number of parameters in rgParamIndexes
        [in, size_is(cParamIndexes)] ULONG rgParamIndexes[],        // array of param indexes where the index in this array is the index to which the
                                                                    //  param is moving, and the value at that index is where the parameter was before the
                                                                    //  reordering (e.g. x(a,b,c) --> x(b,a,c) would be {1,0,2} because the index 0 in this
                                                                    //  array appeared at index 1 prior, index 1 in this array was at index 0, and
                                                                    //  index 2 was at index 2 prior. 
        [out, retval] SAFEARRAY(VSITEMID)* prgAdditionalCheckoutVSITEMIDs);  // array of VSITEMID's if the RefactorNotify implementer needs to check out any files other than
																	//  the generated-code file to be able to carry out the refactor operation (e.g. the designer-owned file).

    // Called after a method has had its params reordered.
    //
    HRESULT OnReorderParams(
        [in] IVsHierarchy *pHier,                               // hierarchy of the designer-owned item associated with the code-file that the language service changed
        [in] VSITEMID itemid,                                   // itemid of the designer-owned item associated with the code-file that the language service changed
        [in] LPCOLESTR lpszRQName,                              // RQName-syntax string that identifies the method whose params are being reordered
        [in] ULONG cParamIndexes,                               // number of parameters in rgParamIndexes
        [in, size_is(cParamIndexes)] ULONG rgParamIndexes[]);   // array of param indexes where the index in this array is the index to which the
                                                                //  param is moving, and the value at that index is where the parameter was before the
                                                                //  reordering (e.g. x(a,b,c) --> x(b,a,c) would be {1,0,2} because the index 0 in this
                                                                //  array appeared at index 1 prior, index 1 in this array was at index 0, and
                                                                //  index 2 was at index 2 prior. 

    // Called when a method is about to have its params removed -- to disallow the remove, return a failure HRESULT
    //  and set an error-info (via SetErrorInfo) for the IVsHierarchy-implementer to be able to retrieve the
    //  error message to display to the user.
    //
    HRESULT OnBeforeRemoveParams(
        [in] IVsHierarchy *pHier,                                   // hierarchy of the designer-owned item associated with the code-file that the language service changed
        [in] VSITEMID itemid,                                       // itemid of the designer-owned item associated with the code-file that the language service changed
        [in] LPCOLESTR lpszRQName,                                  // RQName-syntax string that identifies the method having params removed
        [in] ULONG cParamIndexes,                                   // number of parameters in rgPararmIndexes
        [in, size_is(cParamIndexes)] ULONG rgParamIndexes[],        // array of param indexes where each value indicates the index of the parameter being removed
        [out, retval] SAFEARRAY(VSITEMID)* prgAdditionalCheckoutVSITEMIDs);  // array of VSITEMID's if the RefactorNotify implementer needs to check out any files other than
																	//  the generated-code file to be able to carry out the refactor operation (e.g. the designer-owned file).

    // Called after a method has had its params removed.
    //
    HRESULT OnRemoveParams(
        [in] IVsHierarchy *pHier,                               // hierarchy of the designer-owned item associated with the code-file that the language service changed
        [in] VSITEMID itemid,                                   // itemid of the designer-owned item associated with the code-file that the language service changed
        [in] LPCOLESTR lpszRQName,                              // RQName-syntax string that identifies the method having params removed
        [in] ULONG cParamIndexes,                               // number of parameters in rgPararmIndexes
        [in, size_is(cParamIndexes)] ULONG rgParamIndexes[]);   // array of param indexes where each value indicates the index of the parameter being removed

    // Called when a method is about to have params added -- to disallow the add, return a failure HRESULT
    //  and set an error-info (via SetErrorInfo) for the IVsHierarchy-implementer to be able to retrieve the
    //  error message to display to the user.
    //
    HRESULT OnBeforeAddParams(
        [in] IVsHierarchy *pHier,                                   // hierarchy of the designer-owned item associated with the code-file that the language service changed
        [in] VSITEMID itemid,                                       // itemid of the designer-owned item associated with the code-file that the language service changed
        [in] LPCOLESTR lpszRQName,                                  // RQName-syntax string that identifies the method having params added
        [in] ULONG cParams,                                         // number of parameters in rgszRQTypeNames, rgszParamNames and rgszDefaultValues
        [in, size_is(cParams)] ULONG rgszParamIndexes[],            // the indexes of the new parameters
        [in, size_is(cParams)] LPCOLESTR rgszRQTypeNames[],         // RQName-syntax strings that identify the types of the new parameters
        [in, size_is(cParams)] LPCOLESTR rgszParamNames[],          // the names of the parameters
        [out, retval] SAFEARRAY(VSITEMID)* prgAdditionalCheckoutVSITEMIDs);  // array of VSITEMID's if the RefactorNotify implementer needs to check out any files other than
																	//  the generated-code file to be able to carry out the refactor operation (e.g. the designer-owned file).

    // Called after a method has had its params added.
    //
    HRESULT OnAddParams(
        [in] IVsHierarchy *pHier,                           // hierarchy of the designer-owned item associated with the code-file that the language service changed
        [in] VSITEMID itemid,                               // itemid of the designer-owned item associated with the code-file that the language service changed
        [in] LPCOLESTR lpszRQName,                          // RQName-syntax string that identifies the method having params added
        [in] ULONG cParams,                                 // number of parameters in rgszRQTypeNames, rgszParamNames and rgszDefaultValues
        [in, size_is(cParams)] ULONG rgszParamIndexes[],    // the indexes of the new parameters
        [in, size_is(cParams)] LPCOLESTR rgszRQTypeNames[], // RQName-syntax strings that identify the types of the new parameters
        [in, size_is(cParams)] LPCOLESTR rgszParamNames[]); // the names of the parameters
}

[
  uuid(uuid_IVsMonitorSelection2), 
  version(1.0),
  pointer_default(unique)
]
interface IVsMonitorSelection2 : IUnknown
{
    // Retrieve the VSSELELEMID ID for a VsPackage defined Element of Selection.
    // This is an ID equivalent to SEID_WindowFrame or SEID_ResultList. In order
    // to define a new Selection Element a GUID needs to be registered under
    // HKLM\Software\Microsoft\VisualStudio\<version>\SelectionElements\ as a subkey.
    // For example:
    //     HKLM\Software\Microsoft\VisualStudio\8.0\
    //      SelectionElements\
    //          {...guid1...}\
    //              @ = "Team System Active Portfolio Project"
    //          {...guid2...}\
    //              @ = "Team System Active Team Foundation Server"
    HRESULT GetElementID([in] REFGUID rguidElement, [out] VSSELELEMID *pElementId);

    // The Empty Selection Context manages the selection when the IDE is empty;
    // when there otherwise is no other window active. This Selection Context
    // is always the first Selection Context activated. It can be used to push
    // Elements of Selection (VSSELELEMID) that are globally maintained. Such
    // global Elements of selection should only be set via the EmptySelectionContext
    // object and should not be set on the IVsTrackSelectionEx interface
    // associated with individual IVsWindowFrame objects.
    HRESULT GetEmptySelectionContext([out] IVsTrackSelectionEx **ppEmptySelCtxt);
}

[
  uuid(uuid_IVsToolsOptions),
  version(1.0),
  pointer_default(unique)
]
interface IVsToolsOptions : IUnknown
{
    // Returns whether the Tools Options dialog is currently open.
    // REVIEW: should this be a property?
    HRESULT IsToolsOptionsOpen([out] BOOL* pfOpen);

    // A Tools Options node can be associated with a command UI context by adding a
    // "VisibilityCmdUIContexts" subkey containing entries whose names are the context GUIDs.
    // It then becomes visible only if one or more of those contexts are active.  This method
    // re-evaluates the visibility of each page based on the currently active contexts.
    HRESULT RefreshPageVisibility();
}

[
    uuid(uuid_SVsToolsOptions)
]
interface SVsToolsOptions : IUnknown
{
}

cpp_quote("#define SID_SVsToolsOptions IID_SVsToolsOptions")


//-----------------------------------------------------------------------------
// IVsDeployableProjectCfg2
//-----------------------------------------------------------------------------
// Implemented by a project system that supports Deploying project outputs
// (not to be confused with a project that can EnumOutputs and thus can be
// deployed by a deployment project).
//
// IVsDeployableProjectCfg2 extends IVsDeployableProjectCfg
//
[
    uuid(uuid_IVsDeployableProjectCfg2),
    version(1.0),
    pointer_default(unique)
]
interface IVsDeployableProjectCfg2 : IVsDeployableProjectCfg
{
    // called before actual deploy
    HRESULT StartCleanDeploy([in] IVsOutputWindowPane *pIVsOutputWindowPane, [in] DWORD dwOptions);
}

//---------------------------------------------------------------------------
// IVsFontAndColorStorage2
//---------------------------------------------------------------------------
// Implemented by the Environment.
// Interface retrieved by 
//      pSP->QueryService(SID_SVsFontAndColorStorage, IID_IVsFontAndColorStorage2, (void**)&pObj));
//  Allows font and color info to be stored and retrieved.  This is
//  implemented by the central storage mechanism and QI'd for by the font/
//  color categories. 
[
    uuid(uuid_IVsFontAndColorStorage2),
    version(1.0),
    pointer_default(unique)
]
interface IVsFontAndColorStorage2 : IUnknown
{
    HRESULT RevertFontToDefault();
    HRESULT RevertItemToDefault([in] LPCOLESTR szName);
    HRESULT RevertAllItemsToDefault();
}

// Additional options for IOleComponentUIManager::ShowContextMenu's dwCompRole parameter
// Combine these flags with the OLEROLE enumeration.
// Note that if the role is OLEROLE_UNKNOWN (-1), then these flags cannot be used and
// they are ignored.
enum __VSSHOWCONTEXTMENUOPTS
{
    VSCTXMENU_SELECTFIRSTITEM   = 0x00010000, // Automatically select the first item
    VSCTXMENU_SHOWUNDERLINES    = 0x00020000, // Show keyboard mnemonic underlines
    VSCTXMENU_SUPPORTSTYPEAHEAD = 0x00040000  // supports typeahead, should also be a sorted dynamic item list
};
typedef DWORD VSSHOWCONTEXTMENUOPTS;

// This interface is optionally implemented by an IVsDocOutlineProvider-implementor 
// if it needs to TranslateAccelerator differently from default shell translation
[
    uuid(uuid_IVsDocOutlineProvider2),
    version(1.0),
    pointer_default(unique)
]
interface IVsDocOutlineProvider2 : IUnknown
{
    // return S_OK if no further translation is required
    //        S_FALSE if you want shell to translate the message
    HRESULT TranslateAccelerator([in]LPMSG lpMsg);
};

enum __VSCREATEWEBBROWSER2
{
    /********************************************** defined in vsbrowse.idl
    VSCWB_AutoShow              = 0x00000001,
    VSCWB_AddToMRU              = 0x00000002,
    VSCWB_ReuseExisting         = 0x00000010,
    VSCWB_ForceNew              = 0x00000020, // force create
    VSCWB_FrameMdiChild         = 0x00000000, // default
    VSCWB_FrameFloat            = 0x00000040,
    VSCWB_FrameDock             = 0x00000080,
    VSCWB_StartHome             = 0x00000100,
    VSCWB_StartSearch           = 0x00000200,
    VSCWB_StartCustom           = 0x00000400,
    VSCWB_NoHistory             = 0x00010000, // Suppress the *previous* page in the browser's back/forward list
    VSCWB_NoReadCache           = 0x00020000,
    VSCWB_NoWriteToCache        = 0x00040000,
    VSCWB_AllowAutosearch       = 0x00080000,
    VSCWB_OptionNoDocProps      = 0x00000000, // default
    VSCWB_OptionShowDocProps    = 0x01000000,
    VSCWB_OptionCustomDocProps  = 0x02000000,
    VSCWB_OptionDisableFind     = 0x04000000,
    VSCWB_OptionDisableDockable = 0x08000000,
    VSCWB_OptionDisableStatusBar= 0x10000000,

    VSCWB_StartURLMask          = 0x00000F00,
    VSCWB_NavOptionMask         = 0x000F0000,
    VSCWB_OptionsMask           = 0xFF000000
    **********************************************/ 
    VSCWB_NoHistoryThisPage     = 0x00100000, // Suppress *this* page in the browser's back/forward list
    VSCWB_NavOptionMask2        = 0x001F0000
};




//=----------------------------------------------------------------------=
// IVSMDTypeResolutionService
//=----------------------------------------------------------------------=
// This is an interface that provides access to a ITypeResolutionService object
// through native code.  As a service, this may be queried
// from the service provider returned from IVsProject::GetItemContext.  The
// default implementation of DynamicTypeService will first get the item context
// and query for this service before creating a default implementation of
// ITypeResolutionService.
//
[
object,
uuid(uuid_IVsMDTypeResolutionService),
pointer_default(unique)
]
interface IVSMDTypeResolutionService : IUnknown
{
    [propget]
    HRESULT TypeResolutionService([out, retval] IDispatch **ppTrs);
};

cpp_quote("#define SID_SVSMDTypeResolutionService IID_IVSMDTypeResolutionService")







//---------------------------------------------------------------------------
// IVsUIShellOpenDocument2
//---------------------------------------------------------------------------
// Implemented by the Environment.
// Extends IVsUIShellOpenDocument and can be QI'd from that service.
typedef struct _VSDEFAULTPREVIEWER
{
    BSTR bstrDefBrowserPath; 
    BSTR bstrDefBrowserDisplayName; 
    BOOL fIsInternalBrowser;
    BOOL fIsSystemBrowser;
    VSPREVIEWRESOLUTION defRes;
} VSDEFAULTPREVIEWER;


[
    uuid(uuid_IVsUIShellOpenDocument2),
    version(1.0),
    pointer_default(unique)
]
interface IVsUIShellOpenDocument2 : IUnknown
{
    // Get list of Default Previewers. This is the list of previewers that would be launched
    // if IVsUIShellOpenDocument::OpenStandardPreviewer(NULL) is called.
    // If   celt is zero and pcActual is not NULL, the number of standard previewers 
    //   is returned in *pcActual.
    // If   celt is not zero, rgDefaultPreviewers must not be NULL, or E_POINTER is returned.
    //
    // An   extremely common pattern is something like (omitting error checks for readability):
    //
    // hr   = pIVsUIShellOpenDocument2->GetDefaultPreviewers(0, NULL, &cExpected);
    // prgpDefViewers = ::CoTaskMemAlloc(cExpected * sizeof(VSDEFAULTPREVIEWER));
    // hr   = pIVsUIShellOpenDocument2->GetDefaultPreviewers(cExpected, prgpDefViewers, &cActual);

    HRESULT GetDefaultPreviewers([in] ULONG celt,
        [in, out, size_is(celt)] VSDEFAULTPREVIEWER rgDefaultPreviewers[],
        [out] ULONG *pcActual);
}


////--------------------------------------------------------------------------------------------
//// IVsFilterNewProjectDlg
////
//// Implemented by filters that want to filter items from the New Project dialog box.
//// Use SVsRegisterNewDialogFilters to register the filter.
////--------------------------------------------------------------------------------------------
[
    uuid(uuid_IVsFilterNewProjectDlg), 
    version(1.0),
    pointer_default(unique)
]
interface IVsFilterNewProjectDlg : IUnknown
{
    HRESULT FilterTreeItemByLocalizedName([in] LPCOLESTR pszLocalizedName, [out] BOOL *pfFilter);
    HRESULT FilterTreeItemByTemplateDir([in] LPCOLESTR pszTemplateDir, [out] BOOL *pfFilter);
    HRESULT FilterListItemByLocalizedName([in] LPCOLESTR pszLocalizedName, [out] BOOL *pfFilter);
    HRESULT FilterListItemByTemplateFile([in] LPCOLESTR pszTemplateFile, [out] BOOL *pfFilter);
};

////--------------------------------------------------------------------------------------------
//// IVsRegisterNewDialogFilters 
////
//// Implemented by the shell. This interface is retrieved via IServiceProvider::QueryService on 
////  a IServiceProvider. Use it to install a custom filter for the AddNewProject Dialog or
////  the AddNewItemDialog. Your filter must implement the IVsFilterAddProjectItemDlg interface
////  or the IVsFilterAddProjectDlg interface.
////--------------------------------------------------------------------------------------------
[
    uuid(uuid_IVsRegisterNewDialogFilters), 
    version(1.0),
    pointer_default(unique)
]
interface IVsRegisterNewDialogFilters : IUnknown
{
    HRESULT   RegisterNewProjectDialogFilter([in]IVsFilterNewProjectDlg* pFilter,[out] VSCOOKIE *pdwFilterCookie);
    HRESULT UnregisterNewProjectDialogFilter([in]VSCOOKIE dwFilterCookie);
    HRESULT   RegisterAddNewItemDialogFilter([in]IVsFilterAddProjectItemDlg* pFilter,[out] VSCOOKIE *pdwFilterCookie);
    HRESULT UnregisterAddNewItemDialogFilter([in]VSCOOKIE dwFilterCookie);
};


[uuid(uuid_SVsRegisterNewDialogFilters)]
interface SVsRegisterNewDialogFilters : IUnknown
{
};

cpp_quote("#define SID_SVsRegisterNewDialogFilters IID_SVsRegisterNewDialogFilters")


////--------------------------------------------------------------------------------------------
//// IVsWebBrowserUser2
////
//// Implemented by any client of the IVsWebBrowsingService that wants to offer services
//// to the hosted browser control.  For instance, if the client wants to provide a 
//// custom implementation of IInternetSecurityManager, it should implement this interface
//// and IServiceProvider.  This interface should be implemented on the object passed as
//// pUser to IVsWebBrowsingService.CreateWebBrowser.  The IServiceProvider implementation
//// should return the custom security manager when queried for SID_SInternetSecurityManager.
////--------------------------------------------------------------------------------------------
[
    uuid(821ABD48-96DC-4315-A2C4-82A7239B8166),
    version(1.0),
    pointer_default(unique)
]
interface IVsWebBrowserUser2 : IUnknown
{
    HRESULT GetWebBrowserContext([out] IServiceProvider** ppServiceProvider);
};

//--------------------------------------------------------------------------------------------
// IVsHasRelatedSaveItems
// Provides additional save items.
// Implemented by clients that want to provide additional items to appear in the Save Changes
// dialog or to be saved when a specific item is saved.
// The interface is QI-ed from the following objects:
// - the docdata of the item
// - the lock holders for the item
// - the hierarchy owning the item
// For instance, a lock holder keeping a lock on a document will be closed (by calling
// CloseDocumentHolder) when the document is closed.  If the lock holder closes additional
// items in its CloseDocumentHolder implementation, the lock holder can implement the
// interface and provide additional items to be included in the Save Changes dialog.
//--------------------------------------------------------------------------------------------
[
    uuid(uuid_IVsHasRelatedSaveItems),
    version(1.0),
    pointer_default(unique)
]
interface IVsHasRelatedSaveItems : IUnknown
{
    // If celt is zero and pcActual is not NULL, the number of VSSAVETREEITEM is returned in pcActual.
    // If celt is not zero, rgSaveTreeItems must not be NULL.
    //
    // An extremely common pattern is something like (omitting error checks for readability):
    //
    // hr = pIVsHasRelatedSaveItems->GetRelatedSaveTreeItems(saveItem, 0, NULL, &cExpected);
    // prgSaveTreeItems = ::CoTaskMemAlloc(cExpected * sizeof(VSSAVETREEITEM));
    // hr = pIVsHasRelatedSaveItems->GetRelatedSaveTreeItems(saveItem, cExpected, prgSaveTreeItems, &cActual);
    HRESULT GetRelatedSaveTreeItems([in] VSSAVETREEITEM saveItem, [in] ULONG celt, [in, out, size_is(celt)] VSSAVETREEITEM rgSaveTreeItems[], [out] ULONG *pcActual);
}
