/****************************************************************************
*  The VSSHELL Interfaces
*  Copyright (c) Microsoft Corporation, All Rights Reserved
****************************************************************************/

#ifndef INTEROPLIB

// Imports - all imports should go here (inside the ifndef)
import "oaidl.idl";
import "vsshell.idl";
import "vsshell2.idl";
import "vsshell80.idl";
import "vsshell90.idl";
import "vsshell100.idl";
import "objext.idl";
import "olecm.idl";
import "VsPlatformUI.idl";
import "IVsSccManager2.idl";
import "textfind.idl";

#endif

/****************************************************************************

***** General notes for updating this file

***** Proxy Stub

If you modify anything in here, you may need to rebuild the proxy-stub,
msenv110p.dll, and update its registration file,
SetupAuthoring\env\Registry\msenv110p.ddr. To do that, once this file has been
built and published, build from env\msenv\proxies and observe the build output.

If you need to omit something from the proxy/stub file, then put it inside an
#ifndef PROXYSTUB_BUILD/#endif block

There is no need to define GUIDs in external header files such as
vsshelluuids.h. Instead, define the GUID directly within the [uuid(...)]
attribute and use __uuidof in native code.

***** Primary Interop Assemblies

If you modify anything in here, you may need to rebuild the primary interop
assemblies. To do that, once this file has been built and published, build
from vscommon\pias using: 'msbuild pias.nativeproj'

***** PreserveSig

Prefer "nopreservesig", which is the default for all new interfaces, because
it creates cleaner managed code. Managed implementations are free to throw
exceptions which will automatically be translated to HRESULTs in the CLR's
COM interop layer. Native implementations will return HRESULTs and they will
be converted to exceptions for managed callers.

Do not create methods returning S_FALSE. Instead use an additional
"[out] VARIANT_BOOL*" or "[out,retval] VARIANT_BOOL*" argument.

***** Interface inheritance

You may derive new interfaces from existing ones, but avoid mixing
"preservesig" (old) with "nopreservesig" (new). Derive from an older interface
if all of the methods in your interface match the preservesig attributes of the
older interface.

Remember, when implementing a derived interface in C++, you must implement
QueryInterface for the base interface(s) too.

***** Enumerators and bitwise flags passed as parameters:

When a parameter must be exactly one of a set of values (a true enumerator),
the values should be defined and used as follows:

typedef enum __VSSAMPLETYPE
{
    ST_THISTYPE     = 0,   // first value should be zero or one, except
    ST_THATTYPE     = 1,   // in special cases, and following values
    ST_THEOTHERTYPE = 2,   // should use consecutive numbers
} VSSAMPLETYPE;

interface IVsSample : IUnknown
{
    HRESULT SampleMethod([in] VSSAMPLETYPE stType);
}

When a parameter must be exactly one of a set of values (a true enumerator),
and is considered a PROPID, the values should be defined and used as follows:

enum __VSSAMPLEPROPID
{
    VSSAMPPROPID_LAST     = -7000,  // first value should be a unique
    VSSAMPPROPID_This     = -7000,  // number not used by any other
    VSSAMPPROPID_That     = -7001,  // PROPID, and following values
    VSSAMPPROPID_FIRST    = -7001,  // should use consecutive numbers
};
typedef LONG VSSAMPLEPROPID;

interface IVsSample : IUnknown
{
    HRESULT GetProperty([in] VSSAMPLEPROPID propid, [out,retval] VARIANT *pvar);
    HRESULT SetProperty([in] VSSAMPLEPROPID propid, [in] VARIANT var);
}

When a parameter can be none of or a combination of values (bitwise),
the values should be defined and used as follows:

enum __VSSAMPLEOPTS
{
    SO_THISOPTION     = 0x00000001,   // first value should be one,
    SO_THATOPTION     = 0x00000002,   // following values should use
    SO_THEOTHEROPTION = 0x00000004,   // consecutive powers of two
};
typedef DWORD VSSAMPLEOPTS;

interface IVsSample : IUnknown
{
    HRESULT SampleMethod([in] VSSAMPLEOPTS grfOptions);
}

***** Defining properties

Define properties as follows:

interface IVsSample : IUnknown
{
    [propget] HRESULT Foo([out, retval] BSTR *pbstrFoo);
    [propput] HRESULT Foo([in] LPCOLESTR strFoo);
}

Using [propget], [propput] and [out, retval] makes the interface easier
to implement and consume in managed code.

Note: The example above shows a case where the get/put methods accept slightly different
argument types (BSTR versus LPCOLESTR). As long as the equivalent interop types are the
same, this is fine (MarshalAs[..] attributes will be added as necessary). However, this
is typically seen only for string arguments.

***** Array typed args

Pass array type arguments (both in and out) using [] and size_is when the corresponding
size argument is present. You must have the array size as an argument for interop to
work correctly.

interface IVsSample : IUnknown
{
    HRESULT MethodPassesInArray([in] int cItems, [in, size_is(cItems)] int prgiItems[]);
}

DO NOT use [in] int piItems[].

For simple element types, consider using SAFEARRAY: e.g. SAFEARRAY(VARIANT_BOOL),
SAFEARRAY(BSTR), SAFEARRAY(INT), etc. because they interop cleanly to managed code, but
note that there is additional memory allocation and it may not be appropriate for high-
performance methods. Also see the following note.

******* SAFEARRAY(IVsFoo*)

SAFEARRAY(IVsFoo*) will cause MIDL warning 2456:
    SAFEARRAY(interface pointer) doesn't work using midl generated proxy

If you know for sure that implementions will never will never need to be called cross
apartment (cross thread/process), then you can add [local] to the method.

Alternatively, consider creating a custom IEnumXXX interface.

****** Strings

Use "[in] LPCOLESTR" instead of "[in] BSTR"

for faster marshaling and more convenience to native callers.
(But continue to use "[out] BSTR*" for out args.)

Generally, you don't need to specify [in,string] for NUL-terminated strings
because most of the "pointer to character" typedefs are already attributed with
[string]. (e.g. "typedef [string] const OLECHAR *LPCOLESTR")

******* Boolean

Use VARIANT_BOOL instead of BOOL because it interops as System.Boolean instead
of System.Int

However, exercise caution when assigning or comparing to/from C++ bool in native
code because VARIANT_BOOL is typedef'd as a short and VARIANT_TRUE is ((short)-1)

******* Optional (may be null) args

Use [in,unique] for optional input arguments which may be NULL.
Note that pointer_default(unique) does NOT do this automatically.

Do not use [out,unique] because unique cannot be applied to [out]-only top-level
pointer parameters. However, you can use [in,out,unique].

Do not use [optional]. It only works with VARIANT anyway and it's not
obvious for managed coders.

******* [out] NonNullableType*

Note that arguments of the type "[out] Foo* pFoo", where Foo is a "non-nullable
type" such as int, double, VARIANT_BOOL, BSTR, will be converted to
"out Foo[] pFoo" in managed code. This is a non-standard conversion applied by
an IL transformation step during the build for the interop assembly.

******* Service GUIDs

Define service GUIDs via an empty interface derived from IUnknown
and put it inside an #ifndef PROXYSTUB_BUILD/#endif block

******* HWNDs, HANDLE, and other non-marshalable types

Take care if you define an interface with HWND, HGDIOBJ or other Win32
handle types. These typically need to be marked [local] since they
cannot cross apartment (specifically, process) boundaries.

****************************************************************************/

#include "vsshelluuids.h"

// forward declarations
interface IVsNewDocumentStateContext;
interface IVsSccManager2;
interface IVsTask;
interface IVsHierarchyManipulationStateContext;

enum __VSPROPID5
{
    /********************************************** defined in vsshell.idl
    VSPROPID_LAST                          = -8000,
    VSPROPID_SolutionDirectory         = -8000, // BSTR directory where solution file is saved
    VSPROPID_SolutionFileName              = -8001, // BSTR full path to solution file
    VSPROPID_UserOptionsFileName           = -8002, // BSTR full path to user options file
    VSPROPID_SolutionBaseName              = -8003, // BSTR (Get/Set) base name of solution file
    VSPROPID_IsSolutionDirty               = -8004, // BOOL is solution file dirty
    VSPROPID_IsSolutionOpen            = -8005, // BOOL is a solution file open
    VSPROPID_ProjectCount                  = -8006, // I4 count of projects open in solution
    VSPROPID_RegisteredProjExtns           = -8007, // BSTR semicolon-separated list of all project extensions
    VSPROPID_OpenProjectFilter         = -8008, // BSTR filter/entension list used in Open Project dialog
    VSPROPID_FileDefaultCodePage           = -8009, // I4 codepage for saving files (CP_ACP/CP_WINUNICODE)
    VSPROPID_SolutionFileNameBeingLoaded = -8010,   // BSTR full path to file being opened (valid only during open)
    VSPROPID_SolutionNodeCaption           = -8011, // BSTR caption for solution node in Project Explorer
    VSPROPID_IsSolutionOpening         = -8013, // BOOL is a solution file being opened
    VSPROPID_IsSolutionSaveAsRequired      = -8014, // BOOL will saving the solution require a Save As dialog
    VSPROPID_CountOfProjectsBeingLoaded  = -8015,   // I4 count of projects in file being opened (valid only during open)
    VSPROPID_SolutionPropertyPages     = -8016, // BSTR a semi-colon delimited list of clsid's of sln level prop pages
    VSPROPID_FIRST                     = -8016
    ********************************************** defined in vsshell80.idl
    VSPROPID_IsSolutionNodeHidden       = -8017, // BOOL True if the sln node is hidden in the IDE
    VSPROPID_DeferredSaveSolution       = -8018, // BOOL is solution "zero-impact" (permanent save is performed explicitly via File.SaveAll)?
    VSPROPID_SimplifiedConfigurations   = -8019, // BOOL True if the solution is in simplified configuration mode
    VSPROPID_IsSolutionClosing          = -8020, // BOOL is a solution file being closed
    VSPROPID_IsAProjectClosing          = -8021, // IUnknown of IVsHierarchy of project being closed
    VSPROPID_IsSolutionOpeningDocs      = -8022, // BOOL is the solution re-opening the documents that were open when the solution was last closed?
    VSPROPID_IsOpenNotificationPending  = -8023, // BOOL is the OnAfterOpenSolution notification pending (is a new project being created with a new solution)?
    VSPROPID_ProjectLoadSecurityDialogState = -8024, // I4, state of the project load security dialog kept between different lang packages
    VSPROPID_SolutionUserFileCreatedOnThisComputer = -8025, // BOOL, True if the .suo file accompanying the solution file was originally created on the same
                                                            // computer it's being opened on. Check inside IVsPersistSolutionOpts.ReadUserOptions. Read only.
    VSPROPID_NewProjectDlgPreferredLanguage = -8026, // BSTR, preferred language for the New Project dialog; if there is no preferred language an empty length string is returned.
                                                     // If there is a preferred language, then the non-preferred language project types are displayed under an "Other Languages" node in the New Project dialog. The preferred language is set by the
                                                     // user's choice of development settings in the "Import and Export Settings" dialog. Any project type can designate itself as a "Language" project by registering a "DeveloperActivity" reg value
                                                     // with the string for their language (e.g. "VB", "VC#", "VC++", "VJ#") under their top-level template directories for the New Project Dialog, e.g.:
                                                     // [HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\VisualStudio\8.0\NewProjectTemplates\TemplateDirs\{FFFFFFFF-EEE-DDDD-CCCC-BBBBBBAAAAAA}\/1] "DeveloperActivity"="MYLANG"
                                                     // The Language Project can create its own Developer Settings Profile .vssettings file with the following section:
                                                     // <Category name="Environment_NewProjectDialogPreferredLanguage" Category="{77E22C0C-9F4A-4bfb-AD3A-3F3F4711E9ED}" Package="{DA9FB551-C724-11d0-AE1F-00A0C90FFFC3}" RegisteredName="Environment_NewProjectDialogPreferredLanguage">
                                                     //   <PropertyValue name="HasNewProjectDialogPreferredLanguage">true</PropertyValue>
                                                     //   <PropertyValue name="NewProjectDialogPreferredLanguage">MYLANG</PropertyValue>
                                                     // </Category>
                                                     // Occurrences of "MYLANG" would be replaced with the appropriate string for the language.
    VSPROPID_FIRST2                     = -8026
    ********************************************** defined in vsshell90.idl
    VSPROPID_IsSavingOnClose            = -8027,
    VSPROPID_FIRST3                     = -8027
    ********************************************** defined in vsshell100.idl
    VSPROPID_NoFrameworkDialogState             = -8028,    // I4, the state of the project load security dialog kept between different language packages.
    VSPROPID_IsInBackgroundIdleLoadProjectBatch = -8029,    // BOOL, TRUE if Visual Studio is currently loading a batch of pending projects triggered in the background at idle.
                                                            //    IVsSolutionLoadEvents::OnBeforeLoadProjectBatch(TRUE) has been called
    VSPROPID_IsInSyncDemandLoadProjectBatch     = -8030,    // BOOL, TRUE if Visual Studio is currently loading a batch of pending projects synchronously triggered
                                                            //    by some user action/command invocation that requires a set of projects to be loaded.
                                                            //    IVsSolutionLoadEvents::OnBeforeLoadProjectBatch(FALSE) has been called.
    VSPROPID_IsSolutionFullyLoaded              = -8031,    // BOOL, TRUE if all projects have been loaded by the Background Solution Load feature.
    VSPROPID_BaseSolutionExplorerCaption        = -8032,    // BSTR, Gets or sets the base caption for the Solution Explorer tool window. The default is "SolutionExplorer".
                                                            // The full caption is built by concatenating
                                                            // VSPROPID_BaseSolutionExplorerCaption and VSPROPID_SolutionExplorerCaptionSuffix.
    VSPROPID_SolutionExplorerCaptionSuffix      = -8033,    // BSTR, gets or sets the suffix caption for the Solution Explorer tool window. The default is VT_Empty.
                                                            // The full caption is built by concatenating
                                                            // VSPROPID_BaseSolutionExplorerCaption and VSPROPID_SolutionExplorerCaptionSuffix.
    VSPROPID_SolutionExplorerCaption            = -8034,    // BSTR, gets the full caption for the Solution Explorer tool window. The full caption is built by concatenating
                                                            // VSPROPID_BaseSolutionExplorerCaption and VSPROPID_SolutionExplorerCaptionSuffix.
    VSPROPID_AddNewProjectAsSibling             = -8035,    // BOOL, TRUE if new projects should be added on the sibling directory of the solution.
    VSPROPID_ActiveSolutionLoadManager          = -8036,    // IUnknown, gets or sets a pointer to the active Solution Load Manager. The default is NULL.
                                                            //    A Solution Load Manager is able to control how projects are loaded during
                                                            //    the Solution Open operation. It can control whether projects are loaded
                                                            //    immediately, loaded in the background (at idle), left to be loaded if needed,
                                                            //    or set to stay unloaded. A Solution Load Manager is expected to implement IVsSolutionLoadManager.
                                                            //    A common approach is to have the Solution Load Manager package AutoLoad for the
                                                            //    SolutionOpening UIContext, for example, [ProvideAutoLoad(UIContextGuids.SolutionOpening)].
                                                            //    This property may also be set during IVsSolutionLoadEvents::OnBeforeOpenSolution or
                                                            //    during IVsPersistSolutionProps::ReadSolutionProps for the pre Solution section.
    VSPROPID_FIRST4                         = -8036
    **********************************************/
    VSPROPID_SolutionFileExt                = -8037,  // BSTR - solution file extension (default - ".sln");
    VSPROPID_UserOptsFileExt                = -8038,  // BSTR - solution options file extension (default - ".suo");
    VSPROPID_FaultedProjectCount            = -8039,  // INT - Number of faulted projects in the solution

    VSPROPID_ProjectFaultResolutionContext  = -8040,  // IUnknown of IVsPropertyBag that represents the current project fault resolution context.
                                                      // Read only (but the returned property bag is mutable). This is only non-null if user
                                                      // had just performed a gesture that requires a batch of faulted projects to be resolved.
                                                      // In this case, before invoking IVsProjectFaultResolver::ResolveFault for the first time,
                                                      // a new empty property bag is created and assigned to this property, and the property
                                                      // remains that way for all calls to ResolveFault that logically belong to that gesture.
                                                      // After the last call to ResolveFault, the property is set back to null.
                                                      // Thus, arbitrary data can be preserved and passed between ResolveFault calls in a single
                                                      // gesture. Typically, this is used when fault resolution requires some modal UI prompt,
                                                      // and that provides a "Don't ask me for the remaining projects" flag - this flag can be
                                                      // stored in the property bag along with user's input, and queried on further calls to
                                                      // ResolveFault to suppress the UI and apply the same choice to all projects.
                                                      // See IVsProjectFaultResolver (below) for more info.

    VSPROPID_SolutionViewModel              = -8041,  // IUnknown of IVsUIDatasource that contains the view model for some solution properties.
                                                      // This is primarily used by solution navigator.
    VSPROPID_IsOpeningProjectUserInitiated  = -8042,  // Indicates that a project load/reload is in flight when receiving the solution load event OnAfterOpenProject.
                                                      // This property can be used to distinguish between a user loaded project (e.g. User reloaded or Add existing/new project)
                                                      // vs a project being loaded in the background via the Asynchronous Solution Load feature. 
                                                      // Using the fAdded flag from OnAfterOpenProject does not distinguish these two conditions.
                                                      // fAdded only indicates if a project was loaded before or after the OnAfterOpenSolution event.
                                                      
    // !!!! NOTE !!!!   THIS MUST BE THE SAME AS THE LAST PROP DEFINED
    // when this is extended in the next version idl, uses of it must be changed to the new value
    VSPROPID_FIRST5                         = -8042
};
typedef [public] DWORD VSPROPID5;

// this is an extension of VSSPROPID4, see vsshell100.idl, vsshell90.idl, vsshell80.idl, vsshell.idl
enum __VSSPROPID5
{
    VSSPROPID_LastActiveInputTick          = -9066, // UI4 - DWORD last recorded tick value for user input message
                                                    // In order to avoid noise, property change events are not raised for VSSPROPID_LastActiveInputTick
    VSSPROPID_ProvisionalDelayMilliseconds = -9067, // I4, Read-Only.  Used when implementing single-click preview.  This the number of
                                                    // milliseconds to wait before previewing a selected item.
    VSSPROPID_ReleaseVersion               = -9068, // BSTR, Read-Only. The build version of the release and the branch/machine/user information used to build it (e.g. "10.0.30319.01 RTMRel" or "10.0.30128.1 BRANCHNAME(COMPUTERNAME-USERNAME)"). This is the same as the release string shown in Help/About.
    VSSPROPID_ReleaseDescription           = -9069, // BSTR, Read-Only. What this release is branded as, e.g. CTP, Beta, RTM, etc.
    VSSPROPID_EnablePreviewTab             = -9070, // BOOL (default true).  Is the preview tab enabled?
    VSSPROPID_AppBrandName                 = -9071, // BSTR. The localized full brand name of the application, including SKU information. E.g. "Microsoft Visual Studio Professional 2012 RC" or "Microsoft Visual Studio Express 2012 RC for Windows 8" 
    VSSPROPID_AppShortBrandName            = -9072, // BSTR. A short version of VSSPROPID_AppBrandName, less than 32 chars. E.g. "VS Pro 2012 RC" or "VS Express 2012 RC for Win8" or "VSX 2012 RC for Web", etc.
    VSSPROPID_SKUInfo                      = -9073, // BSTR. A localized text describing the current SKU (name, year, release type, etc). E.g. "Ultimate 2012 RC" or "Express 2012 RC for Web"
    VSSPROPID_NativeScrollbarThemeModePropName = -9074, // BSTR, Read-only.  The string to be used with ::SetProp/::RemoveProp
                                                    // to control theming of native scrollbars.  When calling ::SetProp,
                                                    // the property value provided should be one of the values in the
                                                    // __VSNativeScrollbarThemeMode enumeration.
    VSSPROPID_PreviewFileSizeLimit         = -9075, // UI8, Read-Only. Used when implementing single-click preview.  This the maximum
                                                    // size (in bytes) of a file that should be single-click previewed; files
                                                    // larger than this limit should not be single-click previewed.

    // !!!! NOTE !!!!   THIS MUST BE THE SAME AS THE LAST PROP DEFINED
    // when this is extended in the next version idl, uses of it must be changed to the new value
    VSSPROPID_FIRST5                       = -9075
};
typedef LONG VSSPROPID5;

enum __VSFPROPID5
{
    /********************************************** defined in vsshell.idl
    VSFPROPID_NIL                  = -1,

    VSFPROPID_LAST                 = -3000,
    // The following properties are for all frame   windows
    VSFPROPID_Type                 = -3000,  // I4 -> 1 == Document Frame, 2 == Tool Frame
    VSFPROPID_DocView              = -3001,  // UNK object filling client area of window
    VSFPROPID_SPFrame              = -3002,  // UNK IServiceProvider which is site object for DocView object
    VSFPROPID_SPProjContext        = -3003,  // UNK IServiceProvider provided by the owning IVsHierarchy
    //     This can be QS'ed for project context services
    VSFPROPID_Caption              = -3004,  // BSTR -> full window caption
    //VSFPROPID_                   = -3005,  // obsolete
    //VSFPROPID_                   = -3006,  // obsolete
    VSFPROPID_WindowState          = -3007,  // I4 -> see VSWINDOWSTATE above
    VSFPROPID_FrameMode            = -3008,  // I4 -> see VSFRAMEMODE above
    VSFPROPID_IsWindowTabbed       = -3009,  // I2 returns 0 if window not tabbed,
    //            1 if window is Tabbed and is Active Tab
    //            2 if window is Tabbed and is Not Active tab
    //    Document windows always return 0
    //Note: VSFPROPID_UserContext   should now be used by all toolwindows to push context
    VSFPROPID_UserContext          = -3010,  // UNK IVsUserContext
    VSFPROPID_ViewHelper           = -3011,  // UNK Helper object can override add/override interfaces
    //     normally implemented on the DocView object
    //     ViewHelper can implement following interfaces:
    //         IVsWindowFrameNotify
    //         IOleCommandTarget
    //         IVsToolboxUser
    //         IVsDocOutlineProvider
    //         IDocHostUIHandler
    //         IVsBackForwardNavigation
    //         IVsWindowView
    //         IVsStatusbarUser
    VSFPROPID_ShortCaption         = -3012,  // BSTR -> partial window caption (ie Foo.Txt)

    //Note: to use the default windowhelp   implementation, leave these properties unset
    //    you should only be using these properties if you are not pushing usercontext
    //    (e.g. you are a help window and don't want to blank out other user context)
    VSFPROPID_WindowHelpKeyword    = -3013,  // BSTR -> keyword to be used for cmdidWindowHelp
    VSFPROPID_WindowHelpCmdText    = -3014,  // BSTR -> command text for cmdidWindowHelp (e.g. Help on: Help Index)

    // The following properties are for all document frames
    VSFPROPID_DocCookie            = -4000,  // VT_INT_PTR -> IVsRunningDocumentTable (RDT) key
    VSFPROPID_OwnerCaption         = -4001,  // BSTR portion of caption defined by owner IVsHierarchy
    VSFPROPID_EditorCaption        = -4002,  // BSTR portion of caption defined by editor implementation
    VSFPROPID_pszMkDocument        = -4003,  // BSTR pszMkDocument passed to CreateDocumentWindow
    VSFPROPID_DocData              = -4004,  // UNK returns the AltDocData if available else the RDTDocData
    VSFPROPID_Hierarchy            = -4005,  // UNK owning IVsHierarchy
    VSFPROPID_ItemID               = -4006,  // I4  VSITEMID of document
    VSFPROPID_CmdUIGuid            = -4007,  // GUID used to control visibility of toolbars and AutoVisible tool windows
    VSFPROPID_CreateDocWinFlags    = -4008,  // I4 VSCREATEDOCWIN flags passed to CreateDocumentWindow
    VSFPROPID_guidEditorType       = -4009,  // GUID guidEditorType uniquely identify which IVsEditorFactory created the document.
    VSFPROPID_pszPhysicalView      = -4010,  // BSTR identifies the type of window created by the IVsEditorFactory (e.g. "Form")
    VSFPROPID_InheritKeyBindings   = -4011,  // GUID most often used by an window to inherit the key bindings of the TextEditor
    //      e.g.: pFrame->SetGuidProperty(VSFPROPID_InheritKeyBindings, CMDUIGUID_TextEditor)
    VSFPROPID_RDTDocData           = -4012,  // UNK  the DocData registered in the RDT for the document in this frame
    VSFPROPID_AltDocData           = -4013,  // UNK  if this window is only editing a piece of a larger document
    //      then AltDocData is the DocData object for the piece of the document
    //      that is being edited within the window where as the RDTDocData
    //      is the DocData object for the entire document registered in the RDT.
    //      AltDocData objects are not registered in the RDT. Document Windows
    //      that have AltDocData objects are created using CDW_fAltDocData flag.

    // The following properties are for all tool frames
    VSFPROPID_GuidPersistenceSlot  = -5000,  // GUID that uniquely identifies a tool window type.
    VSFPROPID_GuidAutoActivate     = -5001,  // GUID OBSOLETE. Do NOT use.
    VSFPROPID_CreateToolWinFlags   = -5002,  // I4 VSCREATETOOLWIN flags passed to CreateToolWindow

    // the followin properties are for extensibility
    VSFPROPID_ExtWindowObject      = -5003,  // UNK returns the Environment's "Window" automation IDispatch object

    // The following properties are for all tool frames
    VSFPROPID_MultiInstanceToolNum = -5004,  // I4 ID of a multi-instance tool window
    VSFPROPID_BitmapResource       = -5006,  // I4 Resource number of bitmap in satellite dll
    VSFPROPID_BitmapIndex          = -5007,  // I4 index into strip if bitmap handle is a strip

    // UNK IVsToolbarHost   used to add toolbars to window.  Property is only valid if
    // CTW_fToolbarHost or UIHWF_SupportToolWindowToolbars is   specfied.
    VSFPROPID_ToolbarHost          = -5008,

    VSFPROPID_HideToolwinContainer = -5009,  // I2 make the toolwindow's cntr hidden when saving data file

    VSFPROPID_FIRST                = -5009,
    **********************************************/

    /********************************************** defined in vsshell80.idl
    VSFPROPID_OverrideDirtyState   = -4014,  // BOOL/EMPTY -- tri-state value to control dirty star (*) in window caption
    //      VT_EMPTY: default handling of dirty star
    //      VARIANT_TRUE: override default handling to SHOW dirty star
    //      VARIANT_FALSE: override default handling to show NO dirty star
    VSFPROPID_OLEDocObjectDocument = -4015,  // BOOL if pane is holding OLE doc object
    VSFPROPID_ParentHwnd           = -4016,  // HWND parent of OwnerDocked window
    VSFPROPID_ParentFrame          = -4017,  // IVsWindowFrame of parent container for OwnerDocked window
    VSFPROPID_ToolWindowDocCookie  = -4018,  // VT_INT_PTR -> IVsRunningDocumentTable (RDT) key for document associated with a tool window (eg. Code Definition Window)
                                             // Setting this property enables both caption dirty indicator (*) management and the firing of OnBeforeDocWindowShow() RDT events
                                             // for the tool window.  It is assumed that the frame caption is set correctly, without a dirty indicator (*), before this
                                             // property is set, as setting this property will cause a caption dirty indicator (*) to be added, if the document is dirty.
                                             // Also, when this property is set, the OnBeforeDocWindowShow() RDT event is immediately fired to indicate that a new document has
                                             // been show.
    **********************************************/

    /********************************************** defined in vsshell90.idl
    VSFPROPID_MDIContainerID       = -5010,  // I4 ID of the container (tab) group for the MDI window. Only valid for an MDI Window when IDE is in 'Tabbed Documents' mode. Else returns -1.
    VSFPROPID_NotifyOnActivate     = -5011,  // BOOL Send FRAMESHOW_WinActivated notification when a window is activated.

    VSFPROPID3_FIRST               = -5011,
    **********************************************/

    /********************************************** defined in vsshell100.idl
    VSFPROPID_Icon                 = -5012,  // retrieve an actual HICON resource if the document has one
    VSFPROPID_TabImage             = -5013,  // retrieve an HBITMAP for the image to be displayed on a tab for this frame, the caller must cache and release this object
    VSFPROPID_Thumbnail            = -5014,  // retrieve an HBITMAP thumbnail of the contents of the frame, the caller must cache and release this object, the size will be a best fit in 200x200
    VSFPROPID_NavigationInterface  = -5015,  // retrieve the navigation delegate for this frame
    VSFPROPID_NextCloneID          = -5016,  // return the next instance ID available among sibling clones

    VSFPROPID4_FIRST               = -5016
    **********************************************/
    VSFPROPID_SearchHost           = -5017,  // Retrieve the IVsWindowSearchHost associated with the window or creates a
                                             // search host for a search control with shell-owned positioning within top frame area
    VSFPROPID_IsSearchEnabled      = -5018,  // Returns whether the window supports search (a IVsWindowSearchHost was created and
                                             // associated with the frame, the search was setup with the host and the search is enabled by the provider)
    VSFPROPID_SearchPlacement      = -5019,  // When the frame uses a search control with shell-owned positioning within top frame area
                                             // I4, with values from VSSEARCHPLACEMENT
    VSFPROPID_IsProvisional        = -5020,  // BOOL/EMPTY -- tri-state value indicating whether a window is provisional
                                             // For tool windows, this value is always VARIANT_FALSE and cannot be changed.
                                             // For document windows, this value is initialized to EMPTY.  After the window
                                             // is created but before it is shown, this value can be set to VARIANT_TRUE
                                             // to create a provisional window.  If this value is EMPTY when the window is
                                             // shown, it will be set to VARIANT_FALSE to indicate a non-provisional window.

                                             // Any transitions from EMPTY are valid, as well as VARIANT_TRUE->VARIANT_FALSE.
                                             // Any transitions to EMPTY are invalid, as well as VARIANT_FALSE->VARIANT_TRUE,
                                             // but attempts to make invalid transitions will not result in an error.

    VSFPROPID_IsPinned             = -5021,  // BOOL indicates whether a window is pinned

    VSFPROPID_DontAutoOpen         = -5022,  // BOOL indicates whether a window should be reopened when a solution is opened (default false)

    VSFPROPID_OverrideCaption      = -5023,  // Override the generated caption for this frame.  A null value will restore the default behavior.
    VSFPROPID_OverrideToolTip      = -5024,  // Override the generated tooltip for this frame.  A null value will restore the default behavior.

    VSFPROPID_ReplaceDocumentToolbars = -5025, // BOOL This property is used only for tool windows.  A value of true indicates
                                             // that when the tool window is active, any toolbars that are specific to the
                                             // currently active document should be hidden.  The default is false.
                                             // This property only has an effect when the tool window also supplies a CmdUI GUID
                                             // via the VSFPROPID_CmdUIGuid property.

    VSFPROPID_NativeScrollbarThemeMode = -5026, // I4 (with values from __VSNativeScrollbarThemeMode) indicating whether whether the native
                                             // (i.e. Win32) scrollbars on child windows of this frame should have theming applied.
                                             //
                                             // This property only has an effect on frames whose pane meets one the following criteria:
                                             //
                                             //    1.  The pane is created with IVsWindowPane.CreatePaneWindow, or
                                             //    2.  The pane is created with IVsUIElementPane.CreateUIElementPane and CreateUIElementPane
                                             //        returns IVsUIWin32Element.
                                             //
                                             // If the frame's pane is created with CreateUIElementPane returning either a FrameworkElement
                                             // or IVsUIWpfElement and you wish to control the theming of hosted Win32 scrollbars, you will
                                             // need to call the Windows ::SetProp function for each HwndHost you need to control, using the
                                             // following parameters:
                                             //
                                             //    hwnd:     HwndHost.Handle
                                             //    lpString: the string returned by the VSSPROPID_NativeScrollbarThemeModePropName shell property
                                             //    hData:    a value from __VSNativeScrollbarThemeMode, but not NSTM_Undefined
                                             //
                                             // This value is initialized to NSTM_Undefined.  Until the time IVsWindowPane.CreatePaneWindow or
                                             // IVsUIElementPane.CreateUIElementPane returns, the value can be set to another value from 
                                             // __VSNativeScrollbarThemeMode but once set the value cannot be changed.  
                                             // 
                                             // If this value is NSTM_Undefined when IVsWindowPane.CreatePaneWindow or IVsUIElementPane.CreateUIElementPane
                                             // returns, it will be set to NSTM_All.

    // !!!! NOTE !!!!   THIS MUST BE THE SAME AS THE LAST PROP DEFINED
    // when this is extended in the next version idl, uses of it must be changed to the new value
    VSFPROPID5_FIRST               = -5026,
};
typedef LONG VSFPROPID5;

enum __VSNativeScrollbarThemeMode
{
    NSTM_Undefined    = 0,       // Theme mode isn't defined yet
    NSTM_All          = 1,       // Theme all descendents
    NSTM_None         = 2,       // No theming of descendents
    NSTM_OnlyTopLevel = 3,       // Theme scrollbars on the window to which this is applied, but not descendents
};
typedef DWORD VSNativeScrollbarThemeMode;

// This enum defines directional drop targets that can be used by IVsHierarchyDirectionalDropDataTarget
// to specific above and below drop targets.  These drop targets can be implemented by IVsHierarchy
// implementations to allow user reordering of items within the hierarchy.
enum __HierarchyDropArea
{
    DROPAREA_On = 0x1,
    DROPAREA_Above = 0x2,
    DROPAREA_Below = 0x4
};
typedef DWORD HierarchyDropArea;

//-----------------------------------------------------------------------------
// IVsProjectSpecialFiles enums
//-----------------------------------------------------------------------------
// extension of PSFFILEID
enum __PSFFILEID5
{
    // vsshell.idl
    // PSFFILEID_AppConfig                  = -1000,
    // PSFFILEID_Licenses                   = -1001,
    //
    // vsshell80.idl
    // PSFFILEID_WebSettings                = -1002,
    // PSFFILEID_AppManifest                = -1003,
    // PSFFILEID_AppDesigner                = -1004,
    // PSFFILEID_AppSettings                = -1005,
    // PSFFILEID_AssemblyResource           = -1006,
    // PSFFILEID_AssemblyInfo               = -1007,
    //
    // vsshell90.idl
    // PSFFILEID_AppXaml                    = -1008,
    //
    // vsshell100.idl
    // PSFFILEID_WcfServiceReferencesConfig = -1009,

    PSFFILEID_AppxManifest                  = -1010,

    // !!!! NOTE !!!!   THIS MUST BE THE SAME AS THE LAST PROP DEFINED
    PSFFILEID_FIRST5                        = -1010
};
typedef LONG PSFFILEID5;

// vsshell.idl does not define this in terms of an enum, as other values are,
// and yet vsshell80.idl duplicates the values in an enum (which does not
// actually seem to be used in code.
const DWORD VS_BUILDABLEPROJECTCFGOPTS_PACKAGE = 8;

#ifdef INTEROPLIB

enum BuildableProjectCfgOpts2
{
    // from vsshell80.idl
    //Rebuild = 1,
    //BuildSelectionOnly = 2,
    //BuildActiveDocumentOnly = 4,
    //Private = 0xFFFF0000    // flags private to a particular implementation

    Package = 8
};

#endif

enum __VSHPROPID5
{
    /********************************************** defined in vsshell.idl
    VSHPROPID_NIL   = -1,

    // !!!! NOTE !!!!   THIS MUST BE THE SAME AS THE FIRST PROP DEFINED
    VSHPROPID_LAST                = -1000,
    VSHPROPID_Parent                  = -1000, // I4   itemid of Parent node (ITEMID_NIL if no parent)

    // These properties are defined to deterministically walk   the entire contents of the Hierarchy
    // (or project) independent of which view   is displayed in a UIHierarchyWindow.  Hierarchies
    // that support special views   that either show a subset of items or a superset of member
    // items and non-member items   must implement
    // VSHPROPID_   FirstVisibleChild/NextVisibleSibling/IsHiddenItem/IsNonMemberItem.
    VSHPROPID_FirstChild              = -1001, // INT_PTR itemid of 1st child node (ITEMID_NIL if no children)
    VSHPROPID_NextSibling             = -1002, // INT_PTR itemid of next sibling node (ITEMID_NIL if no more siblings)

    VSHPROPID_Root                = -1003, // INT_PTR [obsolete] itemid of Root must be VSITEMID_ROOT.
    VSHPROPID_TypeGuid            = -1004, // GUID to identify type of node/hierarchy, search on GUID_ItemType
    VSHPROPID_SaveName            = -2002, // BSTR Needed so Shell (i.e. File.Save menu) can display UI.
    VSHPROPID_Caption                 = -2003, // BSTR Needed so Shell (i.e. project window) can display UI.
    VSHPROPID_IconImgList             = -2004, // I4   For icon. Handle to imagelist (Only for itemid==VSITEMID_ROOT)
    VSHPROPID_IconIndex           = -2005, // I4   For icon.  If Expandable=TRUE, then IconIndex+1 is used for open icon.
    // Hierarchy    should support IconHandle or IconImageList/IconIndex but not both.
    VSHPROPID_Expandable              = -2006, // BOOL Should Shell display the "open-this-folder" plus sign?
    VSHPROPID_ExpandByDefault         = -2011, // BOOL Should Shell expand this item?
    VSHPROPID_ProjectName             = -2012, // BSTR [obsolete] use VSHPROPID_Name instead
    VSHPROPID_Name                = -2012, // BSTR Name for project (VSITEMID_ROOT) or item
    VSHPROPID_IconHandle              = -2013, // I4   handle of an icon, UIHierarchyWindow will NOT call DestroyIcon on it
    // Hierarchy    should support IconHandle or IconImageList/IconIndex but not both.
    VSHPROPID_OpenFolderIconHandle  =   -2014, // I4   [optional] handle of an icon for an open folder, UIHierarchyWindow will NOT call DestroyIcon on it
    VSHPROPID_OpenFolderIconIndex     = -2015, // I4   [optional] for icon
    VSHPROPID_CmdUIGuid           = -2016, // GUID for cmdbars (for root only)
    VSHPROPID_SelContainer        = -2017, // UNK  [optional] Returns an ISelectionContainer for property browsing
    VSHPROPID_BrowseObject        = -2018, // DISP [optional] Returns an IDispatch for property browsing
    // Hierarchy    should support SelContainer or BrowseObject but not both.
    VSHPROPID_AltHierarchy        = -2019, // UNK  [optional] Returns an IVsHierarchy for SVsTrackSelectionEx
    VSHPROPID_AltItemid           = -2020, // I4   [optional] Returns an itemid for SVsTrackSelectionEx
    VSHPROPID_ProjectDir              = -2021, // BSTR [optional] full path to project directory (for VSITEMID_ROOT only)
    VSHPROPID_SortPriority        = -2022, // I4   [optional] Sort priority in UIHierarchyWindow. Standard projects have priority 0 (default).
    //                MiscFiles project has priority 10000, SolutionItems project has priority 9999.
    VSHPROPID_UserContext             = -2023, // UNK  [optional] IVsUserContext for project/item
    VSHPROPID_EditLabel           = -2026, // BSTR [optional] string displayed for in-place editing node caption
    VSHPROPID_ExtObject           = -2027, // DISP [optional] For ITEMID_ROOT this is the ext.object of the project (Project).
    // For other    itemids it is that item's ext object (ProjectItem), if any.
    VSHPROPID_ExtSelectedItem         = -2028, // DISP [optional] Returns a custom SelectedItem object for the given itemid.
    // If not supported,    then a default implementation will be provided.
    VSHPROPID_StateIconIndex          = -2029, // I4   For state icon index. Use VsStateIcon enumeration
    VSHPROPID_ProjectType             = -2030, // BSTR [obsolete] use VSHPROPID_TypeName instead
    VSHPROPID_TypeName            = -2030, // BSTR display name to identify type of node/hierarchy (used in title bar)
    VSHPROPID_ReloadableProjectFile =   -2031, // BOOL [obsolete] use VSHPROPID_HandlesOwnReload
    VSHPROPID_HandlesOwnReload    = -2031, // BOOL [optional] project handles unload/reload itself (otherwise environment handles)
    // (Defaults    to FALSE)
    VSHPROPID_ParentHierarchy         = -2032, // UNK  IVsHierarchy that owns this hierarchy.  Hold as UNADDREF'ed ptr in SetProperty.
    VSHPROPID_ParentHierarchyItemid =   -2033, // INT_PTR The itemid of this hierarchy in it's parent hierarchy
    VSHPROPID_ItemDocCookie       = -2034, // INT_PTR [optional] the doc cookie (VSCOOKIE) of the hierarchy item
    VSHPROPID_Expanded            = -2035, // BOOL whether the node is currently expanded in the UIHierarchyWindow, start as FALSE
    // and UIHierarchyWindow    will update
    VSHPROPID_ConfigurationProvider =   -2036, // UNK  OBSOLETE. Use IVsGetCfgProvider interface instead
    VSHPROPID_ImplantHierarchy    = -2037, // UNK  [optional] IVsHierarchy implant for this hierarchy. Hold as UNADDREF'ed ptr in SetProperty.
    // Implant can implement    IVsFilterAddProjectItemDlg and/or IVsToolboxUser.
    VSHPROPID_OwnerKey            = -2038, // BSTR [optional] owner key string that identifies the project GUID of the owning project.
    // only projects    that implement IVsOwnedProjectFactory should support SetProperty for this property.
    VSHPROPID_StartupServices         = -2040, // UNK  [optional] Returns an IVsProjectStartupServices* to add services to be
    // started on next project load (for    VSITEMID_ROOT only)
    VSHPROPID_FirstVisibleChild   = -2041, // INT_PTR [optional] similar to FirstChild but only walks items to be displayed in UIHierarchyWindow.
    // required if hierarchy    supports multiple (subsetted or supersetted)  views of its contents.
    VSHPROPID_NextVisibleSibling      = -2042, // INT_PTR [optional] similar to NextSibling but only walks items to be displayed in UIHierarchyWindow.
    // required if hierarchy    supports multiple (subsetted or supersetted)  views of its contents.
    VSHPROPID_IsHiddenItem        = -2043, // BOOL [optional] is item not displayed in current UIHierarchyWindow view. required if hierarchy
    // supports multiple    (subsetted)  views of its contents.
    VSHPROPID_IsNonMemberItem         = -2044, // BOOL [optional] is item not considered a member of the hierarchy. required if hierarchy supports
    // (supersetted)    views of its contents (e.g. ShowAllFiles displaying files in directory that are not members of the project).
    VSHPROPID_IsNonLocalStorage   = -2045, // BOOL [optional] is project storage local? IPersistFileFormat is used for
    // saving project regardless    of whether it is a local "file" or not.
    VSHPROPID_StorageType             = -2046, // BSTR [optional] non-localize string representing storage type. same as string used in VSDIR file
    // to differentiate between different location MRU lists.
    VSHPROPID_ItemSubType             = -2047, // BSTR [optional] non-localize string representing the subtype of the item.
    // It is    up to each package to agree on the meaning of this string.
    VSHPROPID_OverlayIconIndex    = -2048, // I4 [optional] Use VSOVERLAYICON enum.  Overlay for the item's main icon
    VSHPROPID_DefaultNamespace    = -2049, // BSTR [optional] string representing the items folder based namespace: rootnamespace.folder.subfolder
    VSHPROPID_IsNonSearchable         = -2051, // BOOL [optional] is item not search-and-replace-able via Find/Replace in Files. Should be true for project file itself.
    VSHPROPID_IsFindInFilesForegroundOnly   =  -2052, // BOOL [optional] if true, Find In Files runs in main thread
    VSHPROPID_CanBuildFromMemory      = -2053, // BOOL [optional] if TRUE, we dont need to prompt to save before building
    VSHPROPID_PreferredLanguageSID  =   -2054, // GUID [optional] preferred SID of (text editor) language service for project.
    // (e.g.    used to determine default language for BreakPoint dialog)
    VSHPROPID_ShowProjInSolutionPage = -2055,// BOOL [optional] used to filter project when vb/c#   call the component picker for add-reference.
    // Return VARIANT_TRUE to show the project in the list.
    VSHPROPID_AllowEditInRunMode      = -2056, // BOOL [optional] If FALSE or E_NOTIMPL, the compiler will disallow edits during run mode
    // (this    is the most common expected behavior).  TRUE allows edits.  This property enables VSA scenarios.
    VSHPROPID_IsNewUnsavedItem    = -2057, // BOOL [optional] If TRUE, this is a new unsaved item (as obtained from File.New.File)
    // so the moniker will be a temporary name and the caption should be    used in the UI instead.
    VSHPROPID_ShowOnlyItemCaption     = -2058, // BOOL [optional] If TRUE, this is an item for which only the caption should be shown in the UI instead of the full moniker.
    VSHPROPID_ProjectIDGuid       = -2059, // GUID [optional] Identifies a project across solutions.  Generated and set when project is created.  Retrieved when project is opened.

    VSHPROPID_DesignerVariableNaming = -2060,   // I4 [optional] from the VSDESIGNER_VARIABLENAMING enumeration
    VSHPROPID_DesignerFunctionVisibility = -2061,   // I4 [optional] from the VSDESIGNER_FUNCTIONVISIBILITY enum

    VSHPROPID_HasEnumerationSideEffects =   -2062, // BOOL [optional] If TRUE, then this hierarchy will not be enumerated for FindInFiles and  similar
    // hierarchy    enumerations. (useful if enumerating might cause a login dialog or is unacceptably slow)

    VSHPROPID_DefaultEnableBuildProjectCfg = -2063, // BOOL [optional] Should   "Build" be initially checked by default in the solution cfg
    // Normally "Build" is checked by   default if the project supports IVsBuildableProjectCfg

    VSHPROPID_DefaultEnableDeployProjectCfg =   -2064, // BOOL [optional] Should "Deploy" be initially checked by default in the solution cfg
    // Normally "Deploy" is checked by default if   the project supports IVsDeployableProjectCfg

    // !!!! NOTE !!!!   THIS MUST BE THE SAME AS THE LAST PROP DEFINED
    VSHPROPID_FIRST               = -2064

    ********************************************** defined in vsshell80.idl

    VSHPROPID_PropertyPagesCLSIDList    = -2065, // BSTR [optional] semi-colon delimited list of clsids of the config independent property pages
    VSHPROPID_CfgPropertyPagesCLSIDList = -2066, // BSTR [optional] semi-colon delimited list of clsids of the config dependent property pages

    VSHPROPID_ExtObjectCATID            = -2067, // GUID [optional] Intrinsic Extender CATID of the ExtObject (Automation Object) for the given IVsHierarchy Itemid. For VSITEMID_ROOT this corresponds to the type of the 'Project' object
    VSHPROPID_BrowseObjectCATID         = -2068, // GUID [optional] Intrinsic Extender CATID of the BrowseObject for the given IVsHierarchy Itemid. For VSITEMID_ROOT this corresponds to the object used to build the 'Project.Properties' collection.
    VSHPROPID_CfgBrowseObjectCATID      = -2069, // GUID [optional] Intrinsic Extender CATID of the configuration BrowseObject for the given IVsHierarchy Itemid
    VSHPROPID_AddItemTemplatesGuid      = -2070, // GUID [optional] alternate project type guid to use to get add item templates
    VSHPROPID_ChildrenEnumerated        = -2071, // BOOL [optional] returns TRUE if children have been enumerated. Typically, this is only of interest for project
    // where enumerating children can be expensive (eg. Web projects)
    VSHPROPID_StatusBarClientText       = -2072, // BSTR hierarchy scoped text for Client Text field of status bar. This text is displayed
    // while the given hierarchy is the active hierarchy. VT_EMPTY clears hierarchy scoped
    // text and resets to global text specified by the application.
    VSHPROPID_DebuggeeProcessId         = -2073, // process id of debuggee if known, otherwise zero
    VSHPROPID_IsLinkFile                = -2074,
    VSHPROPID_KeepAliveDocument         = -2075, // BOOL [optional] TRUE if the document should be kept alive in the project regardless of opened/closed state
    VSHPROPID_SupportsProjectDesigner   = -2076, // BOOL [optional] TRUE if the project uses a Project Designer Editor instead of the property page frame to edit project properties
    VSHPROPID_IntellisenseUnknown       = -2077, // IUnknown [optional] returns the IUnknown of the Intellisense compiler used by the project system
    VSHPROPID_IsUpgradeRequired         = -2078, // BOOL [optional] TRUE if the item or any of its children either already in the process of upgrading or must be upgraded
    VSHPROPID_DesignerHiddenCodeGeneration = -2079, // I4 Indicates which code is supposed to go to the hidden designer file.  Bit flag values in __VSDESIGNER_HIDDENCODEGENERATION
    VSHPROPID_SuppressOutOfDateMessageOnBuild = -2080, // BOOL [optional] TRUE if the project does not want to participate in the "this configuration is out of date" message on Build/F5
    VSHPROPID_Container                 = -2081, // BOOL [optional] TRUE if the item is a container (it may not be expandable, but it contains items).
    // support this property if your folder is not expandable but contains items that should be include in SCC operations.
    VSHPROPID_UseInnerHierarchyIconList = -2082, // BOOL [optional] set this to TRUE in the outer hierarchy if you want the icon for an inner (nested) hierarchy root to come from the inner hierarchy image list.
                                                 // by default we're getting that icon from the outer hierarchy image list.
    VSHPROPID_EnableDataSourceWindow   = -2083, // BOOL [optional] set this to TRUE in your hierarchy to disable the Data Source Window for this project.
    VSHPROPID_AppTitleBarTopHierarchyName  = -2084, // BSTR [optional] Gives the hierarchy a chance to put its topmost name (solution or server) into the titlebar of the app. ie Foo part of "Foo - Microsoft Visual Studio"
    VSHPROPID_DebuggerSourcePaths          = -2085, // BSTR [optional] semi-colon delimited list of paths for the debugger to look for source in
    VSHPROPID_CategoryGuid            = -2086, // GUID to identify the family/category of this non-Solution based Hierarchy (e.g. Portfolio Project Hierarchy)
    VSHPROPID_DisableApplicationSettings = -2087, // BOOL [optional] set this to TRUE in your hierarchy to disable Application Settings design time support in your project.
    VSHPROPID_ProjectDesignerEditor        = -2088, // GUID [optional] GUID of the Project Designer Editor that the project uses to edit project properties
                                                    // (VSHPROPID_SupportsProjectDesigner should return VARIANT_TRUE if a ProjectDesignerEditor GUID is returned)
                                                    // This GUID should correspond to an IVsEditorFactory that launches an editor for the Project Properties.
                                                    // A Project Designer is an editor for Project properties that is launched as a document associated with the
                                                    // root of the project. (see IVsSpecifyProjectDesignerPages below for more info)
    VSHPROPID_PriorityPropertyPagesCLSIDList = -2089, // BSTR [optional] semi-colon delimited ordered list of clsids of the prefered property pages.
                                                    // A Project Designer that shows config independent and config dependent property pages in a
                                                    // flat list should use this order as the prefered order for the pages. A project that uses
                                                    // the standard property page frame can ignore this property because the property page frame
                                                    // does not mix the two type of pages in a flat list.
    VSHPROPID_NoDefaultNestedHierSorting  = -2090,  // BOOL [optional] TRUE if the hierarchy DOES NOT want nested hierarchies sorted first and items after, and sorted alphabetically (like solution folders)
    VSHPROPID_ExcludeFromExportItemTemplate = -2091,  // BOOL [optional, default is FALSE] TRUE if the project item can not be exported via export item template
    VSHPROPID_SupportedMyApplicationTypes = -2092,  // BSTR [optional] semi-colon delimited list of application-types supported for project-systems that
                                                    // support My.Application. The property-page that exposes information about My.Application can use this
                                                    // list to determine which values appear in the application-type dropdown as selectable choices for the user.
                                                    // The current list of supported values for VB's implementation is:
                                                    //
                                                    // WindowsApp       - a WinExe with support for Windows application concepts such as My.Forms
                                                    // WindowsClassLib  - a Dll with support for Windows application concepts such as My.Forms
                                                    // CommandLineApp   - a command-line Exe
                                                    // WindowsService   - an Exe that can be run as a Windows Service
                                                    // WebControl       - a Dll with support for Web application concepts
                                                    //
                                                    // An example value that supports all types is "WindowsApp;WindowsClassLib;CommandLineApp;WindowsService;WebControl"


    // !!!! NOTE !!!!   THIS MUST BE THE SAME AS THE LAST PROP DEFINED
    // when this is extended in the next version idl, uses of it must be changed to the new value
    VSHPROPID_FIRST2               = -2092

    **********************************************defined in vsshell90.idl


    VSHPROPID_TargetFrameworkVersion    = -2093, // UI4   For Target Framework version .  Hi word is major version, Lo word is minor version.
    VSHPROPID_WebReferenceSupported     = -2094,   // VT_BOOL [optional] - the project support for web references.
    VSHPROPID_ServiceReferenceSupported = -2095,   // VT_BOOL [optional] - the project support for service references.

    VSHPROPID_SupportsHierarchicalUpdate    = -2096, // BOOL [optional] -  set this to TRUE in your project hierarchy to enable Hierarchical Update for this project.
                             // Setting to TRUE generates typed datasets with a TableAdapterManager and associated methods for enabling hierarchical update.
    VSHPROPID_SupportsNTierDesigner = -2097, // BOOL [optional] - set this to TRUE in your project hierarchy to enable the N-Tier designer for this project.
                         // Setting to TRUE creates datasets with the Dataset Project property for generating Datasets and TableAdapters into separate projects.
    VSHPROPID_SupportsLinqOverDataSet = -2098, // BOOL [optional]- set this to TRUE in your project hierarchy to enable LINQ to DataSet for this project.
                           // Setting to TRUE generates typed datasets with data tables that inherit from System.Data.TypedTableBase in order to enable LINQ queries.

    VSHPROPID_ProductBrandName = -2099, // VT_BSTR [optional]. Replace application name with hierarchy branding in main window title

    VSHPROPID_RefactorExtensions = -2100, // VT_ARRAY|VT_BSTR [optional] - only defined for VSITEMID_ROOT - array of service GUIDs which implement IVsRefactorNotify and for which
                                          // this interface should be called for any refactoring operation in the project. Add to this property by creating registry values under
                                          // the local registry root's Projects\<project type GUID>\FileExtensions\<file extension> key with name "RefactorNotify". Then if there is
                                          // a file with this extension in the project, the VSHPROPID_Extensions property will contain the data from this registry value.

    VSHPROPID_IsDefaultNamespaceRefactorNotify = -2101,     // VT_BOOL [optional] - set to VARIANT_TRUE if we are in the middle of a default namespace IVsRefactorNotify call; VARIANT_FALSE otherwise.

    // !!!! NOTE !!!!   THIS MUST BE THE SAME AS THE LAST PROP DEFINED
    // when this is extended in the next version idl, uses of it must be changed to the new value

    VSHPROPID_FIRST3               = -2101

    **********************************************defined in vsshell100.idl

    VSHPROPID_TargetFrameworkMoniker    = -2102, //VT_BSTR  The format for the target framework moniker is '<Identifier>,Version=<ver>,Profile=<value>'
                                                         // e.g. '.NETFramework,Version=v3.5,Profile=Client'
    VSHPROPID_ExternalItem              = -2103, // BOOL [optional] - This item is to be considered external to the solution.
    VSHPROPID_SupportsAspNetIntegration = -2104, // BOOL [optional] - set this to true in your project hierarchy if your web Project supports being consumed by Silverlight.

    VSHPROPID_DesignTimeDependencies    = -2105, // BSTR [optional], semicolon separated list of projects required to support design time features (Intellisense, Form designers, etc.).
                                                 //                  If this property is not implemented GetProperty(VSHPROPID_BuildDependencies) will be used instead.

    VSHPROPID_BuildDependencies         = -2106, // BSTR [optional], semicolon separated list of projects required to build this project
                                                 //                  If this property is not implemented IVsDependencyProvider::EnumDependencies() will be used.
    VSHPROPID_BuildAction               = -2107, // BSTR [optional], retrieves the build action for an item
    VSHPROPID_DescriptiveName           = -2108, // BSTR [optional], A more descriptive name of the item. Replace the running document table moniker in document windows tooltips or other parts of the UI.

    VSHPROPID_AlwaysBuildOnDebugLaunch  = -2109, // BOOL [optional] - set this to TRUE in your project hierarchy if you want your project to always build on debug launch(F5) when
                                                 // "Only build startup projects and dependencies on Run" Tools option is set. This will make sure your project is built even if your project is not declared
                                                 // as a build dependency of the startup project. This property is a workaround for the fact that currently there is only support for build dependencies
                                                 // ( IVsBuildDependency ) and not deploy dependencies in the solution build manager.
                                                 // This property will be used rarely in circumstances where you may have a circular set of dependencies involving a combination of build
                                                 // and deploy dependencies between multiple projects (e.g. A has a build dependency on B while B has a deploy dependency on A; if B is the
                                                 // startup project then solution build manager would not realize it needs to build A to satisfy the required deploy dependency when the above
                                                 // mentioned Tools option is set).


    // !!!! NOTE !!!!   THIS MUST BE THE SAME AS THE LAST PROP DEFINED
    // when this is extended in the next version idl, uses of it must be changed to the new value
    VSHPROPID_FIRST4 = -2109
    **********************************************/

    VSHPROPID_MinimumDesignTimeCompatVersion = -2110,   // BSTR [optional] - get/set the minimum design time compat version that this project is compatible with,
                                                        // The set is mostly called by the IVsAppCompat service during the addition of a new feature in the project
                                                        // that would break compatibility with a previous version of the application

    VSHPROPID_ProvisionalViewingStatus       = -2112,   // VT_UI4 [optional] The provisional viewing status for the item (from the __VSPROVISIONALVIEWINGSTATUS enum).
                                                        // If this property is not supported and the hierarchy implements IVsProject, the provisional viewing status is
                                                        // determined by calling IVsUIShellOpenDocument3.GetProvisionalViewingStatusForFile with the name returned by
                                                        // IVsProject.GetMkDocument.

    VSHPROPID_SupportedOutputTypes           = -2113,   // VT_ARRAY|VT_UI4 [optional] Returns a list of supported output types (specified as values used by the OutputTypeEx
                                                        // project property).  This allows a flavor to customize the contents of the output type dropdown in the property
                                                        // pages.  Note that this property will be checked first by the property pages, so this property effectively
                                                        // overrides the VSHPROPID_SupportedMyApplicationTypes property used by the VB property page.


    VSHPROPID_TargetPlatformIdentifier       = -2114,   // BSTR [optional] Provides the Target Platform for a project type.  Examples are 'Windows', 'Windows Phone',
                                                        // 'Windows Azure', 'XBox 360', 'Portable'.

    VSHPROPID_TargetPlatformVersion          = -2115,   // BSTR [optional, required if VSHPROPID_TargetPlatformIdentifer is provided] Provides the version of the target
                                                        // platform.  For example '8.0'.

    VSHPROPID_TargetRuntime                  = -2116,   // VT_UI4 [optional] Indicates what runtime the project targets, from VSPROJTARGETRUNTIME enumeration.

    VSHPROPID_AppContainer                   = -2117,   // BOOL [optional] Indicates whether the project's output requires running in an app container or not.

    VSHPROPID_OutputType                     = -2118,   // VT_UI4 [optional] Indicates the output type for a project, from VSPROJOUTPUTTYPE enumeration.

    VSHPROPID_ReferenceManagerUser           = -2119, // VT_UNKNOWN [optional] Returns the implementation of IVsReferenceManagerUser for a project.

    VSHPROPID_ProjectUnloadStatus            = -2120,   // VT_UI4 [optional] representing the unload status (UNLOADSTATUS_UnloadedByUser, UNLOADSTATUS_LoadPendingIfNeeded, etc)
                                                        // from the _VSProjectUnloadStatus enumeration. This is implemented only by the stub hierarchy.

    VSHPROPID_DemandLoadDependencies         = -2121,   // VT_BOOL [optional] If TRUE, and project was loaded synchronously, all its dependencies will also be loaded
                                                        // synchronously (the default); if FALSE, and project was loaded synchronously, those of its dependencies that
                                                        // support asynchronous load may be loaded asynchronously.

    VSHPROPID_IsFaulted                      = -2122,   // VT_BOOL [optional] For project hierarchies, set to TRUE to indicate that the project has encountered an error.
                                                        // Implementations should raise property change events to all IVsHierarchyEvents sinks whenever this value changes.

    VSHPROPID_FaultMessage                   = -2123,   // VT_BSTR [optional] A localized message indicating the reason for a faulted project. This string will be used
                                                        // in the fault resolution UI.

    VSHPROPID_ProjectCapabilities            = -2124,   // BSTR [optional] Provides a space-delimited list of the project's capabilities.

    VSHPROPID_RequiresReloadForExternalFileChange = -2125,   // VT_BOOL [optional] Returns TRUE if the file on disk was NOT last written by the project and thus the
                                                        // user should be prompted to reload due to an external change to the file. This property is defined for ITEMID_ROOT.
                                                        // If is expected that this property is only called during a FilesChanged event handler. The expected implementation
                                                        // is for projects to record the timestamp on the project file when the file is saved. Later when this
                                                        // property is requested, the project should compare the current timestamp of the file to the last recored
                                                        // save timestamp. If they are not equal then return TRUE, else return FALSE (i.e. reload is not required).

    VSHPROPID_ForceFrameworkRetarget         = -2126,   // VT_BSTR [optional] When set, indicates the target framework moniker that the project system should retarget
                                                        // to upon first opportunity.  Project is responsible for ensuring the applicability of the framework that is returned.

    VSHPROPID_IsProjectProvisioned           = -2127,   // VT_BOOL [optional] returns TRUE is an unloaded project is in provisioned state (i.e. displayed with "(initializing)" caption).
                                                        // This is implemented only by the stub hierarchy.
                                                        // This property is used when a project that supports Asynchronous Solution Load is loaded in the background. 
                                                        // While such projects are loading they are exposed in the Solution as unloaded project stub. When the background loading
                                                        // project reaches the "provisioned" state, the real project has been created but has not been publicized via the 
                                                        // solution load events. Therefore the project IVsHierarchy exposed in the Solution project collection (and Solution Explorer)
                                                        // is still the stub hierarchy and not the real project hierarchy. Only basic hierarchy properties are available 
                                                        // such as the project name and icon. When the loading project reaches the provisioned state the 
                                                        // IVsAsynchronousProjectCreateUI::OnAfterProjectProvisioned event is fired.

    VSHPROPID_SupportsCrossRuntimeReferences = -2128,   // VT_BOOL [optional] Indicates whether a project allows references across runtimes (e.g., native to managed).  The
                                                        // default is TRUE, so a project must have the property AND set it to FALSE in order to block cross-runtime references.

    VSHPROPID_WinMDAssembly                  = -2129,   // VT_BOOL [optional] Indicates whether the project produces an assembly (.exe or .dll) with WinMD metadata.

    VSHPROPID_MonikerSameAsPersistFile       = -2130,   // Indicates that IVsProject::GetMkDocument for VSITEMID_ROOT returns the same full path to the project file as 
                                                        // IPersistFileFormat::GetCurFile.  This is useful when it is more expensive to call GetCurFile due to the need 
                                                        // to get the on-disk format.
                                                        
    VSHPROPID_IsPackagingProject             = -2131,   // BOOL [optional] Indicates whether the project;s output is a package of its content (i.e. a zip file).

    VSHPROPID_ProjectPropertiesDebugPageArg  = -2132,   // BSTR or VT_I4 [optional] vaIn argument to be passed to cmdidProjectProperties command to activate the Project's
                                                        // Debug page. This property is used by the VSConstants.VSStd11CmdID.StartupProjectProperties command to activate
                                                        // the correct "Debug" property page for the Startup Project.
                                                        // Projects that use the ProjectDesignerEditor should pass the CLSID of their Debug property page
                                                        // as a string, e.g. C# would pass "{6185191F-1008-4FB2-A715-3A4E4F27E610}". 
                                                        // Projects that use the Property Page Frame may pass the CLSID of their "Debug" property page as a string or they 
                                                        // may pass as a VT_I4 the DISPID of a property on their Debug page that they want to give focus (as long as they 
                                                        // implement IPerPropertyBrowsing::MapPropertyToPage to associate this property with the CLSID of their "Debug" page).

   // !!!! NOTE !!!!   THIS MUST BE THE SAME AS THE LAST PROP DEFINED
   // when this is extended in the next version idl, uses of it must be changed to the new value
   VSHPROPID_FIRST5 = -2132
};
typedef [public] DWORD VSHPROPID5;

// {04b8ab82-a572-4fef-95ce-5222444b6b64}
cpp_quote("DEFINE_GUID(GUID_ProjectDesignerEditorFactory, 0x04b8ab82, 0xa572, 0x4fef, 0x95, 0xce, 0x52, 0x22, 0x44, 0x4b, 0x6b, 0x64);")

enum __VSPROJOUTPUTTYPE
{
    VSPROJ_OUTPUTTYPE_WINEXE           = 0,
    VSPROJ_OUTPUTTYPE_EXE              = 1,
    VSPROJ_OUTPUTTYPE_LIBRARY          = 2,
    VSPROJ_OUTPUTTYPE_WINMDOBJ         = 3,
    VSPROJ_OUTPUTTYPE_APPCONTAINEREXE  = 4,
    VSPROJ_OUTPUTTYPE_NONE             = 100
};
typedef [public] DWORD VSPROJOUTPUTTYPE;

enum __VSPROJTARGETRUNTIME
{
    VSPROJ_TARGETRUNTIME_MANAGED        = 0,
    VSPROJ_TARGETRUNTIME_NATIVE         = 1,
    VSPROJ_TARGETRUNTIME_APPHOST            = 2,
};
typedef [public] DWORD VSPROJTARGETRUNTIME;

//-----------------------------------------------------------------------------
// Extended flags for IVsSolution::GetProjectEnum
//-----------------------------------------------------------------------------
enum __VSENUMPROJFLAGS2
{
    /********************************************** defined in vsshell.idl
    EPF_LOADEDINSOLUTION           = 0x00000001, // normal projects referenced in the solution file and currently loaded
    EPF_UNLOADEDINSOLUTION     = 0x00000002, // normal projects referenced in the solution file and currently NOT loaded
    EPF_ALLINSOLUTION              = (EPF_LOADEDINSOLUTION | EPF_UNLOADEDINSOLUTION),
    //  all normal projects referenced in the solution file
    EPF_MATCHTYPE                  = 0x00000004, // projects with project type GUID matching parameter
    EPF_VIRTUALVISIBLEPROJECT      = 0x00000008, // 'virtual' projects visible as top-level projects in Solution Explorer
    //  (NOTE: these are projects that are not directly referenced in the solution file;
    //  instead they are projects that are created programmatically via a non-standard UI.)
    EPF_VIRTUALNONVISIBLEPROJECT = 0x00000010, //   'virtual' projects NOT visible as top-level projects in Solution Explorer
    //  (NOTE: these are projects that are not directly referenced in the solution file
    //  and are usually displayed as nested (a.k.a. sub) projects in Solution Explorer)
    EPF_ALLVIRTUAL             = (EPF_VIRTUALVISIBLEPROJECT | EPF_VIRTUALNONVISIBLEPROJECT),
    //  all 'virtual' projects of any kind
    EPF_ALLPROJECTS            = (EPF_ALLINSOLUTION | EPF_ALLVIRTUAL),
    //  all projects including normal projects directly referenced in the solution
    //  file as well as all virtual projects including nested (a.k.a. sub) projects
    **********************************************/
    EPF_FAULTED                    = 0x00000020,    // Enumerate only faulted projects
    EPF_NOTFAULTED                 = 0x00000040,    // Enumerate only unfaulted projects
    EPF_MATCHUNLOADEDTYPE          = 0x00000080,    // Enumerate unloaded projects when matching by project type GUID. Note: Do not combine with EPF_MATCHTYPE
                                                    // To enumerate both loaded and unloaded projects by matching type GUID specify EPF_MATCHUNLOADEDTYPE | EPF_LOADEDINSOLUTION | EPF_UNLOADEDINSOLUTION
                                                    // Ideally EPF_MATCHTYPE | EPF_LOADEDINSOLUTION | EPF_UNLOADEDINSOLUTION would do this but for compatibility reasons this will not work.
    EPF_PROVISIONED                = 0x00000100,    // Enumerate the provisioned projects.
};

//-----------------------------------------------------------------------------
// A name-value pair collection.
//-----------------------------------------------------------------------------
[
    uuid(aaeeac4c-3bf3-492c-927d-84ab7d93d6df),
    pointer_default(unique)
]
interface IVsPropertyBag : IUnknown
{
    // Retrieve the value of a named property from the property bag. If the
    // property is not in the bag, then E_INVALIDARG is returned.
    HRESULT GetValue(
        [in] LPCOLESTR szName,          // Name of the property
        [out,retval] VARIANT *pVarValue // Returns the value of the property
        );

    // Add or update a named property in the property bag.
    HRESULT SetValue(
        [in] LPCOLESTR szName,  // Name of the property
        [in] VARIANT *pVarValue // The new or updated value for the property
        );
};

//-----------------------------------------------------------------------------
// Implemented by project hierarchies that participate in fault resolution.
// If the hierarhcy indicates that the project is faulted by setting
// VSHPROPID_IsFaulted, then the shell will call QueryInterface on the
// project's IVsHierarchy to obtain this interface.
//-----------------------------------------------------------------------------
[
    uuid(c94fb6dd-91aa-495f-b399-51f1428723fc),
    pointer_default(unique)
]
interface IVsProjectFaultResolver : IUnknown
{
    // Resolve the fault on this project.
    //
    // In some situations, the shell will call ResolveFault on faulted projects
    // one at a time as part of a bulk resolution. A context property bag will
    // be created before calling the first one and assigned to
    // VSPROPID_ProjectFaultResolutionContext solution property. The hierarchies
    // may read/write properties from/to the context as a way to co-operate with
    // each other in the fault resolution process. The context property bag is
    // destroyed after the bulk resolution completes.
    //
    // If *pfShouldReload is set to VARIANT_FALSE, it is assumed that fault is
    // resolved and no further action is required.
    //
    // If *pfShouldReload is set to VARIANT_TRUE, the shell will immediately
    // reload the project. This is typically used by projects which don't support
    // fine-grained fault resolution, but implement this interface regardless
    // because they want to use VSPROPID_ProjectFaultResolutionContext protocol.
    //
    // This method is intended to be called directly only by the Shell, because only that
    // can properly fulfill its contract by setting VSPROPID_ProjectFaultResolutionContext
    // to something other than null. To programmatically resolve faults on a specific
    // project hierarchy, use IVsSolution5::ResolveFaultedProjects.
    HRESULT ResolveFault([out] VARIANT_BOOL* pfShouldReload);
};

//-----------------------------------------------------------------------------
// IVsPackageExtensionProvider
// Implemented by packages that participate in "pull"-style extension points.
// Retrieved by QI on IVsPackage object.
//
// This is an alternative to the more usual 'factory' model where a package,
// in its SetSite method, registers instances of factories with a central
// registrar. That model requires that the central registrar is created, even
// if that feature is not yet desired. That is a "push"-style where the package
// pushes its factory implementation to the environment.
//
// With IVsPackageExtensionProvider, instances of the extension point are
// "pulled" on demand from packages as needed. This allows the package to
// delay creation of extension point instances until they're actually needed.
//
// It is possible to re-implement traditional project, editor and UI factories
// in terms of IVsPackageExtensionProvider.
//-----------------------------------------------------------------------------
[
    uuid(uuid_IVsPackageExtensionProvider),
    version(1.0),
    pointer_default(unique)
]
interface IVsPackageExtensionProvider : IUnknown
{
    // Create an instance of the requested extension.
    HRESULT CreateExtensionInstance(
        [in] REFCLSID   extensionPoint, // The type of extension point
        [in] REFGUID    instance,       // The instance identifier of the requested extension point
        [out, retval] IUnknown **ppunk  // The requested extension point instance
        );
};

//-----------------------------------------------------------------------------
// IVsShell5
//-----------------------------------------------------------------------------
[
    uuid(uuid_IVsShell5),
    version(1.0),
    pointer_default(unique)
]
interface IVsShell5 : IUnknown
{
    // Load a package. If it is not already loaded, provide additional diagnostic
    // information about the reason for loading. Negative reason codes are reserved
    // by the environment.
    HRESULT LoadPackageWithContext(
        [in] REFGUID packageGuid,   // The GUID of the package to load
        [in] int reason,            // The reason for loading (see above)
        [in] REFGUID context,       // Optional context information associated with the reason
        [out, retval] IVsPackage** package // The loaded package
        );

    // Loads, if necessary, the specified package and creates an instance
    // of the given type of extension point via IVsPackageExtensionProvider
    HRESULT CreatePackageExtension(
        [in] REFGUID    package,        // The package containing the desired extension
        [in] REFCLSID   extensionPoint, // The type of extension point
        [in] REFGUID    instance,       // The instance identifier of the requested extension point
        [out, retval] IUnknown **ppunk  // The requested extension point instance
        );
};

// Identifier for an element in a UI Factory
typedef struct
{
    GUID    Factory;    // UI factory identifier
    DWORD   ElementID;  // Element within that factory
} VsUIElementDescriptor;

//----------------------------------------------------------------------------
// IVsDiagnosticsItem
//
// Implemented by any component that wants to supply information for use
// in diagnostics.
//----------------------------------------------------------------------------
[ uuid (uuid_IVsDiagnosticsItem) ]
interface IVsDiagnosticsItem : IUnknown
{
    // Provide a human-readable name useful for diagnostics
    // The diagnostics name is not localized since it is intended to be used
    // in diagnostics UI only. The name should be short, but sufficiently
    // unique to disambiguate it from other clients.
    [propget] HRESULT DiagnosticsName ([out,retval] BSTR* pstrName);
}


//----------------------------------------------------------------------------
// IVsDiagnosticsProvider
//
// Implemented by components that wish to participate in the Shell's
// diagnostics system.
//
// Implementations should be exposed by packages via the
// IVsPackageExtensionProvider.CreateExtensionInstance mechanism using the
// IVsDiagnosticsProvider extension point.
//
// Diagnostics providers must be pre-registered in the configuration settings
// store.
//
// The following diagram explains the layout in the settings store:
//
// [DiagnosticsProviders]
//  +--[{ComponentOneProvider}]                    ; GUID of 1st diagnostics provider
//  |  |   (Default)        "Component One"        ; Display name of 1st provider
//  |  |                                           ; May also be a resource ID (e.g. #1001)
//  |  |   Package          {ComponentOnePackage}  ; GUID of the ComponentOne package which
//  |  |                                           ; implements a component diagnostics
//  |  |                                           ; extension point.
//  |  |
//  |  +--[Views]                                  ; Optional list of registered views
//  |     |
//  |     +--[1]                                   ; Version of data model in decimal
//  |     |   ViewFactory    "{ViewFactoryGuid1}"  ; GUID of the UI factory for view version 1
//  |     |   View           0x00000100 (DWORD)    ; Element ID of the view for view version 1
//  |     |
//  |     +--[2]                                   ; Version of the data model in decimal
//  |         ViewFactory    "{ViewFactoryGuid2}"  ; GUID of the UI factory for view version 2
//  |         View           0xFECBA987 (DWORD)    ; Element ID of the view for view version 2
//  |
//  +--[{ComponentTwoProvider}]                    ; GUID of 2nd diagnostics provider
//     |   (Default)        "Widget Manager"       ; Readable name of 2nd provider
//     |   Package          {WidgetPackage}        ; GUID of the Widget package which
//     |                                           ; implements a component diagnostics
//     |                                           ; extension point.
//     |
//     +--[Views]                                  ; Optional list of registered views
//        |
//         +--[8]                                  ; Version of the data model in decimal
//             ViewFactory   "{ViewFactoryGuid3}"  ; GUID of the UI factory for view version 8
//             View          0x00000001 (DWORD)    ; Element ID of the view for view version 8
//
// In this example, two diagnostics providers are registered. The first one defines view for both
// version 1 and version 2 of its data model. The second provider defines a view only for version
// 8. All three of these views are registered and the most appropriate view will be selected based
// on the version of the provider's data model. If a view for the requested version is not available
// then the default view (a property grid) will be used instead.
//
// The Views list is optional. If the sub-key doesn't exist, then a default view will be supplied
// which will match version "0" of the data model. The default view is a simple property grid.
//
//----------------------------------------------------------------------------
[ uuid (uuid_IVsDiagnosticsProvider) ]
interface IVsDiagnosticsProvider : IUnknown
{
    [propget] HRESULT Version ([out,retval] DWORD* pdwVersion);
    [propget] HRESULT DataModel ([out,retval] IUnknown** ppDataModel);
}


//-----------------------------------------------------------------------------
// IVsDataObjectStringMapManager2
//-----------------------------------------------------------------------------
// Allows clearing of a specific string map.
[
    uuid(uuid_IVsDataObjectStringMapManager2),
    version(1.0),
    pointer_default(unique)
]
// Methods inherited from the base interface should be PreserveSig
[custom(uuid_VsPreserveSigAttribute, "preservesig")]
interface IVsDataObjectStringMapManager2 : IVsDataObjectStringMapManager
{
    // Clears cached string map data for all data objects with this string map name.
    // New methods don't need to be PreserveSig
    [custom(uuid_VsPreserveSigAttribute, "nopreservesig")]
    HRESULT ClearMapCache([in] LPCWSTR szStringMapName);
}


enum __VSASYNCTOOLBOXSTATE
{
    ATS_NONE         = 0x00000000, // no async operations pending or in progress
    ATS_INITIALIZING = 0x00000001, // init sequence in progress (also set during a reset operation)
    ATS_FILTERING    = 0x00000002, // item visibility determination in progress
};
typedef DWORD VSASYNCTOOLBOXSTATE;


// Normally we would want to derive from the previous version of the interface (IVsToolbox5 in this
// case), but here I avoided that because Dev11+ interfaces have PreserveSig off by default, while
// Dev10 and earlier had it on by default.  To avoid having two different ways to call the
// IVsToolbox5 interfaces, I'm deriving from IUnknown here, but IVsToolbox7 should derive from this
// interface when it's created.
//
// PLEASE KEEP THE COMMENTS FOR EACH METHOD IN SYNC WITH THE ONES ON THE IMPLEMENTATION
// (env\msenv\core\tbx.cpp).

[ uuid (uuid_IVsToolbox6) ]
interface IVsToolbox6 : IUnknown
{
    // Adds the specified item to the active designer as if it was double-clicked in the toolbox.
    //
    // Return value:
    //     E_INVALIDARG if 'pItem' is null.
    //     E_UNEXPECTED if there is no active designer.
    //     Otherwise, S_OK or the return value of the designer's IVsToolboxUser::ItemPicked method.
    HRESULT AddItemToDesigner([in] IDataObject* pItem);

    // Copies the item from the toolbox onto the clipboard.  This is different from putting 'pItem'
    // directly on the clipboard because the toolbox does some additional processing of the data
    // object before sending it to the clipboard.  The result of this method is the same as right-
    // clicking the item in the toolbox and selecting "Copy".
    //
    // Return value:
    //     E_INVALIDARG if 'pItem' is null or the item is not on the toolbox.
    //     STG_E_ACCESSDENIED if we failed to write to the clipboard.
    //     E_UNEXPECTED if an error occurred making a copy of the item and adding extra data to it.
    //     S_OK or a different error code otherwise.
    HRESULT CopyToClipboard([in] IDataObject* pItem);

    // Returns an enumeration of the IDs for the tabs on the toolbox.  This is recommended over
    // IVsToolbox::EnumTabs because EnumTabs may load resource DLLs to resolve resource IDs,
    // taking more time and memory.
    //
    // Return value:
    //     E_POINTER if ppEnum is null.
    //     S_OK or a different error code otherwise.
    HRESULT EnumTabIDs([out, retval] IEnumToolboxTabs** ppEnum);

    // Returns the transparent background color of the given toolbox item.
    //
    // Return value:
    //     E_POINTER if 'pRgbColor' is null.
    //     E_INVALIDARG if 'pItem' is null or the item is not on the toolbox.
    //     S_OK or a different error code otherwise.
    HRESULT GetBitmapBackground([in] IDataObject* pItem, [out, retval] DWORD* pRgbColor);

    // Returns the "unresolved" name of the specified item.  If the item's name was initially
    // specified as a resource ID, this will return the resource ID (unlike IVsToolbox3::
    // GetItemDisplayName, which loads the resource string and returns that).  If the item's name
    // was specified as a literal string, that string will be returned.
    //
    // Return value:
    //     E_POINTER if 'pName' is null.
    //     E_INVALIDARG if 'pItem' is null or the item is not on the toolbox.
    //     S_OK or a different error code otherwise.
    HRESULT GetUnresolvedItemName([in] IDataObject* pItem, [out, retval] BSTR* pName);

    // Returns the "unresolved" name of the specified tab.  If the tab's name was initially
    // specified as a resource ID, this will return the resource ID (unlike IVsToolbox3::
    // GetTabOfID, which loads the resource string and returns that).  If the tab's name was
    // specified as a literal string, that string will be returned.
    //
    // Return value:
    //     E_POINTER if 'pName' is null.
    //     E_INVALIDARG if there is no toolbox tab with ID 'szID'.
    //     S_OK or a different error code otherwise.
    HRESULT GetUnresolvedTabName([in] LPCWSTR szID, [out, retval] BSTR* pName);

    // Gets or sets whether the toolbox is currently filtering items against the active designer
    // and project.  This is the inverse of the "Show All" toggle in the context menu.
    //
    // Return value:
    //     E_POINTER if pFiltered is null.
    //     S_OK or a different error code otherwise.
    [propget] HRESULT IsFiltered([out, retval] VARIANT_BOOL* pFiltered);
    [propput] HRESULT IsFiltered([in] VARIANT_BOOL filtered);

    // Sets *pIsVisible to indicate whether the specified tab is visible (e.g. has any enabled
    // items) in the current context.  If fRefresh is false, the last known visible state of the
    // tab will be returned, which should match what is shown in the UI.  If fRefresh is true,
    // the tab's visibility will be re-evaluated based on its items, so the most up-to-date
    // status will be returned, but that may not match what is shown in the UI yet.
    //
    // Return value:
    //     E_INVALIDARG if there is no tab with id 'szID'.
    //     E_POINTER if pIsVisible is null.
    //     S_OK or a different error code otherwise.
    HRESULT IsTabVisible([in] LPCWSTR szID, [in] VARIANT_BOOL fRefresh, [out, retval] VARIANT_BOOL* pIsVisible);

    // Moves a toolbox item to a position just before the specified "insertion point" item.  If
    // 'pInsertionPoint' is on a different tab, 'pItem' will be moved to that tab.
    //
    // Return value:
    //     E_INVALIDARG if 'pItem' is null or the item is not on the toolbox.
    //     E_UNEXPECTED if 'pInsertionPoint' is null or the item is not on the toolbox.
    //     S_OK or a different error code otherwise.
    HRESULT MoveItem([in] IDataObject* pItem, [in] IDataObject* pInsertionPoint);

    // Moves a toolbox item to the end of the specified tab.
    //
    // Return value:
    //     E_INVALIDARG if 'pItem' is null or the item is not on the toolbox.
    //     E_UNEXPECTED if there is no toolbox tab with ID 'szTabID'.
    //     S_OK or a different error code otherwise.
    HRESULT MoveItemToTab([in] IDataObject* pItem, [in] LPCWSTR szTabID);

    // Moves the specified tab before the tab whose ID is specified by 'szInsertionPoint'.  To move
    // it to the end of the toolbox, pass null for 'szInsertionPoint'.
    //
    // Return value:
    //     E_INVALIDARG if there is no toolbox tab with ID 'szID' or no tab with ID 'szInsertionPoint'.
    //     S_OK or a different error code otherwise.
    HRESULT MoveTab([in] LPCWSTR szID, [in] LPCWSTR szInsertionPoint);

    // Pastes the current clipboard contents into the toolbox at the end of the specified tab.  The
    // resulting toolbox item is returned in *ppItem.
    //
    // Return value:
    //     E_INVALIDARG if there is no toolbox tab with ID 'szTabID'.
    //     E_POINTER if ppItem is null.
    //     STG_E_FILENOTFOUND if the clipboard is empty.
    //     DV_E_CLIPFORMAT if the clipboard data does not contain any recognized formats.
    //     S_OK or a different error code otherwise.
    HRESULT PasteFromClipboard([in] LPCWSTR szTabID, [out] IDataObject** ppItem);

    // Renames the specified item.  'szName' may be a literal string or a resource ID.  See the
    // comments for IVsResourceManager2::ParseResourceID (in vsshell100.idl) for supported resource
    // ID formats.
    //
    // Return value:
    //     E_INVALIDARG if 'szName' is empty or the item is not on the toolbox.
    //     S_OK or a different error code otherwise.
    HRESULT RenameItem([in] IDataObject* pItem, [in] LPCWSTR szName);

    // Renames the specified tab.  'szName' may be a literal string or a resource ID.  See the
    // comments for IVsResourceManager2::ParseResourceID (in vsshell100.idl) for supported resource
    // ID formats.
    //
    // Return value:
    //     E_INVALIDARG if 'szName' is empty or no tab with ID 'szID' is found on the toolbox.
    //     STG_E_FILEALREADYEXISTS if a tab with this name already exists on the toolbox.
    //     S_OK or a different error code otherwise.
    HRESULT RenameTab([in] LPCWSTR szID, [in] LPCWSTR szName);

    // Resets the toolbox to its default state, discarding all user customizations.  If
    // 'promptUser' is true, the user will be given an option to cancel the reset first.  Toolbox
    // reset may be asynchronous, so this method will return quickly with the pending portion of
    // the work represented by *ppTask.  If *ppTask is null, that means the reset completed
    // synchronously.
    //
    // Return value:
    //     E_ABORT if the user canceled the operation.
    //     S_OK or a different error code otherwise.
    HRESULT ResetToolbox([in] VARIANT_BOOL promptUser, [out, retval] IVsTask** ppTask);

    // Removes all items created by the specified package.  Groups created by that package will
    // also be removed unless they contain items not created by that package.
    //
    // Return value: S_OK.
    HRESULT RemovePackageContent([in] REFGUID package);

    // Sets *pInvisible according to whether the specified item is currently invisible due to a
    // search filter.
    //
    // Return value:
    //     E_INVALIDARG if 'pItem' is null or the item is not on the toolbox.
    //     E_POINTER if pInvisible is NULL.
    //     S_OK otherwise.
    HRESULT IsItemFilteredInvisible([in] IDataObject* pItem, [out, retval] VARIANT_BOOL* pInvisible);

    // Sets *pState to indicate what (if any) async operations are pending or in progress.
    //
    // Return value:
    //     E_POINTER if pState is NULL.
    //     S_OK otherwise.
    HRESULT GetAsyncState([out, retval] VSASYNCTOOLBOXSTATE* pState);
}

//-----------------------------------------------------------------------------
// IVsToolWindowToolbarHost3
//-----------------------------------------------------------------------------
// Implemented by the Visual Studio Environment. It is retrieved by QueryInterface on
// the IVsToolWindowToolbarHost that is returned as an out parameter from one of the
// IVsUIShellX.SetupToolbarX flavors.
// It is used by tool window clients that want to have a toolbar within their window and
// need to provide a specific drop target for intercepting drag & drop operations
// over the toolbar area and/or specific command target to be used for the commands on it.
[
    uuid(uuid_IVsToolWindowToolbarHost3),
    version(1.0),
    pointer_default(unique)
]
// Methods inherited from the base interface should be PreserveSig
[custom(uuid_VsPreserveSigAttribute, "preservesig")]
interface IVsToolWindowToolbarHost3 : IVsToolWindowToolbarHost
{
    // Extends IVsToolWindowToolbarHost::AddToolbar to allow specifying the drop target
    // to handle drop operations over the toolbar area and the command target to be used
    // for the commands on it. If command target is null then toolbar host's own command
    // target will be used.
    HRESULT AddToolbar3(
        [in] VSTWT_LOCATION dwLoc,
        [in] const GUID *pguid,
        [in] DWORD dwId,
        [in, optional] IDropTarget *pDropTarget,
        [in, optional] IOleCommandTarget *pCommandTarget);
}

//-----------------------------------------------------------------------------
// Window Search interfaces
//-----------------------------------------------------------------------------

// forward declares
interface IVsSearchToken;
interface IVsSearchFilterToken;
interface IVsSearchQuery;
interface IVsSearchTask;
interface IVsSearchCallback;
interface IVsSearchItemResult;
interface IVsWindowSearch;
interface IVsWindowSearchHost;
interface IVsWindowSearchEvents;
interface IVsWindowSearchFilter;
interface IVsEnumWindowSearchFilters;
interface IVsWindowSearchOption;
interface IVsWindowSearchBooleanOption;
interface IVsWindowSearchCommandOption;
interface IVsEnumWindowSearchOptions;
interface IVsSearchProvider;
interface IVsSearchProviderCallback;
interface IVsGlobalSearchCallback;

enum __VSSEARCHPLACEMENT
{
    SP_NONE    = 0,      // The search is not setup for the window
    SP_DYNAMIC = 1,      // The search control has placement in the shell-owned frame area and the shell adjusts dynamically the control's location and size depending on toolbars number, window size, etc.
    SP_STRETCH = 2,      // The search control has placement in the shell-owned frame area, below the top toolbars (if any), on its own row, stretching the frame width.
    SP_CUSTOM  = 3,      // The window has a search host associated, but the search control does not have placement in the shell-owned frame area
};

typedef DWORD VSSEARCHPLACEMENT;


// Possible bitfield values for the search parser errors
enum __VSSEARCHPARSEERROR
{
    SPE_NONE                   = 0x00000000,  // No error parsing the string
    SPE_UNMATCHEDQUOTES        = 0x00000001,  // Quotes unmatched/unclosed around a search token
    SPE_INVALIDESCAPE          = 0x00000002,  // Invalid escape character sequence ( only \\, \", \:, \= are accepted)
    SPE_EMPTYFILTERFIELD       = 0x00000004,  // Empty filter field in token
    SPE_EMPTYFILTERVALUE       = 0x00000008,  // Empty filter value in token
};

typedef DWORD VSSEARCHPARSEERROR;

enum __VSSEARCHFILTERTOKENTYPE
{
    SFTT_DEFAULT               = 0x00000000,  // Default search token is used in "Contain" searches (search for partial matches of text)
    SFTT_EXCLUDE               = 0x00000001,  // The searched text matching the filter value should be excluded from the results
    SFTT_EXACTMATCH            = 0x00000002,  // The filter value should be used for "Exact" matches (space-separated)
};

typedef DWORD VSSEARCHFILTERTOKENTYPE;

// The CLSID for the VS Search Query Parser object, which implements IVsSearchQueryParser {B71B3DF9-7A4A-4D70-8293-3874DB098FDD}
// Call ILocalRegistry::CreateInstance to create an instance of this.
cpp_quote("extern const __declspec(selectany) CLSID CLSID_VsSearchQueryParser = { 0xB71B3DF9, 0x7A4A, 0x4D70, { 0x82, 0x93,  0x38, 0x74, 0xDB, 0x09, 0x8F, 0xDD } };")

//-----------------------------------------------------------------------------
// IVsSearchQueryParser
//
// Implemented by the Visual Studio Environment, obtainable from the ILocalRegistry-creatable object CLSID_VsSearchQueryParser.
//-----------------------------------------------------------------------------
[uuid(uuid_IVsSearchQueryParser)]
interface IVsSearchQueryParser : IUnknown
{
    // Parse the search string and returns the search query
    HRESULT Parse(
        [in] LPCOLESTR pszSearchString,
        [out, retval] IVsSearchQuery **ppSearchQuery);

    // Returns a search string rebuilt from the input search query
    HRESULT BuildSearchString(
        [in] IVsSearchQuery *pSearchQuery,
        [out, retval] BSTR *pbstrSearchString);

    // Returns a search string rebuilt from a sequence of tokens
    HRESULT BuildSearchStringFromTokens(
        [in] DWORD dwTokens,
        [in, size_is(dwTokens)] IVsSearchToken *pSearchTokens[],
        [out, retval] BSTR *pbstrSearchString);

    // Returns a search token that will parse to the specified token text
    HRESULT GetSearchToken(
        [in] LPCOLESTR pszTokenText,
        [out, retval] IVsSearchToken **ppSearchToken);

    // Returns a search filter token built from the specified filter token components
    HRESULT GetSearchFilterToken(
        [in] LPCOLESTR pszFilterField,
        [in] LPCOLESTR pszFilterValue,
        [in] VSSEARCHFILTERTOKENTYPE dwFilterTokenType,
        [out, retval] IVsSearchFilterToken **ppSearchFilterToken);
}

//-----------------------------------------------------------------------------
// IVsSearchQuery
//
// Describes a structured search string
//-----------------------------------------------------------------------------
[ uuid(uuid_IVsSearchQuery) ]
interface IVsSearchQuery : IUnknown
{
    // Returns the original search string
    [propget] HRESULT SearchString([out, retval] BSTR *pbstrSearchString);
    // Returns whether there was any error parsing the search string into tokens
    [propget] HRESULT ParseError([out, retval] VSSEARCHPARSEERROR *pdwParseError);
    // Get the search tokens
    HRESULT GetTokens(
        [in] DWORD dwMaxTokens,
        [out, size_is(dwMaxTokens), length_is(*pdwTokensReturned)] IVsSearchToken *rgpSearchTokens[],
        [out, retval] DWORD *pdwTokensReturned );
}

//-----------------------------------------------------------------------------
// IVsSearchToken
//
// Describes a token composing a search query
//-----------------------------------------------------------------------------
[ uuid(uuid_IVsSearchToken) ]
interface IVsSearchToken : IUnknown
{
    // Returns the original text of the token
    [propget] HRESULT OriginalTokenText([out, retval] BSTR *pbstrOriginalTokenText);
    // Returns the position of the token in the original text of the search query
    [propget] HRESULT TokenStartPosition([out, retval] DWORD *pdwTokenStartPosition);
    // Returns the token text, with quotes removed and characters unescaped
    [propget] HRESULT ParsedTokenText([out, retval] BSTR *pbstrParsedTokenText);
    // Returns whether there was any error parsing the token
    [propget] HRESULT ParseError([out, retval] VSSEARCHPARSEERROR *pdwParseError);
}

//-----------------------------------------------------------------------------
// IVsSearchFilterToken
//
// Describes a token composing a search query that could belong to a search filter,
// usually having the name:value format
//-----------------------------------------------------------------------------
[ uuid(uuid_IVsSearchFilterToken) ]
interface IVsSearchFilterToken : IVsSearchToken
{
    // Returns the filter name/field, with quotes removed and characters unescaped
    [propget] HRESULT FilterField([out, retval] BSTR *pbstrFilterField);
    // Returns the filter value, with quotes removed and characters unescaped
    [propget] HRESULT FilterValue([out, retval] BSTR *pbstrFilterValue);
    // Returns the filter token type
    [propget] HRESULT FilterTokenType([out, retval] VSSEARCHFILTERTOKENTYPE * pdwFilterTokenType);
    // Returns the position of the filter field separator in the original text of the token
    [propget] HRESULT FilterSeparatorPosition([out, retval] DWORD *pdwFilterSeparatorPosition);
}

//-----------------------------------------------------------------------------
// IVsWindowSearchHostFactory
//
// Implemented by the Visual Studio Environment, obtained via the SID_SVsWindowSearchHostFactory service.
//-----------------------------------------------------------------------------
[ uuid(uuid_IVsWindowSearchHostFactory) ]
interface IVsWindowSearchHostFactory : IUnknown
{
    // Creates a search control child of the specified control and returns its search host interface
    HRESULT CreateWindowSearchHost(
        [in] IUnknown *pParentControl,
        [in, optional] IDropTarget *pDropTarget,
        [out, retval] IVsWindowSearchHost **ppSearchHost);
}

#ifndef PROXYSTUB_BUILD

//-----------------------------------------------------------------------------
// SVsWindowSearchHostFactory
// The service type implementing IVsWindowSearchHostFactory
//-----------------------------------------------------------------------------
[ uuid(uuid_SVsWindowSearchHostFactory)]
interface SVsWindowSearchHostFactory : IUnknown
{
}
cpp_quote("#define SID_SVsWindowSearchHostFactory IID_SVsWindowSearchHostFactory")

#endif

//----------------------------------------------------------------------------
// IVsWindowSearchHost
//
// Implemented by the Shell, called by a toolwindow or dialog to setup a search control
//----------------------------------------------------------------------------
[ uuid (uuid_IVsWindowSearchHost) ]
interface IVsWindowSearchHost : IUnknown
{
    // Associates the search host control with the window search provider
    HRESULT SetupSearch([in] IVsWindowSearch *pWindowSearch);

    // Disassociates the search host control from the window search provider, release resources used by the search
    HRESULT TerminateSearch();

    // Returns the search object once the search has been setup with the host
    [propget] HRESULT SearchObject ([out,retval] IVsWindowSearch **ppSearchObject);

    // Returns the search events callback once the search has been setup with the host
    [propget] HRESULT SearchEvents ([out,retval] IVsWindowSearchEvents **ppSearchEvents);

    // Sets the search query and begins a search; for null query stops the search if necessary and clears it
    HRESULT SearchAsync([in] IVsSearchQuery *pSearchQuery);

    // Returns the search query parser used by the search host to create the search queries from search strings typed by user
    [propget] HRESULT SearchQueryParser([out, retval] IVsSearchQueryParser **ppSearchQueryParser);

    // Returns the current search query, result of parsing the current text in the search control
    [propget] HRESULT SearchQuery([out, retval] IVsSearchQuery **ppSearchQuery);

    // Returns current search task if a search is in progress
    [propget] HRESULT SearchTask([out, retval] IVsSearchTask **ppTask);

    // Show or hide the search control
    [propput] HRESULT IsVisible([in] VARIANT_BOOL fVisible);

    // Returns whether the search control is setup and visible
    [propget] HRESULT IsVisible([out, retval] VARIANT_BOOL *pfVisible);

    // Enable or disable the search control
    [propput] HRESULT IsEnabled([in] VARIANT_BOOL fEnabled);

    // Returns whether the search control is setup and enabled
    [propget] HRESULT IsEnabled([out, retval] VARIANT_BOOL *pfEnabled);

    // Show or hide the search control's popup (if the search control has settings requiring a popup, such as MRU, options or filters)
    [propput] HRESULT IsPopupVisible([in] VARIANT_BOOL fVisible);

    // Returns whether the search control's popup is visible
    [propget] HRESULT IsPopupVisible([out, retval] VARIANT_BOOL *pfVisible);

    // Set focus to the search control
    HRESULT Activate();

    // Returns the help topic associated with the search control, or NULL if no topic has been set
    [propget] HRESULT HelpTopic( [out, retval] BSTR *pbstrHelpTopic );

    // Sets the help topic associated with the search control
    [propput] HRESULT HelpTopic( [in] LPCOLESTR lpszHelpTopic );
}

typedef enum __VSSEARCHSTARTTYPE
{
    SST_INSTANT     = 0,   // The search will start immediately after the user has pressed a characters
    SST_DELAYED     = 1,   // The search will start after a delay since the user has last pressed a character in search box, typically 1 second.
    SST_ONDEMAND    = 2,   // The search will only start when Enter key is pressed
} VSSEARCHSTARTTYPE;

typedef enum __VSSEARCHPROGRESSTYPE
{
    SPT_NONE           = 0,   // The search control will not display any progress type
    SPT_INDETERMINATE  = 1,   // The search will be an infinite-loop animation, as exact search progress cannot be determined
    SPT_DETERMINATE    = 2,   // The search will display a 0-100% progress bar, as the window search can report progress
} VSSEARCHPROGRESSTYPE;

// Navigations keys that are passed in to IVsWindowSearch after the search is started. The window may use them to navigate between the found results.
enum __VSSEARCHNAVIGATIONKEY
{
    SNK_ENTER       = 0x00000000,
    SNK_DOWN        = 0x00000001,
    SNK_UP          = 0x00000002,
    SNK_PAGEDOWN    = 0x00000003,
    SNK_PAGEUP      = 0x00000004,
    SNK_HOME        = 0x00000005,
    SNK_END         = 0x00000006
};

typedef DWORD VSSEARCHNAVIGATIONKEY;

// Various settings that IVsWindowSearch implementers can provide to override the defaults and control the search behavior
cpp_quote("#define szWSS_SEARCH_USE_MRU L\"SearchUseMRU\"")                         // VSUI_TYPE_BOOL. Whether the search control will display MRU items in the drop-down popup. Default=True.
cpp_quote("#define szWSS_MAXIMUM_MRU_ITEMS L\"MaximumMRUItems\"")                   // VSUI_TYPE_DWORD. The maximum number of MRU items to show in the popup. Default=5.
cpp_quote("#define szWSS_SEARCH_START_TYPE L\"SearchStartType\"")                   // VSUI_TYPE_DWORD(VSSEARCHSTARTTYPE). The search start type (instant/delayed/ondemand). Default=SST_DELAYED.
cpp_quote("#define szWSS_SEARCH_START_DELAY L\"SearchStartDelay\"")                 // VSUI_TYPE_DWORD. The delay in milliseconds after which a search starts automatically (for delayed search type). Default=1000ms.
cpp_quote("#define szWSS_SEARCH_START_MINCHARS L\"SearchStartMinChars\"")           // VSUI_TYPE_DWORD. The minimum number of characters that have relevance for the window search. The window host will wait for the user to type at least the min number of characters before calling IVsWindowSearch to start a new search. Default=1.
cpp_quote("#define szWSS_RESTART_SEARCH_IF_UNCHANGED L\"RestartSearchIfUnchanged\"") // VSUI_TYPE_BOOL. Whether the search will be restarted on pressing Enter or selecting MRU item from the list, even if the search string is not changed. Default=False.
cpp_quote("#define szWSS_SEARCH_TRIMS_WHITESPACES L\"SearchTrimsWhitespaces\"")     // VSUI_TYPE_BOOL. Whether the search string has whitespaces trimmed from beginning and end before starting a search or adding the item to MRU list. Default=True.
cpp_quote("#define szWSS_SEARCH_PROGRESS_TYPE L\"SearchProgressType\"")             // VSUI_TYPE_DWORD(VSSEARCHPROGRESSTYPE). The progress type supported by the window search. Default=SPT_INDETERMINATE.
cpp_quote("#define szWSS_SEARCH_PROGRESS_SHOW_DELAY L\"SearchProgressShowDelay\"")  // VSUI_TYPE_DWORD. The delay in milliseconds from the search start after which the progress indicator is displayed. This allows fast searches to complete without showing progress. Default=200ms.
cpp_quote("#define szWSS_SEARCH_POPUP_AUTO_DROPDOWN L\"SearchPopupAutoDropdown\"")  // VSUI_TYPE_BOOL. Whether the search popup is automatically shown on typing (for delayed and on-demand searches only). Default=True.
cpp_quote("#define szWSS_SEARCH_POPUP_CLOSE_DELAY L\"SearchPopupCloseDelay\"")      // VSUI_TYPE_DWORD. The delay in milliseconds after a search is automatically started after which the search popup is automatically closed. Default=4000ms.
cpp_quote("#define szWSS_SEARCH_WATERMARK L\"SearchWatermark\"")                    // VSUI_TYPE_STRING. The string displayed in the search box when it's empty and doesn't have the focus. Default="Search".
cpp_quote("#define szWSS_SEARCH_TOOLTIP L\"SearchTooltip\"")                        // VSUI_TYPE_STRING. The tooltip for the search edit box. Default="Type words to search for".
cpp_quote("#define szWSS_SEARCH_START_TOOLTIP L\"SearchStartTooltip\"")             // VSUI_TYPE_STRING. The tooltip for the search button before starting the search. Default="Search".
cpp_quote("#define szWSS_SEARCH_STOP_TOOLTIP L\"SearchStopTooltip\"")               // VSUI_TYPE_STRING. The tooltip for the search button while the search is performed. Default="Stop search".
cpp_quote("#define szWSS_SEARCH_CLEAR_TOOLTIP L\"SearchClearTooltip\"")             // VSUI_TYPE_STRING. The tooltip for the search button after a search is complete. Default="Clear search".
cpp_quote("#define szWSS_CONTROL_MIN_WIDTH L\"ControlMinWidth\"")                   // VSUI_TYPE_DWORD. The minimum width of the search control. Default=100.
cpp_quote("#define szWSS_CONTROL_MAX_WIDTH L\"ControlMaxWidth\"")                   // VSUI_TYPE_DWORD. The maximum width of the search control. Default=400.
cpp_quote("#define szWSS_CONTROL_MIN_POPUP_WIDTH L\"ControlMinPopupWidth\"")        // VSUI_TYPE_DWORD. The minimum width of the search control's popup. Default=200.
cpp_quote("#define szWSS_SEARCH_BUTTON_VISIBLE L\"SearchButtonVisible\"")           // VSUI_TYPE_BOOL. Whether the search button is visible. Default=True.
cpp_quote("#define szWSS_FORWARD_ENTER_ON_SEARCH_START L\"ForwardEnterKeyOnSearchStart\"") // VSUI_TYPE_BOOL. Whether the search control forwards the enter key event after search is started. Default=False.
cpp_quote("#define szWSS_USE_DEFAULT_THEME_COLORS L\"UseDefaultThemeColors\"")     // VSUI_TYPE_BOOL. Whether the search control should only use the colors of the default theme. This is usually set to true when the search control is hosted in a dialog whose colors don't change when the IDE theme changes. Default=False.


//----------------------------------------------------------------------------
// IVsWindowSearch
//
// Implemented by a window that wants to have searchable content
// The search host will call this interface to initiate the search or obtain search options
//
// When the interface is implemented by a toolwindow on the IVsWindowPane class or on VSFPROPID_ViewHelper,
// it will be called by shell on SearchEnabled to check if the search is enabled for the toolwindow
// and the shell will automatically setup a search host associated with the window,
// using the default placement for the search control in the shell frame/toolbar area.
//----------------------------------------------------------------------------
[ uuid (uuid_IVsWindowSearch) ]
interface IVsWindowSearch : IUnknown
{
    // Returns whether the search should be enabled for the window
    [propget] HRESULT SearchEnabled ([out,retval] VARIANT_BOOL *pfEnabled);

    // Return an identifier of the search provider. For a tool window search provider, if the category is not returned the toolwindow guid will be used by default.
    [propget] HRESULT Category([out,retval] GUID *pguidCategoryId);

    // Creates a new search task object. The task is cold-started - Start() needs to be called on the task object to begin the search.
    HRESULT CreateSearch(
        [in] VSCOOKIE dwCookie,
        [in] IVsSearchQuery *pSearchQuery,
        [in] IVsSearchCallback *pSearchCallback,
        [out, retval] IVsSearchTask **ppSearchTask);

    // Clears the search result (e.g. the user cleared the content of the search edit box)
    HRESULT ClearSearch();

    // Allows the window search host to obtain overridable search options
    HRESULT ProvideSearchSettings ([in] IVsUIDataSource *pSearchSettings);

    // Returns an interface that can be used to enumerate search filters
    [propget] HRESULT SearchFiltersEnum([out,retval] IVsEnumWindowSearchFilters **ppEnum);

    // Returns an interface that can be used to enumerate boolean search options
    [propget] HRESULT SearchOptionsEnum([out,retval] IVsEnumWindowSearchOptions **ppEnum);

    // Allows the window to preview some keydown events that can be used to navigate between the search results or take action on them
    HRESULT OnNavigationKeyDown([in] VSSEARCHNAVIGATIONKEY dwNavigationKey, [in] VSUIACCELMODIFIERS dwModifiers, [out, retval] VARIANT_BOOL *pfHandled);
}

//----------------------------------------------------------------------------
// IVsWindowSearchEvents
//
// Implemented by the window host, can be called by the search provider to let
// the host know there were changes to the filters or options that have to be reflected in UI
//----------------------------------------------------------------------------
[ uuid (uuid_IVsWindowSearchEvents) ]
interface IVsWindowSearchEvents : IUnknown
{
    // Notify there was a change in the search filters (e.g. filters added/removed, displayed texts changes)
    HRESULT SearchFiltersChanged();

    // Notify there was a change in the search options (e.g. options added/removed, displayed texts changes)
    HRESULT SearchOptionsChanged();

    // Notify there was a change in the boolean search option's value
    HRESULT SearchOptionValueChanged( [in] IVsWindowSearchBooleanOption * pOption );
}

//----------------------------------------------------------------------------
// Values for the IVsSearchTask status
//----------------------------------------------------------------------------
enum __VSSEARCHTASKSTATUS
{
    STS_CREATED     = 0,   // The task was created but search was not started yet
    STS_STARTED     = 1,   // The search was started
    STS_COMPLETED   = 2,   // The search has completed
    STS_STOPPED     = 3,   // The search has been stopped/interrupted
    STS_ERROR       = 4,   // The search has encountered errors
};

typedef DWORD VSSEARCHTASKSTATUS;

//----------------------------------------------------------------------------
// IVsSearchTask
//
// Implemented by the search objects
// The search consumer will call this interface to start or stop a search operation
//----------------------------------------------------------------------------
[ uuid (uuid_IVsSearchTask) ]
interface IVsSearchTask : IUnknown
{
    // Starts the actual search. Search operations are always called on background threads.
    HRESULT Start();

    // Stops a previously started search (e.g. the user clicked the X button during a long search)
    HRESULT Stop();

    // Returns the VSCOOKIE identifying the task
    [propget] HRESULT Id([out, retval] VSCOOKIE *pdwCookie);

    // Returns the search query used when the search task was created
    [propget] HRESULT SearchQuery([out, retval] IVsSearchQuery **ppSearchQuery);

    // Returns the task status, with values from VSSEARCHTASKSTATUS
    [propget] HRESULT Status([out, retval] VSSEARCHTASKSTATUS *pTaskStatus);

    // Returns the error code for the search (meaningful only if the search has encountered an error)
    [propget] HRESULT ErrorCode([out,retval] HRESULT *errorCode);
}

//----------------------------------------------------------------------------
// IVsSearchCallback
//
// Implemented by the search consumer (e.g. window search host)
// The search task will call this interface to report progress or completion
//----------------------------------------------------------------------------
[ uuid (uuid_IVsSearchCallback) ]
interface IVsSearchCallback : IUnknown
{
    // Report search progress (if this can be tracked)
    HRESULT ReportProgress([in] IVsSearchTask *pTask, [in] DWORD dwProgress, [in] DWORD dwMaxProgress);

    // Called by the search provider to notify the search is complete (successful, stopped or with error)
    HRESULT ReportComplete([in] IVsSearchTask *pTask, [in] DWORD dwResultsFound);
}

//----------------------------------------------------------------------------
// IVsWindowSearchFilter
//----------------------------------------------------------------------------
[ uuid(uuid_IVsWindowSearchFilter) ]
interface IVsWindowSearchFilter : IUnknown
{
    // Returns a displayable string used for the filter button in the UI
    [propget] HRESULT DisplayText( [out, retval] BSTR *pbstrDisplayText );

    // Returns a string that describe the filter functionality
    [propget] HRESULT Tooltip( [out, retval] BSTR *pbstrTooltip );
}

//----------------------------------------------------------------------------
// IVsWindowSearchSimpleFilter
//----------------------------------------------------------------------------
[ uuid(uuid_IVsWindowSearchSimpleFilter) ]
interface IVsWindowSearchSimpleFilter : IVsWindowSearchFilter
{
    // Returns a string that identifies this filter (in constructs like filterfield:value)
    [propget] HRESULT FilterField( [out, retval] BSTR *pbstrFilterField );

    // Returns a default value string that will be used by the shell in constructs like filterfield:defaultvalue when the filter button is clicked
    [propget] HRESULT DefaultFilterValue( [out, retval] BSTR *pbstrDefaultFilterValue );
}

//----------------------------------------------------------------------------
// IVsWindowSearchCustomFilter
//----------------------------------------------------------------------------
[ uuid(uuid_IVsWindowSearchCustomFilter) ]
interface IVsWindowSearchCustomFilter : IVsWindowSearchFilter
{
    // Apply the filter to the current search string, returning the result and a selection interval delimiting the string that should be displayed selected
    // (use -1 to indicate string end, [0,-1] to select the whole string, etc.
    // Implementers could for instance append a text like Filter:(<parameter>) if no text is selected and return a selection for <parameter> string for easy replacement,
    // or can insert text around the selected text like Filter:(<existing_selection>)
    HRESULT ApplyFilter(
        [in, out] BSTR *pbstrSearchString,
        [in, out] int *piSelectionStart,
        [in, out] int *piSelectionEnd );
}

//----------------------------------------------------------------------------
// IVsEnumWindowSearchFilters
//----------------------------------------------------------------------------
[ uuid(uuid_IVsEnumWindowSearchFilters) ]
interface IVsEnumWindowSearchFilters : IUnknown
{
    HRESULT Next([in] ULONG celt, [out, size_is(celt), length_is(*pceltFetched)] IVsWindowSearchFilter *rgelt[], [out] ULONG *pceltFetched);
    HRESULT Skip([in] ULONG celt);
    HRESULT Reset(void);
    HRESULT Clone([out] IVsEnumWindowSearchFilters **ppenum);
}

//----------------------------------------------------------------------------
// IVsWindowSearchOption
//----------------------------------------------------------------------------
[ uuid(uuid_IVsWindowSearchOption) ]
interface IVsWindowSearchOption : IUnknown
{
    // Returns a displayable string that will be used for the option's text
    [propget] HRESULT DisplayText( [out, retval] BSTR *pbstrDisplayText );

    // Returns a string that describe the option
    [propget] HRESULT Tooltip( [out, retval] BSTR *pbstrTooltip );
}

//----------------------------------------------------------------------------
// IVsEnumWindowSearchOptions
//----------------------------------------------------------------------------
[ uuid(uuid_IVsEnumWindowSearchOptions) ]
interface IVsEnumWindowSearchOptions : IUnknown
{
    HRESULT Next([in] ULONG celt, [out, size_is(celt), length_is(*pceltFetched)] IVsWindowSearchOption *rgelt[], [out] ULONG *pceltFetched);
    HRESULT Skip([in] ULONG celt);
    HRESULT Reset(void);
    HRESULT Clone([out] IVsEnumWindowSearchOptions **ppenum);
}

//----------------------------------------------------------------------------
// IVsWindowSearchBooleanOption
//----------------------------------------------------------------------------
[ uuid(uuid_IVsWindowSearchBooleanOption) ]
interface IVsWindowSearchBooleanOption : IVsWindowSearchOption
{
    // Boolean option getter and setter
    [propput] HRESULT Value( [in] VARIANT_BOOL fValue );
    [propget] HRESULT Value( [out, retval] VARIANT_BOOL *pfValue );
}

//----------------------------------------------------------------------------
// IVsWindowSearchCommandOption
//----------------------------------------------------------------------------
[ uuid(uuid_IVsWindowSearchCommandOption) ]
interface IVsWindowSearchCommandOption : IVsWindowSearchOption
{
    // Invoke the command associated with this option
    HRESULT Invoke();
}

//-----------------------------------------------------------------------------
// Quick Launch / Global Search interfaces
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// IVsEnumSearchProviders
//
// Allows enumeration of search providers
//-----------------------------------------------------------------------------
[ uuid(uuid_IVsEnumSearchProviders) ]
interface IVsEnumSearchProviders : IUnknown
{
    HRESULT Next([in] ULONG celt, [out, size_is(celt), length_is(*pceltFetched)] IVsSearchProvider *rgelt[], [out] ULONG *pceltFetched);
    HRESULT Skip([in] ULONG celt);
    HRESULT Reset(void);
    HRESULT Clone([out] IVsEnumSearchProviders **ppenum);
}

// Various settings that IVsSearchProvider implementers can provide to override the defaults and control the search behavior
cpp_quote("#define szSPS_SEARCH_PROGRESS_TYPE L\"SearchProgressType\"")         // VSUI_TYPE_DWORD(VSSEARCHPROGRESSTYPE). The progress type supported by the search provider. Default=SPT_NONE.
cpp_quote("#define szSPS_SEARCH_RESULTS_CACHEABLE L\"SearchResultsCacheable\"") // VSUI_TYPE_BOOL. Whether the Most Recently Executed provider (IVsMRESearchProvider) can cache the text properties of the result items for faster recent item retrieval. Default=True.

//-----------------------------------------------------------------------------
// IVsSearchProvider
//
// Implemented as package extension point to expose a single search provider
//-----------------------------------------------------------------------------
[ uuid(uuid_IVsSearchProvider) ]
interface IVsSearchProvider : IUnknown
{
    // Returns a displayable name for the search provider, e.g. "Menu items"
    [propget] HRESULT DisplayText([out,retval] BSTR *pbstrDisplayText);

    // Returns a description of the provider results, e.g. "Searches top-level menu items"
    [propget] HRESULT Description([out,retval] BSTR *pbstrDescription);

    // Returns a tooltip for the provider displayed when it appears in the Global Search UI instead of "Show results from this category only"
    [propget] HRESULT Tooltip([out,retval] BSTR *pbstrDescription);

    // Return an identifier of the search provider.
    [propget] HRESULT Category([out,retval] GUID *pguidCategoryId);

    // Returns a unique category shortcut that can be used in filtering the results from multiple providers
    // E.g. searching for "@cmd" will return only search results from the provider with category shortcut "cmd"
    [propget] HRESULT Shortcut([out,retval] BSTR *pbstrCategoryShortcut);

    // Creates a new search task object. The task is cold-started - Start() needs to be called on the task object to begin the search.
    HRESULT CreateSearch(
        [in] VSCOOKIE dwCookie,
        [in] IVsSearchQuery *pSearchQuery,
        [in] IVsSearchProviderCallback *pSearchCallback,
        [out, retval] IVsSearchTask **ppSearchTask);

    // Allows the search service to obtain overridable search settings from this provider
    HRESULT ProvideSearchSettings ([in] IVsUIDataSource *pSearchOptions);

    // Re-creates a result item of this search provider from the item's persistence string
    HRESULT CreateItemResult([in] LPCOLESTR lpszPersistenceData, [out, retval] IVsSearchItemResult **ppResult);
}

//-----------------------------------------------------------------------------
// IVsMRESearchProvider
//
// Implemented by the the shell's Most Recently Executed Command search provider
//-----------------------------------------------------------------------------
[ uuid(uuid_IVsMRESearchProvider) ]
interface IVsMRESearchProvider : IVsSearchProvider
{
    // Called by the shell when a new global search item is executed, allows to be persisted as a MRE item. Returns the new collection of MRE items for the specified query.
    HRESULT SetMostRecentlyExecuted([in] IVsSearchQuery *pSearchQuery, [in] IVsSearchItemResult *pResult, [in] DWORD dwMaxResults, [in, out, size_is(dwMaxResults), length_is(*pdwActualResults) ] IVsSearchItemResult * pSearchItemResults[], [in, out] DWORD *pdwActualResults  );
    // Called to intialize the provider
    HRESULT SetSite([in] IServiceProvider *pSP);
    // Called on shell exit, allows saving the MRE items
    HRESULT Close(void);
}

//-----------------------------------------------------------------------------
// IVsSearchProviderCallback
//
// Implemented by shell search service, allows providers to report search progress
// and return search results
//-----------------------------------------------------------------------------
[ uuid(uuid_IVsSearchProviderCallback) ]
interface IVsSearchProviderCallback : IVsSearchCallback
{
    // Search providers can return results in addition to completion/progress tracking
    HRESULT ReportResult([in] IVsSearchTask *pTask, [in] IVsSearchItemResult *pSearchItemResult);
    HRESULT ReportResults([in] IVsSearchTask *pTask, [in] DWORD dwResults, [in, size_is(dwResults)] IVsSearchItemResult *pSearchItemResults[]);
}

//-----------------------------------------------------------------------------
// IVsSearchItemResult
//
// Implemented by result objects returned by search providers
//-----------------------------------------------------------------------------
[ uuid(uuid_IVsSearchItemResult) ]
interface IVsSearchItemResult : IUnknown
{
    // Display text of the item for the UI
    [propget] HRESULT DisplayText([out,retval] BSTR *pbstrDisplayText);

    // More detailed description of the result
    [propget] HRESULT Description([out,retval] BSTR *pbstrDescription);

    // Tooltip for the item
    [propget] HRESULT Tooltip([out,retval] BSTR * pstrTooltip);

    // Icon associated with the result the item (as IVsUIObject of VSUI_TYPE_ICON or VSUI_TYPE_BITMAP type)
    [propget] HRESULT Icon([out,retval] IVsUIObject **ppIconObject);

    // Invokes a specific action associated with the object when the result is selected.
    HRESULT InvokeAction();

    // The search provider that generated this result
    [propget] HRESULT SearchProvider([out,retval] IVsSearchProvider ** ppProvider);

    // A string that can be used to persist this result and that allows reconstruction of the result after a shell restart
    [propget] HRESULT PersistenceData([out,retval] BSTR *pbstrPersistenceData);
}

//-----------------------------------------------------------------------------
// IVsSearchItemDynamicResult
//
// Implemented by result objects returned by search providers
// that have properties which can change dynamically (e.g. dependent on UI context changes in the shell)
//-----------------------------------------------------------------------------
[ uuid(uuid_IVsSearchItemDynamicResult) ]
interface IVsSearchItemDynamicResult : IVsSearchItemResult
{
    // Forces an update of the item properties to reflect the current state of the shell
    HRESULT Update([out, retval] VARIANT_BOOL *isStillValid);
}

//-----------------------------------------------------------------------------
// IVsGlobalSearchTask
//
// Implemented by the search tasks created by the global service
//-----------------------------------------------------------------------------
[ uuid(uuid_IVsGlobalSearchTask) ]
interface IVsGlobalSearchTask : IVsSearchTask
{
    // Returns the list of providers active when the search task was created
    [propget] HRESULT Providers([out, retval] IVsEnumSearchProviders **pProviders);
}

//-----------------------------------------------------------------------------
// IVsGlobalSearch
//
// Implemented by the global search service to support IDE-wide searches
//-----------------------------------------------------------------------------
[ uuid(uuid_IVsGlobalSearch) ]
interface IVsGlobalSearch : IUnknown
{
    // Create a search task for the available providers or a specific provider category. Use GUID_NULL for category to search across all providers.
    HRESULT CreateSearch(
        [in] IVsSearchQuery *pSearchQuery,
        [in] IVsGlobalSearchCallback *pSearchCallback,
        [in, optional] GUID guidCategory,
        [out, retval] IVsGlobalSearchTask **ppSearchTask );

    // Returns the list of all available/installed providers
    [propget] HRESULT Providers([out, retval] IVsEnumSearchProviders **pProviders);

    // Returns the provider supporting the specified category, or null if no such category exist
    HRESULT GetProvider([in] GUID guidCategoryId, [out,retval] IVsSearchProvider ** ppProvider);

    // Returns whether the specified search provider is enabled
    HRESULT IsProviderEnabled([in] GUID guidCategoryId, [out, retval] VARIANT_BOOL *pfEnabled);

    // Enable or disable the specified search provider
    HRESULT SetProviderEnabled([in] GUID guidCategoryId, [in] VARIANT_BOOL fEnabled);

    // Registers the specified provider
    HRESULT RegisterProvider([in] IVsSearchProvider *pProvider);

    // Unregisters the specified provider
    HRESULT UnregisterProvider([in] GUID guidCategoryId);

    // Returns the provider settings for the specified provider, or null if no such category exists
    HRESULT GetProviderSettings([in] GUID guidCategoryId, [out,retval] IVsUIDataSource **ppProviderSettings);
}

//-----------------------------------------------------------------------------
// IVsGlobalSearchCallback
//
// Implemented by a consumer of the search service to track progress of the searches
//-----------------------------------------------------------------------------
[ uuid(uuid_IVsGlobalSearchCallback) ]
interface IVsGlobalSearchCallback : IVsSearchCallback
{
    // Results available per provider
    HRESULT ResultReported(
        [in] IVsGlobalSearchTask *pTask,
        [in] IVsSearchProvider *pProvider,
        [in] IVsSearchItemResult *pItemResult);

    HRESULT ResultsReported(
        [in] IVsGlobalSearchTask *pTask,
        [in] IVsSearchProvider *pProvider,
        [in] DWORD dwResults,
        [in, size_is(dwResults)] IVsSearchItemResult *pSearchItemResults[]);

    // Progress report per provider
    HRESULT ProgressReported(
        [in] IVsGlobalSearchTask *pTask,
        [in] IVsSearchProvider *pProvider,
        [in] DWORD dwProgress,
        [in] DWORD dwMaxProgress);

    // Events per provider
    HRESULT ProviderSearchStarted(
        [in] IVsGlobalSearchTask *pTask,
        [in] IVsSearchProvider *pProvider,
        [in] IVsSearchTask *pProviderTask);

    HRESULT ProviderSearchCompleted(
        [in] IVsGlobalSearchTask *pTask,
        [in] IVsSearchProvider *pProvider,
        [in] IVsSearchTask *pProviderTask);
}

//----------------------------------------------------------------------------
// IVsGlobalSearchUIResultsCategory
//
// Interface implemented by the Global Search UI for search categories that have returned results
//----------------------------------------------------------------------------
[ uuid(uuid_IVsGlobalSearchUIResultsCategory) ]
interface IVsGlobalSearchUIResultsCategory : IUnknown
{
    // The name of the category, e.g. "All providers" or "Menu items"
    [propget] HRESULT DisplayText([out, retval] BSTR* pRetVal);

    // The provider supporting the category, or NULL for 'All providers' category
    [propget] HRESULT CategoryProvider ([out, retval] IVsSearchProvider ** ppProvider);

    // Total number of results in this category
    [propget] HRESULT TotalResultsCount([out, retval] DWORD * pdwResults);

    // Number of results displayed from this category
    [propget] HRESULT DisplayedResultsCount([out, retval] DWORD * pdwResults);

    // Get the displayed result by index from this category
    HRESULT GetResult([in] DWORD dwIndex, [out, retval] IVsSearchItemResult ** ppSearchItemResult);

    // Invoke to display all results from this category
    HRESULT DisplayAllResults();

    // Returns whether the category is displaying all results
    [propget] HRESULT IsDisplayingAllResults([out, retval] VARIANT_BOOL *pfDisplayingAllResults);
}

//-----------------------------------------------------------------------------
// IVsGlobalSearchUI
//
// Implemented by the search service, allows access to IDE/Global Search UI
//-----------------------------------------------------------------------------
[ uuid(uuid_IVsGlobalSearchUI) ]
interface IVsGlobalSearchUI : IUnknown
{
    // Enable or disable the Global Search UI
    [propput] HRESULT IsEnabled([in] VARIANT_BOOL fEnabled);

    // Returns whether the Global Search UI is enabled
    [propget] HRESULT IsEnabled([out, retval] VARIANT_BOOL *pfEnabled);

    // Sets whether the Global Search will preserve results from previous search to be displayed when the UI is shown again
    [propput] HRESULT PreserveResults([in] VARIANT_BOOL pfPreserve);

    // Returns whether the Global Search preserve results from previous search to be displayed when the UI is shown again
    [propget] HRESULT PreserveResults([out, retval] VARIANT_BOOL *pfPreserve);

    // Returns the search host of the Global Search control. Can be used to initiate IDE-wide searches with UI, get the status of the existing search, etc.
    [propget] HRESULT SearchHost([out, retval] [out, retval] IVsWindowSearchHost **ppSearchHost);

    // Get the results categories for the current search
    HRESULT GetResultsCategories(
        [in] DWORD dwMaxCategories,
        [out, size_is(dwMaxCategories), length_is(*pdwCategoriesReturned)] IVsGlobalSearchUIResultsCategory **rgpResultsCategories,
        [out, retval] DWORD *pdwCategoriesReturned );

    // Get the active category index or -1 if no results are displayed (no categories exist yet)
    [propget] HRESULT ActiveResultsCategory([out, retval] int * piCategoryIndex);

    // Sets the active category index (switches the UI to that category)
    [propput] HRESULT ActiveResultsCategory([in] int iCategoryIndex);

    // Returns whether the global search results popup is visible
    [propget] HRESULT IsResultsListVisible([out, retval] VARIANT_BOOL * pfVisible);

    // Sets whether the global search results popup is visible
    [propput] HRESULT IsResultsListVisible([in] VARIANT_BOOL fVisible);

    // Returns whether the global search control or its popup has focus
    [propget] HRESULT IsActive([out, retval] VARIANT_BOOL * pfActive);

    // Focuses the global search control or shows next results category if the control already is active
    HRESULT Activate();

    // Focuses the global search control or shows previous results category if the control already is active (navigate backwards)
    HRESULT ActivateBack();
}

#ifndef PROXYSTUB_BUILD

//-----------------------------------------------------------------------------
// SVsGlobalSearch
// The service id for vs IVsGlobalSearch service.
//-----------------------------------------------------------------------------
[ uuid(uuid_SVsGlobalSearch)]
interface SVsGlobalSearch : IUnknown
{
}
cpp_quote("#define SID_SVsGlobalSearch IID_SVsGlobalSearch")

#endif

//----------------------------------------------------------------------------
// enum for Process Architecture
//----------------------------------------------------------------------------
typedef enum __VSPROFILERPROCESSARCHTYPE
{
    ARCH_UNKNOWN = 0,
    ARCH_X86 = 1,
    ARCH_X64 = 2,
} VSPROFILERPROCESSARCHTYPE;

//----------------------------------------------------------------------------
// enum for launch options
//----------------------------------------------------------------------------
enum __VSPROFILERLAUNCHOPTS
{
    VSPLO_NOPROFILE = 0x00000001,   // Launch but do not collect profiling information for this target.
};
typedef DWORD VSPROFILERLAUNCHOPTS;

//----------------------------------------------------------------------------
// IVsProfilerTargetInfo
//
// Base class for profiler target infos.
//----------------------------------------------------------------------------
[uuid(uuid_IVsProfilerTargetInfo)]
interface IVsProfilerTargetInfo : IUnknown
{
    // Architecture of the process that will be launched. Needed to correctly determine which profiling monitor to start.
    [propget] HRESULT ProcessArchitecture([out, retval]VSPROFILERPROCESSARCHTYPE* arch);
}

//----------------------------------------------------------------------------
// IVsProfilerLaunchTargetInfo
//
// Target that will be launched by the profiler, not the project system.
//----------------------------------------------------------------------------
[uuid(uuid_IVsProfilerLaunchTargetInfo)]
interface IVsProfilerLaunchTargetInfo : IVsProfilerTargetInfo
{
    // If binaries are referenced by this project, return them here.
    // For VSLangProj.VSProjects, this can be the 'References' property.
    //
    // You may also provide the full path to a project file if you have a project reference.
    [propget] HRESULT References([out,retval]SAFEARRAY(BSTR)* rgbstr);
    // Environment variables that the project system wishes to set for the process to be launched
    // should be returned here in 'CreateProcess' style (Each element is in the form 'Variable=Value').
    [propget] HRESULT EnvironmentSettings([out, retval]SAFEARRAY(BSTR)* pbstr);
    /// Flags that affect the launch.
    [propget] HRESULT LaunchProfilerFlags([out, retval]VSPROFILERLAUNCHOPTS* opts);
}

//----------------------------------------------------------------------------
// IVsProfilerLaunchExeTargetInfo
//
// Executable target that will be launched by the profiler, not the project system.
//----------------------------------------------------------------------------
[uuid(uuid_IVsProfilerLaunchExeTargetInfo)]
interface IVsProfilerLaunchExeTargetInfo : IVsProfilerLaunchTargetInfo
{
    // Command-line arguments for the executable.
    [propget] HRESULT ExecutableArguments([out, retval]BSTR* pbstr);
    // Executable name and optionally the full path.
    [propget] HRESULT ExecutablePath ([out, retval]BSTR* pbstr);
    // Working directory for process to run in.
    [propget] HRESULT WorkingDirectory ([out, retval]BSTR* pbstr);
}

//----------------------------------------------------------------------------
// IVsProfilerLaunchBrowserTargetInfo
//
// Launch a browser with a specified URL.
//----------------------------------------------------------------------------
[uuid(uuid_IVsProfilerLaunchBrowserTargetInfo)]
interface IVsProfilerLaunchBrowserTargetInfo : IVsProfilerLaunchTargetInfo
{
    // URL to launch
    [propget] HRESULT Url([out, retval]BSTR* pbstr);
}

//----------------------------------------------------------------------------
// IVsProfilerLaunchWebServerTargetInfo
//
// Launch a webserver. Uses the URL to determine which instance of w3wp
// to restart/update and then attach to.
//----------------------------------------------------------------------------
[uuid(uuid_IVsProfilerLaunchWebServerTargetInfo)]
interface IVsProfilerLaunchWebServerTargetInfo : IVsProfilerLaunchTargetInfo
{
    // URL that will be used in web server.
    [propget] HRESULT Url([out, retval]BSTR* pbstr);
}

//----------------------------------------------------------------------------
// IVsProfilerAttachTargetInfo
//
// Request that the profiler attach to the specified process Id.
// The ProcessId does not need to set correctly until
// IVsProfilableProjectCfg.LaunchProfiler has been called, but the process
// architecture must be available earlier.
//----------------------------------------------------------------------------
[uuid(uuid_IVsProfilerAttachTargetInfo)]
interface IVsProfilerAttachTargetInfo : IVsProfilerTargetInfo
{
    // Process ID to attach to.
    [propget] HRESULT ProcessId([out, retval]DWORD* processId);
}

//----------------------------------------------------------------------------
// IEnumVsProfilerTargetInfos
//----------------------------------------------------------------------------
[
    uuid(uuid_IEnumVsProfilerTargetInfos),
    version(1.0),
    pointer_default(unique)
]
[custom(uuid_VsPreserveSigAttribute, "preservesig")]
interface IEnumVsProfilerTargetInfos : IUnknown
{
    HRESULT Next([in]   ULONG celt, [out, size_is(celt), length_is(*pceltFetched)] IVsProfilerTargetInfo **rgelt, [out] ULONG *pceltFetched);
    HRESULT Skip([in]   ULONG celt);
    HRESULT Reset(void);
    HRESULT Clone([out] IEnumVsProfilerTargetInfos **ppenum);
}

//----------------------------------------------------------------------------
// IVsProfilableProjectCfg
//
/// A project can indicate that it is profilable by implementing this interface
//----------------------------------------------------------------------------
[uuid(uuid_IVsProfilableProjectCfg)]
interface IVsProfilableProjectCfg : IUnknown
{
    // When the profiler launches in Instrumentation Mode it statically instruments
    // assemblies and if they are signed a warning is displayed to indicate that
    // binaries should be re-signed. If the project system intends to do this anyway,
    // the warning is not required.
    [propget] HRESULT SuppressSignedAssemblyWarnings([retval, out]VARIANT_BOOL* suppress);
    // Some legacy WEB projects (like SharePoint) need additional assistance
    // to start profiling scenario, as they rely on existing VS Profiler functionality.
    // New projects (like IISExpress) do not need it.
    [propget] HRESULT LegacyWebSupportRequired([retval, out]VARIANT_BOOL* required);
    // Profiling tasks that are supported by this project system.
    // If empty, support all profiling tasks.
    // Otherwise, it should return some combination of:
    // - ClassicCPUSampling
    // - ClassicInstrumentation
    // - ClassicConcurrency
    HRESULT GetSupportedProfilingTasks([out] SAFEARRAY(BSTR) *tasks);
    // Called before the launch proceeds to give the project system the opportunity to
    // decide not to launch.
    HRESULT BeforeLaunch([in] BSTR profilingTask);
    // Task to run before profiling of targets starts.
    // Called AFTER the monitor starts and AFTER instrumentation except for dynamic website instrumentation.
    // Called BEFORE any launch targets are started.
    HRESULT BeforeTargetsLaunched();
    // The profiler calls this method in the project system to start the launch procedure.
    // See the comments on IVsProfilerLauncher for typical usage.
    HRESULT LaunchProfiler();
    // Used to find out information about targets that will be used for launch.
    HRESULT QueryProfilerTargetInfoEnum([out] IEnumVsProfilerTargetInfos **targetsEnum);
    // If browser targets were created, this method will be called when all of them have exited.
    // This is useful if the project system wishes to finish profiling when the browser is closed
    // by shutting down any services they provided.
    HRESULT AllBrowserTargetsFinished();
    // This method will be called when Profiler analysis is fully completed.
    // It notifies the project system that it can make now a necessary
    // cleaning (which should not be done too early risking remove files
    // that are still analyzed by Profiler).
    HRESULT ProfilerAnalysisFinished();
}

//----------------------------------------------------------------------------
// IVsProfilerLauncher
//
// Provides the project system with the capability to launch targets under profiling.
//
// Typical usage for a project that delegates to the profiler to do the launch
// (recommended scenario):
// - Inside IVsProfilableProjectCfg.LaunchProfiler, create one or more
//   IVsProfilerLaunchTargetInfos.
// - Get the SVsProfilerLauncher service to get the launch manager service.
//   NOTE: If the profiler is not installed, this service will not be available.
// - Call IVsProfilerLauncher.LaunchProfiler with the created targets.
//   The profiler will do the launch.
//
// There is also an 'Attach' case, where the project system should:
// - Inside IVsProfilableProjectCfg.LaunchProfiler, create the attach targets
// - Get the SVsProfilerLaunchManager service to get the launch manager service.
// - Call QueryProfilingEnvironment to determine which environment variables
//   need to set by the project system
// - Launch targets (with the right profiling environment variables set)
// - Call IVsProfilerLauncher.LaunchProfiler with the attach targets
//   to notify the profiler about the targets that were launched.
//----------------------------------------------------------------------------
[uuid (uuid_IVsProfilerLauncher)]
[custom(uuid_VsPreserveSigAttribute, "preservesig")]
interface IVsProfilerLauncher : IUnknown
{
    // Launch the profiler targets. If the project system has already done the launch,
    // this method notifies the profiler about the targets which were launched.
    HRESULT LaunchProfiler(
        [in] IEnumVsProfilerTargetInfos *targetsEnum);

    // The project can query the profiler to find out the profiling environment variables.
    // Each element of environment is in the form 'Variable=Value'.
    HRESULT QueryProfilingEnvironment(
        [out] SAFEARRAY(BSTR) *environment);

}

#ifndef PROXYSTUB_BUILD

// declare the service type for interop
[ uuid (uuid_SVsProfilerLauncher) ]
interface SVsProfilerLauncher : IUnknown
{
}

cpp_quote("#define SID_SVsProfilerLauncher IID_SVsProfilerLauncher")

#endif


//-----------------------------------------------------------------------------
// IVsMRUItemsStore
//
// Implemented by the shell's SVsMRUItemsStore service
//-----------------------------------------------------------------------------
[ uuid(uuid_IVsMRUItemsStore)]
interface IVsMRUItemsStore : IUnknown
{
    HRESULT GetMRUItems(
        [in] REFGUID guidCategory,
        [in] LPCOLESTR lpszPrefix,
        [in] DWORD dwMaxResults,
        [out, size_is(dwMaxResults), length_is(*pdwResultsFetched)] BSTR *rgbstrItems,
        [out, retval] DWORD *pdwResultsFetched );

    HRESULT AddMRUItem(
        [in] REFGUID guidCategory,
        [in] LPCOLESTR lpszItem );

    HRESULT SetMRUItem(
        [in] REFGUID guidCategory,
        [in] LPCOLESTR lpszItem );

    HRESULT DeleteMRUItem(
        [in] REFGUID guidCategory,
        [in] LPCOLESTR lpszItem );

    HRESULT DeleteMRUItems(
        [in] REFGUID guidCategory );

    HRESULT SetMaxMRUItems(
        [in] REFGUID guidCategory,
        [in] DWORD dwMaxItems );
}

#ifndef PROXYSTUB_BUILD

//-----------------------------------------------------------------------------
// SVsMRUItemsStore
// The service id for the IVsMRUItemsStore service.
//-----------------------------------------------------------------------------
[ uuid(uuid_SVsMRUItemsStore)]
interface SVsMRUItemsStore : IUnknown
{
}
cpp_quote("#define SID_SVsMRUItemsStore IID_SVsMRUItemsStore")

#endif


//----------------------------------------------------------------------------
// IVsHierarchyDirectionalDropDataTarget
//
// Implemented by an IVsHierarchy to support handling drop targets above,
// below, and on the item.  This interface is similar to
// IVsHierarchyDropDataTarget but with extra parameters to facilitate supporting
// 3 different drop areas per item.
//
// If an IVsHierarchy implements both IVsHierarchyDirectionalDropDataTarget and
// IVsHierarchyDropDataTarget, only the methods on IVsHierarchyDirectionalDropDataTarget
// will be called.
//----------------------------------------------------------------------------
[uuid(uuid_IVsHierarchyDirectionalDropDataTarget)]
[custom(uuid_VsPreserveSigAttribute, "preservesig")]    // PreserveSig to match signature of the very similar IVsHierarchyDropDataTarget
interface IVsHierarchyDirectionalDropDataTarget : IUnknown
{
    // Gets the areas supported by the target.  This can be any combination
    // of Above, Below, and On masked together.
    HRESULT GetSupportedAreas(
        [in] VSITEMID itemid,
        [out] HierarchyDropArea * pSupportedAreas);
    // Informs the hierarchy that dragging has entered a new area.
    HRESULT DragEnterArea(
        [in] IDataObject * pDataObject,
        [in] DWORD grfKeyState,
        [in] VSITEMID itemid,
        [in] HierarchyDropArea area,
        [in, out] DWORD * pdwEffect);
    // Informs the hierarchy that dragging has continued over an area.
    HRESULT DragOverArea(
        [in] DWORD grfKeyState,
        [in] VSITEMID itemid,
        [in] HierarchyDropArea area,
        [in, out] DWORD * pdwEffect);
    // Informs the hierarchy that dragging has left the area.
    HRESULT DragLeaveArea();
    // Informs the hierarchy that data has been dropped on on an area.
    HRESULT DropArea(
        [in] IDataObject * pDataObject,
        [in] DWORD grfKeyState,
        [in] VSITEMID itemid,
        [in] HierarchyDropArea area,
        [in, out] DWORD * pdwEffect);
}

//----------------------------------------------------------------------------
// IVsDocumentPreviewer
//----------------------------------------------------------------------------
enum __DOCUMENTPREVIEWERTYPE
{
    DP_InternalBrowser     = 0,     // The previewer is the internal browser
    DP_SystemBrowser       = 1,     // The previewer is configured as the system default browser
    DP_InstalledBrowser    = 2,     // The previewer is a non-default browser installed in the system
    DP_PackageRegistered   = 3,     // The previewer is registered by one of the installed packages
    DP_UserDefined         = 4,     // The previewer is manually added and configured by the user
};
typedef DWORD DOCUMENTPREVIEWERTYPE;

// VSPREVIEWRESOLUTION is an enum type, so let's redefine to be extensible for when we'll support VSPREVIEWRESOLUTION2, etc
typedef DWORD DOCUMENTPREVIEWERRESOLUTION;

[uuid(1A19A9DB-766E-40B4-90FE-B6EF0BE6299B)]
interface IVsDocumentPreviewer : IUnknown
{
    // Returns the friendly name of the previewer
    [propget] HRESULT DisplayName( [out, retval] BSTR *pbstrDisplayName );
    // Returns the path that can be used to invoke the previewer, or null if this is the internal previewer
    [propget] HRESULT Path( [out, retval] BSTR *pbstrPath );
    // Returns the arguments that can be passed when invoking the previewer, or null if this is the internal previewer
    [propget] HRESULT Arguments( [out, retval] BSTR *pbstrArguments );
    // Returns whether the previewer is configured as a default browser (more than one previewer can be marked default)
    [propget] HRESULT IsDefault( [out, retval] VARIANT_BOOL* isDefault );
    // Returns the previewer type (internal, system, user-defined, package-registered)
    [propget] HRESULT Type( [out, retval] DOCUMENTPREVIEWERTYPE* type );
    // Returns the preferred resolution of the previewer window
    [propget] HRESULT Resolution( [out, retval] DOCUMENTPREVIEWERRESOLUTION* resolution );
}

[uuid(B2CA3152-8051-4141-BF11-14A77A4F254E)]
interface IVsEnumDocumentPreviewers : IUnknown
{
    HRESULT Next([in] ULONG celt, [out, size_is(celt), length_is(*pceltFetched)] IVsDocumentPreviewer *rgelt[], [out] ULONG *pceltFetched);
    HRESULT Skip([in] ULONG celt);
    HRESULT Reset(void);
    HRESULT Clone([out] IVsEnumDocumentPreviewers **ppenum);
}

// {6D3CAD8E-9129-4ec0-929E-69B6F5D4400D}
// This UIContext is toggled when there have been changes to the list of previewers.
cpp_quote("extern const __declspec(selectany) GUID UICONTEXT_StandardPreviewerConfigurationChanging = { 0x6d3cad8e, 0x9129, 0x4ec0, { 0x92, 0x9e, 0x69, 0xb6, 0xf5, 0xd4, 0x40, 0xd } };")

// This UIContext is toggled when the active hierarchy / itemid supports "Open in Blend"
// {095B9707-CE75-4464-A29A-BBED6A670875}
cpp_quote("extern const __declspec(selectany) GUID UICONTEXT_CurrentSelectionSupportsBlend = { 0x95b9707, 0xce75, 0x4464, { 0xa2, 0x9a, 0xbb, 0xed, 0x6a, 0x67, 0x8, 0x75 } };")

//----------------------------------------------------------------------------
// IVsUIShellOpenDocument3
//----------------------------------------------------------------------------
enum __VSNEWDOCUMENTSTATE
{
    NDS_Unspecified     = 0x00000000,
    NDS_Provisional     = 0x00000001,       // open in preview window
    NDS_Permanent       = 0x00000002,       // open in permanent window
    NDS_StateMask       = 0x000000FF,       // mask for the provisional/permanent state values
    NDS_OnlyFastViews   = 0x40000000,       // editor views marked with PVA_OpensSlowly in the registry cannot be previewed
    NDS_NoActivate      = 0x80000000,       // don't activate after opening
};
typedef DWORD VSNEWDOCUMENTSTATE;

enum __VSPROVISIONALVIEWINGSTATUS
{
    PVS_Disabled     = 0,                   // provisional viewing is disabled
    PVS_EnabledSlow  = 1,                   // provisional viewing is enabled, but may be slow
    PVS_EnabledLarge = 2,                   // provisional viewing is enabled, but the content to preview is larger
                                            // than the threshold specified by VSSPROPID_PreviewFileSizeLimit
    PVS_Enabled      = 3,                   // provisional viewing is enabled
};
typedef DWORD VSPROVISIONALVIEWINGSTATUS;

enum __VSPHYSICALVIEWATTRIBUTES
{
    PVA_None = 0x00000000,

    // The physical view may open slowly.  "Slow" in this sense means anything longer
    // than approximately two seconds, and the time to consider starts when the editor
    // is created and ends when the UI thread is no longer blocked.  If the the editor
    // takes longer than two seconds to load its file or fully render its content, but
    // that activity takes place on a background thread and doesn't block the UI thread,
    // the non-blocking activity does not need to be considered when assessing slowness.
    PVA_OpensSlowly = 0x00000001,

    // The physical view supports being hosted in a preview tab (i.e. is a document
    // window, not tool window, modal dialog, etc.).
    PVA_SupportsPreview = 0x00000002,
};
typedef DWORD VSPHYSICALVIEWATTRIBUTES;

[uuid(e6a63a28-154c-42cb-a6e7-9252c2e6d943)]
interface IVsUIShellOpenDocument3 : IUnknown
{
    // Allows an entity that is far removed from the IVsUIShellOpenDocument calls that
    // open a document to control how it is opened -- provisionally or permanently.
    // The returned IVsNewDocumentStateContext is not intended to be long-lived; callers
    // of SetNewDocumentState should call IVsNewDocumentStateContext.Restore (or release
    // the context) immediately after the document is opened.
    //
    // If you call this method with NDS_Provisional and then start the process to open
    // a file, the file will be opened even provisional viewing isn't enabled for the
    // file or it's editor.  If you only want to open a file if you know that it will
    // be opened provisionally, you should make that determination using either
    // GetProvisionalViewingStatusForFile or GetProvisionalViewingStatusForEditor
    // and only call this method and open the file if they indicate provisional viewing
    // is enabled.
    HRESULT SetNewDocumentState (
        [in] VSNEWDOCUMENTSTATE state,              // the state used for the next document to be opened
        [in] REFGUID reason,                        // the reason the state is being set (typically this is a
                                                    // tool window or language service GUID)
        [out, retval] IVsNewDocumentStateContext** ppRestoreOnRelease);

    // Determines the state of new documents
    [propget] HRESULT NewDocumentState ([out, retval] VSNEWDOCUMENTSTATE* state);

    // Returns the provisional viewing status for a file/logical view combination.
    // The default provisional viewing status is PVS_Disabled, but may be modified
    // by the editor's "CommonPhysicalViewAttributes" registry value and the
    // values under its "PhysicalViewAttributes" registry subkey.
    HRESULT GetProvisionalViewingStatusForFile (
        [in] LPCOLESTR filename,                    // the name of the file
        [in] IVsHierarchy* hierarchy,               // the hierarchy for the item
        [in] VSITEMID itemid,                       // the itemid for the item
        [in] REFGUID logicalView,                   // the logical view to query
        [out, retval] VSPROVISIONALVIEWINGSTATUS* status);

    // Returns the provisional viewing status for an editor/logical view combination.
    // The default provisional viewing status is PVS_Disabled, but may be modified
    // by the editor's "CommonPhysicalViewAttributes" registry value and the
    // values under its "PhysicalViewAttributes" registry subkey.
    HRESULT GetProvisionalViewingStatusForEditor (
        [in] REFGUID editor,                        // the editor to query
        [in] REFGUID logicalView,                   // the logical view to query
        [out, retval] VSPROVISIONALVIEWINGSTATUS* status);

    // Returns an interface that can be used to enumerate the available document previewers
    [propget] HRESULT DocumentPreviewersEnum (
        [out,retval] IVsEnumDocumentPreviewers **ppEnum);

    // Similar in functionality to GetFirstDefaultPreviewer, but obtains additional information on the browser
    [propget] HRESULT FirstDefaultPreviewer (
        [out, retval] IVsDocumentPreviewer **ppPreviewer);

    // Allows setting a previewer as default, either exclusive or in addition to the existing previewers.
    // The previewer must be one of the available previewers. Resolution supports values from VSPREVIEWRESOLUTION enum.
    HRESULT SetDefaultPreviewer (
        [in] IVsDocumentPreviewer *pPreviewer,
        [in] DOCUMENTPREVIEWERRESOLUTION resolution,
        [in] VARIANT_BOOL fExclusive);
}

//----------------------------------------------------------------------------
// Well-known reasons used with SetNewDocumentState
//----------------------------------------------------------------------------
cpp_quote("#define GUID_FindResultsReason           GUID_FindResults1")
cpp_quote("#define GUID_FindSymbolResultsReason     GUID_ObjectSearchResultsWindow")
cpp_quote("#define GUID_SolutionExplorerReason      GUID_SolutionExplorer")
cpp_quote("extern const __declspec(selectany) GUID GUID_NavigationReason   = { 0x8d57e022, 0x9e44, 0x4efd, { 0x8e, 0x4e, 0x23, 0x02, 0x84, 0xf8, 0x63, 0x76 } };")  // {8d57e022-9e44-4efd-8e4e-230284f86376}
cpp_quote("extern const __declspec(selectany) GUID GUID_TeamExplorerReason = { 0x7aa20502, 0x9463, 0x47b7, { 0xbf, 0x43, 0x34, 0x1b, 0xaf, 0x51, 0x15, 0x7c } };")  // {7aa20502-9463-47b7-bf43-341baf51157c}

//----------------------------------------------------------------------------
// IVsNewDocumentStateContext
//
// Implemented by the environment, obtained via a call to IVsUIShellOpenDocument3.SetNewDocumentState
//----------------------------------------------------------------------------
[uuid(44dd5120-6dfb-4590-a5cb-1066114996ca)]
interface IVsNewDocumentStateContext : IUnknown
{
    // Restores SID_SVsUIShellOpenDocument's NewDocumentState to the value it had
    // before this context was created by IVsUIShellOpenDocument3.SetNewDocumentState.
    // This method will be implicitly called on final release of the interface.
    HRESULT Restore();
}


//--------------------------------------------------------------------------------------------
// IVsLanguageServiceBuildErrorReporter2
//--------------------------------------------------------------------------------------------
// This interface is optionally implemented by a language service object that is connected to
// the project system.
//
// If this interface is implemented, the project system will first call ReportError before
// doing any error handling.  If the language service handles the reporting (returning
// anything other than E_NOTIMPL), the project system will not report the error to the error
// list.
//
// The project system will call ClearErrors when the errors reported to the language service
// are no longer valid, such as when the next build happens.
//
[
    uuid(uuid_IVsLanguageServiceBuildErrorReporter2),
    version(1.0),
    pointer_default(unique)
]
// Methods inherited from the base interface should be PreserveSig
[custom(uuid_VsPreserveSigAttribute, "preservesig")]
interface IVsLanguageServiceBuildErrorReporter2 : IVsLanguageServiceBuildErrorReporter
{
    // Same as IVsLanguageServiceBuildErrorReporter::ReportError, but allows to provide the
    // complete error span (starting and ending positions, rather than just starting one).
    // New methods don't need to be PreserveSig.
    [custom(uuid_VsPreserveSigAttribute, "nopreservesig")]
    HRESULT ReportError2(
        [in] BSTR bstrErrorMessage,
        [in] BSTR bstrErrorId,
        [in] VSTASKPRIORITY nPriority,
        [in] long iStartLine,
        [in] long iStartColumn,
        [in] long iEndLine,
        [in] long iEndColumn,
        [in] BSTR bstrFileName);
};


enum __VSRDTATTRIB2
{
//  RDTA_Hierarchy              = 0x00000001,
//  RDTA_ItemID                 = 0x00000002,
//  RDTA_MkDocument             = 0x00000004,
//  RDTA_DocDataIsDirty         = 0x00000008,
//  RDTA_DocDataIsNotDirty      = 0x00000010,

    // The following attribute events are fired by calling NotifyDocumentChanged
//  RDTA_NOTIFYDOCCHANGEDMASK   = 0xFFFF0000,
//  RDTA_DocDataReloaded        = 0x00010000,
//  RDTA_AltHierarchyItemID     = 0x00020000,

    RDTA_DocDataIsReadOnly      = 0x00040000,
    RDTA_DocDataIsNotReadOnly   = 0x00080000,

    // These attribute events can be fired by calling NotifyDocumentChangedEx
    // (RDTA_NOTIFYDOCCHANGEDMASK | RDTA_DocDataIsDirty | RDTA_DocDataNotIsDirty)
    RDTA_NOTIFYDOCCHANGEDEXMASK = 0xFFFF0018,
};
typedef DWORD VSRDTATTRIB2;

enum _VSRDTFLAGS3
{
//  RDT_NoLock             = 0x00000000,    // can be used with FindAndLockDocument(RDT_NoLock,...,&docCookie) to get DocCookie w/o taking a lock
//  RDT_ReadLock           = 0x00000001,
//  RDT_EditLock           = 0x00000002,
//  RDT_RequestUnlock      = 0x00000004,
//  RDT_LOCKMASK           = 0x00000007,

//  RDT_DontSaveAs         = 0x00000008,
//  RDT_NonCreatable       = 0x00000010,
//  RDT_DontSave           = 0x00000020,
//  RDT_DontAutoOpen       = 0x00000040,
//  RDT_CaseSensitive      = 0x00000080,
//  RDT_CantSave           = RDT_DontSave | RDT_DontSaveAs,
//  RDT_VirtualDocument    = 0x00001000,
//  RDT_ProjSlnDocument    = 0x00002000,
//  RDT_PlaceHolderDoc     = 0x00004000,
//  RDT_CanBuildFromMemory = 0x00008000,
//  RDT_DontAddToMRU       = 0x00010000,

    // Don't poll for changes to the document's dirty or readonly state.
    // The document owner takes responsibility for explicitly updating
    // the state via IVsRunningDocumentTable3.UpdateDirtyState or
    // IVsRunningDocumentTable3.UpdateReadOnlyState.
    RDT_DontPollForState   = 0x00020000,

//  RDT_DOCMASK            = 0xFFFFF0F8,    // allow __VSCREATEDOCWIN flags in doc mask

//  RDT_Unlock_NoSave      = 0x00000100,
//  RDT_Unlock_SaveIfDirty = 0x00000200,
//  RDT_Unlock_PromptSave  = 0x00000400,
//  RDT_Lock_WeakEditLock  = 0x00000800,
//  RDT_SAVEMASK           = 0x00000F00,
//  RDT_LOCKUNLOCKMASK     = 0x00000F00,
};
typedef DWORD VSRDTFLAGS3;

//----------------------------------------------------------------------------
// IVsRunningDocumentTable3
//----------------------------------------------------------------------------
[uuid(30525828-bd80-4bdf-9255-d1e0e1c0f34f)]
interface IVsRunningDocumentTable3 : IUnknown
{
    // Returns the related save tree items for a document.
    // If celt is zero and pcActual is not NULL, the number of VSSAVETREEITEM is returned in pcActual.
    // If celt is not zero, rgSaveTreeItems must not be NULL.
    //
    // An extremely common pattern is something like (omitting error checks for readability):
    //
    // hr = pIVsRunningDocumentTable3->GetRelatedSaveTreeItems(cookie, grfSave, 0, NULL, &cExpected);
    // prgSaveTreeItems = ::CoTaskMemAlloc(cExpected * sizeof(VSSAVETREEITEM));
    // hr = pIVsRunningDocumentTable3->GetRelatedSaveTreeItems(cookie, grfSave, cExpected, prgSaveTreeItems, &cActual);
    HRESULT GetRelatedSaveTreeItems (
        [in] VSCOOKIE cookie,
        [in] VSRDTSAVEOPTIONS grfSave,
        [in] ULONG celt,
        [out, size_is(celt), length_is(*pcActual)] VSSAVETREEITEM rgSaveTreeItems[],
        [out, retval] ULONG *pcActual);

    HRESULT NotifyDocumentChangedEx (
        [in] VSCOOKIE cookie,                   // the document that has changed
        [in] VSRDTATTRIB2 attributes);          // the new attributes for the document

    HRESULT IsDocumentDirty (
        [in] VSCOOKIE cookie,                   // the document to check
        [out, retval] VARIANT_BOOL* dirty);     // is the document dirty?

    HRESULT IsDocumentReadOnly (
        [in] VSCOOKIE cookie,                   // the document to check
        [out, retval] VARIANT_BOOL* readOnly);  // is the document dirty?

    // Calls IVsPersistHierarchyItem::IsItemDirty for the document, and raises
    // OnAfterAttributeChange(Ex) if the dirty state has changed.  This is preferred
    // to calling NotifyDocumentChangedEx directly as the latter may cause extraneous
    // attribute change notifications to be raised.
    HRESULT UpdateDirtyState ([in] VSCOOKIE cookie);

    // Calls IVsPersistDocData::IsDocDataReadOnly for the document, and raises
    // OnAfterAttributeChange(Ex) if the read-only state has changed.  This is preferred
    // to calling NotifyDocumentChangedEx directly as the latter may cause extraneous
    // attribute change notifications to be raised.
    HRESULT UpdateReadOnlyState ([in] VSCOOKIE cookie);
}

//----------------------------------------------------------------------------
// IVsRunningDocTableEvents5
//----------------------------------------------------------------------------
[uuid(ee37a122-55a0-4d1d-970a-78d5eecad16e)]
interface IVsRunningDocTableEvents5 : IUnknown
{
    HRESULT OnAfterDocumentLockCountChanged(
        [in] VSCOOKIE docCookie,
        [in] VSRDTFLAGS dwRDTLockType,
        [in] DWORD dwOldLockCount,
        [in] DWORD dwNewLockCount);
}

//-----------------------------------------------------------------------------
// Reference Manager
//
// Interfaces generated from TlbExp/OLEView from the original managed assembly
//-----------------------------------------------------------------------------

#ifndef PROXYSTUB_BUILD
// Service Guid
[
    uuid(uuid_SVsReferenceManager)
]
interface SVsReferenceManager : IUnknown
{
}
cpp_quote("#define SID_SVsReferenceManager IID_SVsReferenceManager")
#endif

[
    uuid(EF0757D6-678E-45DB-8251-8AA39CC8320C)
]
interface IVsReference : IUnknown
{
    [propget] HRESULT Name([out, retval] BSTR* bstrName);
    [propput] HRESULT Name([in] LPCOLESTR strName);
    [propget] HRESULT FullPath([out, retval] BSTR* bstrFullPath);
    [propput] HRESULT FullPath([in] LPCOLESTR bstrFullPath);
    [propget] HRESULT AlreadyReferenced([out, retval] VARIANT_BOOL* boolAlreadyReferenced);
    [propput] HRESULT AlreadyReferenced([in] VARIANT_BOOL boolAlreadyReferenced);
}

//------------------------------------------------------------------------
// VSREFERENCECHANGEOPERATION - Enumeration describing the operation to
//   be applied to a reference by a client.
//------------------------------------------------------------------------
enum __VSREFERENCECHANGEOPERATION {
    VSREFERENCECHANGEOPERATION_ADD = 1,
    VSREFERENCECHANGEOPERATION_REMOVE = 2
};

typedef DWORD VSREFERENCECHANGEOPERATION;

//------------------------------------------------------------------------
// VSREFERENCECHANGEOPERATIONRESULT - Enumeration describing the result
//   of applying a change to a reference by the client.
//------------------------------------------------------------------------
enum __VSREFERENCECHANGEOPERATIONRESULT {
    VSREFERENCECHANGEOPERATIONRESULT_ALLOW = 1,
    VSREFERENCECHANGEOPERATIONRESULT_DENY = 2
};

typedef DWORD VSREFERENCECHANGEOPERATIONRESULT;

[
    odl,
    uuid(uuid_IVsReferenceProviderContext),
    version(1.0),
    oleautomation,
]
interface IVsReferenceProviderContext : IUnknown
{
    [propget] HRESULT ProviderGuid([out, retval] GUID* pguidProvider);
    [local]  // local due to SAFEARRAY(interface) use
    [propget] HRESULT References([out, retval] SAFEARRAY(IVsReference*)* pReferences);
    // Add reference to the references collection.
    HRESULT AddReference([in] IVsReference* pReference);
    HRESULT CreateReference([out, retval] IVsReference** pRetVal);

    [propget] HRESULT ReferenceFilterPaths([out, retval] SAFEARRAY(BSTR)* pFilterPaths);
    [propput] HRESULT ReferenceFilterPaths([in] SAFEARRAY(BSTR) filterPaths);
};

[
    odl,
    uuid(uuid_IVsAssemblyReference),
    version(1.0),
    oleautomation,
]
interface IVsAssemblyReference : IVsReference {
}

enum __VSASSEMBLYPROVIDERTAB
{
    TAB_ASSEMBLY_FRAMEWORK = 0x1,
    TAB_ASSEMBLY_EXTENSIONS = 0x2,
    TAB_ASSEMBLY_ALL = TAB_ASSEMBLY_FRAMEWORK | TAB_ASSEMBLY_EXTENSIONS
};

typedef DWORD VSASSEMBLYPROVIDERTAB;

cpp_quote("DEFINE_GUID(GUID_AssemblyReferenceProvider,  0x9A341D95, 0x5A64, 0x11d3, 0xBF, 0xF9, 0x00, 0xC0, 0x4F, 0x99, 0x02, 0x35);")

//--------------------------------------------------------------------
// IVsAssemblyReferenceProviderContext - The context object used to
//   initialize the AssemblyReferenceProvider.
//--------------------------------------------------------------------
[
    odl,
    uuid(uuid_IVsAssemblyReferenceProviderContext),
    version(1.0),
    oleautomation,
]
interface IVsAssemblyReferenceProviderContext : IVsReferenceProviderContext {
    /* The paths to search for extension assemblies, which may include registry paths in the MSBuild-normal form */
    [propget] HRESULT AssemblySearchPaths([out, retval] BSTR* pRetVal);
    [propput] HRESULT AssemblySearchPaths([in] LPCOLESTR pRetVal);

    /* The target framework moniker, for instance ".NETFramework, version=4.5" */
    [propget] HRESULT TargetFrameworkMoniker([out, retval] BSTR* pRetVal);
    [propput] HRESULT TargetFrameworkMoniker([in] LPCOLESTR pRetVal);

    /* Specifies the set of tabs to show.  Defaults to all tabs */
    [propget] HRESULT Tabs([out, retval] VSASSEMBLYPROVIDERTAB* peTabs);
    [propput] HRESULT Tabs([in] VSASSEMBLYPROVIDERTAB eTabs);

    [propget] HRESULT SupportsRetargeting([out, retval] VARIANT_BOOL* pvarfSupportsRetargeting);
    [propput] HRESULT SupportsRetargeting([in] VARIANT_BOOL varfSupportsRetargeting);

    HRESULT GetTabTitle([in] VSASSEMBLYPROVIDERTAB etabId, [out, retval] BSTR* bstrTabTitle);
    HRESULT SetTabTitle([in] VSASSEMBLYPROVIDERTAB etabId, [in] LPCOLESTR szTabTitle);

    [propget] HRESULT IsImplicitlyReferenced ([out, retval] VARIANT_BOOL* pvarfIsImplicitlyReferenced);
    [propput] HRESULT IsImplicitlyReferenced ([in] VARIANT_BOOL pvarfIsImplicitlyReferenced);

    [propget] HRESULT RetargetingMessage([out, retval] BSTR* pRetVal);
    [propput] HRESULT RetargetingMessage([in] LPCOLESTR pRetVal);

    // Allows callers to provide a custom no items message for a particular tab:
    HRESULT GetNoItemsMessageForTab([in] VSASSEMBLYPROVIDERTAB etabId, [out, retval] BSTR* bstrNoItemsMessage);
    HRESULT SetNoItemsMessageForTab([in] VSASSEMBLYPROVIDERTAB etabId, [in] LPCOLESTR bstrNoItemsMessage);

};

[
    odl,
    uuid(uuid_IVsProjectReference),
    version(1.0),
    oleautomation,
]
interface IVsProjectReference : IVsReference {
    [propget] HRESULT Identity([out, retval] BSTR* pRetVal);
    [propput] HRESULT Identity([in] LPCOLESTR pRetVal);
    [propget] HRESULT ReferenceSpecification([out, retval] BSTR* pRetVal);
    [propput] HRESULT ReferenceSpecification([in] LPCOLESTR pRetVal);

}

cpp_quote("DEFINE_GUID(GUID_ProjectReferenceProvider,  0x51ECA6BD, 0x5AE4, 0x43F0, 0xAA, 0x76, 0xDD, 0x0A, 0x7B, 0x08, 0xF4, 0x0C);")

[
    odl,
    uuid(uuid_IVsProjectReferenceProviderContext),
    version(1.0),
    oleautomation,
]
interface IVsProjectReferenceProviderContext : IVsReferenceProviderContext {
    [propget] HRESULT CurrentProject([out, retval] IVsHierarchy** pRetVal);
    [propputref] HRESULT CurrentProject([in] IVsHierarchy* pRetVal);
};

[
    odl,
    uuid(uuid_IVsComReference),
    version(1.0),
    oleautomation,
]
interface IVsComReference : IVsReference {
    [propget] HRESULT Identity([out, retval] BSTR* pRetVal);
    [propput] HRESULT Identity([in] LPCOLESTR pRetVal);
    [propget] HRESULT Guid([out, retval] GUID* pRetVal);
    [propput] HRESULT Guid([in] GUID pRetVal);
    [propget] HRESULT MajorVersion([out, retval] WORD* pRetVal);
    [propput] HRESULT MajorVersion([in] WORD pRetVal);
    [propget] HRESULT MinorVersion([out, retval] WORD* pRetVal);
    [propput] HRESULT MinorVersion([in] WORD pRetVal);
}

cpp_quote("DEFINE_GUID(GUID_ComReferenceProvider,  0x4560BE15, 0x8871, 0x482A, 0x80, 0x1D, 0x76, 0xAA, 0x47, 0xF1, 0x76, 0x3A);")
[
    odl,
    uuid(uuid_IVsComReferenceProviderContext),
    version(1.0),
    oleautomation,
]
interface IVsComReferenceProviderContext : IVsReferenceProviderContext {
};

[
    odl,
    uuid(uuid_IVsPlatformReference),
    version(1.0),
    oleautomation,
]
interface IVsPlatformReference : IVsReference {
    [propget] HRESULT SDKIdentity([out, retval] BSTR* pRetVal);
    [propput] HRESULT SDKIdentity([in] LPCOLESTR pRetVal);
    [propget] HRESULT IsSDK([out, retval] VARIANT_BOOL* pRetVal);
    [propput] HRESULT IsSDK([in] VARIANT_BOOL pRetVal);
}

enum __VSSDKPROVIDERTAB
{
    TAB_SDK_PLATFORM = 0x1,
    TAB_SDK_EXTENSIONS = 0x2,
    TAB_SDK_ALL = TAB_SDK_PLATFORM | TAB_SDK_EXTENSIONS
};

typedef DWORD VSSDKPROVIDERTAB;

cpp_quote("DEFINE_GUID(GUID_PlatformReferenceProvider, 0x97324595, 0xE3F9, 0x4AA8, 0x85, 0xB7, 0xDC, 0x94, 0x1E, 0x81, 0x21, 0x52);")

[
    odl,
    uuid(uuid_IVsPlatformReferenceProviderContext),
    version(1.0),
    oleautomation,
]
interface IVsPlatformReferenceProviderContext : IVsReferenceProviderContext {
    // This is the target platform identifier, which indicates where to find SDK references.
    [propget] HRESULT TargetPlatformIdentifier([out, retval] BSTR* pbstrTargetPlatformIdentifier);
    [propput] HRESULT TargetPlatformIdentifier([in] LPCOLESTR strTargetPlatformIdentifier);
    // This is the target platform version, used to indicate to the user where the references come from
    [propget] HRESULT TargetPlatformVersion([out, retval] BSTR* pbstrTargetPlaformVersion);
    [propput] HRESULT TargetPlatformVersion([in] LPCOLESTR strTargetPlaformVersion);
    [propget] HRESULT TargetFrameworkMoniker([out, retval] BSTR* pbstrTargetPlatformMoniker);
    [propput] HRESULT TargetFrameworkMoniker([in] LPCOLESTR strTargetPlatformMoniker);
    // These point to loose extension assemblies
    [propget] HRESULT AssemblySearchPaths([out, retval] BSTR* pbstrAssemblySearchPaths);
    [propput] HRESULT AssemblySearchPaths([in] LPCOLESTR strAssemblySearchPaths);
    // This points to the location of the platform references
    [propget] HRESULT TargetPlatformReferencesLocation([out, retval] BSTR* pbstrPlatformWinmdLocation);
    [propput] HRESULT TargetPlatformReferencesLocation([in] LPCOLESTR strPlatformWinmdLocation);
    // This points to where the SDKs are registered in the registry
    [propget] HRESULT SDKRegistryRoot([out, retval] BSTR* pbstrSdkRegistryRoot);
    [propput] HRESULT SDKRegistryRoot([in] LPCOLESTR strSdkRegistryRoot);
    // This points to the location on disk where unregistered SDKs live
    [propget] HRESULT SDKDirectoryRoot([out, retval] BSTR* pbstrSdkDirectoryRoot);
    [propput] HRESULT SDKDirectoryRoot([in] LPCOLESTR strSdkDirectoryRoot);
    // A space-delimited list of the capabilities. It is typically same as VSHPROPID_ProjectCapabilities.
    // When specified, only matching SDKs, based on AppliesTo section, will be displayed.
    [propget] HRESULT SDKFilterKeywords([out, retval] BSTR* pbstrSDKFilterKeywords);
    [propput] HRESULT SDKFilterKeywords([in] LPCOLESTR strSDKFilterKeywords);
    // The support Visual Studio Version (e.g. 11.0). Sdks with higher VisualStudio version will be filtered out.
    [propget] HRESULT VisualStudioVersion([out, retval] BSTR* pbstrVisualStudioVersion);
    [propput] HRESULT VisualStudioVersion([in] LPCOLESTR strVisualStudioVersion);
    // When true, we show the WinMDs from the SDK in place of the SDK itself.
    [propget] HRESULT ExpandSDKContents([out, retval] VARIANT_BOOL* pvarBoolExpandSDKContents);
    [propput] HRESULT ExpandSDKContents([in] VARIANT_BOOL varBoolExpandSDKContents);
    // Specifies the set of tabs to show.  Defaults to all tabs.
    [propget] HRESULT Tabs([out, retval] VSSDKPROVIDERTAB* peTabs);
    [propput] HRESULT Tabs([in] VSSDKPROVIDERTAB eTabs);
    // Specifies the tab title for each tab.
    HRESULT GetTabTitle([in] VSSDKPROVIDERTAB etabId, [out, retval] BSTR* pbstrTabTitle);
    HRESULT SetTabTitle([in] VSSDKPROVIDERTAB etabId, [in] LPCOLESTR szTabTitle);
    [propget] HRESULT IsImplicitlyReferenced ([out, retval] VARIANT_BOOL* pvarfIsImplicitlyExpanded);
    [propput] HRESULT IsImplicitlyReferenced ([in] VARIANT_BOOL pvarfIsImplicitlyExpanded);
    // Allows callers to provide a custom no items message for a particular tab:
    HRESULT GetNoItemsMessageForTab([in] VSASSEMBLYPROVIDERTAB etabId, [out, retval] BSTR* bstrNoItemsMessage);
    HRESULT SetNoItemsMessageForTab([in] VSASSEMBLYPROVIDERTAB etabId, [in] LPCOLESTR bstrNoItemsMessage);
};

[
    odl,
    uuid(uuid_IVsFileReference),
    version(1.0),
    oleautomation,
]
interface IVsFileReference : IVsReference {
}

cpp_quote("DEFINE_GUID(GUID_FileReferenceProvider, 0x7B069159, 0xFF02, 0x4752, 0x93, 0xE8, 0x96, 0xB3, 0xCA, 0xDF, 0x44, 0x1A);")

[
    odl,
    uuid(uuid_IVsFileReferenceProviderContext),
    version(1.0),
    oleautomation,
]
interface IVsFileReferenceProviderContext : IVsReferenceProviderContext {
    [propget] HRESULT BrowseFilter([out, retval] BSTR* pbstrBrowseFilter);
    [propput] HRESULT BrowseFilter([in] LPCOLESTR bstrBrowseFilter);
    // If this the following returns an non-empty string, reference manager will use the the passed in value instead of last
    // browsed location.
    [propget] HRESULT DefaultBrowseLocation([out, retval] BSTR* pbstrDefaultBrowseLocation);
    [propput] HRESULT DefaultBrowseLocation([in] LPCOLESTR bstrDefaultBrowseLocation);
};

//------------------------------------------------------------------------
// IVsReferenceManagerUser - Interface used by clients of the ReferenceManager
//   dialog to receive change requests.
//------------------------------------------------------------------------
[
    odl,
    uuid(uuid_IVsReferenceManagerUser),
    version(1.0),
    oleautomation,
]
interface IVsReferenceManagerUser : IUnknown {
    // Reference Manager will call this method to update references that are modified by the user. Expected behavior
    // is to add all possible references that are passed in as part IVsReferenceProviderContext and return a single
    // error through HRESULT+IErrorInfo mechanism.
    HRESULT ChangeReferences(
                    [in] VSREFERENCECHANGEOPERATION operation,
                    [in] IVsReferenceProviderContext* changedContext);

    // This method will be called by reference manager to get a list of providers. The order of provider tabs is same
    // as order in the array. Please note that reference manager can call this method multiple times to refresh the state
    // of the dialog.
    [local]  // local due to SAFEARRAY(interface) use
    HRESULT GetProviderContexts([out, retval] SAFEARRAY(IVsReferenceProviderContext*)* rgProviderContexts);

};

enum __VSREFERENCEQUERYRESULT
{
    // The reference is allowed.
    REFERENCE_ALLOW,
    // The reference is not allowed.
    REFERENCE_DENY,
    // The system cannot determine if the reference is allowed.
    REFERENCE_UNKNOWN
};

typedef DWORD VSREFERENCEQUERYRESULT;

//------------------------------------------------------------------------
// IVsReferenceManager - Interface implemented by the service.
//------------------------------------------------------------------------
[
    odl,
    uuid(uuid_IVsReferenceManager),
    version(1.0),
    oleautomation,
]
interface IVsReferenceManager : IUnknown {
    // Shows the reference manager
    [local] // local due to SAFEARRAY(interface) use
    HRESULT ShowReferenceManager(
                    // The callback interface provided by the client.
                    [in] IVsReferenceManagerUser* pRefMgrUser,
                    // The dialog title.
                    [in] LPCWSTR lpszDlgTitle,
                    // The dialog help topic.
                    [in] LPCWSTR lpszHelpTopic,
                    // The GUID of the default provider context. Reference manager will use the default if the last visible provider is not
                    // present in the current invocation of reference manager.
                    [in] GUID guidDefaultProviderContext,
                    // Force show the initial provider.
                    [in] VARIANT_BOOL fForceShowDefaultProvider);

    // Creates a provider context to be used in ShowReferenceManager.
    HRESULT CreateProviderContext(
                    // The provider's GUID
                    [in] GUID guidProvider,
                    // Receives the created context.
                    [out, retval] IVsReferenceProviderContext** pRetVal);

    // Allows a client to determine if one project can reference another based on VS
    // default reference algorithm.
    HRESULT QueryCanReferenceProject(
                    // The project which is doing the referencing.
                    [in] IVsHierarchy* pReferencing,
                    // The project being referenced.
                    [in] IVsHierarchy* pReferenced,
                    // The result of the query
                    [out, retval] VSREFERENCEQUERYRESULT* pQueryResult);
};

//------------------------------------------------------------------------
// IVsReferenceManager2 - Interface implemented by the service.
//------------------------------------------------------------------------
[
    odl,
    uuid(B7821F84-D9C8-48F9-93C4-3C4C98A477A1),
    version(1.0),
    oleautomation
]
interface IVsReferenceManager2 : IUnknown {
    // Given an SDK Reference, parse the manifest and return a list of dependencies
    [local]
    HRESULT GetSDKReferenceDependencies(
        [in] LPCWSTR SDKIdentifier,
        [in] IVsPlatformReferenceProviderContext *pContext,
        [out, retval] SAFEARRAY(IVsPlatformReference) *pDependencies);
};

//------------------------------------------------------------------
// IVsProjectFlavorReferenceManager
// Gives the flavor a way to control invocation and handling of the
// Reference Manager.
//------------------------------------------------------------------
[
    uuid(uuid_IVsProjectFlavorReferenceManager),
    version(1.0),
    pointer_default(unique)
]
interface IVsProjectFlavorReferenceManager : IUnknown
{
    // Allows the flavor to control a request the invoke the reference manager.
    [local]  // local due to SAFEARRAY(interface) use
    HRESULT ShowReferenceManager(
                    // The Reference Manager instance which should be invoked.
                    [in] IVsReferenceManager* pRefMgr,
                    // The Reference Manager User which can handle reference callbacks.
                    [in] IVsReferenceManagerUser* pRefMgrUser,
                    // The dialog title.
                    [in] LPCWSTR lpszDlgTitle,
                    // The help topic
                    [in] LPCWSTR lpszHelpTopic,
                    // The GUID of the default provider context. Reference manager will use the default if the last visible provider is not
                    // present in the current invocation of reference manager.
                    [in] GUID guidDefaultProviderContext,
                    // Force show the initial provider.
                    [in] VARIANT_BOOL fForceShowDefaultProvider);
}


//------------------------------------------------------------------------
// VSQUERYFLAVORREFERENCESCONTEXT
// - Enumeration describing the context when querying IVsProjectFlavorReferences3
//------------------------------------------------------------------------
enum __VSQUERYFLAVORREFERENCESCONTEXT
{
    VSQUERYFLAVORREFERENCESCONTEXT_AddReference = 0,
    VSQUERYFLAVORREFERENCESCONTEXT_LoadReference = 1,
    VSQUERYFLAVORREFERENCESCONTEXT_RefreshReference = 2,
};
typedef LONG VSQUERYFLAVORREFERENCESCONTEXT;

//------------------------------------------------------------------
// IVsProjectFlavorReferences3
//
// Optional interface implemented by a project flavor.
// It gives the project flavor to control certain aspects of project reference handling.
//
// This interface is similar to IVsProjectFlavorReferences, but provides more info for flavor.
// Instead of output a boolean to allow/deny P2P reference in IVsProjectFlavorReferences,
// this interface outputs an integer to represent allow/deny/unknown.
//
// Currently there are 3 different contexts when this interface is called.
//
// - Add reference: The reference is added by user from UI (or from DTE)
//                  It's ok for flavor to show dialogs to prompt user (e.g. show error message)
//
// - Load reference: The reference is read from project file when loading a project
//                   Flavor shouldn't show any dialogs.
//
// - Refresh reference: The reference is refreshed on idle when it's unresolved or
//                      it's a P2P reference and the referenced project's configuration is changed.
//                      Flavor shouldn't show any dialogs. Instead flavor can output the optional "pbstreReason",
//                      which will be shown in Error List View.
//
//------------------------------------------------------------------
[
    uuid(005431fc-cf9c-4154-9b28-ec975d88948d),
    version(1.0),
    pointer_default(unique)
]
[custom(uuid_VsPreserveSigAttribute, "preservesig")]
interface IVsProjectFlavorReferences3 : IUnknown
{
    // Called before adding a reference to a flavored project,
    //            or refreshing a reference which was already added to a flavored project.
    HRESULT QueryAddProjectReferenceEx(
      [in] IUnknown *pReferencedProject,
      [in] VSQUERYFLAVORREFERENCESCONTEXT queryContext,
      [out] VSREFERENCEQUERYRESULT *pResult,
      [out] BSTR *pbstreReason
    );

    // Called before other project attempts to aquire reference to a flavor
    //     or refresh a reference to a flavor which was already acquired by a project.
    HRESULT QueryCanBeReferencedEx(
      [in] IUnknown *pReferencingProject,
      [in] VSQUERYFLAVORREFERENCESCONTEXT queryContext,
      [out] VSREFERENCEQUERYRESULT *pResult,
      [out] BSTR *pbstreReason
    );
}

////////////////////////////////////////////////////////////////////////////
// IVsAppCompat
// This interface is available via the SVsSolution service
// This is typically used to break compatibility of projects with previous versions of the application
[
    uuid(uuid_IVsAppCompat),
    helpstring("IVsAppCompat Interface"),
    pointer_default(unique)
]
interface IVsAppCompat: IUnknown
{
    // When there is a need to break compatibility the method callers should first call AskForUserConsentToBreakAssetCompat and get user consent before calling
    // BreakAssetCompatibility to break compat.
    // So the call sequence would be:
    // 1. Call AskForUserConsentToBreakAssetCompat which shows a dialog asking user consent, if user agrees to continue
    //      then this method returns S_OK, else if user cancels it returns OLE_E_PROMPTSAVECANCELLED.
    // 2. On S_OK in step#1, make the changes that would cause compatibility break.
    // 3. On success in step#2, call BreakAssetCompatibility to finalize compatibility break.

    // Pass in the list of projects whose compatibility would be broken on adding a new feature
    [local]  // local due to SAFEARRAY(interface) use
    HRESULT AskForUserConsentToBreakAssetCompat([in] SAFEARRAY(IVsHierarchy*) sarrProjectHierarchies);

    // Pass the project whose compatibility needs to be broken with the specific minimum version
    HRESULT BreakAssetCompatibility([in] IVsHierarchy * pProjHier, [in] LPCOLESTR lpszMinimumVersion);

    // Gets the current design time compat version for this version of the application
    HRESULT GetCurrentDesignTimeCompatVersion([out] BSTR * pbstrCurrentDesignTimeCompatVersion);
};



//----------------------------------------------------------------------------
// IVsDesignTimeAssemblyResolution2
//----------------------------------------------------------------------------
// Implemented by project objects to provide design time resolution of
// assembly reference paths in the current target framework.
// This interface retrieved as an ItemContext service from the project.
//
//
// Clients may obtain a pointer to the project's IVsDesignTimeAssemblyResolution
// querying for a SVsDesignTimeAssemblyResolution service on the IServiceProvider
// that is returned from IVsProject::GetItemContext. To get this service from
// the project context for the active document, you do the following:
//     1. get the active DocumentWindow by calling IVsMonitorSelection::
//        GetCurrentElementValue(SEID_DocumentFrame, ...)
//     2. get the project item context IServiceProvider from the document
//        WindowFrame by calling IVsWindowFrame::GetProperty(VSFPROPID_SPProjContext,...)
//     3. call IServiceProvider::QueryService(SID_SVsDesignTimeAssemblyResolution, ...)

typedef VsResolvedAssemblyPath * PVsResolvedAssemblyPath;

[
    uuid(uuid_IVsDesignTimeAssemblyResolution2),
    version(1.0),
    pointer_default(unique)
]

[custom(uuid_VsPreserveSigAttribute, "preservesig")]
interface IVsDesignTimeAssemblyResolution2 : IUnknown
{
    //resolves the assembly reference paths for the passed in assemblies while giving the ability to ignore version when resolving a reference from the targeted framework.
    HRESULT ResolveAssemblyPathInTargetFx2(
         [in, size_is(cAssembliesToResolve)] LPCWSTR prgAssemblySpecs[],//array of strings containing the list of assembly names that need to be resolved
         [in] ULONG cAssembliesToResolve,//no of assembly names passed in prgAssemblySpecs
         [in] VARIANT_BOOL ignoreVersionForFrameworkReferences,//should the version be ignored when resolving framework references
         [in, out, size_is(cAssembliesToResolve)] PVsResolvedAssemblyPath prgResolvedAssemblyPaths, //in_out array containing the resolved assembly reference paths,
                                                                                                    //the caller needs to pre-allocate this array for 'cAssembliesToResolve' elements
         [out] ULONG * pcResolvedAssemblyPaths);//no of resolved assembly paths in the prgResolvedAssemblyPaths output array
};

//--------------------------------------------------------------------------------------------
// IVsBuildManagerAccessor2
//--------------------------------------------------------------------------------------------
// Implemented by the Visual Studio Environment, obtained via the
// SID_SVsBuildManagerAccessor service.
// This interface's sole purpose in life is to provide a way to synchronize access to
// the default MSBuild BuildManager.
typedef enum
{
    VSBUILDMANAGERRESOURCE_DESIGNTIME    = 0x00000001,
    VSBUILDMANAGERRESOURCE_UITHREAD      = 0x00000002,
} VSBUILDMANAGERRESOURCE;

[
    uuid(uuid_IVsBuildManagerAccessor2),
    version(1.0),
    pointer_default(unique),
    local // because HANDLE is used
]
[custom(uuid_VsPreserveSigAttribute, "preservesig")]
interface IVsBuildManagerAccessor2 : IVsBuildManagerAccessor
{
    // Gets an event that is signaled whenever the design-time build resource is available.
    [propget] HRESULT DesignTimeBuildAvailable([out, retval] HANDLE *phWaitHandle);

    // Gets an event that is signaled whenever the UI thread is available for a build.
    [propget] HRESULT UIThreadIsAvailableForBuild([out, retval] HANDLE *phWaitHandle);

    // Acquires the design-time build resource and/or the UI thread for a build, if they are available,
    // and returns a cookie that must be used to release the resource(s).
    // This method deprecates BeginDesignTimeBuild and ClaimUIThreadForBuild,
    // and resources acquired via this method can only be released via the ReleaseBuildResources method.
    // Returns E_PENDING if all the resources requested are not immediately available.
    // Otherwise the requested resources are claimed and S_OK is returned.
    HRESULT AcquireBuildResources([in] VSBUILDMANAGERRESOURCE fResources, [out] VSCOOKIE *phCookie);

    // Releases the resource(s) acquired with AcquireBuildResources.
    // This method deprecates ReleaseUIThreadForBuild and EndDesignTimeBuild.
    HRESULT ReleaseBuildResources([in] VSCOOKIE hCookie);
}

// enum __VSDBGLAUNCHFLAGS6 ADDED IN DEV11
// NOTE: USE OF THIS ENUM REQUIRES DEV11 OR ABOVE TO BE INSTALLED
enum __VSDBGLAUNCHFLAGS6
{
    /********************************************** defined in vsshell.idl
    DBGLAUNCH_Silent                = 0x00000001,
    DBGLAUNCH_LocalDeploy           = 0x00000002, // passed to IVsDebuggableProjectCfg::Launch to allow optimizations
    DBGLAUNCH_NoDebug               = 0x00000004, // launch without attaching a debugger
    DBGLAUNCH_DetachOnStop          = 0x00000008, // detach instead of terminate when debugging stopped.
    DBGLAUNCH_Selected              = 0x00000010, // launch selected project instead of startup project
    DBGLAUNCH_StopDebuggingOnEnd    = 0x00000020, // when this process ends, debugging is stopped.
    DBGLAUNCH_WaitForAttachComplete = 0x00000040, // when DLO_LaunchByWebServer, wait for the attach to finish before continuing to launch other targets
    **********************************************  defined in vsshell80.idl*/
    /*
    DBGLAUNCH_MergeEnv              = 0x00000080, // provided environment should be merged with system environment
    DBGLAUNCH_DesignTimeExprEval    = 0x00000100, // launched for design-time expression evaluation
    DBGLAUNCH_StopAtEntryPoint      = 0x00000200, // Stop at the entrypoint (step-into)
    DBGLAUNCH_CannotDebugAlone      = 0x00000400, // this process cannot be debugged alone -- stop debugging when only processes with this flag remain
    **********************************************/
    /********************************************** defined in vsshell90.idl
    DBGLAUNCH_WaitForEvent          = 0x00000800  // Debugger should wait for a named event to become signaled after launching the first debug target and before launching more targets
    **********************************************/
    /********************************************** defined in vsshell90.idl (SP1)
    DBGLAUNCH_UseDefaultBrowser     = 0x00001000  // Debugger should use the Default Web Browser; this flag used in conjunction with DLO_LaunchBrowser.
                                                  // The default browser is obtained via IVsUIShellOpenDocument:: GetFirstDefaultPreviewer().
                                                  // The bstrEXE in VsDebugTargetInfo2 points to the URL to be launched. Web Site projects will use
                                                  // this for Silverlight projects. This allows, for example, Firefox to be used which is single
                                                  // instance and so has to be handled differently on launch. Other project systems (e.g. C++) that
                                                  // currently use DLO_LaunchBrowser will continue to use that and IE will get launched as before.
    **********************************************/
    /********************************************* defined in vsshell100.idl (dev10)
    DBGLAUNCH_PrepForDebug          = 0x00002000, // We will eventually debug this process, so allow the debugger to perform additional setup
    DBGLAUNCH_TerminateOnStop       = 0x00004000, // Terminate the debuggee when debugging is stopped. It is an error to specify both this and DBGLAUNCH_DetachOnStop
    DBGLAUNCH_BreakOneProcess       = 0x00008000  // Disable 'Break all processes when one process breaks' debugger option for the debugging session; this option is ignoring if debugging has already started.
    **********************************************/
    DBGLAUNCH_BlockCredentialsDialog= 0x00010000, // Blocks the creditials dialog from being shown on authentication errors
    DBGLAUNCH_BlockWWSDialog        = 0x00020000, // Blocks the WWS install dialog from being shown
    DBGLAUNCH_StartInSimulator      = 0x00040000  // For DLO_AppPackageDebug, debugger should launch the application (or expect the application to start) in the simulator
};
typedef DWORD VSDBGLAUNCHFLAGS6;

enum _DEBUG_LAUNCH_OPERATION4
{
    /********************************************** defined in vsshell.idl
    DLO_AlreadyRunning,  // attach to a process
    //  bstrExe is the process name, or a NULL character followed by
    //  a string indicating the hexadecimal process id

    DLO_CreateProcess,   // launch the application
    //  bstrExe is the full path to the exe,
    //  bstrArg are the arguments to pass to CreateProcess,
    //  clsidCustom specifies the single debug engine to use (NULL for default),
    //  or dwClsidCount and pclsidList specify the debug engines to use

    DLO_Custom,          // deprecated -- same as DLO_CreateProcess

    DLO_LaunchByWebServer, // Use special HTTP verb to debug
    **********************************************/
    //  bstrExe is the URL

    /******************************************** defined in vsshell80.idl as DEBUG_LAUCH_OPERATION2
    DLO_AttachToHostingProcess = 4,  // attach to a hosting process
    // bstrExe contains the process id as in DLO_AlreadyRunning
    // pUnknown contains the IVsHostingProcessUser callback interface.

    DLO_StartDebuggingHostingProcess = 5  // start debugging
    // bstrExe contains the process id as in DLO_AlreadyRunning
    *********************************************/

    /******************************************** defined in vsshell90.idl as DEBUG_LAUCH_OPERATION3
    DLO_LaunchBrowser = 6  // Launch web browser
    // bstrExe contains the launching URL
    *********************************************/

    // The debugger should launch and/or register for debugging of a Windows 8 appcontainer
    // application. When using this option, VsAppPackageLaunchInfo should be supplied, along
    // with bstrExe, launch flags, remote connection information and engine information.
    DLO_AppPackageDebug = 7,

    // The debugger should attach to the specified process, where the specified
    // process is a newly-launched process, which was launched using the CREATE_SUSPENDED
    // flag to the Win32 CreateProcess API. This allows the debugger to act as though
    // it launched the process, even though the process was actually started via
    // some other mechanism.
    DLO_AttachToSuspendedLaunchProcess = 8
};
typedef DWORD DEBUG_LAUNCH_OPERATION4;

// Indicates the platform that the application is targetting
enum VsAppPackagePlatform
{
    // Used for Windows Store applications
    APPPLAT_WindowsAppx,

    // Used for Windows Phone XAP applications
    APPPLAT_WindowsPhoneXAP
};

// Properties for DLO_AppPackageDebug targets
typedef struct _VsAppPackageLaunchInfo
{
    // String identifying the application package to debug. For Windows 8 based
    // applications, this is the Package full name.
    BSTR PackageMoniker;

    // [Optional] String indentifying the application to activate. This is not required
    // to be from the same package as 'PackageMoniker'. This may be null if the debugger
    // shouldn't activate any application.
    BSTR AppUserModelID;

    // Indicates the platform that the application is targetting
    enum VsAppPackagePlatform AppPlatform;

} VsAppPackageLaunchInfo;

typedef struct _VsDebugTargetInfo4
{
    DEBUG_LAUNCH_OPERATION4 dlo;  // specifies how this process should be launched or attached
    VSDBGLAUNCHFLAGS6 LaunchFlags;// launch flags that were passed to IVsDebuggableProjectCfg::Launch
    BSTR bstrRemoteMachine;       // NULL for local machine, or remote machine name
    BSTR bstrExe;                 // The name of the executable
    BSTR bstrArg;                 // command line arguments to the exe (DLO_CreateProcess)
    BSTR bstrCurDir;              // current directory (DLO_CreateProcess)
    BSTR bstrEnv;                 // environment settings (DLO_CreateProcess)
    DWORD dwProcessId;            // process id (DLO_AlreadyRunning/DLO_AttachToSuspendedProcess)
    VsDebugStartupInfo* pStartupInfo;  // additional options to be passed to CreateProcess (DLO_CreateProcess)
    GUID guidLaunchDebugEngine;   // guid of debug engine used for launch, (DLO_CreateProcess)
    DWORD dwDebugEngineCount;     // number of debug engine guids in the array
    [size_is(dwDebugEngineCount)]
    GUID* pDebugEngines;          // array of debug engine guids, or NULL is if DebugEngineCount is zero
    GUID guidPortSupplier;        // port supplier guid
    BSTR bstrPortName;            // name of port from above supplier (NULL is fine)
    BSTR bstrOptions;             // custom options, specific to each guidLaunchDebugEngine (NULL is recommended)
    BOOL fSendToOutputWindow;     // if TRUE, stdout and stderr will be routed to the output window
    IUnknown* pUnknown;           // interface pointer - usage depends on DEBUG_LAUNCH_OPERATION
    GUID guidProcessLanguage;     // Language of the hosting process. Used to preload EE's

    VsAppPackageLaunchInfo AppPackageLaunchInfo;  // Information required to start/launch appcontainer applications (DLO_AppPackageDebug)

    // [OPTIONAL] Project which is being launched. This is currently used with DLO_AppPackageDebug to update
    // application capabilities when an operation fails due to use of undeclared capabilities. This may be
    // used for additional features moving forward.
    IVsHierarchy* project;

} VsDebugTargetInfo4;


//----------------------------------------------------------------------------
// IVsBackForwardNavigation2
//
// This is an optional interface implemented by the DocView object.
//----------------------------------------------------------------------------
[uuid(6366f292-8597-4e66-b332-c9d00d4367b8)]
interface IVsBackForwardNavigation2 : IUnknown
{
    // Called by the environment to request that a navigation point be added
    // for the view's current location in the frame.  The implementer should
    // call IVsUIShell.AddNewBFNavigationItem; upon return, the value of "added"
    // should indicate whether the navigation item was successfully added.
    HRESULT RequestAddNavigationItem(
        [in] IVsWindowFrame* frame,             // frame containing the nav item
        [out, retval] VARIANT_BOOL* added);     // was the navigation item added?
};


//----------------------------------------------------------------------------
// IVsSerializeNavigationItem
//
// This is an optional interface implemented by the DocView object.  It allows
// a navigation item to be saved after the window frame with which it is
// associated is closed.  If the document associated with that window frame
// is opened again, the navigation item will be re-created via the
// Deserialize method.
//----------------------------------------------------------------------------
[uuid(00757da7-aae5-4fe4-9fdf-2e85364e228b)]
interface IVsSerializeNavigationItem : IUnknown
{
    // serialize the object to the stream
    HRESULT Serialize (
        [in] IVsWindowFrame* pFrame,            // frame containing the nav item
        [in] IStream* pStream,                  // stream to serialize to
        [in] IUnknown* punkObject);             // object to serialize (originally provided via IVsUIShell.AddNewBFNavigationItem)

    // deserialize an object from the stream
    HRESULT Deserialize (
        [in] IVsWindowFrame* pFrame,            // frame containing the nav item
        [in] IStream* pStream,                  // stream to deserialize from
        [out, retval] IUnknown** ppunkObject);  // deserialized object
};


//----------------------------------------------------------------------------
// IVsDynamicNavigationItem
//
// This is an optional interface implemented by object supplied with
// IVsUIShell.AddNewBFNavigationItem.
//----------------------------------------------------------------------------
[uuid(3304fdef-9284-4340-b6b7-37ce11167c8c)]
interface IVsDynamicNavigationItem : IUnknown
{
    // provide the current text for the navigation item
    HRESULT GetText (
        [in] IVsWindowFrame* pFrame,            // frame containing the nav item
        [out, retval] BSTR* pbstrText);         // text to display for the item
};

//----------------------------------------------------------------------------
// IVsProvisionalItem
//
// An optional interface implemented by objects that also implement other
// abstract VS interfaces (e.g. IVsTaskItem).  The implementer can use this
// to opt out of creating a provisional view for the item.  One would do this
// if it takes an unacceptably long period of time to open the file.
//
// If this interface is not implemented, the item is assumed to be previewable.
//----------------------------------------------------------------------------
[uuid(9977da6b-0c38-4565-a38a-71cf8cd1ef53)]
interface IVsProvisionalItem : IUnknown
{
    // Indicates whether provisional viewing is enabled by callee.  This interface
    // is commonly implemented by IVsTaskItem objects.  Standard implementation is
    // to call IVsUIShellOpenDocument3::IsProvisionalViewingEnabledForFile if files
    // are involved.
    [propget] HRESULT IsProvisonalViewingEnabled ([out, retval] VARIANT_BOOL* enabled);
};

//----------------------------------------------------------------------------
// IVsStatusbarUser2
//----------------------------------------------------------------------------
[uuid(6d3e477a-4b61-444c-860d-f725e5560b40)]
interface IVsStatusbarUser2 : IUnknown
{
    // This method is the converse of IVsStatusbarUser::SetInfo.  The user will
    // no longer be the current user of the status bar after it is called.
    HRESULT ClearInfo();
};

//----------------------------------------------------------------------------
// IVsDebugger4
//----------------------------------------------------------------------------
// Implemented by the Debugger, obtained via the SID_SVsShellDebugger service.
[
    uuid(uuid_IVsDebugger4),
    version(1.0),
    pointer_default(unique)
]
interface IVsDebugger4 : IUnknown
{
    // Launch the given debug targets, and return their PIDs and creation times
    HRESULT LaunchDebugTargets4(
        [in] ULONG DebugTargetCount,
        [in, size_is(DebugTargetCount)] VsDebugTargetInfo4* pDebugTargets,
        [out, size_is(DebugTargetCount)] VsDebugTargetProcessInfo* pLaunchResults);

    // Returns the set of projects which have been launched through a debugger launch (F5)
    // and which the debugger is currently debugging.
    // NOTE: This API does not support scenarios where the user attached to the project
    HRESULT EnumCurrentlyDebuggingProjects([out] IEnumHierarchies** projects);
}

//-----------------------------------------------------------------------------
// IVsQueryDebuggableProjectCfg2
//-----------------------------------------------------------------------------
// Implemented by a project system that supports Debug Launch (F5 command), and
// needs to return additional information which is not supported by the
// IVsQueryDebuggableProjectCfg interface.
[
    uuid(uuid_IVsQueryDebuggableProjectCfg2),
    version(1.0),
    pointer_default(unique)
]
interface IVsQueryDebuggableProjectCfg2 : IUnknown
{
midl_pragma warning( disable: 2279 )
    // Return startup options
    HRESULT QueryDebugTargets([in] VSDBGLAUNCHFLAGS grfLaunch,
        [in] ULONG cTargets,
        [in, out, size_is(cTargets)] VsDebugTargetInfo4 rgDebugTargetInfo[],
        [out, optional] ULONG *pcActual);
midl_pragma warning( enable: 2279 )
}

//---------------------------------------------------------------------------
// IVsXMLMemberDataCapability
//---------------------------------------------------------------------------
// Represents capability information in xml documentation
[
    uuid(98F1A862-A153-4369-86B8-7C4E3D0D5E37),
    version(1.0),
    pointer_default(unique)
]
interface IVsXMLMemberDataCapability : IUnknown
{
    [propget] HRESULT Type([out, retval] BSTR* pbstrType);
    [propget] HRESULT Description([out, retval] BSTR* pbstrDescription);
}

//---------------------------------------------------------------------------
// IVsXMLMemberData4
//---------------------------------------------------------------------------
// Extracts information out of xml documentation
[
    uuid(60721047-d8b3-4ff2-b963-d4d1f3102f77),
    version(1.0),
    pointer_default(unique)
]
// Methods inherited from the base interface should be PreserveSig
[custom(uuid_VsPreserveSigAttribute, "preservesig")]
interface IVsXMLMemberData4 : IVsXMLMemberData3
{
    // Disabling this warning is temporary and its resolution is tracked by DevDiv: 277273
midl_pragma warning( disable: 2456 )
    // Get the list of associated capabilities from the xml documentation (<capability> tags).
    // New methods don't need to be PreserveSig.
    [custom(uuid_VsPreserveSigAttribute, "nopreservesig")]
    HRESULT GetAssociatedCapabilities([out, retval] SAFEARRAY(IVsXMLMemberDataCapability*)* prgCapabilities);
midl_pragma warning( enable: 2456 )
};

//----------------------------------------------------------------------------
// IVsHierarchyDeleteHandler3
//----------------------------------------------------------------------------
// This interface provides what IVsHierarchyDeleteHandler offers, but with bulk item delete
// capability.  It is obtained by QI'ing from an IVsHierarchy.  This interface should
// be used instead of IVsHierarchyDeleteHandler when
// deleting multiple items (or even just 1 item) to allow the implementation to use
// the most efficient algorithm.
// In case of an error during a bulk delete operation, implementations should return a failing HRESULT
// immediately and return without deleting further items.  Detailed error messages may be set with
// IVsUIShell.SetErrorInfo.
enum __VSDELETEHANDLEROPTIONS
{
    // No flags.
    DHO_NONE = 0x00000000,

    // Indicates that implementations should not display any confirmation dialogs or SCC checkout UI.
    DHO_SUPPRESS_UI = 0x00000001,
};
typedef DWORD VSDELETEHANDLEROPTIONS;

[
    uuid(uuid_IVsHierarchyDeleteHandler3),
    version(1.0),
    pointer_default(unique),
    custom(uuid_VsPreserveSigAttribute, "preservesig")
]
interface IVsHierarchyDeleteHandler3 : IUnknown
{
    HRESULT QueryDeleteItems([in]  ULONG cItems,
        [in]                       VSDELETEITEMOPERATION dwDelItemOp,
        [in, size_is(cItems)]      VSITEMID   itemid[], // VSITEMID_ROOT to delete all--VSITEMID_SELECTION is not suppported.
        [in, out, size_is(cItems)] VARIANT_BOOL pfCanDelete[]);

    HRESULT DeleteItems([in]        ULONG cItems,
        [in]                        VSDELETEITEMOPERATION   dwDelItemOp,
        [in, size_is(cItems)]       VSITEMID itemid[],  // VSITEMID_ROOT to delete all--VSITEMID_SELECTION is not suppported.
        [in] VSDELETEHANDLEROPTIONS dwFlags);
}

//----------------------------------------------------------------------------
// IVsBooleanSymbolExpressionEvaluator
//----------------------------------------------------------------------------
// This interface provides expression parsing and evaluation against a set of boolean symbols
// in order to test whether a set of symbols cause the expression to evaluate to true.
[uuid(59252755-82AC-4A88-A489-453FEEBC694D)]
interface IVsBooleanSymbolExpressionEvaluator : IUnknown
{
    HRESULT EvaluateExpression(
        [in, unique]  LPCWSTR wszExpression,    // i.e. P1 & P2 & (!P3 | P4)   -- null and empty is allowed and results in a true return value.
        [in, unique]  LPCWSTR wszSymbols,       // space-delimited list of symbols that evaluate to true, same format as __VSHPROPID5.VSHPROPID_ProjectCapabilities  -- null and empty is allowed and results in an empty set of project capabilities during evaluation
        [out, retval] VARIANT_BOOL* pfResult);
}

// The CLSID for the VsProjectCapabilityExpressionMatcher object, which implements IVsBooleanSymbolExpressionEvaluator {7C8306FC-AFBF-43FA-88FC-6FE4D7E16D74}
// Call ILocalRegistry::CreateInstance to create an instance of this.
// Valid expression syntax is defined thus:
// The capability expression, such as "(VisualC | CSharp) + (MSTest | NUnit)".
// The '|' is the OR operator.
// The '&amp;' and '+' characters are both AND operators.
// The '!' character is the NOT operator.
// Parentheses force evaluation precedence order.
// A null or empty expression is evaluated as a match.
// Project capabilities may be any character except these reserved characters:
// "'`:;,+-*/\!~|&%$@^()={}[]<>? \t\b\n\r
#ifndef PROXYSTUB_BUILD

[uuid(943A3169-D328-4E42-8AF6-7200E5E8C2E4)]
interface VsProjectCapabilityExpressionMatcher : IUnknown
{
};

cpp_quote("#define CLSID_VsProjectCapabilityExpressionMatcher IID_VsProjectCapabilityExpressionMatcher")

#endif


//-----------------------------------------------------------------------------
// IVsSccProjectEvents
//
// Advise to this interface from the IVsSccTrackProjectEvents interface from the
// SVsSccManager service to be notified when a project changes its SCC bindings.
//-----------------------------------------------------------------------------
[
    uuid(4C3F73B6-9939-4A4B-8D25-326A8ABED50F),
    version(1.0),
    pointer_default(unique)
]
interface IVsSccProjectEvents : IUnknown
{
    // Raised when a project calls IVsSccManager2::RegisterSccProject or
    // IVsSccManager2::UnregisterSccProject
    HRESULT OnProjectRegisteredForSccChange(
        [in] REFGUID guidProject,
        [in] VARIANT_BOOL fIsRegistered);
}

//-----------------------------------------------------------------------------
// IVsSccManager3
//-----------------------------------------------------------------------------
[
    uuid(224209ED-E56C-4C8D-A7FF-31CF4686798D),
    version(1.0),
    pointer_default(unique)
]
// Methods inherited from the base interface should be PreserveSig
[custom(uuid_VsPreserveSigAttribute, "preservesig")]
interface IVsSccManager3 : IVsSccManager2
{
    // Does the active SCC provider support Background Solution Load
    [custom(uuid_VsPreserveSigAttribute, "nopreservesig")]
    HRESULT IsBSLSupported(
        [out,retval] VARIANT_BOOL* pfIsBSLSupported);
}

//-----------------------------------------------------------------------------
// IVsSccTrackProjectEvents
//-----------------------------------------------------------------------------
[
    uuid(4871BDEF-3B4A-49CE-80CF-51502FA9A464),
    version(1.0),
    pointer_default(unique)
]
interface IVsSccTrackProjectEvents : IUnknown
{
    HRESULT AdviseSccProjectEvents(
        [in] IVsSccProjectEvents *pEventSink,
        [out,retval] VSCOOKIE *pdwCookie);

    HRESULT UnAdviseSccProjectEvents(
        [in] VSCOOKIE dwCookie);
}


// Event sink for IVsProjectBuildMessageReporter.
// The thread from which the methods of this interface are invoked is unspecified, and in
// particular it might not be the UI thread.
[uuid(7fbea20b-68a9-48ec-9032-114268286b24)]
interface IVsProjectBuildMessageEvents : IUnknown
{
    // Called for every build message received from the build system by the implementer of
    // IVsProjectBuildMessageReporter, before the implementer does any usual processing of
    // the message (create a corresponding Error List item etc). All line and column numbers
    // are 1-based.
    //
    // If *pfStopProcessing is set to TRUE, the caller will assume that the implementation
    // of this method has taken full responsibility over its proper processing and reporting.
    // In particular, the caller will not create any Error List items corresponding to this
    // message. Furthermore, if there is more than one subscriber to this event, the remaining
    // subscribers will not be called.
    //
    // If *pfStopProcessing is set to FALSE, the caller will proceed to invoke any remaining
    // subscribers. If all subscribers set it to FALSE, the message will be processed normally
    // (i.e. Error List item created etc).
    HRESULT OnBuildMessage(
        [in] VSERRORCATEGORY category,
        [in] LPCWSTR szMessage,
        [in] LPCWSTR szErrorCode,
        [in] LPCWSTR szHelpKeyword,
        [in] long line,
        [in] long column,
        [in] long endingLine,
        [in] long endingColumn,
        [in] LPCWSTR szFile,
        [in, optional] IUnknown* pAdditionalInfo,
        [out, retval] VARIANT_BOOL* pfStopProcessing);
};

// Implemented by project hierarchies willing to provide the ability to intercept build
// messages (errors, warnings etc) for that project for the purposes of custom reporting.
// Should be queried from the object implementing root IVsHierarchy for the project.
[uuid(359bf057-da83-455c-9b72-ec00cb478c85)]
interface IVsProjectBuildMessageReporter : IUnknown
{
    HRESULT AdviseProjectBuildMessageEvents(
        [in] IVsProjectBuildMessageEvents* pEvents,
        [out] VSCOOKIE *pdwCookie);

    HRESULT UnadviseProjectBuildMessageEvents(
        [in] VSCOOKIE dwCookie);
};

enum __SymbolToolLanguage
{
    SymbolToolLanguage_None = 0,
    SymbolToolLanguage_CSharp = 1,
    SymbolToolLanguage_VB = 2,
    SymbolToolLanguage_VC_CLI = 3,
    SymbolToolLanguage_VC_ZW = 4
};
typedef DWORD SymbolToolLanguage;

[
    uuid(916BA1DD-4C84-431e-9B06-FC80F9496FCF),
    version(1.0),
    pointer_default(unique)
]
// Methods inherited from the base interface should be PreserveSig
[custom(uuid_VsPreserveSigAttribute, "preservesig")]
interface IVsNavInfo2 : IVsNavInfo
{
    // This allows the nav info to specify a preferred language for the complus library,
    // overriding the default algorithm for determining the display language.
    //
    // New methods don't need to be PreserveSig
    [custom(uuid_VsPreserveSigAttribute, "nopreservesig")]
    HRESULT GetPreferredLanguage([out] SymbolToolLanguage *pLanguage);
};

// IVsLibrary3 - Interface that allows the creation of IVsNavInfo2 objects
// from a vector of SYMBOL_DESCRIPTION_NODE objects.
[
    uuid(4B78A0FC-CFCF-46CB-9363-C13E55165DE3),
    version(1.0),
    pointer_default(unique)
]
interface IVsLibrary3 : IUnknown
{
    // Allow the library to create an IVsNavInfo2 object with the specified language.
    HRESULT CreateNavInfo2([in] SymbolToolLanguage language, [in, size_is(ulcNodes)] SYMBOL_DESCRIPTION_NODE rgSymbolNodes[], [in] ULONG ulcNodes, [out] IVsNavInfo2 ** ppNavInfo);
};

//-----------------------------------------------------------------------------
// NOTE: Add new interfaces above this comment
//
// Newer versions of existing public interfaces defined in this file should
// derive from previous versions if possible.  However, make sure that you
// mark methods inherited from the base interface PreserveSig since the build
// process for Dev11 interop assemblies no longer automatically adds
// PreserveSig to every interface method.  See IVsDataObjectStringMapManager2
// for an example.
//-----------------------------------------------------------------------------



// VS-specific HRESULT failure codes - start at 0x80042003
//

// Errors returned by a project system in the call to IVsProjectFactory::CreateProject during Open Project:
// 1. If it detects that the project is "poisoned" i.e. it has features added from a higher version of VS
cpp_quote("#define VS_E_INCOMPATIBLEPROJECT    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x2003)")

// 2. If it detects that the project is a classic project (not Tailored/Immersive) and the SKU is VSWinExpress
cpp_quote("#define VS_E_INCOMPATIBLECLASSICPROJECT    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x2004)")

// 3. If it detects that the project is not supported by Visual Studio running in the current operating system, i.e.
//    Visual Studio needs to be running in a later operating system to open the project which returned this HRESULT
cpp_quote("#define VS_E_INCOMPATIBLEPROJECT_UNSUPPORTED_OS    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x2005)")

// VS-specific HRESULT success codes - start at 0x00041FF2
//

// SUCCESS code returned by IVsProjectUpgradeViaFactory::UpgradeProject_CheckOnly to indicate what kind of upgrade is required
//
// - A safe-repair is one which is not a real full upgrade but merely a repair to make the project asset compatible
//    without the risk of issues being encountered by the previous versions of the product
//
// - An usafe-repair is one which is similarly not a full upgrade, but with a risk of issues being encountered by the newer
//   or previous version of the product. For example if a newer dependent SDK is not currently installed
//
// - A one-way upgrade is a full upgrade which will make the project incompatible with the previous version of the product
//
cpp_quote("#define VS_S_PROJECT_SAFEREPAIRREQUIRED      MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_ITF, 0x1FF2)")
cpp_quote("#define VS_S_PROJECT_UNSAFEREPAIRREQUIRED      MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_ITF, 0x1FF3)")
cpp_quote("#define VS_S_PROJECT_ONEWAYUPGRADEREQUIRED      MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_ITF, 0x1FF4)")
cpp_quote("#define VS_S_INCOMPATIBLEPROJECT      MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_ITF, 0x1FF5)")

// Error code returned when an attempt to do a save using RDTSAVEOPT_SileSave fails because source control requires a UI prompt
// in order to make the file to be saved editable.
cpp_quote("#define VS_E_PROMPTREQUIRED MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x2006)")

// Error code returned by Visual Studio task library Wait and GetResult operations when
// the requested operation would cause a deadlock due to circular dependency
cpp_quote("#define VS_E_CIRCULARTASKDEPENDENCY MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x2007)")

// Error code returned by Visual Studio task library Wait and GetResult operations when 
// the requested operation had to be aborted because of a task scheduling error
cpp_quote("#define VS_E_TASKSCHEDULERFAIL MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x2008)")

enum __VSRDTSAVEOPTIONS3
{
    /*VSRDTSAVEOPTIONS*/
    //RDTSAVEOPT_SaveIfDirty      = 0x00000000,  // save only if dirty (this is the default)
    //RDTSAVEOPT_PromptSave       = 0x00000001,  // prompt user whether to save
    //RDTSAVEOPT_ForceSave        = 0x00000002,  // force save even if not dirty
    //RDTSAVEOPT_SaveNoChildren   = 0x00000004,  // save only the root of the hierarchy passed in, don't include its children
    //RDTSAVEOPT_SaveOnlyChildren = 0x00000008,  // save only children of the hierarchy passed in, don't include hierarchy itself
    //RDTSAVEOPT_ActivateDocOnErr = 0x00000010,  // activates the editor window of a doc if it errors on save
    //RDTSAVEOPT_SkipNewUnsaved   = 0x00000020,  // indicates that new unsaved files (created via File.New File) should be skipped
    //RDTSAVEOPT_SaveAllButThis   = 0x00000040,  // the supplied document token indicates the exception and everything but it will be saved normaly
    //RDTSAVEOPT_DocClose         = 0x00010000,  // indicates save is a result of a document close*/

    /*VSRDTSAVEOPTIONS2*/
    //RDTSAVEOPT_FSaveAs          = 0x20000000,  //determine if we should bring up a SaveAs dialog - IMPORTANT: this value must be kept

    RDTSAVEOPT_SilentSave         = 0x00000080   //Instructs the RDT to pass along a request to make the save silent (no UI prompts). The call may fail
                                                 //with this flag if a silent save is not possible.

    //in sync with the internal flag RDTSAVEOPT_FSAVEAS defined in env\msenv\core\vsrdtbl.h !!!
    //RDTSAVEOPT_Reserved         = 0xFFFF0000,  // reserved internal bits*/
};
typedef DWORD VSRDTSAVEOPTIONS3;

#ifndef PROXYSTUB_BUILD
// Service Guid for the difference service.
// This service allows clients to open a window in Visual Studio that compares two files via the IVsDifferenceService interface.
[
    uuid(77115E75-EF9E-4F30-92F2-3FE78BCAF6CF)
]
interface SVsDifferenceService : IUnknown
{
}

cpp_quote("#define SID_SVsDifferenceService IID_SVsDifferenceService")
#endif

enum __VSDIFFSERVICEOPTIONS
{
    VSDIFFOPT_DoNotShow                 = 0x00000001,   //Do not show the comparison window after creating it.
    VSDIFFOPT_DetectBinaryFiles         = 0x00000002,   //Display a dialog box if attempting to compare binary files (and return success).
    VSDIFFOPT_PromptForEncodingForLeft  = 0x00000004,   //Prompt the user for the encoding of the left file.
    VSDIFFOPT_PromptForEncodingForRight = 0x00000008,   //Prompt the user for the encoding of the right file.
    VSDIFFOPT_LeftFileIsTemporary       = 0x00000010,   //The left file is a temporary file explicitly created for diff.
    VSDIFFOPT_RightFileIsTemporary      = 0x00000020,   //The right file is a temporary file explicitly created for diff.
};
typedef DWORD VSDIFFSERVICEOPTIONS;

//---------------------------------------------------------------------------
// IVsDifferenceService
//---------------------------------------------------------------------------
[
    uuid(E20E53BE-8B7A-408F-AEA7-C0AAD6D1B946),
    helpstring("IVsDifferenceService Interface"),
    pointer_default(unique)
]
interface IVsDifferenceService : IUnknown
{
    //Open and display a file comparison window in Visual Studio with default labels and no additional roles.
    //
    //If either the left or right file is a binary file (which cannot be opened in the text editor), then this call will cause VS to display a modal dialog box and
    //return S_OK (even though pDiffWindow will be NULL).
    //
    //The left and right files will, if possibly, be retrieved from the running documents table. If either file is already in the running documents table but can't
    //be opened in the text editor (because, for example, they are project files in the current solution), the file(s) will be copied to a temporary directory and opened
    //instead of the specified file(s).
    //
    //The label for the left view will be the name of the left file. The label for the right view will be the name of the right file. No label will be
    //displayed for the inline view.
    HRESULT OpenComparisonWindow([in] LPCOLESTR leftFileMoniker,              //Path to the file that will be displayed in the left side of the comparison.
                                 [in] LPCOLESTR rightFileMoniker,             //Path to the file that will be displayed in the right side of the comparison.
                                 [out, retval] IVsWindowFrame** pDiffWindow); //WindowFrame for the comparison view.

    //Open and display a file comparison window in Visual Studio, parsing the arguments parameter to extract the left & right files, and the labels and roles
    //(using the default labels and roles as above if none are specified explicitly). The arguments are:
    //              leftFile rightFile leftLabel rightLabel inlineLabel roles
    //(separated by spaces).
    //
    //If either the left or right file is a binary file (which cannot be opened in the text editor), then this call will cause VS to display a modal dialog box and
    //return S_OK (even though pDiffWindow will be NULL).
    HRESULT OpenComparisonWindowFromCommandLineArguments([in] LPCOLESTR arguments,
                                                         [out, retval] IVsWindowFrame** pDiffWindow); //WindowFrame for the comparison view.

    //Open and display a file comparison window in Visual Studio.
    //
    //The left and right files will, if possibly, be retrieved from the running documents table. If either file is already in the running documents table but can't
    //be opened in the text editor (because, for example, they are project files in the current solution), the file(s) will be copied to a temporary directory and opened
    //instead of the specified file(s).
    //
    //The caption, tooltip and label parameters use C#-style string formatting where {0} corresponds to the name of the left file and {1} corresponds to the name of the right file.
    //For example, if you set the inlineLabel to "{0} => {1}" and compare foo.txt with bar.txt, then the displayed label will be "foo.txt => bar.txt".
    HRESULT OpenComparisonWindow2([in] LPCOLESTR leftFileMoniker,                 //Path to the file that will be displayed in the left side of the comparison.
                                  [in] LPCOLESTR rightFileMoniker,                //Path to the file that will be displayed in the right side of the comparison.
                                  [in] LPCOLESTR caption,                         //Caption to display in the document tab. If null or empty, {0} vs. {1} is shown.
                                  [in] LPCOLESTR tooltip,                         //Tooltip to display for the document tab. if null or empty, the default tooltip used.
                                  [in] LPCOLESTR leftLabel,                       //Label to display above the left view. If null or empty, then no label is shown.
                                  [in] LPCOLESTR rightLabel,                      //Label to display above the right view. If null or empty, then no label is shown.
                                  [in] LPCOLESTR inlineLabel,                     //Label to display above the inline view. If null or empty, then no label is shown.
                                  [in] LPCOLESTR roles,                           //Additional TextViewRoles added to the difference views.
                                  [in] VSDIFFSERVICEOPTIONS grfDiffOptions,       //Mask of options for the comparison window.
                                  [out, retval] IVsWindowFrame** pDiffWindow);    //WindowFrame for the comparison view.
}

#ifndef PROXYSTUB_BUILD

// Service Guid for the file merge service.
// This service allows clients to open a window in Visual Studio that performs a three way merge operation via the IVsFileMergeService interface.
[
    uuid(34D4713E-EB24-4746-938B-BE5640D03210)
]
interface SVsFileMergeService : IUnknown
{
}

#endif

//---------------------------------------------------------------------------
// IVsFileMergeService
//---------------------------------------------------------------------------
cpp_quote("#define SID_SVsFileMergeService IID_SVsFileMergeService")

[
    uuid(9003D4ED-2B8E-46B8-9838-78F5AE7B656D),
    helpstring("IVsFileMergeService Interface"),
    pointer_default(unique)
]
interface IVsFileMergeService : IUnknown
{
    //Opens a three way merge window to perform a three way merge operation
    HRESULT OpenAndRegisterMergeWindow([in] LPCOLESTR leftFileMoniker,                          //The left file path
                                       [in] LPCOLESTR rightFileMoniker,                         //The right file path
                                       [in] LPCOLESTR baseFileMoniker,                          //The base file path
                                       [in] LPCOLESTR resultFileMoniker,                        //The result file path where the merge results will be stored
                                       [in] LPCOLESTR leftFileTag,                              //The tag for the left file
                                       [in] LPCOLESTR rightFileTag,                             //The tag for the right file
                                       [in] LPCOLESTR baseFileTag,                              //The tag for the base file
                                       [in] LPCOLESTR resultFileTag,                            //The tag for the result file
                                       [in] LPCOLESTR leftFileLabel,                            //The label for the left file
                                       [in] LPCOLESTR rightFileLabel,                           //The label for the right file
                                       [in] LPCOLESTR baseFileLabel,                            //The label for the base file
                                       [in] LPCOLESTR resultFileLabel,                          //The label for the result file
                                       [in] LPCOLESTR serverGuid,                               //The server guid this is called for(Can be empty) - used to make special features such as history and annotate available
                                       [in] LPCOLESTR leftFileSpec,                             //The server file spec for the left file - used to make special features such as history and annotate available
                                       [in] LPCOLESTR rightFileSpec,                            //The server file spec for the right file - used to make special features such as history and annotate available
                                       [out] int* cookie,                                       //A cookie for the window created
                                       [out, retval] IVsWindowFrame** pMergeWindow);            //The IVsWindow Frame for the merge window created

    //Unregisters the merge window created
    HRESULT UnregisterMergeWindow([in] int cookie);                                             //The cookie for the window frame

    //Query the service for the merge window result
    HRESULT QueryMergeWindowState([in] int cookie,                                              //The cookie for the window frame
                                  [out] int* pfState,                                           //The current state of the window
                                  [out] BSTR* errorAndWarningMsg);                              //A string array of any errors or warnings to prompt the user
}


//---------------------------------------------------------------------------
// IVsUpdateSolutionEvents4
//---------------------------------------------------------------------------
[
    uuid(uuid_IVsUpdateSolutionEvents4),
    version(1.0),
    pointer_default(unique)
]
interface IVsUpdateSolutionEvents4 : IUnknown
{
    // Fired before the first update action, just after IVsUpdateSolutionEvents.UpdateSolution_StartUpdate to determine if we should delay.
    // If pfDelay is set to non-zero, the update action will be delayed and invoked at a later idle time.  Implementations of this
    // method should be side-effect free, as this method may be called multiple times before UpdateSolution_BeginFirstUpdateAction()
    // is invoked.
    HRESULT UpdateSolution_QueryDelayFirstUpdateAction([out] int *pfDelay);

    // Fired to start the first update action.  Called after QueryDelayFirstUpdateAction has indicated no delays for any
    // of the advisees.
    HRESULT UpdateSolution_BeginFirstUpdateAction();

    // Fired just after the last update action, but before IVsUpdateSolutionEvents.UpdateSolution_Done is invoked.  Matches
    // UpdateSolution_BeginFirstUpdateAction().
    HRESULT UpdateSolution_EndLastUpdateAction();

    // Fired before every update action begins during solution build - before the first UpdateProjectCfg_Begin
    // for the same action, but after UpdateSolution_BeginFirstUpdateAction if this is the first action.
    // Always paired with UpdateSolution_EndUpdateAction with matching dwAction, with no nested pairs allowed.
    //
    // dwAction indicates the update action that is about to begin. Values are flags or combinations of flags
    // from VSSOLNBUILDUPDATEFLAGS enum. Legal values are the following, in the order in which the actions
    // are executed during the build:
    //
    // SBF_OPERATION_CLEAN - clean action
    // SBF_OPERATION_PUBLISHUI - publish UI action
    // SBF_OPERATION_BUILD - build action
    // SBF_OPERATION_BUILD | SBF_OPERATION_FORCE_UPDATE - rebuild action
    // SBF_OPERATION_DEPLOY - deploy action
    // SBF_OPERATION_PUBLISH - publish action
    HRESULT UpdateSolution_BeginUpdateAction([in] DWORD dwAction);

    // Fired after every update actions ends, and the next one (if any) is about to begin - after the last
    // UpdateProjectCfg_Done for the same action, but before UpdateSolution_EndLastUpdateAction if this is
    // the last action. Always paired with UpdateSolution_BeginUpdateAction with matching dwAction, with
    // no nested pairs allowed.
    //
    // dwAction indicates the update action that is about to end. Values are flags or combinations of flags
    // from VSSOLNBUILDUPDATEFLAGS enum. See UpdateSolution_BeginUpdateAction for the list of legal values.
    HRESULT UpdateSolution_EndUpdateAction([in] DWORD dwAction);

    // Fired to indicate that several OnActiveProjectCfgChange events will follow in rapid succession.
    // OnActiveProjectCfgChangeBatchEnd is fired afterwards to indicate the end of batch.
    //
    // Subscribers that handle OnActiveProjectCfgChange and do expensive work in response to it may use this
    // and OnActiveProjectCfgChangeBatchEnd to detect several consequtive configuration changes, and only
    // doing the work once for all of them, rather than recomputing for each separate event.
    HRESULT OnActiveProjectCfgChangeBatchBegin();

    // Fired to indicate the end of event batch that began with OnActiveProjectCfgChangeBatchBegin.
    HRESULT OnActiveProjectCfgChangeBatchEnd();
};


//---------------------------------------------------------------------------
// IVsFireUpdateSolutionEvents
//---------------------------------------------------------------------------
// Implemented by the Environment. 
// Used by projects that nest sub-projects. These projects must implement IVsParentProject.
// This interface allows a project that nests sub-projects to fire the same UpdateSolutionEvents
// that the Solution normally fires. This interface is similar to the related 
// IVsFireSolutionEvents interface but is accessed via QueryService for the 
// SVsSolutionBuildManager service. These methods iterate through the notification sinks 
// of clients of IVsUpdateSolutionEvents and call the appropriate notification method.
//---------------------------------------------------------------------------
[
    uuid(D8C0B590-65EC-42F7-903F-8ED7C1B3D629),
    version(1.0),
    pointer_default(unique)
]
interface IVsFireUpdateSolutionEvents : IUnknown
{
    HRESULT FireOnActiveProjectCfgChange([in] IVsHierarchy *pIVsHierarchy);
    HRESULT FireOnActiveProjectCfgChangeBatchBegin();
    HRESULT FireOnActiveProjectCfgChangeBatchEnd();
};

//---------------------------------------------------------------------------
// IVsUpdateSolutionEventsAsyncCallback
//
// Provides a method for asynchronous implementors of UpdateSolution_EndLastUpdateActionAsync
// to notify the SolutionBuildManager when their work is complete.  See IVsUpdateSolutionEventsAsync.
//---------------------------------------------------------------------------
[
    uuid(02D0878C-53F5-4CE9-B55C-3577DAE64761),
    version(1.0),
    pointer_default(unique)
]
interface IVsUpdateSolutionEventsAsyncCallback : IUnknown
{
    HRESULT CompleteLastUpdateAction();
}

//---------------------------------------------------------------------------
// IVsUpdateSolutionEventsAsync
//
// This interface is implemented by clients of the SolutionBuildManager which need to be able
// to respond to the UpdateSolution_EndLastUpdateActionAsync event.  When clients have completed their 
// work, they invoke the CompleteLastUpdateAction() method on the provided callback, indicating the
// SolutionBuildManager need no longer wait for them.  This is used to allow clients to avoid blocking 
// for possibly long running work on the UI thread.
//---------------------------------------------------------------------------
[
    uuid(703ECC2C-7631-46A9-AD1E-19D9592C7A6B),
    version(1.0),
    pointer_default(unique)
]
interface IVsUpdateSolutionEventsAsync : IUnknown
{
    HRESULT UpdateSolution_EndLastUpdateActionAsync(IVsUpdateSolutionEventsAsyncCallback* pCallback);
}

//---------------------------------------------------------------------------
// IVsSolutionBuildManager5
//---------------------------------------------------------------------------
// Provides access to IVsUpdateSolutionEvents4 events.
[
    uuid(uuid_IVsSolutionBuildManager5),
    version(1.0),
    pointer_default(unique)
]
interface IVsSolutionBuildManager5 : IUnknown
{
    HRESULT AdviseUpdateSolutionEvents4([in] IVsUpdateSolutionEvents4 *pIVsUpdateSolutionEvents4, [out] VSCOOKIE *pdwCookie);
    HRESULT UnadviseUpdateSolutionEvents4([in] VSCOOKIE dwCookie);

    HRESULT AdviseUpdateSolutionEventsAsync([in] IVsUpdateSolutionEventsAsync *pIVsUpdateSolutionEventsAsync, [out] VSCOOKIE *pdwCookie);
    HRESULT UnadviseUpdateSolutionEventsAsync([in] VSCOOKIE dwCookie);

    // Obtains the full (i.e. "Debug|Win32") name of the project configuration that is in the active solution configuration.
    [custom(uuid_VsPreserveSigAttribute, "preservesig")]
    HRESULT FindActiveProjectCfgName([in] REFGUID rguidProjectID, [out] BSTR* pbstrProjectCfgCanonicalName);
};

// {7CAC4AE1-2E6B-4B02-A91C-71611E86F273}
// Set when a solution contains an appcontainer project.
cpp_quote("extern const __declspec(selectany) GUID UICONTEXT_SolutionHasAppContainerProject = { 0x7CAC4AE1, 0x2E6B, 0x4B02, { 0xA9, 0x1C, 0x71, 0x61, 0x1E, 0x86, 0xF2, 0x73 } };")

//-----------------------------------------------------------------------------
// VsUpToDateCheckFlags2
//-----------------------------------------------------------------------------
// Flags passed into IVsSolutionBuildManager3::AreProjectsUpToDate() as well as
// IVsSolutionBuildManager::QueryStartUpToDateCheck() and IVsSolutionBuildManager::
// StartUpToDateCheck() to indicate that the operation is done for purposes of
// a particular build request.
typedef enum _vsuptodatecheckflags2
{
    VSUTDCF_REBUILD        = 0x00000002,    // corresponds to VS_BUILDABLEPROJECTCFGOPTS_REBUILD
    VSUTDCF_PACKAGE        = 0x00000004,    // corresponds to VS_BUILDABLEPROJECTCFGOPTS_PACKAGE
    VSUTDCF_PRIVATE        = 0xFFFF0000,    // corresponds to any private values in the VS_BUILDABLEPROJECTCFGOPTS_PRIVATE range
} VsUpToDateCheckFlags2;

//---------------------------------------------------------------------------
// IVsLaunchPad4
//---------------------------------------------------------------------------
[
    uuid(uuid_IVsLaunchPad4),
    version(1.0),
    pointer_default(unique)
]
interface IVsLaunchPad4 : IUnknown
{
    // Executes the given command with elevation. If user is not currently logged in with administrator
    // privileges, the user will be prompted with the system elevation prompt. In contrast to the
    // IVsLaunchPad[2]::ExecCommand[Ex] methods, this method lacks the parameters for piping output
    // from the process and controlling the process's lifetime, because these things can't be done
    // to an elevated process (unless VS is also running elevated).
    // In contrast to the IVsLaunchPad3::ExecCommandWithElevationIfRequired, this method always
    // forces elevation (if user is not already elevated); this method will also return the application's
    // exit code.
    HRESULT ExecCommandWithElevation(
           [in] LPCOLESTR pszApplicationName,
           [in] LPCOLESTR pszCommandLine,
           [in] LPCOLESTR pszWorkingDir,
           [out,retval] DWORD *pdwProcessExitCode      // value return by process (may NOT be NULL)
           );
};

// {E7B2B2DB-973B-4CE9-A8D7-8498895DEA73}
// Packages may register for AutoLoad on this UIContext in order to perfom expensive one-time per-user
// initialization. During FirstLaunchSetup many services are unavailable and a package may NOT display
// any UI. FirstLaunchSetup is not guaranteed to be called; it is just an opportunity to build caches.
cpp_quote("extern const __declspec(selectany) GUID UICONTEXT_FirstLaunchSetup = { 0xe7b2b2db, 0x973b, 0x4ce9, { 0xa8, 0xd7, 0x84, 0x98, 0x89, 0x5d, 0xea, 0x73 } };")

// {67CFF80C-0863-4202-A4E4-CE80FDF8506E}
// One can use this UIContext to show/hide components based on current OS version
cpp_quote("extern const __declspec(selectany) GUID UICONTEXT_OsWindows8OrHigher = { 0x67CFF80C, 0x0863, 0x4202, { 0xA4, 0xE4, 0xCE, 0x80, 0xFD, 0xF8, 0x50, 0x6E } };")

// {643905EE-DAE9-4F52-A343-6A5A7349D52C}
// One can use this UIContext to check if toolbox is visible
cpp_quote("extern const __declspec(selectany) GUID UICONTEXT_ToolboxVisible = { 0x643905ee, 0xdae9, 0x4f52, { 0xa3, 0x43, 0x6a, 0x5a, 0x73, 0x49, 0xd5, 0x2c } };")

// {dc769521-31a2-41a5-9bbb-210b5d63568d}
// If this UI context is active during project load, it means that this project load operation is occuring
// in the background (e.g. as part of BSL), and should not present any UI prompts to the user. If a project
// hierarchy requires user input to continue loading, it should use VSHPROP_IsFaulted to communicate the fact,
// and possibly implement IVsProjectFaultResolver to handle resolution.
// When projects are explicitly (re)loaded by the user - either directly via "Reload Project", or indirectly
// via "Resolve Errors", this UI context is not active - even during BSL.
cpp_quote("extern const __declspec(selectany) GUID UICONTEXT_BackgroundProjectLoad = { 0xdc769521, 0x31a2, 0x41a5, {0x9b, 0xbb, 0x21, 0x0b, 0x5d, 0x63, 0x56, 0x8d } };")


//----------------------------------------------------------------------------
// IVsEnumGuids - similar with IVsEnumGUID,
// but without preservesig, and without legacy GetCount function
//----------------------------------------------------------------------------
[
    uuid(BEC804F7-F5DE-4F3E-8EBB-DAB26649F33F),
    version(1.0),
    pointer_default(unique)
]
interface IVsEnumGuids : IUnknown
{
    HRESULT Next([in] ULONG celt, [out, size_is(celt), length_is(*pceltFetched)] GUID rgelt[], [out] ULONG *pceltFetched);
    HRESULT Skip([in] ULONG celt);
    HRESULT Reset(void);
    HRESULT Clone([out] IVsEnumGuids **ppenum);
};

// Enumerates the possible color types for IVsUIShell5.GetThemedColor.
// Background is for colors drawn as the background of an element.
// Foreground is for colors drawn as text or foreground of an element.
enum __THEMEDCOLORTYPE
{
    TCT_Background,
    TCT_Foreground
};

// Represents a value from the __THEMEDCOLORTYPE enumeration.
typedef DWORD THEMEDCOLORTYPE;

// Represents an RGBA color with the red channel in the low byte to the alpha channel in the high byte.
typedef DWORD VS_RGBA;

//---------------------------------------------------------------------------
// IVsUIShell5
//---------------------------------------------------------------------------
[
    uuid(uuid_IVsUIShell5),
    version(1.0),
    pointer_default(unique)
]
interface IVsUIShell5 : IUnknown
{
midl_pragma warning( disable: 2279 )
    // bring up the MSO Open dialog to obtain an open file name.
    HRESULT GetOpenFileNameViaDlgEx2([in,out] VSOPENFILENAMEW * openFileName, [in] LPCOLESTR helpTopic, [in] LPCOLESTR openButtonLabel);
midl_pragma warning( enable: 2279 )

    // Gets the current RGBA value of a themed color (identified by a color category and a color name).  This
    // function will fail if the color doesn't exist.
    HRESULT GetThemedColor([in] REFGUID colorCategory, [in] LPCOLESTR colorName, [in] THEMEDCOLORTYPE colorType, [out, retval] VS_RGBA* colorRgba);

    // Returns the name of a keybinding scope. Valid keybinding scopes are registered editor's Guids, and guidVSStd97 is the Global scope.
    HRESULT GetKeyBindingScope([in] REFGUID keyBindingScope, [out, retval] BSTR * pbstrName);

    // Returns the available key binding scopes
    HRESULT EnumKeyBindingScopes([out, retval] IVsEnumGuids** ppEnum);
    
    // Apply the VS-theme to the specified window, for supported window classes.
    [local] HRESULT ThemeWindow([in] HWND hwnd, [out, optional, retval] VARIANT_BOOL * pfThemeApplied);

    // Creates a themed image list.  Themed image lists attempt to transform the images to target a given background.
    // The caller is responsible for calling ImageList_Destroy to delete the imagelist.
    // NOTE: HANDLE represents an HIMAGELIST, but including commctrl.h can produce build issues for projects that
    // would not otherwise support common controls.
    [local] HRESULT CreateThemedImageList([in] HANDLE hImageList, [in] COLORREF crBackground, [out, retval] HANDLE* phThemedImageList);

    // Applies theming to BGRA32 device-independent bitmap bits. The luminosity of the image is transformed so that the constant "halo" luminosity blends
    // in with the background.  This has the effect of eliminating the halo visually.  The "halo" luminosity is an immutable constant,
    // and is not calculated from the input image.
    // Images which contain cyan (#00FFFF) in their top-right pixel are not inverted.  Instead, the top-right pixel is cleared (RGBA are all set to 0) and S_OK is returned
    // without otherwise modifying the image.
    HRESULT ThemeDIBits([in] DWORD dwBitmapLength, [in, out, size_is(dwBitmapLength)] BYTE pBitmap[], [in] DWORD dwPixelWidth, [in] DWORD dwPixelHeight, [in] VARIANT_BOOL fIsTopDownBitmap, [in] COLORREF crBackground);
};

//----------------------------------------------------------------------------
// Well-known color themes names
//----------------------------------------------------------------------------
cpp_quote("extern const __declspec(selectany) GUID GUID_LightColorTheme             = { 0xde3dbbcd, 0xf642, 0x433c, { 0x83, 0x53, 0x8f, 0x1d, 0xf4, 0x37, 0x0a, 0xba} };") // {de3dbbcd-f642-433c-8353-8f1df4370aba}
cpp_quote("extern const __declspec(selectany) GUID GUID_DarkColorTheme              = { 0x1ded0138, 0x47ce, 0x435e, { 0x84, 0xef, 0x9e, 0xc1, 0xf4, 0x39, 0xb7, 0x49} };") // {1ded0138-47ce-435e-84ef-9ec1f439b749}

//----------------------------------------------------------------------------
// Well-known color categories to use with IVsUIShell5.GetThemedColor
//----------------------------------------------------------------------------
cpp_quote("extern const __declspec(selectany) GUID GUID_EnvironmentColorsCategory   = { 0x624ed9c3, 0xbdfd, 0x41fa, { 0x96, 0xc3, 0x7c, 0x82, 0x4e, 0xa3, 0x2e, 0x3d } };")  // {624ed9c3-bdfd-41fa-96c3-7c824ea32e3d}
cpp_quote("extern const __declspec(selectany) GUID GUID_TreeViewColorsCatetory      = { 0x92ecf08e, 0x8b13, 0x4cf4, { 0x99, 0xe9, 0xae, 0x26, 0x92, 0x38, 0x21, 0x85 } };")  // {92ecf08e-8b13-4cf4-99e9-ae2692382185}
cpp_quote("extern const __declspec(selectany) GUID GUID_HeaderColorsCatetory        = { 0x4997f547, 0x1379, 0x456e, { 0xb9, 0x85, 0x2f, 0x41, 0x3c, 0xdf, 0xa5, 0x36 } };")  // {4997f547-1379-456e-b985-2f413cdfa536}
cpp_quote("extern const __declspec(selectany) GUID GUID_SearchControlColorsCatetory = { 0xf1095fad, 0x881f, 0x45f1, { 0x85, 0x80, 0x58, 0x9e, 0x10, 0x32, 0x5e, 0xb8 } };")  // {f1095fad-881f-45f1-8580-589e10325eb8}

//---------------------------------------------------------------------------
// IVsDebugRemoteDiscoveryUI
// Implemented by the Debugger, obtained via the SID_SVsDebugRemoteDiscoveryUI service.
//---------------------------------------------------------------------------
enum DEBUG_REMOTE_DISCOVERY_FLAGS
{
    // No flags.
    DRD_NONE        = 0x00000000,
    DRD_SHOW_MANUAL = 0x00000001
};

[
    uuid(uuid_IVsDebugRemoteDiscoveryUI),
    version(1.0),
    pointer_default(unique)
]
interface IVsDebugRemoteDiscoveryUI : IUnknown
{
    // Shows the Remote Debugger Discovery dialog, returning the selected computer.
    //
    // flags: Flags specified in the DEBUG_REMOTE_DISCOVERY_FLAGS enum.
    //
    // transportQualifier: String to pass to the debugger to connect to selected computer. This
    //   is also the string which should show up in project properties.
    // guidPortSupplier: GUID indicating the transport (port supplier) to use when connecting. Currently this
    //   will either be Guid.Empty to indicate Windows authentication, or guidNoAuthPortSupplier
    //   for no-authentication
    [custom(uuid_VsPreserveSigAttribute, "preservesig")]
    HRESULT SelectRemoteInstanceViaDlg(
        [in] BSTR currentTransportQualifier,
        [in] GUID currentPortSupplier,
        [in] DWORD flags,
        [out] BSTR* transportQualifier,
        [out] GUID* guidPortSupplier
        );
};

//---------------------------------------------------------------------------
// SVsDebugRemoteDiscoveryUI
// The service type implementing IVsDebugRemoteDiscoveryUI
//---------------------------------------------------------------------------

#ifndef PROXYSTUB_BUILD

[ uuid (uuid_SVsDebugRemoteDiscoveryUI) ]
interface SVsDebugRemoteDiscoveryUI : IUnknown
{
};

cpp_quote("#define SID_SVsDebugRemoteDiscoveryUI IID_SVsDebugRemoteDiscoveryUI")

#endif

// Interfaces for task scheduling

enum __VSTASKRUNCONTEXT
{
    VSTC_BACKGROUNDTHREAD = 0, // on background thread
    VSTC_UITHREAD_SEND = 1, // runs on UI thread with the highest priority, may cause reentrancy.
    VSTC_UITHREAD_BACKGROUND_PRIORITY = 2, // runs on UI thread giving priority to user input
    VSTC_UITHREAD_IDLE_PRIORITY = 3, // runs on UI thread during Visual Studio idle loop processing
    VSTC_CURRENTCONTEXT = 4,
    VSTC_BACKGROUNDTHREAD_LOW_IO_PRIORITY = 5,
    VSTC_UITHREAD_NORMAL_PRIORITY = 6
};

typedef DWORD VSTASKRUNCONTEXT;

//----------------------------------------------------------------------------
// VSTASKCONTINUATIONOPTIONS enum
//
// This needs to be kept in sync with System.Threading.Task.TaskContinuation options
//----------------------------------------------------------------------------
enum __VSTASKCONTINUATIONOPTIONS
{
    VSTCO_None = 0,
    VSTCO_PreferFairness = 1,
    VSTCO_LongRunning = 2,
    VSTCO_AttachedToParent = 4,
    VSTCO_DenyChildAttach = 8,
    VSTCO_LazyCancelation = 32,
    VSTCO_NotOnRanToCompletion = 0x10000,
    VSTCO_NotOnFaulted = 0x20000,
    VSTCO_OnlyOnCanceled = 0x30000,
    VSTCO_NotOnCanceled = 0x40000,
    VSTCO_OnlyOnFaulted = 0x50000,
    VSTCO_OnlyOnRanToCompletion = 0x60000,
    VSTCO_ExecuteSynchronously = 0x80000, // This option is not supported by VS task library and it will be ignored hence continuations will not be inlined.
    VSTCO_IndependentlyCanceled = 0x40000000,
    VSTCO_NotCancelable = 0x80000000,
    VSTCO_Default = VSTCO_NotOnFaulted
};

typedef DWORD VSTASKCONTINUATIONOPTIONS;

//----------------------------------------------------------------------------
// VSTASKCREATIONOPTIONS enum
//
// This needs to be kept in sync with System.Threading.Task.TaskCreationOptions options
//----------------------------------------------------------------------------
enum __VSTASKCREATIONOPTIONS
{
    VSTCRO_None = VSTCO_None,
    VSTCRO_PreferFairness = VSTCO_PreferFairness,
    VSTCRO_LongRunning = VSTCO_LongRunning,
    VSTCRO_AttachedToParent = VSTCO_AttachedToParent,
    VSTCRO_DenyChildAttach = VSTCO_DenyChildAttach,
    VSTCRO_NotCancelable = VSTCO_NotCancelable
};

typedef DWORD VSTASKCREATIONOPTIONS;

//----------------------------------------------------------------------------
// VSTASKWAITOPTIONS enum
//
// Options for task wait operations
//----------------------------------------------------------------------------
enum __VSTASKWAITOPTIONS
{
    VSTWO_None = 0x0000,
    VSTWO_AbortOnTaskCancellation = 0x0001   // Return from wait immediately if task is canceled
};

typedef DWORD VSTASKWAITOPTIONS;

//----------------------------------------------------------------------------
// IVsTaskBody
//
// Interface implemented by a Visual Studio task worker method. This interface
// is for internal helper library use only to wrap native or managed anonymous methods
// It is not intented to be implemented directly by users of the service.
//----------------------------------------------------------------------------
[
    uuid(05a07459-551f-4cdf-b38a-16089d083110),
    version(1.0),
    pointer_default(unique)
]
interface IVsTaskBody : IUnknown
{
    HRESULT DoWork([in] IVsTask *pTask, [in] DWORD dwCount, [in, size_is(dwCount)] IVsTask * pParentTasks[], [out] VARIANT *pResult);
}

//----------------------------------------------------------------------------
// IVsTask
//
// Interface implemented by a Visual Studio task. This interface can be used
// to interact with the task such as starting it, cancelling or appending continuations
//----------------------------------------------------------------------------
[
    uuid(0b98eab8-00bb-45d0-ae2f-3de35cd68235),
    version(1.0),
    pointer_default(unique)
]
interface IVsTask : IUnknown
{
    // Creates a continuation that will run after this task is completed
    HRESULT ContinueWith(
        [in] VSTASKRUNCONTEXT context,
        [in] IVsTaskBody *pTaskBody,
        [out, retval] IVsTask **ppTask);

    // Creates a continuation that will run after this task is completed
    // Allows specification of continuation options that match the TPL Tasks.TaskContinuationOptions enum.
    HRESULT ContinueWithEx(
        [in] VSTASKRUNCONTEXT context,
        [in] VSTASKCONTINUATIONOPTIONS options,
        [in] IVsTaskBody *pTaskBody,
        [in] VARIANT pAsyncState,
        [out, retval] IVsTask **ppTask);

    HRESULT Start();
    HRESULT Cancel();

    // Waits for the task to complete (not including any continuations) and
    // returns the result set by the task.
    // If the task returns an error code or an exception, this method will also
    // return the same error code.
    //
    // This method can return VS_E_CIRCULARTASKDEPEDENCY if task library determines that
    // the call would result in a deadlock.
    HRESULT GetResult([out, retval] VARIANT *pResult);

    // Returns S_OK if task is not cancelled or returns an error code that should be returned
    // from the task for proper cancellation. Task implementors should use this method
    // to return from a cancelled task
    HRESULT AbortIfCanceled();

    // Waits for the task to complete (not including any continuations).
    // If the task returns an error code or an exception, this method will also
    // return the same error code.
    //
    // This method can return VS_E_CIRCULARTASKDEPEDENCY if task library determines that
    // the call would result in a deadlock.
    HRESULT Wait();

    // Waits for the task to complete (not including any continuations).
    // You can either specify a timeout (or INFINITE) or set the flag to abort on task cancellation.
    // If the task returns an error code or an exception, this method will also return the same error code.
    // If the task does not complete before the time out, S_OK will be returned with pTaskCompleted set to false.
    // If the task is canceled and abort on cancel flag is set, this method will also fail
    //
    // This method can return VS_E_CIRCULARTASKDEPEDENCY if task library determines that
    // the call would result in a deadlock.
    HRESULT WaitEx([in] int millisecondsTimeout, [in] VSTASKWAITOPTIONS options, [out, retval] VARIANT_BOOL *pTaskCompleted);

    [propget] HRESULT IsFaulted([out, retval] VARIANT_BOOL *pResult);

    [propget] HRESULT IsCompleted([out, retval] VARIANT_BOOL *pResult);

    [propget] HRESULT IsCanceled([out, retval] VARIANT_BOOL *pResult);

    [propget] HRESULT AsyncState([out, retval] VARIANT *pAsyncState);

    [propget] HRESULT Description([out, retval] BSTR *ppDescriptionText);
    [propput] HRESULT Description([in] LPCOLESTR pDescriptionText);
}

//----------------------------------------------------------------------------
// IVsTaskCompletionSource
//
// Interface implemented by a Visual Studio task. This interface can be used
// to interact with the task such as starting it, cancelling or appending continuations
//----------------------------------------------------------------------------
[
    uuid(ce465203-16bc-4ebd-b4d1-9b4416b80931),
    version(1.0),
    pointer_default(unique)
]
interface IVsTaskCompletionSource : IUnknown
{
    [propget] HRESULT Task([out, retval] IVsTask **ppTask);

    // Sets the owned by this source to completed state with the given result
    HRESULT SetResult([in] VARIANT result);

    // Sets the task owned by this source to canceled state, also cancelling the task
    HRESULT SetCanceled();

    // Sets the task owned by this source in to faulted state with the given HR code.
    HRESULT SetFaulted([in] HRESULT hr);

    // Adds this provided task to task completion sources dependent task list
    // so that if Wait is called on IVsTaskCompletionSource.Task
    // we can unblock UI correctly
    HRESULT AddDependentTask([in] IVsTask *pTask);
}

//----------------------------------------------------------------------------
// IVsTaskSchedulerService
//
// Interface implemented by the task scheduler service that can be used to create
// and interact with Visual Studio task blocks.
//----------------------------------------------------------------------------
[
    uuid(83cfbaaf-0df9-403d-ae42-e738f0ac9735),
    version(1.0),
    pointer_default(unique)
]
interface IVsTaskSchedulerService : IUnknown
{
    /// Creates a task that will be executed on the given context
    HRESULT CreateTask([in] VSTASKRUNCONTEXT context, [in] IVsTaskBody *pTaskBody, [out, retval] IVsTask **ppTask);

    /// Creates a task that will be executed on the given context
    HRESULT CreateTaskEx([in] VSTASKRUNCONTEXT context,
                         [in] VSTASKCREATIONOPTIONS options,
                         [in] IVsTaskBody *pTaskBody,
                         [in] VARIANT pAsyncState,
                         [out, retval] IVsTask **ppTask);

    /// Creates a task that will be executed once all the given tasks are completed.
    /// Note: Task service will also take ownership of dependent tasks after this call
    HRESULT ContinueWhenAllCompleted([in] VSTASKRUNCONTEXT context,
                                     [in] DWORD dwTasks,
                                     [in, size_is(dwTasks)] IVsTask *pDependentTasks[],
                                     [in] IVsTaskBody* pTaskBody,
                                     [out, retval] IVsTask **ppTask);

    /// Creates a task that will be executed once all the given tasks are completed.
    /// Note: Task service will also take ownership of dependent tasks after this call
    HRESULT ContinueWhenAllCompletedEx([in] VSTASKRUNCONTEXT context,
                                     [in] DWORD dwTasks,
                                     [in, size_is(dwTasks)] IVsTask *pDependentTasks[],
                                     [in] VSTASKCONTINUATIONOPTIONS options,
                                     [in] IVsTaskBody* pTaskBody,
                                     [in] VARIANT pAsyncState,
                                     [out, retval] IVsTask **ppTask);

    HRESULT CreateTaskCompletionSource([out, retval] IVsTaskCompletionSource **ppTaskSource);

    HRESULT CreateTaskCompletionSourceEx([in] VSTASKCREATIONOPTIONS options,
                                         [in] VARIANT asyncState,
                                         [out, retval] IVsTaskCompletionSource **ppTaskSource);

}

#ifndef PROXYSTUB_BUILD

[
    uuid(ab244925-40a8-4c5c-b0a5-717bb5d615b6),
    version(1.0),
    pointer_default(unique)
]
interface SVsTaskSchedulerService : IUnknown
{
}

#endif // PROXYSTUB_BUILD

enum __VSIconSource
{
    IS_Unknown         = 0,     // the provider of the icon is unknown
    IS_VisualStudio    = 1,     // the icon is provided by Visual Studio
    IS_OperatingSystem = 2,     // the icon is provided by the operating system
};
typedef DWORD VSIconSource;

//---------------------------------------------------------------------------
// IVsImageService
// A general purpose service for registering well known images (such as icons) for Visual Studio.
//---------------------------------------------------------------------------
[
    uuid(59A26C3B-4E73-4E57-B1C2-F8A44BCA3CA1),
    version(1.0),
    pointer_default(unique)
]
interface IVsImageService : IUnknown
{
    // Adds an icon with the given name to the service.
    HRESULT Add(
        [in] LPCOLESTR name,
        [in] IVsUIObject *pIconObject);

    // Gets the icon with the given name.  Returns null if the icon doesn't exist.
    HRESULT Get(
        [in] LPCOLESTR name,
        [out, retval] IVsUIObject **ppIconObject);

    // Gets the 16x16 icon for the given file.  Returns null if the icon cannot be retrieved.
    HRESULT GetIconForFile(
        [in] LPCOLESTR filename,
        [in] __VSUIDATAFORMAT desiredFormat,
        [out, retval] IVsUIObject **ppIconObject);

    // Gets the 16x16 icon for the given file.  Returns null if the icon cannot be retrieved, 
    // and an indication of the origin of the icon.
    HRESULT GetIconForFileEx(
        [in] LPCOLESTR filename,
        [in] __VSUIDATAFORMAT desiredFormat,
        [out] VSIconSource* iconSource,
        [out, retval] IVsUIObject **ppIconObject);
};

#ifndef PROXYSTUB_BUILD

//---------------------------------------------------------------------------
// SVsImageService
// The service type implementing IVsImageService
//---------------------------------------------------------------------------
[
    uuid(ACC9EB93-CAD8-41DE-80DA-BD35CC5112AE),
    version(1.0),
    pointer_default(unique)
]
interface SVsImageService : IUnknown
{
};

cpp_quote("#define SID_SVsImageService IID_SVsImageService")

#endif // PROXYSTUB_BUILD

// IVsProjectUpgradeViaFactory4
//
// This interface is implemented by the project factory (or at least QIable from IVsProjectFactory).
// IVSProjectUpgradeViaFactory4 is called by the solution, before the project is opened.
//
// This new interface is optional; but recommended for all projects to support the new upgrade method.
// This provides support for projects to return specialized upgrade options.
// The user can choose which projects to upgrade using the compatibility dialog.
//
enum __VSPPROJECTUPGRADEVIAFACTORYREPAIRFLAGS
{
    // - A safe-repair is one which is not a real full upgrade but merely a repair to make the project asset compatible
    //    without the risk of issues being encountered by the previous versions of the product
    //
    // - An usafe-repair is one which is similarly not a full upgrade, but with a risk of issues being encountered by the newer
    //   or previous version of the product. For example if a newer dependent SDK is not currently installed
    //
    // - A one-way upgrade is a full upgrade which will make the project incompatible with the previous version of the product
    //
    // Please enumerate flags by compatibility severity
    //
     VSPUVF_PROJECT_NOREPAIR       = 0x00000000
    ,VSPUVF_PROJECT_SAFEREPAIR     = 0x00000010
    ,VSPUVF_PROJECT_UNSAFEREPAIR   = 0x00000020
    ,VSPUVF_PROJECT_ONEWAYUPGRADE  = 0x00000040
    ,VSPUVF_PROJECT_INCOMPATIBLE   = 0x00000080
    ,VSPUVF_PROJECT_DEPRECATED     = 0x00000100
};
typedef DWORD VSPUVF_REPAIRFLAGS;

[
    uuid(uuid_IVsProjectUpgradeViaFactory4),
    helpstring("IVsProjectUpgradeViaFactory4 Interface"),
    pointer_default(unique)
]
interface IVsProjectUpgradeViaFactory4 : IUnknown
{
    // Ask a project factory if Get upgrade flags from a project factory
    HRESULT UpgradeProject_CheckOnly(
         [in]  LPCOLESTR             pszFileName
        ,[in]  IVsUpgradeLogger    * pLogger
        ,[out] VSPUVF_REPAIRFLAGS  * pUpgradeRequired
        ,[out] GUID                * pguidNewProjectFactory                //If a different prj factory should be used to create the upgraded proj, the guid should be returned here
        ,[out] VSPUVF_FLAGS        * pUpgradeProjectCapabilityFlags        //Some kinds of projects may support different backup styles
        );
};

// IVsProjectFlavorUpgradeViaFactory2
//
// This interface is implemented by the project factory of a Project Flavor that wants to particpate
// in the upgrade process of a flavored base project. The Project Flavor is able to update persisted
// build properties as well the XML Fragments it stores in the Project and Project User files.
// The IVsProjectUpgradeViaFactory implementation of a base project's IVsProjectFactory object is called
// by the solution, before the project is opened. Allowing the ProjectFactory to handle this upgrade
// process provides a level of abstraction and keeps knowledge of previous file formats out of the
// project implementation object.
//
// In order to allow ProjectFlavors particpate in the project file upgrade process, the base projects
// implemenation of IVsProjectUpgradeViaFactory will call IVsProjectFlavorUpgradeViaFactory::UpgradeProjectFlavor
// on each of the project flavor ProjectFactories included in the aggregated guid list. The base project
// will call these methods even if the base project itself does not require upgrading. If any project
// flavor requires upgrade then the base project will perform a project upgrade taking care of the SxS
// versus Copy backup of the project file as required. The base project determines the style of backup
// that is appropriate.

[
    uuid(uuid_IVsProjectFlavorUpgradeViaFactory2),
    helpstring("IVsProjectFlavorUpgradeViaFactory2 Interface"),
    pointer_default(unique)
]
interface IVsProjectFlavorUpgradeViaFactory2 : IUnknown
{
    HRESULT UpgradeProjectFlavor_CheckOnly(
         [in]  LPCOLESTR                          pszFileName

         // used to read build related properties and imports
        // ,[in]  IVsUpgradeBuildPropertyStorage   * pUpgradeBuildPropStg

        // BUGBUG: Some quirk in how Microsoft.VisualStudio.Shell.Interop.9.0 was generated causes IVsUpgradeBuildPropertyStorage
        // not to be found when building the interop assembly Microsoft.VisualStudio.Shell.Interop.11.0 so as a workaround
        // we will have this as IUnknown until the issue is fixed..
        ,[in]  IUnknown                         * pUpgradeBuildPropStg

        ,[in]  LPCOLESTR                          pszProjFileXMLFragment
        ,[in]  LPCOLESTR                          pszUserFileXMLFragment
        ,[in]  IVsUpgradeLogger                 * pLogger
        ,[out] VSPUVF_REPAIRFLAGS               * pUpgradeRequired

          // If a different prj flavor factory should be used to create the upgraded proj, the guid should be returned here
        ,[out, optional] GUID                   * pguidNewProjectFactory
        );
};

// IVsUpgradeLogger2
//
// This interface provides support for an upgrade logger to change the absolute file name of the upgrade log file after
// the upgrade logger has been initialized. IVsUpgradeLogger in VSShell80 provides Flush and WriteUpgradeReportRequiredFiles
// which can be called when a component has finished logging, however once the upgrade logger has been initialized there
// is no way to change the path of the log file without destroying and creating a new one with a different file name.
// This enables scenarios where a component can create the upgrade logger lightweight without having to do an IO test first
// to verify the current save location is ok until the end when it determines it's worth writing the upgrade
// report and the accompanying resource files - for example writing an upgrade report only if there is an error or
// a warning that may be of interest to the user during upgrade checking and migration.
[
    uuid(DCF3E6DE-2DC0-421E-9DBB-375BB5255A80),
    helpstring("IVsUpgradeLogger2 Interface"),
    pointer_default(unique)
]
interface IVsUpgradeLogger2 : IUnknown
{
    HRESULT ChangeUpgradeLogPath([in] LPCOLESTR lpszNewLogFileName);
}

// IVsSolution5
//
// Implemented by the Visual Studio Environment.
// Available via QueryService(SVsSolution)
[
    uuid(90570d49-7b10-4dcd-b9ac-530d91f4ebb5),
    version(1.0),
    pointer_default(unique)
]
interface IVsSolution5 : IUnknown
{
    // Resolve faulted projects.
    //
    // rgHierarchies is the array of project hierarchies that are to be resolved.
    // If empty (cHierarchies == 0), all faulted projects in the solution are resolved.
    //
    // pProjectFaultResolutionContext is the property bag to be used as a fault resolution context. If it is provided,
    // VSPROPID_ProjectFaultResolutionContext will be made to reference it for the duration of the call - caller may
    // use this to pass initial values for specific properties instead of default values. If null is passed in this
    // argument, a new blank property bag will be used as the context.
    //
    // The fault resolution process is as follows. For each project hierarchy in rgHierarchies:
    // 1. Query VSHPROPID_IsFaulted. If it is false, then skip this project.
    // 2. Check whether the hierarchy supports IVsProjectFaultResolver.
    // 3. If IVsProjectFaultResolver is supported, call ResolveFault on the hierarchy. If it fails with
    //    OLE_E_PROMPTSAVECANCELLED, then stop processing projects and return OLE_E_PROMPTSAVECANCELLED.
    // 4. If IVsProjectFaultResolver is not supported, or if ResolveFault set *pfShouldReload to true,
    //    reload the hierarchy. If it fails with OLE_E_PROMPTSAVECANCELLED, then stop processing projects
    //    and return OLE_E_PROMPTSAVECANCELLED.
    //
    // On return:
    //
    // If pcResolved is not null, *pcResolved is set to the number of projects for which resolution was attempted
    // (i.e. ResolveFault called and/or project reloaded). This may be less than cHierarchies if some of the projects
    // in rgHierarchies are not faulted, or if one of the projects failed to resolve with OLE_E_PROMPTSAVECANCELLED.
    //
    // If pcFaulted is not null, *pcFaulted is set to the number of projects that remain in faulted state after
    // an attempted resolution. It does not count projects for which resolution was not attempted, e.g. those following
    // the project which failed to resolve with OLE_E_PROMPTSAVECANCELLED.
    HRESULT ResolveFaultedProjects(
        [in] DWORD cHierarchies,
        [in, size_is(cHierarchies)] IVsHierarchy* rgHierarchies[],
        [in, unique] IVsPropertyBag* pProjectFaultResolutionContext,
        [out] DWORD* pcResolved,
        [out] DWORD* pcFailed);

    // Returns the GUID of the project specified by the given project file.
    HRESULT GetGuidOfProjectFile(
        [in] LPCOLESTR pszProjectFile,
        [out, retval] GUID *pProjectGuid);
};

//----------------------------------------------------------------------------
// IVsTaskList3
//
// Interface implemented by the task list and error list to allow for
// asynchronous task updates for specific providers (or all providers).
//----------------------------------------------------------------------------
[
    uuid(6028FB96-E279-4707-8945-7A503AEC636E),
    version(1.0),
    pointer_default(unique)
]
interface IVsTaskList3 : IUnknown
{
    HRESULT RefreshTasksAsync([in] VSCOOKIE providerCookie,
                              [out, retval] IVsTask **task);

    HRESULT RefreshOrAddTasksAsync([in] VSCOOKIE providerCookie,
                                   [in] int taskItemCount,
                                   [in, size_is(taskItemCount)] IVsTaskItem* taskItems[],
                                   [out, retval] IVsTask **task);

    HRESULT RemoveTasksAsync([in] VSCOOKIE providerCookie,
                             [in] int taskItemCount,
                             [in, size_is(taskItemCount)] IVsTaskItem* taskItems[],
                             [out, retval] IVsTask **task);

    HRESULT RefreshAllProvidersAsync([out, retval] IVsTask **task);
};


[
    uuid(d79ca884-27fc-43f4-a51b-d0b068b312c9),
    version(1.0),
    pointer_default(unique),
    custom(uuid_VsPreserveSigAttribute, "preservesig")
]
interface IVsPersistSolutionOpts2 : IVsPersistSolutionOpts
{
    // If the package implements IVsPersistSolutionOpts2, this method is called in preference to IVsPersistSolutionOpts::LoadUserOptions
    // when opening the solution, after all synchronously loaded projects are opened, with fPreLoad=FALSE.
    // In addition, this method is also called for the same SUO immediately before any synchronous loaded projects are opened,
    // with fPreLoad=TRUE. This allows the package to preload any user options that may be queried by project factories while
    // opening projects.
    // LoadUserOptions(pPersistence, grfLoadOpts) must behave identical to LoadUserOptionsEx(FALSE, pPersistence, grfLoadOpts).
    [custom(uuid_VsPreserveSigAttribute, "nopreservesig")]
    HRESULT LoadUserOptionsEx([in] BOOL fPreLoad, [in] IVsSolutionPersistence *pPersistence, [in] VSLOADUSEROPTS grfLoadOpts);
};

//-----------------------------------------------------------------------------
// Implemented by project factories to support background solution load (BSL)
//-----------------------------------------------------------------------------
[
    uuid(uuid_IVsAsynchronousProjectCreate),
    version(1.0),
    pointer_default(unique)
]
interface IVsAsynchronousProjectCreate : IUnknown
{
    HRESULT CanCreateProjectAsynchronously(
        [in] REFGUID rguidProjectID,    // GUID of the project in the solution file (same as what will be returned by IVsSolution::GetGuidOfProject)
        [in] LPCOLESTR filename, // filename of the project
        [in] VSCREATEPROJFLAGS flags,   // creation flags
        [out,retval] VARIANT_BOOL* canOpenAsync);

    // Called if canOpenAsync from CanCreateProjectAsynchronously is not VARIANT_FALSE
    // and if the project has been successfully scheduled for background loading.
    // The call will occur during the synchronous portion of solution load and allows
    // project factories to start pre-emptive, concurrent and non blocking work to
    // improve the performance of project loading.
    HRESULT OnBeforeCreateProjectAsync(
        [in] REFGUID rguidProjectID,    // GUID of the project in the solution file (same as what will be returned by IVsSolution::GetGuidOfProject)
        [in] LPCOLESTR filename, // filename of the project
        [in] LPCOLESTR location, // location of the project
        [in] LPCOLESTR pszName,  // project name
        [in] VSCREATEPROJFLAGS flags);  // creation flags

    // The result of the IVsTask should be a Variant of type
    // VT_UNKNOWN and will be QI'd for the IVsHierarchy of the created project.
    // The task may return E_ABORT to indicate the project creation was canceled.
    // The GetResult method on the task will return a failed HRESULT for any failure
    // encountered during the async project creation. Otherwise the result will be
    // returned in the VARIANT out parameter of the GetResult method.
    HRESULT CreateProjectAsync(
        [in] REFGUID rguidProjectID,    // GUID of the project in the solution file (same as what will be returned by IVsSolution::GetGuidOfProject)
        [in] LPCOLESTR filename, // filename of the project
        [in] LPCOLESTR location, // location of the project
        [in] LPCOLESTR pszName,  // project name
        [in] VSCREATEPROJFLAGS flags,   // creation flags
        [out, retval] IVsTask** task);
};


//---------------------------------------------------------------------------
// IVsSolutionEvents5
//---------------------------------------------------------------------------
[
    uuid(af530689-9987-48be-af20-d9392a9c67ff),
    version(1.0),
    pointer_default(unique)
]
interface IVsSolutionEvents5 : IUnknown
{
    // A notification fired before each project is created.
    // This is called after IVsSolutionLoadManager::OnBeforeOpenProject and, unlike the latter,
    // has no means to control how the project will be opened. This method should be preferred
    // over IVsSolutionLoadManager::OnBeforeOpenProject for for cases where a simple notification
    // about project being opened is desired.
    //
    // It is guaranteed that, for cases where VSPROPID_ProjectFaultResolutionContext is present,
    // it will be set to the expected value before this notification is fired. It is valid for
    // the implementation of this method to query for specific properties in the fault resolution
    // context, or change their values.
    HRESULT OnBeforeOpenProject(
        [in] REFGUID guidProjectID,
        [in] REFGUID guidProjectType,
        [in] LPCOLESTR pszFileName);
};

//---------------------------------------------------------------------------
// IVsHierarchyEvents2
//---------------------------------------------------------------------------
[
    uuid(0D707B06-F2E8-4556-A98A-D015B67AE3EF),
    version(1.0),
    pointer_default(unique)
]
[custom(uuid_VsPreserveSigAttribute, "preservesig")]
interface IVsHierarchyEvents2 : IUnknown
{
    // An updated method for OnItemAdded that includes a bool that determines whether to make sure the node is visible after it is added.
    HRESULT OnItemAdded([in] VSITEMID itemidParent, [in] VSITEMID itemidSiblingPrev, [in] VSITEMID itemidAdded, [in] VARIANT_BOOL ensureVisible);
};

//-----------------------------------------------------------------------------
// IVsAsynchronousProjectCreateUI
//-----------------------------------------------------------------------------
[
    uuid(808D838C-5821-4E4D-9399-0AB656A64E48),
    version(1.0),
    pointer_default(unique)
]
interface IVsAsynchronousProjectCreateUI : IUnknown
{
    // Called when a project that supports Asynchronous Solution Load is loaded
    // in the background. While the project has been created it has not been publicized
    // via the solution load events. Therefore pHier is still the stub hierarchy and not the real
    // project hierarchy. Only basic hierarchy properties are available such as the project name and icon.
    // Typically this event will only be used by components that need to show UI updates as a project loads
    // in the background. The event will not be raised for projects that are force loaded due to user 
    // actions such a expanding a project node in Solution Explorer.
    HRESULT OnAfterProjectProvisioned([in] IVsHierarchy *pHier);
}

[
    uuid(56870613-AB44-40B6-8125-F0D82D566C26),
    version(1.0),
    pointer_default(unique)
]
interface IVsSolutionUIEvents : IUnknown
{
    // When switching from Filter A to Filter B, the events will be fired in the following order:
    //     1. OnFilterAsyncLoadCompleted(A_FilterGroup, A_FilterID)
    //        Note this event will be forced to fire if it has not yet fired, but if A had previously finished initialization, it will not fire a second time.
    //     2. OnFilterChanged(A_FilterGroup, A_FilterID, B_FilterGroup, B_FilterID)
    //     3. OnFilterAsyncLoadStarted(B_FilterGroup, B_FilterID)
    //     4. OnFilterAsyncLoadCompleted(B_FilterGroup, B_FilterID)

    // Called when a filter is enabled or disabled.  The [pguidNewFilterGroup, nNewFilterID] pair indicate which filter was just turned on while
    // [pguidOldFilterGroup, nOldFilterID] indicate the filter that was just turned off.  When a filter is disabled without switching to
    // a new filter, Guid.Empty will be passed in for pguidNewFilterGroup and 0 will be passed in for nNewFilterID.
    HRESULT OnFilterChanged([in] REFGUID pguidOldFilterGoup, [in] UINT nOldFilterID, [in] REFGUID pguidNewFilterGroup, [in] UINT nNewFilterID);

    // Called after a filter has been created and is starting to be initialized.
    HRESULT OnFilterAsyncLoadStarted([in] REFGUID pguidFilterGroup, [in] UINT nFilterID);

    // Called when a filter has finished its asynchronous initialization.
    HRESULT OnFilterAsyncLoadCompleted([in] REFGUID pguidFilterGroup, [in] UINT nFilterID);
};

[
    uuid(D286024E-6940-4D08-986D-CE82E732BAAB),
    version(1.0),
    pointer_default(unique)
]
interface IVsSolutionUIHierarchyWindow : IUnknown
{
    // Enable the filter specified by the pguidFilterGroup, nFilterID pair.  Returns true if the
    // filter was successfully enabled.
    HRESULT EnableFilter([in] REFGUID pguidFilterGroup, [in] UINT nFilterID, [out, retval] VARIANT_BOOL *pSuccessful);

    // Disables the currently enabled filter.  If no filter is currently enabled, DisableFilter does nothing.
    HRESULT DisableFilter();

    // Returns true if the current filter is enabled and false if it is disabled.
    HRESULT IsFilterEnabled([out, retval] VARIANT_BOOL *pIsEnabled);

    // Gets the Guid, uint pair for the currently enabled filter.
    // If no filter is currently enabled, pguidFilterGroup will be set to Guid.Empty and nFitlerID will be set to 0.
    HRESULT GetCurrentFilter([out] GUID* pguidFilterGroup, [out] UINT* nFilterID);

    // Register an event sink to listen to events related to this IVsSolutionUIHierarchyWindow.
    HRESULT AdviseSolutionUIEvents([in] IVsSolutionUIEvents* pEventSink, [out] VSCOOKIE* pdwCookie);

    // Unregister an event sink so that it will no longer recieve events from this IVsSolutionUIHierarchyWindow.
    HRESULT UnadviseSolutionUIEvents([in] VSCOOKIE dwCookie);
};

//---------------------------------------------------------------------------
// IVsPrioritizedSolutionEventsSink
//
// Sinks implementing this intefaces will get priority notification for the solution
// events (in VS 2012, it only prioritizes IVsSolutionLoadEvents).
//
// Here is the order:
// OnAfter*** events will arrive before other non-prioritied sinks
// OnBefore*** events will arrive after other non-prioritied sinks
//
// For example, a background compiler may need to be started before other dependent
// components start using it, and it may need to shut down after the other dependent
// components stop using it. The background compiler can be initialized when the
// OnAfterBackgroundSolutionLoadComplete event is fired, so that when other
// components respond to the OnAfterBackgroundSolutionLoadComplete event, the compiler
// is ready.
//
// Please note that this interface is typically implemented by project systems to allow
// them to correctly initialize during solution load. Other components should refrain
// from using this interface.
//---------------------------------------------------------------------------
[
    uuid(6E8674B2-EFA9-4CD6-9743-CC7A549BB0EB),
    version(1.0),
    pointer_default(unique)
]
interface IVsPrioritizedSolutionEventsSink : IUnknown
{
};


//This is the overlay icon that your ui hierarchy should return
//when asked for VSHPROPID_OverlayIconIndex.  This will be transparently
//drawn on top of your item's normal icon
enum __VSOVERLAYICON3
{
    /********************************************** defined in vsshell.idl
    OVERLAYICON_NONE            = 0,
    OVERLAYICON_SHORTCUT        = 1,
    OVERLAYICON_POLICY          = 2,
    OVERLAYICON_CONNECTED       = 3,
    OVERLAYICON_DISCONNECTED    = 4,
    OVERLAYICON_MAXINDEX        = 4 //should be same as last valid overlay
    **********************************************/
    /********************************************** defined in vsshell80.idl
    OVERLAYICON_EXCLUDED        = 5,
    OVERLAYICON_NOTONDISK       = 6,
    OVERLAYICON_MAXINDEX2        = 6 //should be same as last valid overlay
    */
    OVERLAYICON_FAULTED         = 7,
    OVERLAYICON_MAXINDEX3       = 7 // should be same as last valid overlay
};
typedef DWORD VSOVERLAYICON3;   // different type than original

//---------------------------------------------------------------------------
// IVsManifestReferenceResolver
//---------------------------------------------------------------------------
[
    uuid(DA5C54DC-7F35-4149-8E1C-948DEBA1CA92),
    version(1.0),
    pointer_default(unique)
]
interface IVsManifestReferenceResolver : IUnknown
{
    // The result of the IVsTask should be a Variant of type VT_BSTR or VT_EMPTY.
    // If the path did resolve then the resolved localPath as a VT_BSTR.  If the
    // path did not resolve then VT_EMPTY is returned.  The GetResult method on
    // the task will return a failed HRESULT for any failure encountered during
    // the ResolveReferenceAsync operation.  Otherwise the result will be
    // returned in the VARIANT out parameter of the GetResult method.
     HRESULT ResolveReferenceAsync([in] LPCOLESTR reference, [in] LPCOLESTR relativeToFile, [out, retval] IVsTask** task);
};

//---------------------------------------------------------------------------
// IVsThreadedWaitDialogCallback
//---------------------------------------------------------------------------
[
    uuid(f5caf6e8-ad40-4d9d-8366-a919f03ca969),
    version(1.0),
    pointer_default(unique)
]
interface IVsThreadedWaitDialogCallback : IUnknown
{
    // Notification fired when user cancels the threaded wait dialog.
    // This method will be called from threaded wait dialog background thread without marshaling
    // so the implementation of this interface must be prepared to be called from any thread
    // Note: This breaks COM rules intentionally
    HRESULT OnCanceled();
};

//---------------------------------------------------------------------------
// IVsThreadedWaitDialog3
//---------------------------------------------------------------------------
// Implemented by the Visual Studio Environment.
// Interface allows a modal dialog to be displayed on a background thread to
// allow the IDE to appear responsive even when the foreground thread is busy
// with an extended operation
//
// Available via QueryService(SVsThreadedWaitDialogFactory)
// This dialog differs from IVsThreadedWaitDialog in that it can have a progress AND
// Cancel button at the same time. Additionally supports progress with accurate percentage.
[
    uuid(e92e3159-2381-4179-a500-9676dee38896),
    version(1.0),
    pointer_default(unique)
]
interface IVsThreadedWaitDialog3 : IVsThreadedWaitDialog2
{
    HRESULT StartWaitDialogWithCallback(
        [in, unique]  LPCWSTR       szWaitCaption,
        [in]  LPCWSTR       szWaitMessage,
        [in, unique]  LPCWSTR       szProgressText,     // Can be NULL
        [in]  VARIANT       varStatusBmpAnim,   // Optional: should be a VT_INT_PTR containing a valid BMP, or VT_NULL
        [in, unique]  LPCWSTR       szStatusBarText,    // Can be NULL
        [in]  VARIANT_BOOL  fIsCancelable,      // Should there be a cancelable button on the dialog.
        [in]  LONG          iDelayToShowDialog, // Number of seconds to delay showing dialog.
        [in]  VARIANT_BOOL  fShowProgress,      // Determines whether progress bar is visible or not
        [in]  LONG          iTotalSteps,        // How many steps equals 100% complete, specify 0 or negative for marquee progress
        [in]  LONG          iCurrentStep,       // How many steps have complete so far
        [in]  IVsThreadedWaitDialogCallback* pCallback); // Callback interface
};

//-----------------------------------------------------------------------------
// SVsHierarchyManipulation
//-----------------------------------------------------------------------------
[
    uuid(1C917A11-5B6E-4752-9DEC-94B041A05745),
    version(1.0),
    pointer_default(unique)
]
interface SVsHierarchyManipulation : IUnknown
{
};

cpp_quote("#define SID_SVsHierarchyManipulation __uuidof(SVsHierarchyManipulation)")

//----------------------------------------------------------------------------
// IVsHierarchyManipulation
//----------------------------------------------------------------------------
enum __VSHIERARCHYMANIPULATIONSTATE
{
    HMS_Unspecified     = 0x00000000,
    HMS_System          = 0x00000001,       // the hierarchy manipulation was caused by the system (not explicitly by the user)
};
typedef DWORD VSHIERARCHYMANIPULATIONSTATE;

[
    uuid(F3581DB8-1DCE-4267-8145-B6906AC4D028),
    version(1.0),
    pointer_default(unique)
]
interface IVsHierarchyManipulation : IUnknown
{
    // Specifies state at the time that an IVsHierarchy is manipulated.
    HRESULT SetManipulationState (
        [in] VSHIERARCHYMANIPULATIONSTATE state,    // the state used for the next document to be opened
        [out, retval] IVsHierarchyManipulationStateContext** ppRestoreOnRelease);
}

[
    uuid(E9274A0A-CC2F-4ECB-9FD0-F7BB59C7A47F),
    version(1.0),
    pointer_default(unique)
]
interface IVsHierarchyManipulationStateContext : IUnknown
{
    // Restores the IVsHierarchy manipulation state to the value it had
    // before this context was created by IVsHierarchyManipulation.SetManipulationState.
    HRESULT Restore();
}

[
    uuid(BAA340BB-FA34-4CCB-8C81-436566368517),
    version(1.0),
    pointer_default(unique)
]
[custom(uuid_VsPreserveSigAttribute, "preservesig")]
interface IVsFontAndColorStorage3 : IVsFontAndColorStorage2
{
    // Reverts all items in all categories to their default values.
    HRESULT RevertAllCategoriesToDefault();
}

[
    uuid(6F6E00CC-2261-49E2-8FD9-356B6637A2D9),
    version(1.0),
    pointer_default(unique)
]
interface IVsTaskProvider4 : IUnknown
{
    [local][propget] HRESULT ThemedImageList([out,retval] HANDLE *phImageList);
}
